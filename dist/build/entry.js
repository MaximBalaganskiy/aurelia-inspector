var entry;entry =
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpClientConfiguration": () => /* binding */ HttpClientConfiguration
/* harmony export */ });
/* harmony import */ var _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./retry-interceptor.js */ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js");

/**
 * A class for configuring HttpClients.
 */
class HttpClientConfiguration {
    constructor() {
        /**
         * The base URL to be prepended to each Request's url before sending.
         */
        this.baseUrl = '';
        /**
         * Default values to apply to init objects when creating Requests. Note that
         * defaults cannot be applied when Request objects are manually created because
         * Request provides its own defaults and discards the original init object.
         * See also https://developer.mozilla.org/en-US/docs/Web/API/Request/Request
         */
        this.defaults = {};
        /**
         * Interceptors to be added to the HttpClient.
         */
        this.interceptors = [];
        this.dispatcher = null;
    }
    /**
     * Sets the baseUrl.
     *
     * @param baseUrl - The base URL.
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    withBaseUrl(baseUrl) {
        this.baseUrl = baseUrl;
        return this;
    }
    /**
     * Sets the defaults.
     *
     * @param defaults - The defaults.
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    withDefaults(defaults) {
        this.defaults = defaults;
        return this;
    }
    /**
     * Adds an interceptor to be run on all requests or responses.
     *
     * @param interceptor - An object with request, requestError,
     * response, or responseError methods. request and requestError act as
     * resolve and reject handlers for the Request before it is sent.
     * response and responseError act as resolve and reject handlers for
     * the Response after it has been received.
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    withInterceptor(interceptor) {
        this.interceptors.push(interceptor);
        return this;
    }
    /**
     * Applies a configuration that addresses common application needs, including
     * configuring same-origin credentials, and using rejectErrorResponses.
     *
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    useStandardConfiguration() {
        const standardConfig = { credentials: 'same-origin' };
        Object.assign(this.defaults, standardConfig, this.defaults);
        return this.rejectErrorResponses();
    }
    /**
     * Causes Responses whose status codes fall outside the range 200-299 to reject.
     * The fetch API only rejects on network errors or other conditions that prevent
     * the request from completing, meaning consumers must inspect Response.ok in the
     * Promise continuation to determine if the server responded with a success code.
     * This method adds a response interceptor that causes Responses with error codes
     * to be rejected, which is common behavior in HTTP client libraries.
     *
     * @returns The chainable instance of this configuration object.
     * @chainable
     */
    rejectErrorResponses() {
        return this.withInterceptor({ response: rejectOnError });
    }
    withRetry(config) {
        const interceptor = new _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_0__.RetryInterceptor(config);
        return this.withInterceptor(interceptor);
    }
    withDispatcher(dispatcher) {
        this.dispatcher = dispatcher;
        return this;
    }
}
function rejectOnError(response) {
    if (!response.ok) {
        throw response;
    }
    return response;
}
//# sourceMappingURL=http-client-configuration.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/http-client.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/http-client.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IHttpClient": () => /* binding */ IHttpClient,
/* harmony export */   "HttpClient": () => /* binding */ HttpClient
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http-client-configuration.js */ "./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js");
/* harmony import */ var _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retry-interceptor.js */ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js");



const absoluteUrlRegexp = /^([a-z][a-z0-9+\-.]*:)?\/\//i;
const IHttpClient = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IHttpClient', x => x.singleton(HttpClient));
/**
 * An HTTP client based on the Fetch API.
 */
class HttpClient {
    /**
     * Creates an instance of HttpClient.
     */
    constructor() {
        this.dispatcher = null;
        this.activeRequestCount = 0;
        this.isRequesting = false;
        this.isConfigured = false;
        this.baseUrl = '';
        this.defaults = null;
        this.interceptors = [];
    }
    /**
     * Configure this client with default settings to be used by all requests.
     *
     * @param config - A configuration object, or a function that takes a config
     * object and configures it.
     * @returns The chainable instance of this HttpClient.
     * @chainable
     */
    configure(config) {
        let normalizedConfig;
        if (typeof config === 'object') {
            const requestInitConfiguration = { defaults: config };
            normalizedConfig = requestInitConfiguration;
        }
        else if (typeof config === 'function') {
            normalizedConfig = new _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_1__.HttpClientConfiguration();
            normalizedConfig.baseUrl = this.baseUrl;
            normalizedConfig.defaults = { ...this.defaults };
            normalizedConfig.interceptors = this.interceptors;
            normalizedConfig.dispatcher = this.dispatcher;
            const c = config(normalizedConfig);
            if (Object.prototype.isPrototypeOf.call(_http_client_configuration_js__WEBPACK_IMPORTED_MODULE_1__.HttpClientConfiguration.prototype, c)) {
                normalizedConfig = c;
            }
        }
        else {
            throw new Error('invalid config');
        }
        const defaults = normalizedConfig.defaults;
        if (defaults !== undefined && Object.prototype.isPrototypeOf.call(Headers.prototype, defaults.headers)) {
            // Headers instances are not iterable in all browsers. Require a plain
            // object here to allow default headers to be merged into request headers.
            throw new Error('Default headers must be a plain object.');
        }
        const interceptors = normalizedConfig.interceptors;
        if (interceptors !== undefined && interceptors.length) {
            // find if there is a RetryInterceptor
            if (interceptors.filter(x => Object.prototype.isPrototypeOf.call(_retry_interceptor_js__WEBPACK_IMPORTED_MODULE_2__.RetryInterceptor.prototype, x)).length > 1) {
                throw new Error('Only one RetryInterceptor is allowed.');
            }
            const retryInterceptorIndex = interceptors.findIndex(x => Object.prototype.isPrototypeOf.call(_retry_interceptor_js__WEBPACK_IMPORTED_MODULE_2__.RetryInterceptor.prototype, x));
            if (retryInterceptorIndex >= 0 && retryInterceptorIndex !== interceptors.length - 1) {
                throw new Error('The retry interceptor must be the last interceptor defined.');
            }
        }
        this.baseUrl = normalizedConfig.baseUrl;
        this.defaults = defaults;
        this.interceptors = normalizedConfig.interceptors !== undefined ? normalizedConfig.interceptors : [];
        this.dispatcher = normalizedConfig.dispatcher;
        this.isConfigured = true;
        return this;
    }
    /**
     * Starts the process of fetching a resource. Default configuration parameters
     * will be applied to the Request. The constructed Request will be passed to
     * registered request interceptors before being sent. The Response will be passed
     * to registered Response interceptors before it is returned.
     *
     * See also https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    fetch(input, init) {
        this.trackRequestStart();
        let request = this.buildRequest(input, init);
        return this.processRequest(request, this.interceptors).then(result => {
            let response;
            if (Object.prototype.isPrototypeOf.call(Response.prototype, result)) {
                response = Promise.resolve(result);
            }
            else if (Object.prototype.isPrototypeOf.call(Request.prototype, result)) {
                request = result;
                response = fetch(request);
            }
            else {
                throw new Error(`An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [${result}]`);
            }
            return this.processResponse(response, this.interceptors, request);
        })
            .then(result => {
            if (Object.prototype.isPrototypeOf.call(Request.prototype, result)) {
                return this.fetch(result);
            }
            return result;
        })
            .then(result => {
            this.trackRequestEnd();
            return result;
        }, error => {
            this.trackRequestEnd();
            throw error;
        });
    }
    buildRequest(input, init) {
        const defaults = this.defaults !== null ? this.defaults : {};
        let request;
        let body;
        let requestContentType;
        const parsedDefaultHeaders = parseHeaderValues(defaults.headers);
        if (Object.prototype.isPrototypeOf.call(Request.prototype, input)) {
            request = input;
            requestContentType = new Headers(request.headers).get('Content-Type');
        }
        else {
            if (!init) {
                init = {};
            }
            body = init.body;
            const bodyObj = body !== undefined ? { body: body } : null;
            const requestInit = { ...defaults, headers: {}, ...init, ...bodyObj };
            requestContentType = new Headers(requestInit.headers).get('Content-Type');
            request = new Request(getRequestUrl(this.baseUrl, input), requestInit);
        }
        if (!requestContentType) {
            if (new Headers(parsedDefaultHeaders).has('content-type')) {
                request.headers.set('Content-Type', new Headers(parsedDefaultHeaders).get('content-type'));
            }
            else if (body !== undefined && isJSON(body)) {
                request.headers.set('Content-Type', 'application/json');
            }
        }
        setDefaultHeaders(request.headers, parsedDefaultHeaders);
        if (body !== undefined && Object.prototype.isPrototypeOf.call(Blob.prototype, body) && body.type) {
            // work around bug in IE & Edge where the Blob type is ignored in the request
            // https://connect.microsoft.com/IE/feedback/details/2136163
            request.headers.set('Content-Type', body.type);
        }
        return request;
    }
    /**
     * Calls fetch as a GET request.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    get(input, init) {
        return this.fetch(input, init);
    }
    /**
     * Calls fetch with request method set to POST.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    post(input, body, init) {
        return this.callFetch(input, body, init, 'POST');
    }
    /**
     * Calls fetch with request method set to PUT.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    put(input, body, init) {
        return this.callFetch(input, body, init, 'PUT');
    }
    /**
     * Calls fetch with request method set to PATCH.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    patch(input, body, init) {
        return this.callFetch(input, body, init, 'PATCH');
    }
    /**
     * Calls fetch with request method set to DELETE.
     *
     * @param input - The resource that you wish to fetch. Either a
     * Request object, or a string containing the URL of the resource.
     * @param body - The body of the request.
     * @param init - An options object containing settings to be applied to
     * the Request.
     * @returns A Promise for the Response from the fetch request.
     */
    delete(input, body, init) {
        return this.callFetch(input, body, init, 'DELETE');
    }
    trackRequestStart() {
        this.isRequesting = !!(++this.activeRequestCount);
        if (this.isRequesting && this.dispatcher !== null) {
            const evt = new this.dispatcher.ownerDocument.defaultView.CustomEvent('aurelia-fetch-client-request-started', { bubbles: true, cancelable: true });
            setTimeout(() => { this.dispatcher.dispatchEvent(evt); }, 1);
        }
    }
    trackRequestEnd() {
        this.isRequesting = !!(--this.activeRequestCount);
        if (!this.isRequesting && this.dispatcher !== null) {
            const evt = new this.dispatcher.ownerDocument.defaultView.CustomEvent('aurelia-fetch-client-requests-drained', { bubbles: true, cancelable: true });
            setTimeout(() => { this.dispatcher.dispatchEvent(evt); }, 1);
        }
    }
    processRequest(request, interceptors) {
        return this.applyInterceptors(request, interceptors, 'request', 'requestError', this);
    }
    processResponse(response, interceptors, request) {
        return this.applyInterceptors(response, interceptors, 'response', 'responseError', request, this);
    }
    applyInterceptors(input, interceptors, successName, errorName, ...interceptorArgs) {
        return (interceptors !== undefined ? interceptors : [])
            .reduce((chain, interceptor) => {
            const successHandler = interceptor[successName];
            const errorHandler = interceptor[errorName];
            // TODO: Fix this, as it violates `strictBindCallApply`.
            return chain.then(successHandler ? (value => successHandler.call(interceptor, value, ...interceptorArgs)) : identity, errorHandler ? (reason => errorHandler.call(interceptor, reason, ...interceptorArgs)) : thrower);
        }, Promise.resolve(input));
    }
    callFetch(input, body, init, method) {
        if (!init) {
            init = {};
        }
        init.method = method;
        if (body) {
            init.body = body;
        }
        return this.fetch(input, init);
    }
}
function parseHeaderValues(headers) {
    const parsedHeaders = {};
    const $headers = headers !== undefined ? headers : {};
    for (const name in $headers) {
        if (Object.prototype.hasOwnProperty.call($headers, name)) {
            parsedHeaders[name] = (typeof $headers[name] === 'function')
                ? $headers[name]()
                : $headers[name];
        }
    }
    return parsedHeaders;
}
function getRequestUrl(baseUrl, url) {
    if (absoluteUrlRegexp.test(url)) {
        return url;
    }
    return (baseUrl !== undefined ? baseUrl : '') + url;
}
function setDefaultHeaders(headers, defaultHeaders) {
    const $defaultHeaders = defaultHeaders !== undefined ? defaultHeaders : {};
    for (const name in $defaultHeaders) {
        if (Object.prototype.hasOwnProperty.call($defaultHeaders, name) && !headers.has(name)) {
            headers.set(name, $defaultHeaders[name]);
        }
    }
}
function isJSON(str) {
    try {
        JSON.parse(str);
    }
    catch (err) {
        return false;
    }
    return true;
}
function identity(x) {
    return x;
}
function thrower(x) {
    throw x;
}
//# sourceMappingURL=http-client.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "json": () => /* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_0__.json,
/* harmony export */   "retryStrategy": () => /* reexport safe */ _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_1__.retryStrategy,
/* harmony export */   "RetryInterceptor": () => /* reexport safe */ _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_1__.RetryInterceptor,
/* harmony export */   "HttpClientConfiguration": () => /* reexport safe */ _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_2__.HttpClientConfiguration,
/* harmony export */   "HttpClient": () => /* reexport safe */ _http_client_js__WEBPACK_IMPORTED_MODULE_3__.HttpClient,
/* harmony export */   "IHttpClient": () => /* reexport safe */ _http_client_js__WEBPACK_IMPORTED_MODULE_3__.IHttpClient
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/@aurelia/fetch-client/dist/esm/util.js");
/* harmony import */ var _retry_interceptor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retry-interceptor.js */ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js");
/* harmony import */ var _http_client_configuration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http-client-configuration.js */ "./node_modules/@aurelia/fetch-client/dist/esm/http-client-configuration.js");
/* harmony import */ var _http_client_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./http-client.js */ "./node_modules/@aurelia/fetch-client/dist/esm/http-client.js");




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/retry-interceptor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retryStrategy": () => /* binding */ retryStrategy,
/* harmony export */   "RetryInterceptor": () => /* binding */ RetryInterceptor
/* harmony export */ });
const retryStrategy = {
    fixed: 0,
    incremental: 1,
    exponential: 2,
    random: 3
};
const defaultRetryConfig = {
    maxRetries: 3,
    interval: 1000,
    strategy: retryStrategy.fixed
};
/**
 * Interceptor that retries requests on error, based on a given RetryConfiguration.
 */
class RetryInterceptor {
    /**
     * Creates an instance of RetryInterceptor.
     */
    constructor(retryConfig) {
        this.retryConfig = { ...defaultRetryConfig, ...(retryConfig !== undefined ? retryConfig : {}) };
        if (this.retryConfig.strategy === retryStrategy.exponential &&
            this.retryConfig.interval <= 1000) {
            throw new Error('An interval less than or equal to 1 second is not allowed when using the exponential retry strategy');
        }
    }
    /**
     * Called with the request before it is sent. It remembers the request so it can be retried on error.
     *
     * @param request - The request to be sent.
     * @returns The existing request, a new request or a response; or a Promise for any of these.
     */
    request(request) {
        if (!request.retryConfig) {
            request.retryConfig = { ...this.retryConfig };
            request.retryConfig.counter = 0;
        }
        // do this on every request
        request.retryConfig.requestClone = request.clone();
        return request;
    }
    /**
     * Called with the response after it is received. Clears the remembered request, as it was succesfull.
     *
     * @param response - The response.
     * @returns The response; or a Promise for one.
     */
    response(response, request) {
        // retry was successful, so clean up after ourselves
        Reflect.deleteProperty(request, 'retryConfig');
        return response;
    }
    /**
     * Handles fetch errors and errors generated by previous interceptors. This
     * function acts as a Promise rejection handler. It wil retry the remembered request based on the
     * configured RetryConfiguration.
     *
     * @param error - The rejection value from the fetch request or from a
     * previous interceptor.
     * @returns The response of the retry; or a Promise for one.
     */
    responseError(error, request, httpClient) {
        const { retryConfig } = request;
        const { requestClone } = retryConfig;
        return Promise.resolve().then(() => {
            if (retryConfig.counter < retryConfig.maxRetries) {
                const result = retryConfig.doRetry !== undefined ? retryConfig.doRetry(error, request) : true;
                return Promise.resolve(result).then(doRetry => {
                    if (doRetry) {
                        retryConfig.counter++;
                        const delay = calculateDelay(retryConfig);
                        return new Promise(resolve => setTimeout(resolve, !isNaN(delay) ? delay : 0))
                            .then(() => {
                            const newRequest = requestClone.clone();
                            if (typeof (retryConfig.beforeRetry) === 'function') {
                                return retryConfig.beforeRetry(newRequest, httpClient);
                            }
                            return newRequest;
                        })
                            .then(newRequest => {
                            const retryableRequest = { ...newRequest, retryConfig };
                            return httpClient.fetch(retryableRequest);
                        });
                    }
                    // no more retries, so clean up
                    Reflect.deleteProperty(request, 'retryConfig');
                    throw error;
                });
            }
            // no more retries, so clean up
            Reflect.deleteProperty(request, 'retryConfig');
            throw error;
        });
    }
}
function calculateDelay(retryConfig) {
    const { interval, strategy, minRandomInterval, maxRandomInterval, counter } = retryConfig;
    if (typeof (strategy) === 'function') {
        return retryConfig.strategy(counter);
    }
    switch (strategy) {
        case (retryStrategy.fixed):
            return retryStrategies[retryStrategy.fixed](interval);
        case (retryStrategy.incremental):
            return retryStrategies[retryStrategy.incremental](counter, interval);
        case (retryStrategy.exponential):
            return retryStrategies[retryStrategy.exponential](counter, interval);
        case (retryStrategy.random):
            return retryStrategies[retryStrategy.random](counter, interval, minRandomInterval, maxRandomInterval);
        default:
            throw new Error('Unrecognized retry strategy');
    }
}
const retryStrategies = [
    // fixed
    interval => interval,
    // incremental
    (retryCount, interval) => interval * retryCount,
    // exponential
    (retryCount, interval) => retryCount === 1 ? interval : interval ** retryCount / 1000,
    // random
    (retryCount, interval, minRandomInterval = 0, maxRandomInterval = 60000) => {
        return Math.random() * (maxRandomInterval - minRandomInterval) + minRandomInterval;
    }
];
//# sourceMappingURL=retry-interceptor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/fetch-client/dist/esm/util.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/fetch-client/dist/esm/util.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "json": () => /* binding */ json
/* harmony export */ });
/**
 * Serialize an object to JSON. Useful for easily creating JSON fetch request bodies.
 *
 * @param body - The object to be serialized to JSON.
 * @param replacer - The JSON.stringify replacer used when serializing.
 * @returns A JSON string.
 */
function json(body, replacer) {
    return JSON.stringify((body !== undefined ? body : {}), replacer);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/di.js":
/*!*****************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/di.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResolverBuilder": () => /* binding */ ResolverBuilder,
/* harmony export */   "DefaultResolver": () => /* binding */ DefaultResolver,
/* harmony export */   "ContainerConfiguration": () => /* binding */ ContainerConfiguration,
/* harmony export */   "DI": () => /* binding */ DI,
/* harmony export */   "IContainer": () => /* binding */ IContainer,
/* harmony export */   "IServiceLocator": () => /* binding */ IServiceLocator,
/* harmony export */   "inject": () => /* binding */ inject,
/* harmony export */   "transient": () => /* binding */ transient,
/* harmony export */   "singleton": () => /* binding */ singleton,
/* harmony export */   "all": () => /* binding */ all,
/* harmony export */   "lazy": () => /* binding */ lazy,
/* harmony export */   "optional": () => /* binding */ optional,
/* harmony export */   "ignore": () => /* binding */ ignore,
/* harmony export */   "newInstanceForScope": () => /* binding */ newInstanceForScope,
/* harmony export */   "newInstanceOf": () => /* binding */ newInstanceOf,
/* harmony export */   "ResolverStrategy": () => /* binding */ ResolverStrategy,
/* harmony export */   "Resolver": () => /* binding */ Resolver,
/* harmony export */   "Factory": () => /* binding */ Factory,
/* harmony export */   "Container": () => /* binding */ Container,
/* harmony export */   "ParameterizedRegistry": () => /* binding */ ParameterizedRegistry,
/* harmony export */   "Registration": () => /* binding */ Registration,
/* harmony export */   "InstanceProvider": () => /* binding */ InstanceProvider,
/* harmony export */   "validateKey": () => /* binding */ validateKey
/* harmony export */ });
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions.js */ "./node_modules/@aurelia/kernel/dist/esm/functions.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");

(0,_aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.applyMetadataPolyfill)(Reflect);



class ResolverBuilder {
    constructor(container, key) {
        this.container = container;
        this.key = key;
    }
    instance(value) {
        return this.registerResolver(0 /* instance */, value);
    }
    singleton(value) {
        return this.registerResolver(1 /* singleton */, value);
    }
    transient(value) {
        return this.registerResolver(2 /* transient */, value);
    }
    callback(value) {
        return this.registerResolver(3 /* callback */, value);
    }
    cachedCallback(value) {
        return this.registerResolver(3 /* callback */, cacheCallbackResult(value));
    }
    aliasTo(destinationKey) {
        return this.registerResolver(5 /* alias */, destinationKey);
    }
    registerResolver(strategy, state) {
        const { container, key } = this;
        this.container = this.key = (void 0);
        return container.registerResolver(key, new Resolver(key, strategy, state));
    }
}
function cloneArrayWithPossibleProps(source) {
    const clone = source.slice();
    const keys = Object.keys(source);
    const len = keys.length;
    let key;
    for (let i = 0; i < len; ++i) {
        key = keys[i];
        if (!(0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.isArrayIndex)(key)) {
            clone[key] = source[key];
        }
    }
    return clone;
}
const DefaultResolver = {
    none(key) { throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`); },
    singleton(key) { return new Resolver(key, 1 /* singleton */, key); },
    transient(key) { return new Resolver(key, 2 /* transient */, key); },
};
class ContainerConfiguration {
    constructor(inheritParentResources, defaultResolver) {
        this.inheritParentResources = inheritParentResources;
        this.defaultResolver = defaultResolver;
    }
    static from(config) {
        if (config === void 0 ||
            config === ContainerConfiguration.DEFAULT) {
            return ContainerConfiguration.DEFAULT;
        }
        return new ContainerConfiguration(config.inheritParentResources ?? false, config.defaultResolver ?? DefaultResolver.singleton);
    }
}
ContainerConfiguration.DEFAULT = ContainerConfiguration.from({});
const DI = {
    createContainer(config) {
        return new Container(null, ContainerConfiguration.from(config));
    },
    getDesignParamtypes(Type) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn('design:paramtypes', Type);
    },
    getAnnotationParamtypes(Type) {
        const key = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor('di:paramtypes');
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, Type);
    },
    getOrCreateAnnotationParamTypes(Type) {
        const key = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor('di:paramtypes');
        let annotationParamtypes = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, Type);
        if (annotationParamtypes === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, annotationParamtypes = [], Type);
            _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.appendTo(Type, key);
        }
        return annotationParamtypes;
    },
    getDependencies(Type) {
        // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,
        // so be careful with making changes here as it can have a huge impact on complex end user apps.
        // Preferably, only make changes to the dependency resolution process via a RFC.
        const key = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor('di:dependencies');
        let dependencies = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, Type);
        if (dependencies === void 0) {
            // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor
            // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).
            // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.
            // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.
            const inject = Type.inject;
            if (inject === void 0) {
                // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.
                const designParamtypes = DI.getDesignParamtypes(Type);
                // au:annotation:di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject
                const annotationParamtypes = DI.getAnnotationParamtypes(Type);
                if (designParamtypes === void 0) {
                    if (annotationParamtypes === void 0) {
                        // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as
                        // there is no sound way to merge a type's deps with its prototype's deps
                        const Proto = Object.getPrototypeOf(Type);
                        if (typeof Proto === 'function' && Proto !== Function.prototype) {
                            dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));
                        }
                        else {
                            dependencies = [];
                        }
                    }
                    else {
                        // No design:paramtypes so just use the au:annotation:di:paramtypes
                        dependencies = cloneArrayWithPossibleProps(annotationParamtypes);
                    }
                }
                else if (annotationParamtypes === void 0) {
                    // No au:annotation:di:paramtypes so just use the design:paramtypes
                    dependencies = cloneArrayWithPossibleProps(designParamtypes);
                }
                else {
                    // We've got both, so merge them (in case of conflict on same index, au:annotation:di:paramtypes take precedence)
                    dependencies = cloneArrayWithPossibleProps(designParamtypes);
                    let len = annotationParamtypes.length;
                    let auAnnotationParamtype;
                    for (let i = 0; i < len; ++i) {
                        auAnnotationParamtype = annotationParamtypes[i];
                        if (auAnnotationParamtype !== void 0) {
                            dependencies[i] = auAnnotationParamtype;
                        }
                    }
                    const keys = Object.keys(annotationParamtypes);
                    len = keys.length;
                    let key;
                    for (let i = 0; i < len; ++i) {
                        key = keys[i];
                        if (!(0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.isArrayIndex)(key)) {
                            dependencies[key] = annotationParamtypes[key];
                        }
                    }
                }
            }
            else {
                // Ignore paramtypes if we have static inject
                dependencies = cloneArrayWithPossibleProps(inject);
            }
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, dependencies, Type);
            _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.appendTo(Type, key);
        }
        return dependencies;
    },
    /**
     * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.
     * ```ts
     * const ILogger = DI.createInterface<Logger>('Logger');
     * container.register(Registration.singleton(ILogger, getSomeLogger()));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * you can also build default registrations into your interface.
     * ```ts
     * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * but these default registrations won't work the same with other decorators that take keys, for example
     * ```ts
     * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));
     * class Foo {
     *   constructor( @optional(MyStr) public readonly str: string ) {
     *   }
     * }
     * container.get(Foo).str; // returns undefined
     * ```
     * to fix this add this line somewhere before you do a `get`
     * ```ts
     * container.register(MyStr);
     * container.get(Foo).str; // returns 'somestring'
     * ```
     *
     * - @param friendlyName used to improve error messaging
     */
    createInterface(configureOrName, configuror) {
        const configure = typeof configureOrName === 'function' ? configureOrName : configuror;
        const friendlyName = typeof configureOrName === 'string' ? configureOrName : undefined;
        const Interface = function (target, property, index) {
            if (target == null || new.target !== undefined) {
                throw new Error(`No registration for interface: '${Interface.friendlyName}'`); // TODO: add error (trying to resolve an InterfaceSymbol that has no registrations)
            }
            const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
            annotationParamtypes[index] = Interface;
        };
        Interface.$isInterface = true;
        Interface.friendlyName = friendlyName == null ? '(anonymous)' : friendlyName;
        if (configure != null) {
            Interface.register = function (container, key) {
                return configure(new ResolverBuilder(container, key ?? Interface));
            };
        }
        Interface.toString = function toString() {
            return `InterfaceSymbol<${Interface.friendlyName}>`;
        };
        return Interface;
    },
    inject(...dependencies) {
        return function (target, key, descriptor) {
            if (typeof descriptor === 'number') { // It's a parameter decorator.
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
                const dep = dependencies[0];
                if (dep !== void 0) {
                    annotationParamtypes[descriptor] = dep;
                }
            }
            else if (key) { // It's a property decorator. Not supported by the container without plugins.
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target.constructor);
                const dep = dependencies[0];
                if (dep !== void 0) {
                    annotationParamtypes[key] = dep;
                }
            }
            else if (descriptor) { // It's a function decorator (not a Class constructor)
                const fn = descriptor.value;
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(fn);
                let dep;
                for (let i = 0; i < dependencies.length; ++i) {
                    dep = dependencies[i];
                    if (dep !== void 0) {
                        annotationParamtypes[i] = dep;
                    }
                }
            }
            else { // It's a class decorator.
                const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target);
                let dep;
                for (let i = 0; i < dependencies.length; ++i) {
                    dep = dependencies[i];
                    if (dep !== void 0) {
                        annotationParamtypes[i] = dep;
                    }
                }
            }
        };
    },
    /**
     * Registers the `target` class as a transient dependency; each time the dependency is resolved
     * a new instance will be created.
     *
     * @param target - The class / constructor function to register as transient.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     *
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.transient(Foo);
     *
     * // Inline declaration
     * const Foo = DI.transient(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    transient(target) {
        target.register = function register(container) {
            const registration = Registration.transient(target, target);
            return registration.register(container, target);
        };
        target.registerInRequestor = false;
        return target;
    },
    /**
     * Registers the `target` class as a singleton dependency; the class will only be created once. Each
     * consecutive time the dependency is resolved, the same instance will be returned.
     *
     * @param target - The class / constructor function to register as a singleton.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.singleton(Foo);
     *
     * // Inline declaration
     * const Foo = DI.singleton(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    singleton(target, options = defaultSingletonOptions) {
        target.register = function register(container) {
            const registration = Registration.singleton(target, target);
            return registration.register(container, target);
        };
        target.registerInRequestor = options.scoped;
        return target;
    },
};
const IContainer = DI.createInterface('IContainer');
const IServiceLocator = IContainer;
function createResolver(getter) {
    return function (key) {
        const resolver = function (target, property, descriptor) {
            DI.inject(resolver)(target, property, descriptor);
        };
        resolver.$isResolver = true;
        resolver.resolve = function (handler, requestor) {
            return getter(key, handler, requestor);
        };
        return resolver;
    };
}
const inject = DI.inject;
function transientDecorator(target) {
    return DI.transient(target);
}
function transient(target) {
    return target == null ? transientDecorator : transientDecorator(target);
}
const defaultSingletonOptions = { scoped: false };
function singletonDecorator(target) {
    return DI.singleton(target);
}
function singleton(targetOrOptions) {
    if (typeof targetOrOptions === 'function') {
        return DI.singleton(targetOrOptions);
    }
    return function ($target) {
        return DI.singleton($target, targetOrOptions);
    };
}
function createAllResolver(getter) {
    return function (key, searchAncestors) {
        searchAncestors = !!searchAncestors;
        const resolver = function (target, property, descriptor) {
            DI.inject(resolver)(target, property, descriptor);
        };
        resolver.$isResolver = true;
        resolver.resolve = function (handler, requestor) {
            return getter(key, handler, requestor, searchAncestors);
        };
        return resolver;
    };
}
const all = createAllResolver((key, handler, requestor, searchAncestors) => requestor.getAll(key, searchAncestors));
/**
 * Lazily inject a dependency depending on whether the [[`Key`]] is present at the time of function call.
 *
 * You need to make your argument a function that returns the type, for example
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => number )
 * }
 * const foo = container.get(Foo); // instanceof Foo
 * foo.random(); // throws
 * ```
 * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a
 * new [['Math.random()']] number each time.
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => random )
 * }
 * container.register(Registration.callback('random', Math.random ));
 * container.get(Foo).random(); // some random number
 * container.get(Foo).random(); // another random number
 * ```
 * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a
 * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.
 *
 * - @param key [[`Key`]]
 * see { @link DI.createInterface } on interactions with interfaces
 */
const lazy = createResolver((key, handler, requestor) => {
    return () => requestor.get(key);
});
/**
 * Allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example
 * ```ts
 * class Foo {
 *   constructor( @inject('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo); // throws
 * ```
 * would fail
 * ```ts
 * class Foo {
 *   constructor( @optional('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo).str // somestring
 * ```
 * if you use it without a default it will inject `undefined`, so rember to mark your input type as
 * possibly `undefined`!
 *
 * - @param key: [[`Key`]]
 *
 * see { @link DI.createInterface } on interactions with interfaces
 */
const optional = createResolver((key, handler, requestor) => {
    if (requestor.has(key, true)) {
        return requestor.get(key);
    }
    else {
        return undefined;
    }
});
/**
 * ignore tells the container not to try to inject a dependency
 */
function ignore(target, property, descriptor) {
    DI.inject(ignore)(target, property, descriptor);
}
ignore.$isResolver = true;
ignore.resolve = () => undefined;
const newInstanceForScope = createResolver((key, handler, requestor) => {
    const instance = createNewInstance(key, handler);
    const instanceProvider = new InstanceProvider(String(key));
    instanceProvider.prepare(instance);
    requestor.registerResolver(key, instanceProvider, true);
    return instance;
});
const newInstanceOf = createResolver((key, handler, _requestor) => createNewInstance(key, handler));
function createNewInstance(key, handler) {
    return handler.getFactory(key).construct(handler);
}
/** @internal */
var ResolverStrategy;
(function (ResolverStrategy) {
    ResolverStrategy[ResolverStrategy["instance"] = 0] = "instance";
    ResolverStrategy[ResolverStrategy["singleton"] = 1] = "singleton";
    ResolverStrategy[ResolverStrategy["transient"] = 2] = "transient";
    ResolverStrategy[ResolverStrategy["callback"] = 3] = "callback";
    ResolverStrategy[ResolverStrategy["array"] = 4] = "array";
    ResolverStrategy[ResolverStrategy["alias"] = 5] = "alias";
})(ResolverStrategy || (ResolverStrategy = {}));
/** @internal */
class Resolver {
    constructor(key, strategy, state) {
        this.key = key;
        this.strategy = strategy;
        this.state = state;
        this.resolving = false;
    }
    get $isResolver() { return true; }
    register(container, key) {
        return container.registerResolver(key || this.key, this);
    }
    resolve(handler, requestor) {
        switch (this.strategy) {
            case 0 /* instance */:
                return this.state;
            case 1 /* singleton */: {
                if (this.resolving) {
                    throw new Error(`Cyclic dependency found: ${this.state.name}`);
                }
                this.resolving = true;
                this.state = handler.getFactory(this.state).construct(requestor);
                this.strategy = 0 /* instance */;
                this.resolving = false;
                return this.state;
            }
            case 2 /* transient */: {
                // Always create transients from the requesting container
                const factory = handler.getFactory(this.state);
                if (factory === null) {
                    throw new Error(`Resolver for ${String(this.key)} returned a null factory`);
                }
                return factory.construct(requestor);
            }
            case 3 /* callback */:
                return this.state(handler, requestor, this);
            case 4 /* array */:
                return this.state[0].resolve(handler, requestor);
            case 5 /* alias */:
                return requestor.get(this.state);
            default:
                throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);
        }
    }
    getFactory(container) {
        switch (this.strategy) {
            case 1 /* singleton */:
            case 2 /* transient */:
                return container.getFactory(this.state);
            case 5 /* alias */:
                return container.getResolver(this.state)?.getFactory?.(container) ?? null;
            default:
                return null;
        }
    }
}
function containerGetKey(d) {
    return this.get(d);
}
function transformInstance(inst, transform) {
    return transform(inst);
}
/** @internal */
class Factory {
    constructor(Type, dependencies) {
        this.Type = Type;
        this.dependencies = dependencies;
        this.transformers = null;
    }
    construct(container, dynamicDependencies) {
        let instance;
        if (dynamicDependencies === void 0) {
            instance = new this.Type(...this.dependencies.map(containerGetKey, container));
        }
        else {
            instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
        }
        if (this.transformers == null) {
            return instance;
        }
        return this.transformers.reduce(transformInstance, instance);
    }
    registerTransformer(transformer) {
        (this.transformers ?? (this.transformers = [])).push(transformer);
    }
}
const containerResolver = {
    $isResolver: true,
    resolve(handler, requestor) {
        return requestor;
    }
};
function isRegistry(obj) {
    return typeof obj.register === 'function';
}
function isSelfRegistry(obj) {
    return isRegistry(obj) && typeof obj.registerInRequestor === 'boolean';
}
function isRegisterInRequester(obj) {
    return isSelfRegistry(obj) && obj.registerInRequestor;
}
function isClass(obj) {
    return obj.prototype !== void 0;
}
function isResourceKey(key) {
    return typeof key === 'string' && key.indexOf(':') > 0;
}
const InstrinsicTypeNames = new Set([
    'Array',
    'ArrayBuffer',
    'Boolean',
    'DataView',
    'Date',
    'Error',
    'EvalError',
    'Float32Array',
    'Float64Array',
    'Function',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Map',
    'Number',
    'Object',
    'Promise',
    'RangeError',
    'ReferenceError',
    'RegExp',
    'Set',
    'SharedArrayBuffer',
    'String',
    'SyntaxError',
    'TypeError',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array',
    'URIError',
    'WeakMap',
    'WeakSet',
]);
const factoryKey = 'di:factory';
const factoryAnnotationKey = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.annotation.keyFor(factoryKey);
/** @internal */
class Container {
    constructor(parent, config) {
        this.parent = parent;
        this.config = config;
        this.registerDepth = 0;
        this.disposableResolvers = new Set();
        if (parent === null) {
            this.root = this;
            this.resolvers = new Map();
            this.factories = new Map();
            this.resourceResolvers = Object.create(null);
        }
        else {
            this.root = parent.root;
            this.resolvers = new Map();
            this.factories = parent.factories;
            if (config.inheritParentResources) {
                this.resourceResolvers = Object.assign(Object.create(null), parent.resourceResolvers, this.root.resourceResolvers);
            }
            else {
                this.resourceResolvers = Object.assign(Object.create(null), this.root.resourceResolvers);
            }
        }
        this.resolvers.set(IContainer, containerResolver);
    }
    get depth() {
        return this.parent === null ? 0 : this.parent.depth + 1;
    }
    register(...params) {
        if (++this.registerDepth === 100) {
            throw new Error(`Unable to autoregister dependency: [${params.map(String)}]`);
            // TODO: change to reporter.error and add various possible causes in description.
            // Most likely cause is trying to register a plain object that does not have a
            // register method and is not a class constructor
        }
        let current;
        let keys;
        let value;
        let j;
        let jj;
        for (let i = 0, ii = params.length; i < ii; ++i) {
            current = params[i];
            if (!(0,_aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.isObject)(current)) {
                continue;
            }
            if (isRegistry(current)) {
                current.register(this);
            }
            else if (_resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.has(current)) {
                const defs = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.getAll(current);
                if (defs.length === 1) {
                    // Fast path for the very common case
                    defs[0].register(this);
                }
                else {
                    const len = defs.length;
                    for (let d = 0; d < len; ++d) {
                        defs[d].register(this);
                    }
                }
            }
            else if (isClass(current)) {
                Registration.singleton(current, current).register(this);
            }
            else {
                keys = Object.keys(current);
                j = 0;
                jj = keys.length;
                for (; j < jj; ++j) {
                    value = current[keys[j]];
                    if (!(0,_aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
                        continue;
                    }
                    // note: we could remove this if-branch and call this.register directly
                    // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator
                    if (isRegistry(value)) {
                        value.register(this);
                    }
                    else {
                        this.register(value);
                    }
                }
            }
        }
        --this.registerDepth;
        return this;
    }
    registerResolver(key, resolver, isDisposable = false) {
        validateKey(key);
        const resolvers = this.resolvers;
        const result = resolvers.get(key);
        if (result == null) {
            resolvers.set(key, resolver);
            if (isResourceKey(key)) {
                this.resourceResolvers[key] = resolver;
            }
        }
        else if (result instanceof Resolver && result.strategy === 4 /* array */) {
            result.state.push(resolver);
        }
        else {
            resolvers.set(key, new Resolver(key, 4 /* array */, [result, resolver]));
        }
        if (isDisposable) {
            this.disposableResolvers.add(resolver);
        }
        return resolver;
    }
    // public deregisterResolverFor<K extends Key, T = K>(key: K): void {
    //   // const console =  (globalThis as any).console;
    //   // console.group("deregisterResolverFor");
    //   validateKey(key);
    //   let current: Container = this;
    //   let resolver: IResolver | undefined;
    //   while (current != null) {
    //     resolver = current.resolvers.get(key);
    //     if (resolver != null) { break; }
    //     if (current.parent == null) { return; }
    //     current = current.parent;
    //   }
    //   if (resolver === void 0) { return; }
    //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {
    //     throw new Error('Cannot deregister a resolver with array strategy');
    //   }
    //   if (this.disposableResolvers.has(resolver as IDisposableResolver<T>)) {
    //     (resolver as IDisposableResolver<T>).dispose();
    //   }
    //   if (isResourceKey(key)) {
    //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    //     delete this.resourceResolvers[key];
    //   }
    //   // console.log(`BEFORE delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);
    //   current.resolvers.delete(key);
    //   // console.log(`AFTER delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);
    //   // console.groupEnd();
    // }
    registerTransformer(key, transformer) {
        const resolver = this.getResolver(key);
        if (resolver == null) {
            return false;
        }
        if (resolver.getFactory) {
            const factory = resolver.getFactory(this);
            if (factory == null) {
                return false;
            }
            // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.
            // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on
            // type Constructable. So the return type of that optional method has this additional constraint, which
            // seems to confuse the type checker.
            factory.registerTransformer(transformer);
            return true;
        }
        return false;
    }
    getResolver(key, autoRegister = true) {
        validateKey(key);
        if (key.resolve !== void 0) {
            return key;
        }
        let current = this;
        let resolver;
        while (current != null) {
            resolver = current.resolvers.get(key);
            if (resolver == null) {
                if (current.parent == null) {
                    const handler = (isRegisterInRequester(key)) ? this : current;
                    return autoRegister ? this.jitRegister(key, handler) : null;
                }
                current = current.parent;
            }
            else {
                return resolver;
            }
        }
        return null;
    }
    has(key, searchAncestors = false) {
        return this.resolvers.has(key)
            ? true
            : searchAncestors && this.parent != null
                ? this.parent.has(key, true)
                : false;
    }
    get(key) {
        validateKey(key);
        if (key.$isResolver) {
            return key.resolve(this, this);
        }
        let current = this;
        let resolver;
        while (current != null) {
            resolver = current.resolvers.get(key);
            if (resolver == null) {
                if (current.parent == null) {
                    const handler = (isRegisterInRequester(key)) ? this : current;
                    resolver = this.jitRegister(key, handler);
                    return resolver.resolve(current, this);
                }
                current = current.parent;
            }
            else {
                return resolver.resolve(current, this);
            }
        }
        throw new Error(`Unable to resolve key: ${key}`);
    }
    getAll(key, searchAncestors = false) {
        validateKey(key);
        const requestor = this;
        let current = requestor;
        let resolver;
        if (searchAncestors) {
            let resolutions = _platform_js__WEBPACK_IMPORTED_MODULE_2__.emptyArray;
            while (current != null) {
                resolver = current.resolvers.get(key);
                if (resolver != null) {
                    resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));
                }
                current = current.parent;
            }
            return resolutions;
        }
        else {
            while (current != null) {
                resolver = current.resolvers.get(key);
                if (resolver == null) {
                    current = current.parent;
                    if (current == null) {
                        return _platform_js__WEBPACK_IMPORTED_MODULE_2__.emptyArray;
                    }
                }
                else {
                    return buildAllResponse(resolver, current, requestor);
                }
            }
        }
        return _platform_js__WEBPACK_IMPORTED_MODULE_2__.emptyArray;
    }
    getFactory(Type) {
        let factory = this.factories.get(Type);
        if (factory === void 0) {
            if ((0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.isNativeFunction)(Type)) {
                throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);
            }
            this.factories.set(Type, factory = new Factory(Type, DI.getDependencies(Type)));
        }
        return factory;
    }
    registerFactory(key, factory) {
        this.factories.set(key, factory);
    }
    createChild(config) {
        if (config === void 0 && this.config.inheritParentResources) {
            if (this.config === ContainerConfiguration.DEFAULT) {
                return new Container(this, this.config);
            }
            return new Container(this, ContainerConfiguration.from({
                ...this.config,
                inheritParentResources: false,
            }));
        }
        return new Container(this, ContainerConfiguration.from(config ?? this.config));
    }
    disposeResolvers() {
        const disposables = Array.from(this.disposableResolvers);
        while (disposables.length > 0) {
            disposables.pop()?.dispose();
        }
    }
    find(kind, name) {
        const key = kind.keyFrom(name);
        let resolver = this.resourceResolvers[key];
        if (resolver === void 0) {
            resolver = this.root.resourceResolvers[key];
            if (resolver === void 0) {
                return null;
            }
        }
        if (resolver === null) {
            return null;
        }
        if (typeof resolver.getFactory === 'function') {
            const factory = resolver.getFactory(this);
            if (factory === null || factory === void 0) {
                return null;
            }
            const definition = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(kind.name, factory.Type);
            if (definition === void 0) {
                // TODO: we may want to log a warning here, or even throw. This would happen if a dependency is registered with a resource-like key
                // but does not actually have a definition associated via the type's metadata. That *should* generally not happen.
                return null;
            }
            return definition;
        }
        return null;
    }
    create(kind, name) {
        const key = kind.keyFrom(name);
        let resolver = this.resourceResolvers[key];
        if (resolver === void 0) {
            resolver = this.root.resourceResolvers[key];
            if (resolver === void 0) {
                return null;
            }
            return resolver.resolve(this.root, this) ?? null;
        }
        return resolver.resolve(this, this) ?? null;
    }
    dispose() {
        this.disposeResolvers();
        this.resolvers.clear();
    }
    jitRegister(keyAsValue, handler) {
        if (typeof keyAsValue !== 'function') {
            throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this resource?`);
        }
        if (InstrinsicTypeNames.has(keyAsValue.name)) {
            throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);
        }
        if (isRegistry(keyAsValue)) {
            const registrationResolver = keyAsValue.register(handler, keyAsValue);
            if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
                const newResolver = handler.resolvers.get(keyAsValue);
                if (newResolver != void 0) {
                    return newResolver;
                }
                throw new Error(`Invalid resolver returned from the static register method`);
            }
            return registrationResolver;
        }
        else if (_resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.has(keyAsValue)) {
            const defs = _resource_js__WEBPACK_IMPORTED_MODULE_3__.Protocol.resource.getAll(keyAsValue);
            if (defs.length === 1) {
                // Fast path for the very common case
                defs[0].register(handler);
            }
            else {
                const len = defs.length;
                for (let d = 0; d < len; ++d) {
                    defs[d].register(handler);
                }
            }
            const newResolver = handler.resolvers.get(keyAsValue);
            if (newResolver != void 0) {
                return newResolver;
            }
            throw new Error(`Invalid resolver returned from the static register method`);
        }
        else if (keyAsValue.$isInterface) {
            throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);
        }
        else {
            const resolver = this.config.defaultResolver(keyAsValue, handler);
            handler.resolvers.set(keyAsValue, resolver);
            return resolver;
        }
    }
}
/**
 * An implementation of IRegistry that delegates registration to a
 * separately registered class. The ParameterizedRegistry facilitates the
 * passing of parameters to the final registry.
 */
class ParameterizedRegistry {
    constructor(key, params) {
        this.key = key;
        this.params = params;
    }
    register(container) {
        if (container.has(this.key, true)) {
            const registry = container.get(this.key);
            registry.register(container, ...this.params);
        }
        else {
            container.register(...this.params.filter(x => typeof x === 'object'));
        }
    }
}
const cache = new WeakMap();
function cacheCallbackResult(fun) {
    return function (handler, requestor, resolver) {
        if (cache.has(resolver)) {
            return cache.get(resolver);
        }
        const t = fun(handler, requestor, resolver);
        cache.set(resolver, t);
        return t;
    };
}
/**
 * you can use the resulting {@linkcode IRegistration} of any of the factory methods
 * to register with the container, e.g.
 * ```
 * class Foo {}
 * const container = DI.createContainer();
 * container.register(Registration.instance(Foo, new Foo()));
 * container.get(Foo);
 * ```
 */
const Registration = {
    /**
     * allows you to pass an instance.
     * Every time you request this {@linkcode Key} you will get this instance back.
     * ```
     * Registration.instance(Foo, new Foo()));
     * ```
     *
     * @param key
     * @param value
     */
    instance(key, value) {
        return new Resolver(key, 0 /* instance */, value);
    },
    /**
     * Creates an instance from the class.
     * Every time you request this {@linkcode Key} you will get the same one back.
     * ```
     * Registration.singleton(Foo, Foo);
     * ```
     *
     * @param key
     * @param value
     */
    singleton(key, value) {
        return new Resolver(key, 1 /* singleton */, value);
    },
    /**
     * Creates an instance from a class.
     * Every time you request this {@linkcode Key} you will get a new instance.
     * ```
     * Registration.instance(Foo, Foo);
     * ```
     *
     * @param key
     * @param value
     */
    transient(key, value) {
        return new Resolver(key, 2 /* transient */, value);
    },
    /**
     * Creates an instance from the method passed.
     * Every time you request this {@linkcode Key} you will get a new instance.
     * ```
     * Registration.callback(Foo, () => new Foo());
     * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
     * ```
     *
     * @param key
     * @param callback
     */
    callback(key, callback) {
        return new Resolver(key, 3 /* callback */, callback);
    },
    /**
     * Creates an instance from the method passed.
     * On the first request for the {@linkcode Key} your callback is called and returns an instance.
     * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.
     * If you pass the same {@linkcode Registration} to another container the same cached value will be used.
     * Should all references to the resolver returned be removed, the cache will expire.
     * ```
     * Registration.cachedCallback(Foo, () => new Foo());
     * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
     * ```
     *
     * @param key
     * @param callback
     */
    cachedCallback(key, callback) {
        return new Resolver(key, 3 /* callback */, cacheCallbackResult(callback));
    },
    /**
     * creates an alternate {@linkcode Key} to retrieve an instance by.
     * Returns the same scope as the original {@linkcode Key}.
     * ```
     * Register.singleton(Foo, Foo)
     * Register.aliasTo(Foo, MyFoos);
     *
     * container.getAll(MyFoos) // contains an instance of Foo
     * ```
     *
     * @param originalKey
     * @param aliasKey
     */
    aliasTo(originalKey, aliasKey) {
        return new Resolver(aliasKey, 5 /* alias */, originalKey);
    },
    /**
     * @internal
     * @param key
     * @param params
     */
    defer(key, ...params) {
        return new ParameterizedRegistry(key, params);
    }
};
class InstanceProvider {
    constructor(friendlyName) {
        this.friendlyName = friendlyName;
        this.instance = null;
    }
    prepare(instance) {
        this.instance = instance;
    }
    get $isResolver() { return true; }
    resolve() {
        if (this.instance == null) {
            throw new Error(`Cannot call resolve ${this.friendlyName} before calling prepare or after calling dispose.`);
        }
        return this.instance;
    }
    dispose() {
        this.instance = null;
    }
}
/** @internal */
function validateKey(key) {
    if (key === null || key === void 0) {
        throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
    }
}
function buildAllResponse(resolver, handler, requestor) {
    if (resolver instanceof Resolver && resolver.strategy === 4 /* array */) {
        const state = resolver.state;
        let i = state.length;
        const results = new Array(i);
        while (i--) {
            results[i] = state[i].resolve(handler, requestor);
        }
        return results;
    }
    return [resolver.resolve(handler, requestor)];
}
//# sourceMappingURL=di.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/eventaggregator.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/eventaggregator.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IEventAggregator": () => /* binding */ IEventAggregator,
/* harmony export */   "EventAggregator": () => /* binding */ EventAggregator
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* eslint-disable @typescript-eslint/restrict-template-expressions */

/**
 * Represents a handler for an EventAggregator event.
 */
class Handler {
    constructor(messageType, callback) {
        this.messageType = messageType;
        this.callback = callback;
    }
    handle(message) {
        if (message instanceof this.messageType) {
            this.callback.call(null, message);
        }
    }
}
const IEventAggregator = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IEventAggregator', x => x.singleton(EventAggregator));
/**
 * Enables loosely coupled publish/subscribe messaging.
 */
class EventAggregator {
    constructor() {
        /** @internal */
        this.eventLookup = {};
        /** @internal */
        this.messageHandlers = [];
    }
    publish(channelOrInstance, message) {
        if (!channelOrInstance) {
            throw new Error(`Invalid channel name or instance: ${channelOrInstance}.`);
        }
        if (typeof channelOrInstance === 'string') {
            let subscribers = this.eventLookup[channelOrInstance];
            if (subscribers !== void 0) {
                subscribers = subscribers.slice();
                let i = subscribers.length;
                while (i-- > 0) {
                    subscribers[i](message, channelOrInstance);
                }
            }
        }
        else {
            const subscribers = this.messageHandlers.slice();
            let i = subscribers.length;
            while (i-- > 0) {
                subscribers[i].handle(channelOrInstance);
            }
        }
    }
    subscribe(channelOrType, callback) {
        if (!channelOrType) {
            throw new Error(`Invalid channel name or type: ${channelOrType}.`);
        }
        let handler;
        let subscribers;
        if (typeof channelOrType === 'string') {
            if (this.eventLookup[channelOrType] === void 0) {
                this.eventLookup[channelOrType] = [];
            }
            handler = callback;
            subscribers = this.eventLookup[channelOrType];
        }
        else {
            handler = new Handler(channelOrType, callback);
            subscribers = this.messageHandlers;
        }
        subscribers.push(handler);
        return {
            dispose() {
                const idx = subscribers.indexOf(handler);
                if (idx !== -1) {
                    subscribers.splice(idx, 1);
                }
            }
        };
    }
    subscribeOnce(channelOrType, callback) {
        const sub = this.subscribe(channelOrType, function (message, event) {
            sub.dispose();
            callback(message, event);
        });
        return sub;
    }
}
//# sourceMappingURL=eventaggregator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/functions.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/functions.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isArrayIndex": () => /* binding */ isArrayIndex,
/* harmony export */   "isNumberOrBigInt": () => /* binding */ isNumberOrBigInt,
/* harmony export */   "isStringOrDate": () => /* binding */ isStringOrDate,
/* harmony export */   "camelCase": () => /* binding */ camelCase,
/* harmony export */   "pascalCase": () => /* binding */ pascalCase,
/* harmony export */   "kebabCase": () => /* binding */ kebabCase,
/* harmony export */   "toArray": () => /* binding */ toArray,
/* harmony export */   "nextId": () => /* binding */ nextId,
/* harmony export */   "resetId": () => /* binding */ resetId,
/* harmony export */   "compareNumber": () => /* binding */ compareNumber,
/* harmony export */   "mergeDistinct": () => /* binding */ mergeDistinct,
/* harmony export */   "bound": () => /* binding */ bound,
/* harmony export */   "mergeArrays": () => /* binding */ mergeArrays,
/* harmony export */   "mergeObjects": () => /* binding */ mergeObjects,
/* harmony export */   "firstDefined": () => /* binding */ firstDefined,
/* harmony export */   "getPrototypeChain": () => /* binding */ getPrototypeChain,
/* harmony export */   "toLookup": () => /* binding */ toLookup,
/* harmony export */   "isNativeFunction": () => /* binding */ isNativeFunction,
/* harmony export */   "onResolve": () => /* binding */ onResolve,
/* harmony export */   "resolveAll": () => /* binding */ resolveAll
/* harmony export */ });
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");

const isNumericLookup = {};
/**
 * Efficiently determine whether the provided property key is numeric
 * (and thus could be an array indexer) or not.
 *
 * Always returns true for values of type `'number'`.
 *
 * Otherwise, only returns true for strings that consist only of positive integers.
 *
 * Results are cached.
 */
function isArrayIndex(value) {
    switch (typeof value) {
        case 'number':
            return value >= 0 && (value | 0) === value;
        case 'string': {
            const result = isNumericLookup[value];
            if (result !== void 0) {
                return result;
            }
            const length = value.length;
            if (length === 0) {
                return isNumericLookup[value] = false;
            }
            let ch = 0;
            for (let i = 0; i < length; ++i) {
                ch = value.charCodeAt(i);
                if (i === 0 && ch === 0x30 && length > 1 /* must not start with 0 */ || ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
                    return isNumericLookup[value] = false;
                }
            }
            return isNumericLookup[value] = true;
        }
        default:
            return false;
    }
}
/**
 * Determines if the value passed is a number or bigint for parsing purposes
 *
 * @param value - Value to evaluate
 */
function isNumberOrBigInt(value) {
    switch (typeof value) {
        case 'number':
        case 'bigint':
            return true;
        default:
            return false;
    }
}
/**
 * Determines if the value passed is a number or bigint for parsing purposes
 *
 * @param value - Value to evaluate
 */
function isStringOrDate(value) {
    switch (typeof value) {
        case 'string':
            return true;
        case 'object':
            return value instanceof Date;
        default:
            return false;
    }
}
/**
 * Base implementation of camel and kebab cases
 */
const baseCase = (function () {
    let CharKind;
    (function (CharKind) {
        CharKind[CharKind["none"] = 0] = "none";
        CharKind[CharKind["digit"] = 1] = "digit";
        CharKind[CharKind["upper"] = 2] = "upper";
        CharKind[CharKind["lower"] = 3] = "lower";
    })(CharKind || (CharKind = {}));
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    const isDigit = Object.assign(Object.create(null), {
        '0': true,
        '1': true,
        '2': true,
        '3': true,
        '4': true,
        '5': true,
        '6': true,
        '7': true,
        '8': true,
        '9': true,
    });
    function charToKind(char) {
        if (char === '') {
            // We get this if we do charAt() with an index out of range
            return 0 /* none */;
        }
        if (char !== char.toUpperCase()) {
            return 3 /* lower */;
        }
        if (char !== char.toLowerCase()) {
            return 2 /* upper */;
        }
        if (isDigit[char] === true) {
            return 1 /* digit */;
        }
        return 0 /* none */;
    }
    return function (input, cb) {
        const len = input.length;
        if (len === 0) {
            return input;
        }
        let sep = false;
        let output = '';
        let prevKind;
        let curChar = '';
        let curKind = 0 /* none */;
        let nextChar = input.charAt(0);
        let nextKind = charToKind(nextChar);
        for (let i = 0; i < len; ++i) {
            prevKind = curKind;
            curChar = nextChar;
            curKind = nextKind;
            nextChar = input.charAt(i + 1);
            nextKind = charToKind(nextChar);
            if (curKind === 0 /* none */) {
                if (output.length > 0) {
                    // Only set sep to true if it's not at the beginning of output.
                    sep = true;
                }
            }
            else {
                if (!sep && output.length > 0 && curKind === 2 /* upper */) {
                    // Separate UAFoo into UA Foo.
                    // Separate uaFOO into ua FOO.
                    sep = prevKind === 3 /* lower */ || nextKind === 3 /* lower */;
                }
                output += cb(curChar, sep);
                sep = false;
            }
        }
        return output;
    };
})();
/**
 * Efficiently convert a string to camelCase.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert DOM attribute names to ViewModel property names.
 *
 * Results are cached.
 */
const camelCase = (function () {
    const cache = Object.create(null);
    function callback(char, sep) {
        return sep ? char.toUpperCase() : char.toLowerCase();
    }
    return function (input) {
        let output = cache[input];
        if (output === void 0) {
            output = cache[input] = baseCase(input, callback);
        }
        return output;
    };
})();
/**
 * Efficiently convert a string to PascalCase.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert element names to class names for synthetic types.
 *
 * Results are cached.
 */
const pascalCase = (function () {
    const cache = Object.create(null);
    return function (input) {
        let output = cache[input];
        if (output === void 0) {
            output = camelCase(input);
            if (output.length > 0) {
                output = output[0].toUpperCase() + output.slice(1);
            }
            cache[input] = output;
        }
        return output;
    };
})();
/**
 * Efficiently convert a string to kebab-case.
 *
 * Non-alphanumeric characters are treated as separators.
 *
 * Primarily used by Aurelia to convert ViewModel property names to DOM attribute names.
 *
 * Results are cached.
 */
const kebabCase = (function () {
    const cache = Object.create(null);
    function callback(char, sep) {
        return sep ? `-${char.toLowerCase()}` : char.toLowerCase();
    }
    return function (input) {
        let output = cache[input];
        if (output === void 0) {
            output = cache[input] = baseCase(input, callback);
        }
        return output;
    };
})();
/**
 * Efficiently (up to 10x faster than `Array.from`) convert an `ArrayLike` to a real array.
 *
 * Primarily used by Aurelia to convert DOM node lists to arrays.
 */
function toArray(input) {
    // benchmark: http://jsben.ch/xjsyF
    const { length } = input;
    const arr = Array(length);
    for (let i = 0; i < length; ++i) {
        arr[i] = input[i];
    }
    return arr;
}
const ids = {};
/**
 * Retrieve the next ID in a sequence for a given string, starting with `1`.
 *
 * Used by Aurelia to assign unique ID's to controllers and resources.
 *
 * Aurelia will always prepend the context name with `au$`, so as long as you avoid
 * using that convention you should be safe from collisions.
 */
function nextId(context) {
    if (ids[context] === void 0) {
        ids[context] = 0;
    }
    return ++ids[context];
}
/**
 * Reset the ID for the given string, so that `nextId` will return `1` again for the next call.
 *
 * Used by Aurelia to reset ID's in between unit tests.
 */
function resetId(context) {
    ids[context] = 0;
}
/**
 * A compare function to pass to `Array.prototype.sort` for sorting numbers.
 * This is needed for numeric sort, since the default sorts them as strings.
 */
function compareNumber(a, b) {
    return a - b;
}
/**
 * Efficiently merge and deduplicate the (primitive) values in two arrays.
 *
 * Does not deduplicate existing values in the first array.
 *
 * Guards against null or undefined arrays.
 *
 * Returns `emptyArray` if both arrays are either `null`, `undefined` or `emptyArray`
 *
 * @param slice - If `true`, always returns a new array copy (unless neither array is/has a value)
 */
function mergeDistinct(arr1, arr2, slice) {
    if (arr1 === void 0 || arr1 === null || arr1 === _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        if (arr2 === void 0 || arr2 === null || arr2 === _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
            return _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        else {
            return slice ? arr2.slice(0) : arr2;
        }
    }
    else if (arr2 === void 0 || arr2 === null || arr2 === _platform_js__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        return slice ? arr1.slice(0) : arr1;
    }
    const lookup = {};
    const arr3 = slice ? arr1.slice(0) : arr1;
    let len1 = arr1.length;
    let len2 = arr2.length;
    while (len1-- > 0) {
        lookup[arr1[len1]] = true;
    }
    let item;
    while (len2-- > 0) {
        item = arr2[len2];
        if (lookup[item] === void 0) {
            arr3.push(item);
            lookup[item] = true;
        }
    }
    return arr3;
}
/**
 * Decorator. (lazily) bind the method to the class instance on first call.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function bound(target, key, descriptor) {
    return {
        configurable: true,
        enumerable: descriptor.enumerable,
        get() {
            const boundFn = descriptor.value.bind(this);
            Reflect.defineProperty(this, key, {
                value: boundFn,
                writable: true,
                configurable: true,
                enumerable: descriptor.enumerable,
            });
            return boundFn;
        },
    };
}
function mergeArrays(...arrays) {
    const result = [];
    let k = 0;
    const arraysLen = arrays.length;
    let arrayLen = 0;
    let array;
    for (let i = 0; i < arraysLen; ++i) {
        array = arrays[i];
        if (array !== void 0) {
            arrayLen = array.length;
            for (let j = 0; j < arrayLen; ++j) {
                result[k++] = array[j];
            }
        }
    }
    return result;
}
function mergeObjects(...objects) {
    const result = {};
    const objectsLen = objects.length;
    let object;
    let key;
    for (let i = 0; i < objectsLen; ++i) {
        object = objects[i];
        if (object !== void 0) {
            for (key in object) {
                result[key] = object[key];
            }
        }
    }
    return result;
}
function firstDefined(...values) {
    const len = values.length;
    let value;
    for (let i = 0; i < len; ++i) {
        value = values[i];
        if (value !== void 0) {
            return value;
        }
    }
    throw new Error(`No default value found`);
}
const getPrototypeChain = (function () {
    const functionPrototype = Function.prototype;
    const getPrototypeOf = Object.getPrototypeOf;
    const cache = new WeakMap();
    let proto = functionPrototype;
    let i = 0;
    let chain = void 0;
    return function (Type) {
        chain = cache.get(Type);
        if (chain === void 0) {
            cache.set(Type, chain = [proto = Type]);
            i = 0;
            while ((proto = getPrototypeOf(proto)) !== functionPrototype) {
                chain[++i] = proto;
            }
        }
        return chain;
    };
})();
function toLookup(...objs) {
    return Object.assign(Object.create(null), ...objs);
}
/**
 * Determine whether the value is a native function.
 *
 * @param fn - The function to check.
 * @returns `true` is the function is a native function, otherwise `false`
 */
const isNativeFunction = (function () {
    // eslint-disable-next-line @typescript-eslint/ban-types
    const lookup = new WeakMap();
    let isNative = false;
    let sourceText = '';
    let i = 0;
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function (fn) {
        isNative = lookup.get(fn);
        if (isNative === void 0) {
            sourceText = fn.toString();
            i = sourceText.length;
            // http://www.ecma-international.org/ecma-262/#prod-NativeFunction
            isNative = (
            // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string
            i >= 29 &&
                // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.
                i <= 100 &&
                // This whole heuristic *could* be tricked by a comment. Do we need to care about that?
                sourceText.charCodeAt(i - 1) === 0x7D && // }
                // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.
                sourceText.charCodeAt(i - 2) <= 0x20 && // whitespace
                sourceText.charCodeAt(i - 3) === 0x5D && // ]
                sourceText.charCodeAt(i - 4) === 0x65 && // e
                sourceText.charCodeAt(i - 5) === 0x64 && // d
                sourceText.charCodeAt(i - 6) === 0x6F && // o
                sourceText.charCodeAt(i - 7) === 0x63 && // c
                sourceText.charCodeAt(i - 8) === 0x20 && //
                sourceText.charCodeAt(i - 9) === 0x65 && // e
                sourceText.charCodeAt(i - 10) === 0x76 && // v
                sourceText.charCodeAt(i - 11) === 0x69 && // i
                sourceText.charCodeAt(i - 12) === 0x74 && // t
                sourceText.charCodeAt(i - 13) === 0x61 && // a
                sourceText.charCodeAt(i - 14) === 0x6E && // n
                sourceText.charCodeAt(i - 15) === 0x58 // [
            );
            lookup.set(fn, isNative);
        }
        return isNative;
    };
})();
/**
 * Normalize a potential promise via a callback, to ensure things stay synchronous when they can.
 *
 * If the value is a promise, it is `then`ed before the callback is invoked. Otherwise the callback is invoked synchronously.
 */
function onResolve(maybePromise, resolveCallback) {
    if (maybePromise instanceof Promise) {
        return maybePromise.then(resolveCallback);
    }
    return resolveCallback(maybePromise);
}
/**
 * Normalize an array of potential promises, to ensure things stay synchronous when they can.
 *
 * If exactly one value is a promise, then that promise is returned.
 *
 * If more than one value is a promise, a new `Promise.all` is returned.
 *
 * If none of the values is a promise, nothing is returned, to indicate that things can stay synchronous.
 */
function resolveAll(...maybePromises) {
    let maybePromise = void 0;
    let firstPromise = void 0;
    let promises = void 0;
    for (let i = 0, ii = maybePromises.length; i < ii; ++i) {
        maybePromise = maybePromises[i];
        if ((maybePromise = maybePromises[i]) instanceof Promise) {
            if (firstPromise === void 0) {
                firstPromise = maybePromise;
            }
            else if (promises === void 0) {
                promises = [firstPromise, maybePromise];
            }
            else {
                promises.push(maybePromise);
            }
        }
    }
    if (promises === void 0) {
        return firstPromise;
    }
    return Promise.all(promises);
}
//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IPlatform": () => /* binding */ IPlatform,
/* harmony export */   "Platform": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Platform,
/* harmony export */   "TaskQueue": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueue,
/* harmony export */   "Task": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Task,
/* harmony export */   "TaskAbortError": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskAbortError,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueuePriority,
/* harmony export */   "TaskStatus": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskStatus,
/* harmony export */   "all": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.all,
/* harmony export */   "DI": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.DI,
/* harmony export */   "IContainer": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.IContainer,
/* harmony export */   "inject": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.inject,
/* harmony export */   "IServiceLocator": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.IServiceLocator,
/* harmony export */   "lazy": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.lazy,
/* harmony export */   "optional": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.optional,
/* harmony export */   "ignore": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.ignore,
/* harmony export */   "Registration": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.Registration,
/* harmony export */   "singleton": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.singleton,
/* harmony export */   "transient": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.transient,
/* harmony export */   "InstanceProvider": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider,
/* harmony export */   "newInstanceForScope": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.newInstanceForScope,
/* harmony export */   "newInstanceOf": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.newInstanceOf,
/* harmony export */   "ContainerConfiguration": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.ContainerConfiguration,
/* harmony export */   "DefaultResolver": () => /* reexport safe */ _di_js__WEBPACK_IMPORTED_MODULE_0__.DefaultResolver,
/* harmony export */   "metadata": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata,
/* harmony export */   "Metadata": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Metadata,
/* harmony export */   "isNullOrUndefined": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined,
/* harmony export */   "isObject": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.isObject,
/* harmony export */   "applyMetadataPolyfill": () => /* reexport safe */ _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.applyMetadataPolyfill,
/* harmony export */   "LogLevel": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.LogLevel,
/* harmony export */   "ColorOptions": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ColorOptions,
/* harmony export */   "ILogConfig": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ILogConfig,
/* harmony export */   "ILogEventFactory": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ILogEventFactory,
/* harmony export */   "ISink": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ISink,
/* harmony export */   "ILogger": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ILogger,
/* harmony export */   "LogConfig": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.LogConfig,
/* harmony export */   "DefaultLogEvent": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.DefaultLogEvent,
/* harmony export */   "DefaultLogEventFactory": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.DefaultLogEventFactory,
/* harmony export */   "DefaultLogger": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.DefaultLogger,
/* harmony export */   "ConsoleSink": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.ConsoleSink,
/* harmony export */   "LoggerConfiguration": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.LoggerConfiguration,
/* harmony export */   "format": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.format,
/* harmony export */   "sink": () => /* reexport safe */ _logger_js__WEBPACK_IMPORTED_MODULE_3__.sink,
/* harmony export */   "IModuleLoader": () => /* reexport safe */ _module_loader_js__WEBPACK_IMPORTED_MODULE_4__.IModuleLoader,
/* harmony export */   "AnalyzedModule": () => /* reexport safe */ _module_loader_js__WEBPACK_IMPORTED_MODULE_4__.AnalyzedModule,
/* harmony export */   "ModuleItem": () => /* reexport safe */ _module_loader_js__WEBPACK_IMPORTED_MODULE_4__.ModuleItem,
/* harmony export */   "noop": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_5__.noop,
/* harmony export */   "emptyArray": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_5__.emptyArray,
/* harmony export */   "emptyObject": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_5__.emptyObject,
/* harmony export */   "Protocol": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.Protocol,
/* harmony export */   "fromAnnotationOrDefinitionOrTypeOrDefault": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.fromAnnotationOrDefinitionOrTypeOrDefault,
/* harmony export */   "fromAnnotationOrTypeOrDefault": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.fromAnnotationOrTypeOrDefault,
/* harmony export */   "fromDefinitionOrDefault": () => /* reexport safe */ _resource_js__WEBPACK_IMPORTED_MODULE_6__.fromDefinitionOrDefault,
/* harmony export */   "EventAggregator": () => /* reexport safe */ _eventaggregator_js__WEBPACK_IMPORTED_MODULE_7__.EventAggregator,
/* harmony export */   "IEventAggregator": () => /* reexport safe */ _eventaggregator_js__WEBPACK_IMPORTED_MODULE_7__.IEventAggregator,
/* harmony export */   "isArrayIndex": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isArrayIndex,
/* harmony export */   "camelCase": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.camelCase,
/* harmony export */   "kebabCase": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.kebabCase,
/* harmony export */   "pascalCase": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.pascalCase,
/* harmony export */   "toArray": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.toArray,
/* harmony export */   "nextId": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.nextId,
/* harmony export */   "resetId": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.resetId,
/* harmony export */   "compareNumber": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.compareNumber,
/* harmony export */   "mergeDistinct": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.mergeDistinct,
/* harmony export */   "isNumberOrBigInt": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isNumberOrBigInt,
/* harmony export */   "isStringOrDate": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isStringOrDate,
/* harmony export */   "bound": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.bound,
/* harmony export */   "mergeArrays": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.mergeArrays,
/* harmony export */   "mergeObjects": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.mergeObjects,
/* harmony export */   "firstDefined": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.firstDefined,
/* harmony export */   "getPrototypeChain": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.getPrototypeChain,
/* harmony export */   "isNativeFunction": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.isNativeFunction,
/* harmony export */   "onResolve": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.onResolve,
/* harmony export */   "resolveAll": () => /* reexport safe */ _functions_js__WEBPACK_IMPORTED_MODULE_8__.resolveAll
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger.js */ "./node_modules/@aurelia/kernel/dist/esm/logger.js");
/* harmony import */ var _module_loader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./module-loader.js */ "./node_modules/@aurelia/kernel/dist/esm/module-loader.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");
/* harmony import */ var _eventaggregator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./eventaggregator.js */ "./node_modules/@aurelia/kernel/dist/esm/eventaggregator.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./functions.js */ "./node_modules/@aurelia/kernel/dist/esm/functions.js");

const IPlatform = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IPlatform');









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/logger.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/logger.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogLevel": () => /* binding */ LogLevel,
/* harmony export */   "ColorOptions": () => /* binding */ ColorOptions,
/* harmony export */   "ILogConfig": () => /* binding */ ILogConfig,
/* harmony export */   "ISink": () => /* binding */ ISink,
/* harmony export */   "ILogEventFactory": () => /* binding */ ILogEventFactory,
/* harmony export */   "ILogger": () => /* binding */ ILogger,
/* harmony export */   "ILogScopes": () => /* binding */ ILogScopes,
/* harmony export */   "LoggerSink": () => /* binding */ LoggerSink,
/* harmony export */   "sink": () => /* binding */ sink,
/* harmony export */   "format": () => /* binding */ format,
/* harmony export */   "LogConfig": () => /* binding */ LogConfig,
/* harmony export */   "DefaultLogEvent": () => /* binding */ DefaultLogEvent,
/* harmony export */   "DefaultLogEventFactory": () => /* binding */ DefaultLogEventFactory,
/* harmony export */   "ConsoleSink": () => /* binding */ ConsoleSink,
/* harmony export */   "DefaultLogger": () => /* binding */ DefaultLogger,
/* harmony export */   "LoggerConfiguration": () => /* binding */ LoggerConfiguration
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functions.js */ "./node_modules/@aurelia/kernel/dist/esm/functions.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




var LogLevel;
(function (LogLevel) {
    /**
     * The most detailed information about internal app state.
     *
     * Disabled by default and should never be enabled in a production environment.
     */
    LogLevel[LogLevel["trace"] = 0] = "trace";
    /**
     * Information that is useful for debugging during development and has no long-term value.
     */
    LogLevel[LogLevel["debug"] = 1] = "debug";
    /**
     * Information about the general flow of the application that has long-term value.
     */
    LogLevel[LogLevel["info"] = 2] = "info";
    /**
     * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.
     */
    LogLevel[LogLevel["warn"] = 3] = "warn";
    /**
     * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.
     */
    LogLevel[LogLevel["error"] = 4] = "error";
    /**
     * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.
     */
    LogLevel[LogLevel["fatal"] = 5] = "fatal";
    /**
     * No messages should be written.
     */
    LogLevel[LogLevel["none"] = 6] = "none";
})(LogLevel || (LogLevel = {}));
/**
 * Flags to enable/disable color usage in the logging output.
 */
var ColorOptions;
(function (ColorOptions) {
    /**
     * Do not use ASCII color codes in logging output.
     */
    ColorOptions[ColorOptions["noColors"] = 0] = "noColors";
    /**
     * Use ASCII color codes in logging output. By default, timestamps and the TRC and DBG prefix are colored grey. INF white, WRN yellow, and ERR and FTL red.
     */
    ColorOptions[ColorOptions["colors"] = 1] = "colors";
})(ColorOptions || (ColorOptions = {}));
const ILogConfig = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogConfig', x => x.instance(new LogConfig(0 /* noColors */, 3 /* warn */)));
const ISink = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISink');
const ILogEventFactory = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogEventFactory', x => x.singleton(DefaultLogEventFactory));
const ILogger = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogger', x => x.singleton(DefaultLogger));
const ILogScopes = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILogScope');
const LoggerSink = Object.freeze({
    key: _resource_js__WEBPACK_IMPORTED_MODULE_2__.Protocol.annotation.keyFor('logger-sink-handles'),
    define(target, definition) {
        _aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata.define(this.key, definition.handles, target.prototype);
        return target;
    },
    getHandles(target) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.Metadata.get(this.key, target);
    },
});
function sink(definition) {
    return function (target) {
        return LoggerSink.define(target, definition);
    };
}
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
const format = (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
    red(str) {
        return `\u001b[31m${str}\u001b[39m`;
    },
    green(str) {
        return `\u001b[32m${str}\u001b[39m`;
    },
    yellow(str) {
        return `\u001b[33m${str}\u001b[39m`;
    },
    blue(str) {
        return `\u001b[34m${str}\u001b[39m`;
    },
    magenta(str) {
        return `\u001b[35m${str}\u001b[39m`;
    },
    cyan(str) {
        return `\u001b[36m${str}\u001b[39m`;
    },
    white(str) {
        return `\u001b[37m${str}\u001b[39m`;
    },
    grey(str) {
        return `\u001b[90m${str}\u001b[39m`;
    },
});
class LogConfig {
    constructor(colorOptions, level) {
        this.colorOptions = colorOptions;
        this.level = level;
    }
}
const getLogLevelString = (function () {
    const logLevelString = [
        (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
            TRC: 'TRC',
            DBG: 'DBG',
            INF: 'INF',
            WRN: 'WRN',
            ERR: 'ERR',
            FTL: 'FTL',
            QQQ: '???',
        }),
        (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
            TRC: format.grey('TRC'),
            DBG: format.grey('DBG'),
            INF: format.white('INF'),
            WRN: format.yellow('WRN'),
            ERR: format.red('ERR'),
            FTL: format.red('FTL'),
            QQQ: format.grey('???'),
        }),
    ];
    return function (level, colorOptions) {
        if (level <= 0 /* trace */) {
            return logLevelString[colorOptions].TRC;
        }
        if (level <= 1 /* debug */) {
            return logLevelString[colorOptions].DBG;
        }
        if (level <= 2 /* info */) {
            return logLevelString[colorOptions].INF;
        }
        if (level <= 3 /* warn */) {
            return logLevelString[colorOptions].WRN;
        }
        if (level <= 4 /* error */) {
            return logLevelString[colorOptions].ERR;
        }
        if (level <= 5 /* fatal */) {
            return logLevelString[colorOptions].FTL;
        }
        return logLevelString[colorOptions].QQQ;
    };
})();
function getScopeString(scope, colorOptions) {
    if (colorOptions === 0 /* noColors */) {
        return scope.join('.');
    }
    return scope.map(format.cyan).join('.');
}
function getIsoString(timestamp, colorOptions) {
    if (colorOptions === 0 /* noColors */) {
        return new Date(timestamp).toISOString();
    }
    return format.grey(new Date(timestamp).toISOString());
}
class DefaultLogEvent {
    constructor(severity, message, optionalParams, scope, colorOptions, timestamp) {
        this.severity = severity;
        this.message = message;
        this.optionalParams = optionalParams;
        this.scope = scope;
        this.colorOptions = colorOptions;
        this.timestamp = timestamp;
    }
    toString() {
        const { severity, message, scope, colorOptions, timestamp } = this;
        if (scope.length === 0) {
            return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;
        }
        return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;
    }
}
let DefaultLogEventFactory = class DefaultLogEventFactory {
    constructor(config) {
        this.config = config;
    }
    createLogEvent(logger, level, message, optionalParams) {
        return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());
    }
};
DefaultLogEventFactory = __decorate([
    __param(0, ILogConfig)
], DefaultLogEventFactory);

class ConsoleSink {
    constructor($console) {
        this.handleEvent = function emit(event) {
            const optionalParams = event.optionalParams;
            if (optionalParams === void 0 || optionalParams.length === 0) {
                switch (event.severity) {
                    case 0 /* trace */:
                    case 1 /* debug */:
                        return $console.debug(event.toString());
                    case 2 /* info */:
                        return $console.info(event.toString());
                    case 3 /* warn */:
                        return $console.warn(event.toString());
                    case 4 /* error */:
                    case 5 /* fatal */:
                        return $console.error(event.toString());
                }
            }
            else {
                switch (event.severity) {
                    case 0 /* trace */:
                    case 1 /* debug */:
                        return $console.debug(event.toString(), ...optionalParams);
                    case 2 /* info */:
                        return $console.info(event.toString(), ...optionalParams);
                    case 3 /* warn */:
                        return $console.warn(event.toString(), ...optionalParams);
                    case 4 /* error */:
                    case 5 /* fatal */:
                        return $console.error(event.toString(), ...optionalParams);
                }
            }
        };
    }
}
let DefaultLogger = class DefaultLogger {
    constructor(
    /**
     * The global logger configuration.
     */
    config, factory, sinks, 
    /**
     * The scopes that this logger was created for, if any.
     */
    scope = [], parent = null) {
        this.config = config;
        this.factory = factory;
        this.scope = scope;
        this.scopedLoggers = Object.create(null);
        let traceSinks;
        let debugSinks;
        let infoSinks;
        let warnSinks;
        let errorSinks;
        let fatalSinks;
        if (parent === null) {
            this.root = this;
            this.parent = this;
            traceSinks = this.traceSinks = [];
            debugSinks = this.debugSinks = [];
            infoSinks = this.infoSinks = [];
            warnSinks = this.warnSinks = [];
            errorSinks = this.errorSinks = [];
            fatalSinks = this.fatalSinks = [];
            for (const $sink of sinks) {
                const handles = LoggerSink.getHandles($sink);
                if (handles?.includes(0 /* trace */) ?? true) {
                    traceSinks.push($sink);
                }
                if (handles?.includes(1 /* debug */) ?? true) {
                    debugSinks.push($sink);
                }
                if (handles?.includes(2 /* info */) ?? true) {
                    infoSinks.push($sink);
                }
                if (handles?.includes(3 /* warn */) ?? true) {
                    warnSinks.push($sink);
                }
                if (handles?.includes(4 /* error */) ?? true) {
                    errorSinks.push($sink);
                }
                if (handles?.includes(5 /* fatal */) ?? true) {
                    fatalSinks.push($sink);
                }
            }
        }
        else {
            this.root = parent.root;
            this.parent = parent;
            traceSinks = this.traceSinks = parent.traceSinks;
            debugSinks = this.debugSinks = parent.debugSinks;
            infoSinks = this.infoSinks = parent.infoSinks;
            warnSinks = this.warnSinks = parent.warnSinks;
            errorSinks = this.errorSinks = parent.errorSinks;
            fatalSinks = this.fatalSinks = parent.fatalSinks;
        }
    }
    trace(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 0 /* trace */) {
            this.emit(this.traceSinks, 0 /* trace */, messageOrGetMessage, optionalParams);
        }
    }
    debug(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 1 /* debug */) {
            this.emit(this.debugSinks, 1 /* debug */, messageOrGetMessage, optionalParams);
        }
    }
    info(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 2 /* info */) {
            this.emit(this.infoSinks, 2 /* info */, messageOrGetMessage, optionalParams);
        }
    }
    warn(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 3 /* warn */) {
            this.emit(this.warnSinks, 3 /* warn */, messageOrGetMessage, optionalParams);
        }
    }
    error(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 4 /* error */) {
            this.emit(this.errorSinks, 4 /* error */, messageOrGetMessage, optionalParams);
        }
    }
    fatal(messageOrGetMessage, ...optionalParams) {
        if (this.config.level <= 5 /* fatal */) {
            this.emit(this.fatalSinks, 5 /* fatal */, messageOrGetMessage, optionalParams);
        }
    }
    /**
     * Create a new logger with an additional permanent prefix added to the logging outputs.
     * When chained, multiple scopes are separated by a dot.
     *
     * This is preliminary API and subject to change before alpha release.
     *
     * @example
     *
     * ```ts
     * export class MyComponent {
     *   constructor(@ILogger private logger: ILogger) {
     *     this.logger.debug('before scoping');
     *     // console output: '[DBG] before scoping'
     *     this.logger = logger.scopeTo('MyComponent');
     *     this.logger.debug('after scoping');
     *     // console output: '[DBG MyComponent] after scoping'
     *   }
     *
     *   public doStuff(): void {
     *     const logger = this.logger.scopeTo('doStuff()');
     *     logger.debug('doing stuff');
     *     // console output: '[DBG MyComponent.doStuff()] doing stuff'
     *   }
     * }
     * ```
     */
    scopeTo(name) {
        const scopedLoggers = this.scopedLoggers;
        let scopedLogger = scopedLoggers[name];
        if (scopedLogger === void 0) {
            scopedLogger = scopedLoggers[name] = new DefaultLogger(this.config, this.factory, (void 0), this.scope.concat(name), this);
        }
        return scopedLogger;
    }
    emit(sinks, level, msgOrGetMsg, optionalParams) {
        const message = typeof msgOrGetMsg === 'function' ? msgOrGetMsg() : msgOrGetMsg;
        const event = this.factory.createLogEvent(this, level, message, optionalParams);
        for (let i = 0, ii = sinks.length; i < ii; ++i) {
            sinks[i].handleEvent(event);
        }
    }
};
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "trace", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "debug", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "info", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "warn", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "error", null);
__decorate([
    _functions_js__WEBPACK_IMPORTED_MODULE_1__.bound
], DefaultLogger.prototype, "fatal", null);
DefaultLogger = __decorate([
    __param(0, ILogConfig),
    __param(1, ILogEventFactory),
    __param(2, (0,_di_js__WEBPACK_IMPORTED_MODULE_0__.all)(ISink)),
    __param(3, (0,_di_js__WEBPACK_IMPORTED_MODULE_0__.optional)(ILogScopes)),
    __param(4, _di_js__WEBPACK_IMPORTED_MODULE_0__.ignore)
], DefaultLogger);

/**
 * A basic `ILogger` configuration that configures a single `console` sink based on provided options.
 *
 * NOTE: You *must* register the return value of `.create` with the container / au instance, not this `LoggerConfiguration` object itself.
 *
 * @example
 * ```ts
 * container.register(LoggerConfiguration.create());
 *
 * container.register(LoggerConfiguration.create({$console: console}))
 *
 * container.register(LoggerConfiguration.create({$console: console, level: LogLevel.debug}))
 *
 * container.register(LoggerConfiguration.create({
 *  $console: {
 *     debug: noop,
 *     info: noop,
 *     warn: noop,
 *     error: msg => {
 *       throw new Error(msg);
 *     }
 *  },
 *  level: LogLevel.debug
 * }))
 *
 * ```
 */
const LoggerConfiguration = (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
    /**
     * @param $console - The `console` object to use. Can be the native `window.console` / `global.console`, but can also be a wrapper or mock that implements the same interface.
     * @param level - The global `LogLevel` to configure. Defaults to `warn` or higher.
     * @param colorOptions - Whether to use colors or not. Defaults to `noColors`. Colors are especially nice in nodejs environments but don't necessarily work (well) in all environments, such as browsers.
     */
    create({ $console, level = 3 /* warn */, colorOptions = 0 /* noColors */, sinks = [], } = {}) {
        return (0,_functions_js__WEBPACK_IMPORTED_MODULE_1__.toLookup)({
            register(container) {
                container.register(_di_js__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(ILogConfig, new LogConfig(colorOptions, level)));
                if ($console !== void 0 && $console !== null) {
                    container.register(_di_js__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(ISink, new ConsoleSink($console)));
                }
                for (const $sink of sinks) {
                    container.register(_di_js__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(ISink, $sink));
                }
                return container;
            },
        });
    },
});
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/module-loader.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/module-loader.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IModuleLoader": () => /* binding */ IModuleLoader,
/* harmony export */   "ModuleLoader": () => /* binding */ ModuleLoader,
/* harmony export */   "AnalyzedModule": () => /* binding */ AnalyzedModule,
/* harmony export */   "ModuleItem": () => /* binding */ ModuleItem
/* harmony export */ });
/* harmony import */ var _di_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./di.js */ "./node_modules/@aurelia/kernel/dist/esm/di.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");
/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resource.js */ "./node_modules/@aurelia/kernel/dist/esm/resource.js");



const IModuleLoader = _di_js__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface(x => x.singleton(ModuleLoader));
function noTransform(m) {
    return m;
}
class ModuleTransformer {
    constructor($transform) {
        this.$transform = $transform;
        this.promiseCache = new Map();
        this.objectCache = new Map();
    }
    transform(objOrPromise) {
        if (objOrPromise instanceof Promise) {
            return this.transformPromise(objOrPromise);
        }
        else if (typeof objOrPromise === 'object' && objOrPromise !== null) {
            return this.transformObject(objOrPromise);
        }
        else {
            throw new Error(`Invalid input: ${String(objOrPromise)}. Expected Promise or Object.`);
        }
    }
    transformPromise(promise) {
        if (this.promiseCache.has(promise)) {
            return this.promiseCache.get(promise);
        }
        const ret = promise.then(obj => {
            return this.transformObject(obj);
        });
        this.promiseCache.set(promise, ret);
        void ret.then(value => {
            // make it synchronous for future requests
            this.promiseCache.set(promise, value);
        });
        return ret;
    }
    transformObject(obj) {
        if (this.objectCache.has(obj)) {
            return this.objectCache.get(obj);
        }
        const ret = this.$transform(this.analyze(obj));
        this.objectCache.set(obj, ret);
        if (ret instanceof Promise) {
            void ret.then(value => {
                // make it synchronous for future requests
                this.objectCache.set(obj, value);
            });
        }
        return ret;
    }
    analyze(m) {
        let value;
        let isRegistry;
        let isConstructable;
        let definitions;
        const items = [];
        for (const key in m) {
            switch (typeof (value = m[key])) {
                case 'object':
                    if (value === null) {
                        continue;
                    }
                    isRegistry = typeof value.register === 'function';
                    isConstructable = false;
                    definitions = _platform_js__WEBPACK_IMPORTED_MODULE_1__.emptyArray;
                    break;
                case 'function':
                    isRegistry = typeof value.register === 'function';
                    isConstructable = value.prototype !== void 0;
                    definitions = _resource_js__WEBPACK_IMPORTED_MODULE_2__.Protocol.resource.getAll(value);
                    break;
                default:
                    continue;
            }
            items.push(new ModuleItem(key, value, isRegistry, isConstructable, definitions));
        }
        return new AnalyzedModule(m, items);
    }
}
class ModuleLoader {
    constructor() {
        this.transformers = new Map();
    }
    load(objOrPromise, transform = noTransform) {
        const transformers = this.transformers;
        let transformer = transformers.get(transform);
        if (transformer === void 0) {
            transformers.set(transform, transformer = new ModuleTransformer(transform));
        }
        return transformer.transform(objOrPromise);
    }
    dispose() {
        this.transformers.clear();
    }
}
class AnalyzedModule {
    constructor(raw, items) {
        this.raw = raw;
        this.items = items;
    }
}
class ModuleItem {
    constructor(key, value, isRegistry, isConstructable, definitions) {
        this.key = key;
        this.value = value;
        this.isRegistry = isRegistry;
        this.isConstructable = isConstructable;
        this.definitions = definitions;
    }
}
//# sourceMappingURL=module-loader.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/platform.js":
/*!***********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/platform.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "emptyArray": () => /* binding */ emptyArray,
/* harmony export */   "emptyObject": () => /* binding */ emptyObject,
/* harmony export */   "noop": () => /* binding */ noop
/* harmony export */ });
/* eslint-disable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */
const emptyArray = Object.freeze([]);
const emptyObject = Object.freeze({});
/* eslint-enable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */
// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() { }
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/@aurelia/kernel/dist/esm/resource.js":
/*!***********************************************************!*\
  !*** ./node_modules/@aurelia/kernel/dist/esm/resource.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Protocol": () => /* binding */ Protocol,
/* harmony export */   "fromAnnotationOrDefinitionOrTypeOrDefault": () => /* binding */ fromAnnotationOrDefinitionOrTypeOrDefault,
/* harmony export */   "fromAnnotationOrTypeOrDefault": () => /* binding */ fromAnnotationOrTypeOrDefault,
/* harmony export */   "fromDefinitionOrDefault": () => /* binding */ fromDefinitionOrDefault
/* harmony export */ });
/* harmony import */ var _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/metadata */ "./node_modules/@aurelia/metadata/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/kernel/dist/esm/platform.js");


const annotation = {
    name: 'au:annotation',
    appendTo(target, key) {
        const keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(annotation.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(annotation.name, [key], target);
        }
        else {
            keys.push(key);
        }
    },
    set(target, prop, value) {
        _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(annotation.keyFor(prop), value, target);
    },
    get(target, prop) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(annotation.keyFor(prop), target);
    },
    getKeys(target) {
        let keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(annotation.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(annotation.name, keys = [], target);
        }
        return keys;
    },
    isKey(key) {
        return key.startsWith(annotation.name);
    },
    keyFor(name, context) {
        if (context === void 0) {
            return `${annotation.name}:${name}`;
        }
        return `${annotation.name}:${name}:${context}`;
    },
};
const resource = {
    name: 'au:resource',
    appendTo(target, key) {
        const keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(resource.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(resource.name, [key], target);
        }
        else {
            keys.push(key);
        }
    },
    has(target) {
        return _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(resource.name, target);
    },
    getAll(target) {
        const keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(resource.name, target);
        if (keys === void 0) {
            return _platform_js__WEBPACK_IMPORTED_MODULE_1__.emptyArray;
        }
        else {
            return keys.map(k => _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(k, target));
        }
    },
    getKeys(target) {
        let keys = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(resource.name, target);
        if (keys === void 0) {
            _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(resource.name, keys = [], target);
        }
        return keys;
    },
    isKey(key) {
        return key.startsWith(resource.name);
    },
    keyFor(name, context) {
        if (context === void 0) {
            return `${resource.name}:${name}`;
        }
        return `${resource.name}:${name}:${context}`;
    },
};
const Protocol = {
    annotation,
    resource,
};
const hasOwn = Object.prototype.hasOwnProperty;
/**
 * The order in which the values are checked:
 * 1. Annotations (usually set by decorators) have the highest priority; they override the definition as well as static properties on the type.
 * 2. Definition properties (usually set by the customElement decorator object literal) come next. They override static properties on the type.
 * 3. Static properties on the type come last. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)
 * 4. The default property that is provided last. The function is only called if the default property is needed
 */
function fromAnnotationOrDefinitionOrTypeOrDefault(name, def, Type, getDefault) {
    let value = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Protocol.annotation.keyFor(name), Type);
    if (value === void 0) {
        value = def[name];
        if (value === void 0) {
            value = Type[name];
            if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain
                return getDefault();
            }
            return value;
        }
        return value;
    }
    return value;
}
/**
 * The order in which the values are checked:
 * 1. Annotations (usually set by decorators) have the highest priority; they override static properties on the type.
 * 2. Static properties on the typ. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)
 * 3. The default property that is provided last. The function is only called if the default property is needed
 */
function fromAnnotationOrTypeOrDefault(name, Type, getDefault) {
    let value = _aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Protocol.annotation.keyFor(name), Type);
    if (value === void 0) {
        value = Type[name];
        if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain
            return getDefault();
        }
        return value;
    }
    return value;
}
/**
 * The order in which the values are checked:
 * 1. Definition properties.
 * 2. The default property that is provided last. The function is only called if the default property is needed
 */
function fromDefinitionOrDefault(name, def, getDefault) {
    const value = def[name];
    if (value === void 0) {
        return getDefault();
    }
    return value;
}
//# sourceMappingURL=resource.js.map

/***/ }),

/***/ "./node_modules/@aurelia/metadata/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aurelia/metadata/dist/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObject": () => /* binding */ isObject,
/* harmony export */   "isNullOrUndefined": () => /* binding */ isNullOrUndefined,
/* harmony export */   "metadata": () => /* binding */ metadata,
/* harmony export */   "Metadata": () => /* binding */ Metadata,
/* harmony export */   "applyMetadataPolyfill": () => /* binding */ applyMetadataPolyfill
/* harmony export */ });
/**
 * Determine whether a value is an object.
 *
 * Uses `typeof` to guarantee this works cross-realm, which is where `instanceof Object` might fail.
 *
 * Some environments where these issues are known to arise:
 * - same-origin iframes (accessing the other realm via `window.top`)
 * - `jest`.
 *
 * The exact test is:
 * ```ts
 * typeof value === 'object' && value !== null || typeof value === 'function'
 * ```
 *
 * @param value - The value to test.
 * @returns `true` if the value is an object, otherwise `false`.
 * Also performs a type assertion that defaults to `value is Object | Function` which, if the input type is a union with an object type, will infer the correct type.
 * This can be overridden with the generic type argument.
 *
 * @example
 *
 * ```ts
 * class Foo {
 *   bar = 42;
 * }
 *
 * function doStuff(input?: Foo | null) {
 *   input.bar; // Object is possibly 'null' or 'undefined'
 *
 *   // input has an object type in its union (Foo) so that type will be extracted for the 'true' condition
 *   if (isObject(input)) {
 *     input.bar; // OK (input is now typed as Foo)
 *   }
 * }
 *
 * function doOtherStuff(input: unknown) {
 *   input.bar; // Object is of type 'unknown'
 *
 *   // input is 'unknown' so there is no union type to match and it will default to 'Object | Function'
 *   if (isObject(input)) {
 *     input.bar; // Property 'bar' does not exist on type 'Object | Function'
 *   }
 *
 *   // if we know for sure that, if input is an object, it must be a specific type, we can explicitly tell the function to assert that for us
 *   if (isObject<Foo>(input)) {
 *    input.bar; // OK (input is now typed as Foo)
 *   }
 * }
 * ```
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(value) {
    return typeof value === 'object' && value !== null || typeof value === 'function';
}
/**
 * Determine whether a value is `null` or `undefined`.
 *
 * @param value - The value to test.
 * @returns `true` if the value is `null` or `undefined`, otherwise `false`.
 * Also performs a type assertion that ensures TypeScript treats the value appropriately in the `if` and `else` branches after this check.
 */
function isNullOrUndefined(value) {
    return value === null || value === void 0;
}
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/ban-types */
const metadataInternalSlot = new WeakMap();
function $typeError(operation, args, paramName, actualValue, expectedType) {
    return new TypeError(`${operation}(${args.map(String).join(',')}) - Expected '${paramName}' to be of type ${expectedType}, but got: ${Object.prototype.toString.call(actualValue)} (${String(actualValue)})`);
}
function toPropertyKeyOrUndefined(propertyKey) {
    switch (typeof propertyKey) {
        case 'undefined':
        case 'string':
        case 'symbol':
            return propertyKey;
        default:
            return `${propertyKey}`;
    }
}
function toPropertyKey(propertyKey) {
    switch (typeof propertyKey) {
        case 'string':
        case 'symbol':
            return propertyKey;
        default:
            return `${propertyKey}`;
    }
}
function ensurePropertyKeyOrUndefined(propertyKey) {
    switch (typeof propertyKey) {
        case 'undefined':
        case 'string':
        case 'symbol':
            return propertyKey;
        default:
            throw new TypeError(`Invalid metadata propertyKey: ${propertyKey}.`);
    }
}
function GetOrCreateMetadataMap(O, P, Create) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let targetMetadata be the value of O's [[Metadata]] internal slot.
    let targetMetadata = metadataInternalSlot.get(O);
    // 3. If targetMetadata is undefined, then
    if (targetMetadata === void 0) {
        // 3. a. If Create is false, return undefined.
        if (!Create) {
            return void 0;
        }
        // 3. b. Set targetMetadata to be a newly created Map object.
        targetMetadata = new Map();
        // 3. c. Set the [[Metadata]] internal slot of O to targetMetadata.
        metadataInternalSlot.set(O, targetMetadata);
    }
    // 4. Let metadataMap be ? Invoke(targetMetadata, "get", P).
    let metadataMap = targetMetadata.get(P);
    // 5. If metadataMap is undefined, then
    if (metadataMap === void 0) {
        // 5. a. If Create is false, return undefined.
        if (!Create) {
            return void 0;
        }
        // 5. b. Set metadataMap to be a newly created Map object.
        metadataMap = new Map();
        // 5. c. Perform ? Invoke(targetMetadata, "set", P, metadataMap).
        targetMetadata.set(P, metadataMap);
    }
    // 6. Return metadataMap.
    return metadataMap;
}
// 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);
    // 3. If metadataMap is undefined, return false.
    if (metadataMap === void 0) {
        return false;
    }
    // 4. Return ? ToBoolean(? Invoke(metadataMap, "has", MetadataKey)).
    return metadataMap.has(MetadataKey);
}
// 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
function OrdinaryHasMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).
    // 3. If hasOwn is true, return true.
    if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {
        return true;
    }
    // 4. Let parent be ? O.[[GetPrototypeOf]]().
    const parent = Object.getPrototypeOf(O);
    // 5. If parent is not null, Return ? parent.[[HasMetadata]](MetadataKey, P).
    if (parent !== null) {
        return OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    // 6. Return false.
    return false;
}
// 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);
    // 3. If metadataMap is undefined, return undefined.
    if (metadataMap === void 0) {
        return void 0;
    }
    // 4. Return ? Invoke(metadataMap, "get", MetadataKey).
    return metadataMap.get(MetadataKey);
}
// 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
function OrdinaryGetMetadata(MetadataKey, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).
    // 3. If hasOwn is true, return ? OrdinaryGetOwnMetadata(MetadataKey, O, P).
    if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
    }
    // 4. Let parent be ? O.[[GetPrototypeOf]]().
    const parent = Object.getPrototypeOf(O);
    // 5. If parent is not null, return ? parent.[[GetMetadata]](MetadataKey, P).
    if (parent !== null) {
        return OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    // 6. Return undefined.
    return void 0;
}
// 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, true).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ true);
    // 3. Return ? Invoke(metadataMap, "set", MetadataKey, MetadataValue).
    metadataMap.set(MetadataKey, MetadataValue);
}
// 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
function OrdinaryOwnMetadataKeys(O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let keys be ? ArrayCreate(0).
    const keys = [];
    // 3. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);
    // 4. If metadataMap is undefined, return keys.
    if (metadataMap === void 0) {
        return keys;
    }
    // 5. Let keysObj be ? Invoke(metadataMap, "keys").
    const keysObj = metadataMap.keys();
    // 6. Let iterator be ? GetIterator(keysObj).
    // 7. Let k be 0.
    let k = 0;
    // 8. Repeat
    for (const key of keysObj) {
        // 8. a. Let Pk be ! ToString(k).
        // 8. b. Let next be ? IteratorStep(iterator).
        // 8. c. If next is false, then
        // 8. c. i. Let setStatus be ? Set(keys, "length", k, true).
        // 8. c. ii. Assert: setStatus is true.
        // 8. c. iii. Return keys.
        // 8. d. Let nextValue be ? IteratorValue(next).
        // 8. e. Let defineStatus be CreateDataPropertyOrThrow(keys, Pk, nextValue).
        keys[k] = key;
        // 8. f. If defineStatus is an abrupt completion, return ? IteratorClose(iterator, defineStatus).
        // 8. g. Increase k by 1.
        ++k;
    }
    return keys;
}
// 3.1.6.1 OrdinaryMetadataKeys(O, P)
// https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
function OrdinaryMetadataKeys(O, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let ownKeys be ? OrdinaryOwnMetadataKeys(O, P).
    const ownKeys = OrdinaryOwnMetadataKeys(O, P);
    // 3. Let parent be ? O.[[GetPrototypeOf]]().
    const parent = Object.getPrototypeOf(O);
    // 4. If parent is null, then return ownKeys.
    if (parent === null) {
        return ownKeys;
    }
    // 5. Let parentKeys be ? O.[[OrdinaryMetadataKeys]](P).
    const parentKeys = OrdinaryMetadataKeys(parent, P);
    // 6. Let ownKeysLen = ? Get(ownKeys, "length").
    const ownKeysLen = ownKeys.length;
    // 7. If ownKeysLen is 0, return parentKeys.
    if (ownKeysLen === 0) {
        return parentKeys;
    }
    // 8. Let parentKeysLen = ? Get(parentKeys, "length").
    const parentKeysLen = parentKeys.length;
    // 9. If parentKeysLen is 0, return ownKeys.
    if (parentKeysLen === 0) {
        return ownKeys;
    }
    // 10. Let set be a newly created Set object.
    const set = new Set();
    // 11. Let keys be ? ArrayCreate(0).
    const keys = [];
    // 12. Let k be 0.
    let k = 0;
    // 13. For each element key of ownKeys
    let key;
    for (let i = 0; i < ownKeysLen; ++i) {
        key = ownKeys[i];
        // 13. a. Let hasKey be ? Invoke(set, "has", key).
        // 13. b. If hasKey is false, then
        if (!set.has(key)) {
            // 13. b. i. Let Pk be ! ToString(k).
            // 13. b. ii. Perform ? Invoke(set, "add", key).
            set.add(key);
            // 13. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).
            // 13. b. iv. Assert: defineStatus is true.
            keys[k] = key;
            // 13. b. v. Increase k by 1.
            ++k;
        }
    }
    // 14. For each element key of parentKeys
    for (let i = 0; i < parentKeysLen; ++i) {
        key = parentKeys[i];
        // 14. a. Let hasKey be ? Invoke(set, "has", key).
        // 14. b. If hasKey is false, then
        if (!set.has(key)) {
            // 14. b. i. Let Pk be ! ToString(k).
            // 14. b. ii. Perform ? Invoke(set, "add", key).
            set.add(key);
            // 14. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).
            // 14. b. iv. Assert: defineStatus is true.
            keys[k] = key;
            // 14. b. v. Increase k by 1.
            ++k;
        }
    }
    // 15. Perform ? Set(keys, "length", k).
    // 16. return keys.
    return keys;
}
// 3.1.8 DeleteMetadata(MetadataKey, P)
// https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots-deletemetadata
function OrdinaryDeleteMetadata(O, MetadataKey, P) {
    // 1. Assert: P is undefined or IsPropertyKey(P) is true.
    // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).
    const metadataMap = GetOrCreateMetadataMap(O, P, false);
    // 3. If metadataMap is undefined, return false.
    if (metadataMap === void 0) {
        return false;
    }
    // 4. Return ? Invoke(metadataMap, "delete", MetadataKey).
    return metadataMap.delete(MetadataKey);
}
// 4.1.2 Reflect.metadata(metadataKey, metadataValue)
// https://rbuckton.github.io/reflect-metadata/#reflect.metadata
/**
 * A default metadata decorator factory that can be used on a class, class member, or parameter.
 *
 * @param metadataKey - The key for the metadata entry.
 * If `metadataKey` is already defined for the target and target key, the
 * metadataValue for that key will be overwritten.
 * @param metadataValue - The value for the metadata entry.
 * @returns A decorator function.
 */
function metadata(metadataKey, metadataValue) {
    function decorator(target, propertyKey) {
        // 1. Assert: F has a [[MetadataKey]] internal slot whose value is an ECMAScript language value, or undefined.
        // 2. Assert: F has a [[MetadataValue]] internal slot whose value is an ECMAScript language value, or undefined.
        // 3. If Type(target) is not Object, throw a TypeError exception.
        if (!isObject(target)) {
            throw $typeError('@metadata', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');
        }
        // 4. If key is not undefined and IsPropertyKey(key) is false, throw a TypeError exception.
        // 5. Let metadataKey be the value of F's [[MetadataKey]] internal slot.
        // 6. Let metadataValue be the value of F's [[MetadataValue]] internal slot.
        // 7. Perform ? target.[[DefineMetadata]](metadataKey, metadataValue, target, key).
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, ensurePropertyKeyOrUndefined(propertyKey));
        // 8. Return undefined.
    }
    return decorator;
}
function decorate(decorators, target, propertyKey, attributes) {
    if (propertyKey !== void 0) {
        if (!Array.isArray(decorators)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');
        }
        if (!isObject(target)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Object or Function');
        }
        if (!isObject(attributes) && !isNullOrUndefined(attributes)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'attributes', attributes, 'Object, Function, null, or undefined');
        }
        if (attributes === null) {
            attributes = void 0;
        }
        propertyKey = toPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
    }
    else {
        if (!Array.isArray(decorators)) {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');
        }
        if (typeof target !== 'function') {
            throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Function');
        }
        return DecorateConstructor(decorators, target);
    }
}
function DecorateConstructor(decorators, target) {
    for (let i = decorators.length - 1; i >= 0; --i) {
        const decorator = decorators[i];
        const decorated = decorator(target);
        if (!isNullOrUndefined(decorated)) {
            if (typeof decorated !== 'function') {
                throw $typeError('DecorateConstructor', [decorators, target], 'decorated', decorated, 'Function, null, or undefined');
            }
            target = decorated;
        }
    }
    return target;
}
function DecorateProperty(decorators, target, propertyKey, descriptor) {
    for (let i = decorators.length - 1; i >= 0; --i) {
        const decorator = decorators[i];
        const decorated = decorator(target, propertyKey, descriptor);
        if (!isNullOrUndefined(decorated)) {
            if (!isObject(decorated)) {
                throw $typeError('DecorateProperty', [decorators, target, propertyKey, descriptor], 'decorated', decorated, 'Object, Function, null, or undefined');
            }
            descriptor = decorated;
        }
    }
    return descriptor;
}
function $define(metadataKey, metadataValue, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.define', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[DefineMetadata]](metadataKey, metadataValue, propertyKey).
    return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, toPropertyKeyOrUndefined(propertyKey));
}
function $has(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.has', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[HasMetadata]](metadataKey, propertyKey).
    return OrdinaryHasMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $hasOwn(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.hasOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[HasOwn]](metadataKey, propertyKey).
    return OrdinaryHasOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $get(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.get', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetMetadata]](metadataKey, propertyKey).
    return OrdinaryGetMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $getOwn(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.getOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetOwnMetadata]](metadataKey, propertyKey).
    return OrdinaryGetOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));
}
function $getKeys(target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.getKeys', [target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetMetadataKeys]](propertyKey).
    return OrdinaryMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));
}
function $getOwnKeys(target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.getOwnKeys', [target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[GetOwnMetadataKeys]](propertyKey).
    return OrdinaryOwnMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));
}
function $delete(metadataKey, target, propertyKey) {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!isObject(target)) {
        throw $typeError('Metadata.delete', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');
    }
    // 2. Return ? target.[[DeleteMetadata]](metadataKey, propertyKey).
    return OrdinaryDeleteMetadata(target, metadataKey, toPropertyKeyOrUndefined(propertyKey));
}
const Metadata = {
    define: $define,
    has: $has,
    hasOwn: $hasOwn,
    get: $get,
    getOwn: $getOwn,
    getKeys: $getKeys,
    getOwnKeys: $getOwnKeys,
    delete: $delete,
};
function def(obj, key, value, writable, configurable) {
    if (!Reflect.defineProperty(obj, key, {
        writable,
        enumerable: false,
        configurable,
        value,
    })) {
        throw new Error(`Unable to apply metadata polyfill: could not add property '${key}' to the global Reflect object`);
    }
}
const internalSlotName = '[[$au]]';
function hasInternalSlot(reflect) {
    return internalSlotName in reflect;
}
function $applyMetadataPolyfill(reflect, writable, configurable) {
    def(reflect, internalSlotName, metadataInternalSlot, writable, configurable);
    def(reflect, 'metadata', metadata, writable, configurable);
    def(reflect, 'decorate', decorate, writable, configurable);
    def(reflect, 'defineMetadata', $define, writable, configurable);
    def(reflect, 'hasMetadata', $has, writable, configurable);
    def(reflect, 'hasOwnMetadata', $hasOwn, writable, configurable);
    def(reflect, 'getMetadata', $get, writable, configurable);
    def(reflect, 'getOwnMetadata', $getOwn, writable, configurable);
    def(reflect, 'getMetadataKeys', $getKeys, writable, configurable);
    def(reflect, 'getOwnMetadataKeys', $getOwnKeys, writable, configurable);
    def(reflect, 'deleteMetadata', $delete, writable, configurable);
}
function applyMetadataPolyfill(reflect, throwIfConflict = true, forceOverwrite = false, writable = true, configurable = true) {
    if (hasInternalSlot(reflect)) {
        if (reflect[internalSlotName] === metadataInternalSlot) {
            return;
        }
        throw new Error(`Conflicting @aurelia/metadata module import detected. Please make sure you have the same version of all Aurelia packages in your dependency tree.`);
    }
    const presentProps = [
        'metadata',
        'decorate',
        'defineMetadata',
        'hasMetadata',
        'hasOwnMetadata',
        'getMetadata',
        'getOwnMetadata',
        'getMetadataKeys',
        'getOwnMetadataKeys',
        'deleteMetadata',
    ].filter(function (p) {
        return p in Reflect;
    });
    if (presentProps.length > 0) {
        if (throwIfConflict) {
            const implementationSummary = presentProps.map(function (p) {
                const impl = `${Reflect[p].toString().slice(0, 100)}...`;
                return `${p}:\n${impl}`;
            }).join('\n\n');
            throw new Error(`Conflicting reflect.metadata polyfill found. If you have 'reflect-metadata' or any other reflect polyfill imported, please remove it, if not (or if you must use a specific polyfill) please file an issue at https://github.com/aurelia/aurelia/issues so that we can look into compatibility options for this scenario. Implementation summary:\n\n${implementationSummary}`);
        }
        else if (forceOverwrite) {
            $applyMetadataPolyfill(reflect, writable, configurable);
        }
    }
    else {
        $applyMetadataPolyfill(reflect, writable, configurable);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/platform-browser/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aurelia/platform-browser/dist/esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserPlatform": () => /* binding */ BrowserPlatform
/* harmony export */ });
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");

const lookup = new Map();
function notImplemented(name) {
    return function notImplemented() {
        throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name}'.`); // TODO: link to docs describing how to fix this issue
    };
}
class BrowserPlatform extends _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.Platform {
    constructor(g, overrides = {}) {
        super(g, overrides);
        this.domReadRequested = false;
        this.domReadHandle = -1;
        this.domWriteRequested = false;
        this.domWriteHandle = -1;
        this.Node = 'Node' in overrides ? overrides.Node : g.Node;
        this.Element = 'Element' in overrides ? overrides.Element : g.Element;
        this.HTMLElement = 'HTMLElement' in overrides ? overrides.HTMLElement : g.HTMLElement;
        this.CustomEvent = 'CustomEvent' in overrides ? overrides.CustomEvent : g.CustomEvent;
        this.CSSStyleSheet = 'CSSStyleSheet' in overrides ? overrides.CSSStyleSheet : g.CSSStyleSheet;
        this.ShadowRoot = 'ShadowRoot' in overrides ? overrides.ShadowRoot : g.ShadowRoot;
        this.MutationObserver = 'MutationObserver' in overrides ? overrides.MutationObserver : g.MutationObserver;
        this.window = 'window' in overrides ? overrides.window : g.window;
        this.document = 'document' in overrides ? overrides.document : g.document;
        this.location = 'location' in overrides ? overrides.location : g.location;
        this.history = 'history' in overrides ? overrides.history : g.history;
        this.navigator = 'navigator' in overrides ? overrides.navigator : g.navigator;
        this.fetch = 'fetch' in overrides ? overrides.fetch : g.fetch?.bind(g) ?? notImplemented('fetch');
        this.requestAnimationFrame = 'requestAnimationFrame' in overrides ? overrides.requestAnimationFrame : g.requestAnimationFrame?.bind(g) ?? notImplemented('requestAnimationFrame');
        this.cancelAnimationFrame = 'cancelAnimationFrame' in overrides ? overrides.cancelAnimationFrame : g.cancelAnimationFrame?.bind(g) ?? notImplemented('cancelAnimationFrame');
        this.customElements = 'customElements' in overrides ? overrides.customElements : g.customElements;
        this.flushDomRead = this.flushDomRead.bind(this);
        this.flushDomWrite = this.flushDomWrite.bind(this);
        this.domReadQueue = new _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueue(this, this.requestDomRead.bind(this), this.cancelDomRead.bind(this));
        this.domWriteQueue = new _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueue(this, this.requestDomWrite.bind(this), this.cancelDomWrite.bind(this));
        /* eslint-enable @typescript-eslint/no-unnecessary-type-assertion */
    }
    static getOrCreate(g, overrides = {}) {
        let platform = lookup.get(g);
        if (platform === void 0) {
            lookup.set(g, platform = new BrowserPlatform(g, overrides));
        }
        return platform;
    }
    static set(g, platform) {
        lookup.set(g, platform);
    }
    requestDomRead() {
        this.domReadRequested = true;
        // Yes, this is intentional: the timing of the read can only be "found" by doing a write first.
        // The flushDomWrite queues the read.
        // If/when requestPostAnimationFrame is implemented in browsers, we can use that instead.
        if (this.domWriteHandle === -1) {
            this.domWriteHandle = this.requestAnimationFrame(this.flushDomWrite);
        }
    }
    cancelDomRead() {
        this.domReadRequested = false;
        if (this.domReadHandle > -1) {
            this.clearTimeout(this.domReadHandle);
            this.domReadHandle = -1;
        }
        if (this.domWriteRequested === false && this.domWriteHandle > -1) {
            this.cancelAnimationFrame(this.domWriteHandle);
            this.domWriteHandle = -1;
        }
    }
    flushDomRead() {
        this.domReadHandle = -1;
        if (this.domReadRequested === true) {
            this.domReadRequested = false;
            this.domReadQueue.flush();
        }
    }
    requestDomWrite() {
        this.domWriteRequested = true;
        if (this.domWriteHandle === -1) {
            this.domWriteHandle = this.requestAnimationFrame(this.flushDomWrite);
        }
    }
    cancelDomWrite() {
        this.domWriteRequested = false;
        if (this.domWriteHandle > -1 &&
            // if dom read is requested and there is no readHandle yet, we need the rAF to proceed regardless.
            // The domWriteRequested=false will prevent the read flush from happening.
            (this.domReadRequested === false || this.domReadHandle > -1)) {
            this.cancelAnimationFrame(this.domWriteHandle);
            this.domWriteHandle = -1;
        }
    }
    flushDomWrite() {
        this.domWriteHandle = -1;
        if (this.domWriteRequested === true) {
            this.domWriteRequested = false;
            this.domWriteQueue.flush();
        }
        if (this.domReadRequested === true && this.domReadHandle === -1) {
            this.domReadHandle = this.setTimeout(this.flushDomRead, 0);
        }
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/platform/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@aurelia/platform/dist/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Platform": () => /* binding */ Platform,
/* harmony export */   "TaskQueue": () => /* binding */ TaskQueue,
/* harmony export */   "TaskAbortError": () => /* binding */ TaskAbortError,
/* harmony export */   "TaskStatus": () => /* binding */ TaskStatus,
/* harmony export */   "Task": () => /* binding */ Task,
/* harmony export */   "TaskQueuePriority": () => /* binding */ TaskQueuePriority
/* harmony export */ });
const lookup = new Map();
function notImplemented(name) {
    return function notImplemented() {
        throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name}'.`); // TODO: link to docs describing how to fix this issue
    };
}
class Platform {
    constructor(g, overrides = {}) {
        this.macroTaskRequested = false;
        this.macroTaskHandle = -1;
        this.globalThis = g;
        this.decodeURI = 'decodeURI' in overrides ? overrides.decodeURI : g.decodeURI;
        this.decodeURIComponent = 'decodeURIComponent' in overrides ? overrides.decodeURIComponent : g.decodeURIComponent;
        this.encodeURI = 'encodeURI' in overrides ? overrides.encodeURI : g.encodeURI;
        this.encodeURIComponent = 'encodeURIComponent' in overrides ? overrides.encodeURIComponent : g.encodeURIComponent;
        this.Date = 'Date' in overrides ? overrides.Date : g.Date;
        this.Reflect = 'Reflect' in overrides ? overrides.Reflect : g.Reflect;
        this.clearInterval = 'clearInterval' in overrides ? overrides.clearInterval : g.clearInterval?.bind(g) ?? notImplemented('clearInterval');
        this.clearTimeout = 'clearTimeout' in overrides ? overrides.clearTimeout : g.clearTimeout?.bind(g) ?? notImplemented('clearTimeout');
        this.queueMicrotask = 'queueMicrotask' in overrides ? overrides.queueMicrotask : g.queueMicrotask?.bind(g) ?? notImplemented('queueMicrotask');
        this.setInterval = 'setInterval' in overrides ? overrides.setInterval : g.setInterval?.bind(g) ?? notImplemented('setInterval');
        this.setTimeout = 'setTimeout' in overrides ? overrides.setTimeout : g.setTimeout?.bind(g) ?? notImplemented('setTimeout');
        this.console = 'console' in overrides ? overrides.console : g.console;
        this.performanceNow = 'performanceNow' in overrides ? overrides.performanceNow : g.performance?.now?.bind(g.performance) ?? notImplemented('performance.now');
        this.flushMacroTask = this.flushMacroTask.bind(this);
        this.macroTaskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));
    }
    static getOrCreate(g, overrides = {}) {
        let platform = lookup.get(g);
        if (platform === void 0) {
            lookup.set(g, platform = new Platform(g, overrides));
        }
        return platform;
    }
    static set(g, platform) {
        lookup.set(g, platform);
    }
    requestMacroTask() {
        this.macroTaskRequested = true;
        if (this.macroTaskHandle === -1) {
            this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);
        }
    }
    cancelMacroTask() {
        this.macroTaskRequested = false;
        if (this.macroTaskHandle > -1) {
            this.clearTimeout(this.macroTaskHandle);
            this.macroTaskHandle = -1;
        }
    }
    flushMacroTask() {
        this.macroTaskHandle = -1;
        if (this.macroTaskRequested === true) {
            this.macroTaskRequested = false;
            this.macroTaskQueue.flush();
        }
    }
}
function isPersistent(task) {
    return task.persistent;
}
class TaskQueue {
    constructor(platform, $request, $cancel) {
        this.platform = platform;
        this.$request = $request;
        this.$cancel = $cancel;
        this.processing = [];
        this.suspenderTask = void 0;
        this.pendingAsyncCount = 0;
        this.pending = [];
        this.delayed = [];
        this.flushRequested = false;
        this.yieldPromise = void 0;
        this.taskPool = [];
        this.taskPoolSize = 0;
        this.lastRequest = 0;
        this.lastFlush = 0;
        this.requestFlush = () => {
            if (this.tracer.enabled) {
                this.tracer.enter(this, 'requestFlush');
            }
            if (!this.flushRequested) {
                this.flushRequested = true;
                this.lastRequest = this.platform.performanceNow();
                this.$request();
            }
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'requestFlush');
            }
        };
        this.tracer = new Tracer(platform.console);
    }
    get isEmpty() {
        return this.processing.length === 0 && this.pending.length === 0 && this.delayed.length === 0;
    }
    /**
     * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,
     * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.
     *
     * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.
     *
     * If that is the case, we can resolve the promise that was created when `yield()` is called.
     */
    get hasNoMoreFiniteWork() {
        return (this.pendingAsyncCount === 0 &&
            this.processing.every(isPersistent) &&
            this.pending.every(isPersistent) &&
            this.delayed.every(isPersistent));
    }
    flush(time = this.platform.performanceNow()) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'flush');
        }
        this.flushRequested = false;
        this.lastFlush = time;
        // Only process normally if we are *not* currently waiting for an async task to finish
        if (this.suspenderTask === void 0) {
            if (this.pending.length > 0) {
                this.processing.push(...this.pending);
                this.pending.length = 0;
            }
            if (this.delayed.length > 0) {
                let i = -1;
                while (++i < this.delayed.length && this.delayed[i].queueTime <= time) { /* do nothing */ }
                this.processing.push(...this.delayed.splice(0, i));
            }
            let cur;
            while (this.processing.length > 0) {
                (cur = this.processing.shift()).run();
                // If it's still running, it can only be an async task
                if (cur.status === 1 /* running */) {
                    if (cur.suspend === true) {
                        this.suspenderTask = cur;
                        this.requestFlush();
                        if (this.tracer.enabled) {
                            this.tracer.leave(this, 'flush early async');
                        }
                        return;
                    }
                    else {
                        ++this.pendingAsyncCount;
                    }
                }
            }
            if (this.pending.length > 0) {
                this.processing.push(...this.pending);
                this.pending.length = 0;
            }
            if (this.delayed.length > 0) {
                let i = -1;
                while (++i < this.delayed.length && this.delayed[i].queueTime <= time) { /* do nothing */ }
                this.processing.push(...this.delayed.splice(0, i));
            }
            if (this.processing.length > 0 || this.delayed.length > 0 || this.pendingAsyncCount > 0) {
                this.requestFlush();
            }
            if (this.yieldPromise !== void 0 &&
                this.hasNoMoreFiniteWork) {
                const p = this.yieldPromise;
                this.yieldPromise = void 0;
                p.resolve();
            }
        }
        else {
            // If we are still waiting for an async task to finish, just schedule the next flush and do nothing else.
            // Should the task finish before the next flush is invoked,
            // the callback to `completeAsyncTask` will have reset `this.suspenderTask` back to undefined so processing can return back to normal next flush.
            this.requestFlush();
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'flush full');
        }
    }
    /**
     * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.
     *
     * This operation is idempotent and will do nothing if no flush is scheduled.
     */
    cancel() {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'cancel');
        }
        if (this.flushRequested) {
            this.$cancel();
            this.flushRequested = false;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'cancel');
        }
    }
    /**
     * Returns a promise that, when awaited, resolves when:
     * - all *non*-persistent (including async) tasks have finished;
     * - the last-added persistent task has run exactly once;
     *
     * This operation is idempotent: the same promise will be returned until it resolves.
     *
     * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.
     */
    async yield() {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'yield');
        }
        if (this.isEmpty) {
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'yield empty');
            }
        }
        else {
            if (this.yieldPromise === void 0) {
                if (this.tracer.enabled) {
                    this.tracer.trace(this, 'yield - creating promise');
                }
                this.yieldPromise = createExposedPromise();
            }
            await this.yieldPromise;
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'yield task');
            }
        }
    }
    queueTask(callback, opts) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'queueTask');
        }
        const { delay, preempt, persistent, reusable, suspend } = { ...defaultQueueTaskOptions, ...opts };
        if (preempt) {
            if (delay > 0) {
                throw new Error(`Invalid arguments: preempt cannot be combined with a greater-than-zero delay`);
            }
            if (persistent) {
                throw new Error(`Invalid arguments: preempt cannot be combined with persistent`);
            }
        }
        if (this.processing.length === 0) {
            this.requestFlush();
        }
        const time = this.platform.performanceNow();
        let task;
        if (reusable) {
            const taskPool = this.taskPool;
            const index = this.taskPoolSize - 1;
            if (index >= 0) {
                task = taskPool[index];
                taskPool[index] = (void 0);
                this.taskPoolSize = index;
                task.reuse(time, delay, preempt, persistent, suspend, callback);
            }
            else {
                task = new Task(this.tracer, this, time, time + delay, preempt, persistent, suspend, reusable, callback);
            }
        }
        else {
            task = new Task(this.tracer, this, time, time + delay, preempt, persistent, suspend, reusable, callback);
        }
        if (preempt) {
            this.processing[this.processing.length] = task;
        }
        else if (delay === 0) {
            this.pending[this.pending.length] = task;
        }
        else {
            this.delayed[this.delayed.length] = task;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'queueTask');
        }
        return task;
    }
    /**
     * Remove the task from this queue.
     */
    remove(task) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'remove');
        }
        let idx = this.processing.indexOf(task);
        if (idx > -1) {
            this.processing.splice(idx, 1);
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'remove processing');
            }
            return;
        }
        idx = this.pending.indexOf(task);
        if (idx > -1) {
            this.pending.splice(idx, 1);
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'remove pending');
            }
            return;
        }
        idx = this.delayed.indexOf(task);
        if (idx > -1) {
            this.delayed.splice(idx, 1);
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'remove delayed');
            }
            return;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'remove error');
        }
        throw new Error(`Task #${task.id} could not be found`);
    }
    /**
     * Return a reusable task to the shared task pool.
     * The next queued callback will reuse this task object instead of creating a new one, to save overhead of creating additional objects.
     */
    returnToPool(task) {
        if (this.tracer.enabled) {
            this.tracer.trace(this, 'returnToPool');
        }
        this.taskPool[this.taskPoolSize++] = task;
    }
    /**
     * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.
     */
    resetPersistentTask(task) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'resetPersistentTask');
        }
        task.reset(this.platform.performanceNow());
        if (task.createdTime === task.queueTime) {
            this.pending[this.pending.length] = task;
        }
        else {
            this.delayed[this.delayed.length] = task;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'resetPersistentTask');
        }
    }
    /**
     * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.
     */
    completeAsyncTask(task) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'completeAsyncTask');
        }
        if (task.suspend === true) {
            if (this.suspenderTask !== task) {
                if (this.tracer.enabled) {
                    this.tracer.leave(this, 'completeAsyncTask error');
                }
                throw new Error(`Async task completion mismatch: suspenderTask=${this.suspenderTask?.id}, task=${task.id}`);
            }
            this.suspenderTask = void 0;
        }
        else {
            --this.pendingAsyncCount;
        }
        if (this.yieldPromise !== void 0 &&
            this.hasNoMoreFiniteWork) {
            const p = this.yieldPromise;
            this.yieldPromise = void 0;
            p.resolve();
        }
        if (this.isEmpty) {
            this.cancel();
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'completeAsyncTask');
        }
    }
}
class TaskAbortError extends Error {
    constructor(task) {
        super('Task was canceled.');
        this.task = task;
    }
}
let id = 0;
var TaskStatus;
(function (TaskStatus) {
    TaskStatus[TaskStatus["pending"] = 0] = "pending";
    TaskStatus[TaskStatus["running"] = 1] = "running";
    TaskStatus[TaskStatus["completed"] = 2] = "completed";
    TaskStatus[TaskStatus["canceled"] = 3] = "canceled";
})(TaskStatus || (TaskStatus = {}));
class Task {
    constructor(tracer, taskQueue, createdTime, queueTime, preempt, persistent, suspend, reusable, callback) {
        this.tracer = tracer;
        this.taskQueue = taskQueue;
        this.createdTime = createdTime;
        this.queueTime = queueTime;
        this.preempt = preempt;
        this.persistent = persistent;
        this.suspend = suspend;
        this.reusable = reusable;
        this.callback = callback;
        this.id = ++id;
        this.resolve = void 0;
        this.reject = void 0;
        this._result = void 0;
        this._status = 0 /* pending */;
    }
    get result() {
        const result = this._result;
        if (result === void 0) {
            switch (this._status) {
                case 0 /* pending */: {
                    const promise = this._result = createExposedPromise();
                    this.resolve = promise.resolve;
                    this.reject = promise.reject;
                    return promise;
                }
                case 1 /* running */:
                    throw new Error('Trying to await task from within task will cause a deadlock.');
                case 2 /* completed */:
                    return this._result = Promise.resolve();
                case 3 /* canceled */:
                    return this._result = Promise.reject(new TaskAbortError(this));
            }
        }
        return result;
    }
    get status() {
        return this._status;
    }
    run(time = this.taskQueue.platform.performanceNow()) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'run');
        }
        if (this._status !== 0 /* pending */) {
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'run error');
            }
            throw new Error(`Cannot run task in ${this._status} state`);
        }
        // this.persistent could be changed while the task is running (this can only be done by the task itself if canceled, and is a valid way of stopping a loop)
        // so we deliberately reference this.persistent instead of the local variable, but we keep it around to know whether the task *was* persistent before running it,
        // so we can set the correct cancelation state.
        const { persistent, reusable, taskQueue, callback, resolve, reject, createdTime, } = this;
        this._status = 1 /* running */;
        try {
            const ret = callback(time - createdTime);
            if (ret instanceof Promise) {
                ret.then($ret => {
                    if (this.persistent) {
                        taskQueue['resetPersistentTask'](this);
                    }
                    else {
                        if (persistent) {
                            // Persistent tasks never reach completed status. They're either pending, running, or canceled.
                            this._status = 3 /* canceled */;
                        }
                        else {
                            this._status = 2 /* completed */;
                        }
                        this.dispose();
                    }
                    taskQueue['completeAsyncTask'](this);
                    if (this.tracer.enabled) {
                        this.tracer.leave(this, 'run async then');
                    }
                    if (resolve !== void 0) {
                        resolve($ret);
                    }
                    if (!this.persistent && reusable) {
                        taskQueue['returnToPool'](this);
                    }
                })
                    .catch(err => {
                    if (!this.persistent) {
                        this.dispose();
                    }
                    taskQueue['completeAsyncTask'](this);
                    if (this.tracer.enabled) {
                        this.tracer.leave(this, 'run async catch');
                    }
                    if (reject !== void 0) {
                        reject(err);
                    }
                    else {
                        throw err;
                    }
                });
            }
            else {
                if (this.persistent) {
                    taskQueue['resetPersistentTask'](this);
                }
                else {
                    if (persistent) {
                        // Persistent tasks never reach completed status. They're either pending, running, or canceled.
                        this._status = 3 /* canceled */;
                    }
                    else {
                        this._status = 2 /* completed */;
                    }
                    this.dispose();
                }
                if (this.tracer.enabled) {
                    this.tracer.leave(this, 'run sync success');
                }
                if (resolve !== void 0) {
                    resolve(ret);
                }
                if (!this.persistent && reusable) {
                    taskQueue['returnToPool'](this);
                }
            }
        }
        catch (err) {
            if (!this.persistent) {
                this.dispose();
            }
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'run sync error');
            }
            if (reject !== void 0) {
                reject(err);
            }
            else {
                throw err;
            }
        }
    }
    cancel() {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'cancel');
        }
        if (this._status === 0 /* pending */) {
            const taskQueue = this.taskQueue;
            const reusable = this.reusable;
            const reject = this.reject;
            taskQueue.remove(this);
            if (taskQueue.isEmpty) {
                taskQueue.cancel();
            }
            this._status = 3 /* canceled */;
            this.dispose();
            if (reusable) {
                taskQueue['returnToPool'](this);
            }
            if (reject !== void 0) {
                reject(new TaskAbortError(this));
            }
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'cancel true =pending');
            }
            return true;
        }
        else if (this._status === 1 /* running */ && this.persistent) {
            this.persistent = false;
            if (this.tracer.enabled) {
                this.tracer.leave(this, 'cancel true =running+persistent');
            }
            return true;
        }
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'cancel false');
        }
        return false;
    }
    reset(time) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'reset');
        }
        const delay = this.queueTime - this.createdTime;
        this.createdTime = time;
        this.queueTime = time + delay;
        this._status = 0 /* pending */;
        this.resolve = void 0;
        this.reject = void 0;
        this._result = void 0;
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'reset');
        }
    }
    reuse(time, delay, preempt, persistent, suspend, callback) {
        if (this.tracer.enabled) {
            this.tracer.enter(this, 'reuse');
        }
        this.createdTime = time;
        this.queueTime = time + delay;
        this.preempt = preempt;
        this.persistent = persistent;
        this.suspend = suspend;
        this.callback = callback;
        this._status = 0 /* pending */;
        if (this.tracer.enabled) {
            this.tracer.leave(this, 'reuse');
        }
    }
    dispose() {
        if (this.tracer.enabled) {
            this.tracer.trace(this, 'dispose');
        }
        this.callback = (void 0);
        this.resolve = void 0;
        this.reject = void 0;
        this._result = void 0;
    }
}
function taskStatus(status) {
    switch (status) {
        case 0 /* pending */: return 'pending';
        case 1 /* running */: return 'running';
        case 3 /* canceled */: return 'canceled';
        case 2 /* completed */: return 'completed';
    }
}
class Tracer {
    constructor(console) {
        this.console = console;
        this.enabled = false;
        this.depth = 0;
    }
    enter(obj, method) {
        this.log(`${'  '.repeat(this.depth++)}> `, obj, method);
    }
    leave(obj, method) {
        this.log(`${'  '.repeat(--this.depth)}< `, obj, method);
    }
    trace(obj, method) {
        this.log(`${'  '.repeat(this.depth)}- `, obj, method);
    }
    log(prefix, obj, method) {
        if (obj instanceof TaskQueue) {
            const processing = obj['processing'].length;
            const pending = obj['pending'].length;
            const delayed = obj['delayed'].length;
            const flushReq = obj['flushRequested'];
            const susTask = !!obj['suspenderTask'];
            const info = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;
            this.console.log(`${prefix}[Q.${method}] ${info}`);
        }
        else {
            const id = obj['id'];
            const created = Math.round(obj['createdTime'] * 10) / 10;
            const queue = Math.round(obj['queueTime'] * 10) / 10;
            const preempt = obj['preempt'];
            const reusable = obj['reusable'];
            const persistent = obj['persistent'];
            const suspend = obj['suspend'];
            const status = taskStatus(obj['_status']);
            const info = `id=${id} created=${created} queue=${queue} preempt=${preempt} persistent=${persistent} reusable=${reusable} status=${status} suspend=${suspend}`;
            this.console.log(`${prefix}[T.${method}] ${info}`);
        }
    }
}
var TaskQueuePriority;
(function (TaskQueuePriority) {
    TaskQueuePriority[TaskQueuePriority["render"] = 0] = "render";
    TaskQueuePriority[TaskQueuePriority["macroTask"] = 1] = "macroTask";
    TaskQueuePriority[TaskQueuePriority["postRender"] = 2] = "postRender";
})(TaskQueuePriority || (TaskQueuePriority = {}));
const defaultQueueTaskOptions = {
    delay: 0,
    preempt: false,
    persistent: false,
    reusable: true,
    suspend: false,
};
let $resolve;
let $reject;
function executor(resolve, reject) {
    $resolve = resolve;
    $reject = reject;
}
/**
 * Efficiently create a promise where the `resolve` and `reject` functions are stored as properties on the prommise itself.
 */
function createExposedPromise() {
    const p = new Promise(executor);
    p.resolve = $resolve;
    p.reject = $reject;
    return p;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/route-recognizer/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@aurelia/route-recognizer/dist/esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigurableRoute": () => /* binding */ ConfigurableRoute,
/* harmony export */   "Endpoint": () => /* binding */ Endpoint,
/* harmony export */   "RecognizedRoute": () => /* binding */ RecognizedRoute,
/* harmony export */   "RouteRecognizer": () => /* binding */ RouteRecognizer
/* harmony export */ });
class ConfigurableRoute {
    constructor(path, caseSensitive, handler) {
        this.path = path;
        this.caseSensitive = caseSensitive;
        this.handler = handler;
    }
}
class Endpoint {
    constructor(route, paramNames) {
        this.route = route;
        this.paramNames = paramNames;
    }
}
class RecognizedRoute {
    constructor(endpoint, params) {
        this.endpoint = endpoint;
        this.params = params;
    }
}
class Candidate {
    constructor(chars, states, skippedStates, result) {
        this.chars = chars;
        this.states = states;
        this.skippedStates = skippedStates;
        this.result = result;
        this.head = states[states.length - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        this.endpoint = this.head?.endpoint;
    }
    advance(ch) {
        const { chars, states, skippedStates, result } = this;
        let stateToAdd = null;
        let matchCount = 0;
        const state = states[states.length - 1];
        function $process(nextState, skippedState) {
            if (nextState.isMatch(ch)) {
                if (++matchCount === 1) {
                    stateToAdd = nextState;
                }
                else {
                    result.add(new Candidate(chars.concat(ch), states.concat(nextState), skippedState === null ? skippedStates : skippedStates.concat(skippedState), result));
                }
            }
            if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {
                if (nextState.nextStates.length > 1) {
                    throw new Error(`${nextState.nextStates.length} nextStates`);
                }
                const separator = nextState.nextStates[0];
                if (!separator.isSeparator) {
                    throw new Error(`Not a separator`);
                }
                if (separator.nextStates !== null) {
                    for (const $nextState of separator.nextStates) {
                        $process($nextState, nextState);
                    }
                }
            }
        }
        if (state.isDynamic) {
            $process(state, null);
        }
        if (state.nextStates !== null) {
            for (const nextState of state.nextStates) {
                $process(nextState, null);
            }
        }
        if (stateToAdd !== null) {
            states.push(this.head = stateToAdd);
            chars.push(ch);
            if (stateToAdd.endpoint !== null) {
                this.endpoint = stateToAdd.endpoint;
            }
        }
        if (matchCount === 0) {
            result.remove(this);
        }
    }
    finalize() {
        function collectSkippedStates(skippedStates, state) {
            const nextStates = state.nextStates;
            if (nextStates !== null) {
                if (nextStates.length === 1 && nextStates[0].segment === null) {
                    collectSkippedStates(skippedStates, nextStates[0]);
                }
                else {
                    for (const nextState of nextStates) {
                        if (nextState.isOptional && nextState.endpoint !== null) {
                            skippedStates.push(nextState);
                            if (nextState.nextStates !== null) {
                                for (const $nextState of nextState.nextStates) {
                                    collectSkippedStates(skippedStates, $nextState);
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        collectSkippedStates(this.skippedStates, this.head);
    }
    getParams() {
        const { states, chars, endpoint } = this;
        const params = {};
        // First initialize all properties with undefined so they all exist (even if they're not filled, e.g. non-matched optional params)
        for (const name of endpoint.paramNames) {
            params[name] = void 0;
        }
        for (let i = 0, ii = states.length; i < ii; ++i) {
            const state = states[i];
            if (state.isDynamic) {
                const name = state.segment.name;
                if (params[name] === void 0) {
                    params[name] = chars[i];
                }
                else {
                    params[name] += chars[i];
                }
            }
        }
        return params;
    }
    /**
     * Compares this candidate to another candidate to determine the correct sorting order.
     *
     * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares
     * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types
     *
     * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the
     * same sorting value because they both consist of two static segments and one dynamic segment.
     *
     * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,
     * and static wins over dynamic.
     *
     * ### NOTE
     * This algorithm violates some of the invariants of v1's algorithm,
     * but those invariants were arguably not very sound to begin with. Example:
     *
     * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`
     * - in v1, the first would win because that match has fewer stars
     * - in v2, the second will win because there is a bigger static match at the start of the pattern
     *
     * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of
     * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,
     * intentionally or unintentionally.
     *
     * @param b - The candidate to compare this to.
     * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.
     * This will bring the candidate with the highest score to the first position of the array.
     */
    compareTo(b) {
        const statesA = this.states;
        const statesB = b.states;
        for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {
            let stateA = statesA[iA];
            if (stateA === void 0) {
                return 1;
            }
            let stateB = statesB[iB];
            if (stateB === void 0) {
                return -1;
            }
            let segmentA = stateA.segment;
            let segmentB = stateB.segment;
            if (segmentA === null) {
                if (segmentB === null) {
                    ++iB;
                    continue;
                }
                if ((stateA = statesA[++iA]) === void 0) {
                    return 1;
                }
                segmentA = stateA.segment;
            }
            else if (segmentB === null) {
                if ((stateB = statesB[++iB]) === void 0) {
                    return -1;
                }
                segmentB = stateB.segment;
            }
            if (segmentA.kind < segmentB.kind) {
                return 1;
            }
            if (segmentA.kind > segmentB.kind) {
                return -1;
            }
            ++iB;
        }
        const skippedStatesA = this.skippedStates;
        const skippedStatesB = b.skippedStates;
        const skippedStatesALen = skippedStatesA.length;
        const skippedStatesBLen = skippedStatesB.length;
        if (skippedStatesALen < skippedStatesBLen) {
            return 1;
        }
        if (skippedStatesALen > skippedStatesBLen) {
            return -1;
        }
        for (let i = 0; i < skippedStatesALen; ++i) {
            const skippedStateA = skippedStatesA[i];
            const skippedStateB = skippedStatesB[i];
            if (skippedStateA.length < skippedStateB.length) {
                return 1;
            }
            if (skippedStateA.length > skippedStateB.length) {
                return -1;
            }
        }
        // This should only be possible with a single pattern with multiple consecutive star segments.
        // TODO: probably want to warn or even throw here, but leave it be for now.
        return 0;
    }
}
function hasEndpoint(candidate) {
    return candidate.head.endpoint !== null;
}
function compareChains(a, b) {
    return a.compareTo(b);
}
class RecognizeResult {
    constructor(rootState) {
        this.candidates = [];
        this.candidates = [new Candidate([''], [rootState], [], this)];
    }
    get isEmpty() {
        return this.candidates.length === 0;
    }
    getSolution() {
        const candidates = this.candidates.filter(hasEndpoint);
        if (candidates.length === 0) {
            return null;
        }
        for (const candidate of candidates) {
            candidate.finalize();
        }
        candidates.sort(compareChains);
        return candidates[0];
    }
    add(candidate) {
        this.candidates.push(candidate);
    }
    remove(candidate) {
        this.candidates.splice(this.candidates.indexOf(candidate), 1);
    }
    advance(ch) {
        const candidates = this.candidates.slice();
        for (const candidate of candidates) {
            candidate.advance(ch);
        }
    }
}
class RouteRecognizer {
    constructor() {
        this.rootState = new State(null, null, '');
        this.cache = new Map();
    }
    add(routeOrRoutes) {
        if (routeOrRoutes instanceof Array) {
            for (const route of routeOrRoutes) {
                this.$add(route);
            }
        }
        else {
            this.$add(routeOrRoutes);
        }
        // Clear the cache whenever there are state changes, because the recognizeResults could be arbitrarily different as a result
        this.cache.clear();
    }
    $add(route) {
        const path = route.path;
        const $route = new ConfigurableRoute(route.path, route.caseSensitive === true, route.handler);
        // Normalize leading, trailing and double slashes by ignoring empty segments
        const parts = path === '' ? [''] : path.split('/').filter(isNotEmpty);
        const paramNames = [];
        let state = this.rootState;
        for (const part of parts) {
            // Each segment always begins with a slash, so we represent this with a non-segment state
            state = state.append(null, '/');
            switch (part.charAt(0)) {
                case ':': { // route parameter
                    const isOptional = part.endsWith('?');
                    const name = isOptional ? part.slice(1, -1) : part.slice(1);
                    paramNames.push(name);
                    state = new DynamicSegment(name, isOptional).appendTo(state);
                    break;
                }
                case '*': { // dynamic route
                    const name = part.slice(1);
                    paramNames.push(name);
                    state = new StarSegment(name).appendTo(state);
                    break;
                }
                default: { // standard path route
                    state = new StaticSegment(part, $route.caseSensitive).appendTo(state);
                    break;
                }
            }
        }
        const endpoint = new Endpoint($route, paramNames);
        state.setEndpoint(endpoint);
    }
    recognize(path) {
        let result = this.cache.get(path);
        if (result === void 0) {
            this.cache.set(path, result = this.$recognize(path));
        }
        return result;
    }
    $recognize(path) {
        path = decodeURI(path);
        if (!path.startsWith('/')) {
            path = `/${path}`;
        }
        if (path.length > 1 && path.endsWith('/')) {
            path = path.slice(0, -1);
        }
        const result = new RecognizeResult(this.rootState);
        for (let i = 0, ii = path.length; i < ii; ++i) {
            const ch = path.charAt(i);
            result.advance(ch);
            if (result.isEmpty) {
                return null;
            }
        }
        const candidate = result.getSolution();
        if (candidate === null) {
            return null;
        }
        const { endpoint } = candidate;
        const params = candidate.getParams();
        return new RecognizedRoute(endpoint, params);
    }
}
class State {
    constructor(prevState, segment, value) {
        this.prevState = prevState;
        this.segment = segment;
        this.value = value;
        this.nextStates = null;
        this.endpoint = null;
        switch (segment?.kind) {
            case 2 /* dynamic */:
                this.length = prevState.length + 1;
                this.isSeparator = false;
                this.isDynamic = true;
                this.isOptional = segment.optional;
                break;
            case 1 /* star */:
                this.length = prevState.length + 1;
                this.isSeparator = false;
                this.isDynamic = true;
                this.isOptional = false;
                break;
            case 3 /* static */:
                this.length = prevState.length + 1;
                this.isSeparator = false;
                this.isDynamic = false;
                this.isOptional = false;
                break;
            case undefined:
                this.length = prevState === null ? 0 : prevState.length;
                this.isSeparator = true;
                this.isDynamic = false;
                this.isOptional = false;
                break;
        }
    }
    append(segment, value) {
        let state;
        let nextStates = this.nextStates;
        if (nextStates === null) {
            state = void 0;
            nextStates = this.nextStates = [];
        }
        else if (segment === null) {
            state = nextStates.find(s => s.value === value);
        }
        else {
            state = nextStates.find(s => s.segment?.equals(segment));
        }
        if (state === void 0) {
            nextStates.push(state = new State(this, segment, value));
        }
        return state;
    }
    setEndpoint(endpoint) {
        if (this.endpoint !== null) {
            throw new Error(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);
        }
        this.endpoint = endpoint;
        if (this.isOptional) {
            this.prevState.setEndpoint(endpoint);
            if (this.prevState.isSeparator && this.prevState.prevState !== null) {
                this.prevState.prevState.setEndpoint(endpoint);
            }
        }
    }
    isMatch(ch) {
        const segment = this.segment;
        switch (segment?.kind) {
            case 2 /* dynamic */:
                return !this.value.includes(ch);
            case 1 /* star */:
                return true;
            case 3 /* static */:
            case undefined:
                // segment separators (slashes) are non-segments. We could say return ch === '/' as well, technically.
                return this.value.includes(ch);
        }
    }
}
function isNotEmpty(segment) {
    return segment.length > 0;
}
var SegmentKind;
(function (SegmentKind) {
    SegmentKind[SegmentKind["star"] = 1] = "star";
    SegmentKind[SegmentKind["dynamic"] = 2] = "dynamic";
    SegmentKind[SegmentKind["static"] = 3] = "static";
})(SegmentKind || (SegmentKind = {}));
class StaticSegment {
    constructor(value, caseSensitive) {
        this.value = value;
        this.caseSensitive = caseSensitive;
    }
    get kind() { return 3 /* static */; }
    appendTo(state) {
        const { value, value: { length } } = this;
        if (this.caseSensitive) {
            for (let i = 0; i < length; ++i) {
                state = state.append(
                /* segment */ this, 
                /* value   */ value.charAt(i));
            }
        }
        else {
            for (let i = 0; i < length; ++i) {
                const ch = value.charAt(i);
                state = state.append(
                /* segment */ this, 
                /* value   */ ch.toUpperCase() + ch.toLowerCase());
            }
        }
        return state;
    }
    equals(b) {
        return (b.kind === 3 /* static */ &&
            b.caseSensitive === this.caseSensitive &&
            b.value === this.value);
    }
}
class DynamicSegment {
    constructor(name, optional) {
        this.name = name;
        this.optional = optional;
    }
    get kind() { return 2 /* dynamic */; }
    appendTo(state) {
        state = state.append(
        /* segment */ this, 
        /* value   */ '/');
        return state;
    }
    equals(b) {
        return (b.kind === 2 /* dynamic */ &&
            b.optional === this.optional &&
            b.name === this.name);
    }
}
class StarSegment {
    constructor(name) {
        this.name = name;
    }
    get kind() { return 1 /* star */; }
    appendTo(state) {
        state = state.append(
        /* segment */ this, 
        /* value   */ '');
        return state;
    }
    equals(b) {
        return (b.kind === 1 /* star */ &&
            b.name === this.name);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/awaitable-map.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/awaitable-map.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AwaitableMap": () => /* binding */ AwaitableMap
/* harmony export */ });
/* harmony import */ var _open_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./open-promise.js */ "./node_modules/@aurelia/router/dist/esm/open-promise.js");
// export class OpenPromise<T> {
//   public isPending: boolean = true;
//   public promise!: Promise<T>;
//   public resolve!: (value: T | PromiseLike<T>) => void;
//   public reject!: () => void;
// }

class AwaitableMap {
    constructor() {
        this.map = new Map();
    }
    set(key, value) {
        const openPromise = this.map.get(key);
        if (openPromise instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise) {
            openPromise.resolve(value);
            // openPromise.isPending = false;
        }
        this.map.set(key, value);
    }
    delete(key) {
        const current = this.map.get(key);
        if (current instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise) {
            current.reject();
            // current.isPending = false;
        }
        this.map.delete(key);
    }
    await(key) {
        if (!this.map.has(key)) {
            const openPromise = new _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise();
            // openPromise.promise = new Promise((res, rej) => {
            //   openPromise.resolve = res;
            //   openPromise.reject = rej;
            // });
            this.map.set(key, openPromise);
            return openPromise.promise;
        }
        const current = this.map.get(key);
        if (current instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise) {
            return current.promise;
        }
        return current;
    }
    has(key) {
        return this.map.has(key) && !(this.map.get(key) instanceof _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise);
    }
    clone() {
        const clone = new AwaitableMap();
        clone.map = new Map(this.map);
        return clone;
    }
}
//# sourceMappingURL=awaitable-map.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/browser-viewer-store.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/browser-viewer-store.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserViewerStore": () => /* binding */ BrowserViewerStore
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _task_queue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./task-queue.js */ "./node_modules/@aurelia/router/dist/esm/task-queue.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


/**
 * @internal - Shouldn't be used directly
 */
let BrowserViewerStore = class BrowserViewerStore {
    constructor(platform, window, history, location) {
        this.platform = platform;
        this.window = window;
        this.history = history;
        this.location = location;
        this.allowedExecutionCostWithinTick = 2; // Limit no of executed actions within the same RAF (due to browser limitation)
        this.isActive = false;
        this.options = {
            useUrlFragmentHash: true,
            callback: () => { return; },
        };
        this.forwardedState = { eventTask: null, suppressPopstate: false };
        this.handlePopstate = async (event) => {
            const { eventTask, suppressPopstate } = this.forwardedState;
            this.forwardedState = { eventTask: null, suppressPopstate: false };
            return this.pendingCalls.enqueue(async (task) => {
                const store = this;
                const ev = event;
                const evTask = eventTask;
                const suppressPopstateEvent = suppressPopstate;
                await store.popstate(ev, evTask, suppressPopstateEvent);
                task.resolve();
            }, 1).wait();
        };
        this.pendingCalls = new _task_queue_js__WEBPACK_IMPORTED_MODULE_1__.TaskQueue();
    }
    start(options) {
        if (this.isActive) {
            throw new Error('Browser navigation has already been started');
        }
        this.isActive = true;
        this.options.callback = options.callback;
        if (options.useUrlFragmentHash != void 0) {
            this.options.useUrlFragmentHash = options.useUrlFragmentHash;
        }
        this.pendingCalls.start({ platform: this.platform, allowedExecutionCostWithinTick: this.allowedExecutionCostWithinTick });
        this.window.addEventListener('popstate', this.handlePopstate);
    }
    stop() {
        if (!this.isActive) {
            throw new Error('Browser navigation has not been started');
        }
        this.window.removeEventListener('popstate', this.handlePopstate);
        this.pendingCalls.stop();
        this.options = { useUrlFragmentHash: true, callback: () => { return; } };
        this.isActive = false;
    }
    get length() {
        return this.history.length;
    }
    get state() {
        return this.history.state;
    }
    get viewerState() {
        const { pathname, search, hash } = this.location;
        return {
            path: pathname,
            query: search,
            hash,
            instruction: this.options.useUrlFragmentHash ? hash.slice(1) : pathname,
        };
    }
    async go(delta, suppressPopstateEvent = false) {
        const doneTask = this.pendingCalls.createQueueTask((task) => task.resolve(), 1);
        this.pendingCalls.enqueue([
            (task) => {
                const store = this;
                const eventTask = doneTask;
                const suppressPopstate = suppressPopstateEvent;
                store.forwardState({ eventTask, suppressPopstate });
                task.resolve();
            },
            (task) => {
                const history = this.history;
                const steps = delta;
                history.go(steps);
                task.resolve();
            },
        ], [0, 1]);
        return doneTask.wait();
    }
    async pushNavigatorState(state) {
        const { title, path } = state.currentEntry;
        const fragment = this.options.useUrlFragmentHash ? '#/' : '';
        return this.pendingCalls.enqueue((task) => {
            const history = this.history;
            const data = state;
            const titleOrEmpty = title || '';
            const url = `${fragment}${path}`;
            history.pushState(data, titleOrEmpty, url);
            task.resolve();
        }, 1).wait();
    }
    async replaceNavigatorState(state) {
        const { title, path } = state.currentEntry;
        const fragment = this.options.useUrlFragmentHash ? '#/' : '';
        return this.pendingCalls.enqueue((task) => {
            const history = this.history;
            const data = state;
            const titleOrEmpty = title || '';
            const url = `${fragment}${path}`;
            history.replaceState(data, titleOrEmpty, url);
            task.resolve();
        }, 1).wait();
    }
    async popNavigatorState() {
        const doneTask = this.pendingCalls.createQueueTask((task) => task.resolve(), 1);
        this.pendingCalls.enqueue(async (task) => {
            const store = this;
            const eventTask = doneTask;
            await store.popState(eventTask);
            task.resolve();
        }, 1);
        return doneTask.wait();
    }
    async popState(doneTask) {
        await this.go(-1, true);
        const state = this.history.state;
        // TODO: Fix browser forward bug after pop on first entry
        if (state && state.currentEntry && !state.currentEntry.firstEntry) {
            await this.go(-1, true);
            await this.pushNavigatorState(state);
        }
        await doneTask.execute();
    }
    forwardState(state) {
        this.forwardedState = state;
    }
    async popstate(ev, eventTask, suppressPopstate = false) {
        if (!suppressPopstate) {
            this.options.callback({
                ...this.viewerState,
                ...{
                    event: ev,
                    state: this.history.state,
                },
            });
        }
        if (eventTask !== null) {
            await eventTask.execute();
        }
    }
    setTitle(title) {
        this.window.document.title = title;
    }
};
BrowserViewerStore = __decorate([
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IPlatform),
    __param(1, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IWindow),
    __param(2, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IHistory),
    __param(3, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.ILocation)
], BrowserViewerStore);

//# sourceMappingURL=browser-viewer-store.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/collection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/collection.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Collection": () => /* binding */ Collection
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");

/**
 * @internal - Helper class
 */
class Collection extends Array {
    constructor() {
        super(...arguments);
        this.currentIndex = -1;
    }
    next() {
        if (this.length > this.currentIndex + 1) {
            return this[++this.currentIndex];
        }
        else {
            this.currentIndex = -1;
            return null;
        }
    }
    removeCurrent() {
        this.splice(this.currentIndex--, 1);
    }
    remove(instruction) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.arrayRemove)(this, value => value === instruction);
    }
}
//# sourceMappingURL=collection.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/configuration.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/configuration.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterRegistration": () => /* binding */ RouterRegistration,
/* harmony export */   "DefaultComponents": () => /* binding */ DefaultComponents,
/* harmony export */   "ViewportCustomElement": () => /* reexport safe */ _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement,
/* harmony export */   "ViewportScopeCustomElement": () => /* reexport safe */ _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__.ViewportScopeCustomElement,
/* harmony export */   "NavCustomElement": () => /* reexport safe */ _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__.NavCustomElement,
/* harmony export */   "GotoCustomAttribute": () => /* reexport safe */ _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__.GotoCustomAttribute,
/* harmony export */   "LoadCustomAttribute": () => /* reexport safe */ _resources_load_js__WEBPACK_IMPORTED_MODULE_6__.LoadCustomAttribute,
/* harmony export */   "HrefCustomAttribute": () => /* reexport safe */ _resources_href_js__WEBPACK_IMPORTED_MODULE_7__.HrefCustomAttribute,
/* harmony export */   "ViewportCustomElementRegistration": () => /* binding */ ViewportCustomElementRegistration,
/* harmony export */   "ViewportScopeCustomElementRegistration": () => /* binding */ ViewportScopeCustomElementRegistration,
/* harmony export */   "NavCustomElementRegistration": () => /* binding */ NavCustomElementRegistration,
/* harmony export */   "GotoCustomAttributeRegistration": () => /* binding */ GotoCustomAttributeRegistration,
/* harmony export */   "LoadCustomAttributeRegistration": () => /* binding */ LoadCustomAttributeRegistration,
/* harmony export */   "HrefCustomAttributeRegistration": () => /* binding */ HrefCustomAttributeRegistration,
/* harmony export */   "DefaultResources": () => /* binding */ DefaultResources,
/* harmony export */   "RouterConfiguration": () => /* binding */ RouterConfiguration
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/nav.js */ "./node_modules/@aurelia/router/dist/esm/resources/nav.js");
/* harmony import */ var _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/viewport.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport.js");
/* harmony import */ var _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resources/viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js");
/* harmony import */ var _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resources/goto.js */ "./node_modules/@aurelia/router/dist/esm/resources/goto.js");
/* harmony import */ var _resources_load_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resources/load.js */ "./node_modules/@aurelia/router/dist/esm/resources/load.js");
/* harmony import */ var _resources_href_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./resources/href.js */ "./node_modules/@aurelia/router/dist/esm/resources/href.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");









const RouterRegistration = _router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter;
/**
 * Default runtime/environment-agnostic implementations for the following interfaces:
 * - `IRouter`
 */
const DefaultComponents = [
    RouterRegistration,
];

const ViewportCustomElementRegistration = _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement;
const ViewportScopeCustomElementRegistration = _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__.ViewportScopeCustomElement;
const NavCustomElementRegistration = _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__.NavCustomElement;
const GotoCustomAttributeRegistration = _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__.GotoCustomAttribute;
const LoadCustomAttributeRegistration = _resources_load_js__WEBPACK_IMPORTED_MODULE_6__.LoadCustomAttribute;
const HrefCustomAttributeRegistration = _resources_href_js__WEBPACK_IMPORTED_MODULE_7__.HrefCustomAttribute;
/**
 * Default router resources:
 * - Custom Elements: `au-viewport`, `au-nav`
 * - Custom Attributes: `goto`, `load`, `href`
 */
const DefaultResources = [
    _resources_viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement,
    _resources_viewport_scope_js__WEBPACK_IMPORTED_MODULE_4__.ViewportScopeCustomElement,
    _resources_nav_js__WEBPACK_IMPORTED_MODULE_2__.NavCustomElement,
    _resources_goto_js__WEBPACK_IMPORTED_MODULE_5__.GotoCustomAttribute,
    _resources_load_js__WEBPACK_IMPORTED_MODULE_6__.LoadCustomAttribute,
    _resources_href_js__WEBPACK_IMPORTED_MODULE_7__.HrefCustomAttribute,
];
let configurationOptions = {};
let configurationCall = (router) => {
    router.start(configurationOptions);
};
/**
 * A DI configuration object containing router resource registrations.
 */
const routerConfiguration = {
    /**
     * Apply this configuration to the provided container.
     */
    register(container) {
        return container.register(...DefaultComponents, ...DefaultResources, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter).beforeActivate().call(configurationCall), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter).afterActivate().call(router => router.loadUrl()), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_router_js__WEBPACK_IMPORTED_MODULE_8__.IRouter).afterDeactivate().call(router => router.stop()));
    },
    /**
     * Create a new container with this configuration applied to it.
     */
    createContainer() {
        return this.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer());
    }
};
const RouterConfiguration = {
    /**
     * Make it possible to specify options to Router activation.
     * Parameter is either a config object that's passed to Router's start
     * or a config function that's called instead of Router's start.
     */
    customize(config) {
        if (config === undefined) {
            configurationOptions = {};
            configurationCall = (router) => {
                router.start(configurationOptions);
            };
        }
        else if (config instanceof Function) {
            configurationCall = config;
        }
        else {
            configurationOptions = config;
        }
        return { ...routerConfiguration };
    },
    ...routerConfiguration,
};
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/found-route.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/found-route.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FoundRoute": () => /* binding */ FoundRoute
/* harmony export */ });
/**
 * @internal - Used when founding route/instructions
 */
class FoundRoute {
    constructor(match = null, matching = '', instructions = [], remaining = '', 
    // public remaining: string | null = null,
    params = {}) {
        this.match = match;
        this.matching = matching;
        this.instructions = instructions;
        this.remaining = remaining;
        this.params = params;
    }
    get foundConfiguration() {
        return this.match !== null;
    }
    get foundInstructions() {
        return this.instructions.length > 0;
    }
    get hasRemaining() {
        return this.remaining !== null && this.remaining.length > 0;
    }
}
//# sourceMappingURL=found-route.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/hook-manager.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/hook-manager.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HookTypes": () => /* binding */ HookTypes,
/* harmony export */   "HookManager": () => /* binding */ HookManager
/* harmony export */ });
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hook.js */ "./node_modules/@aurelia/router/dist/esm/hook.js");

/**
 * Public API
 */
var HookTypes;
(function (HookTypes) {
    HookTypes["BeforeNavigation"] = "beforeNavigation";
    HookTypes["TransformFromUrl"] = "transformFromUrl";
    HookTypes["TransformToUrl"] = "transformToUrl";
    HookTypes["SetTitle"] = "setTitle";
})(HookTypes || (HookTypes = {}));
/**
 * @internal - Shouldn't be used directly
 */
class HookManager {
    constructor() {
        this.hooks = {
            beforeNavigation: [],
            transformFromUrl: [],
            transformToUrl: [],
            setTitle: [],
        };
        this.lastIdentity = 0;
    }
    addHook(hookFunction, options) {
        const hook = new _hook_js__WEBPACK_IMPORTED_MODULE_0__.Hook(hookFunction, options || {}, ++this.lastIdentity);
        this.hooks[hook.type].push(hook);
        return this.lastIdentity;
    }
    removeHook(id) {
        for (const type in this.hooks) {
            if (Object.prototype.hasOwnProperty.call(this.hooks, type)) {
                const index = this.hooks[type].findIndex(hook => hook.id === id);
                if (index >= 0) {
                    this.hooks[type].splice(index, 1);
                }
            }
        }
    }
    async invokeBeforeNavigation(viewportInstructions, navigationInstruction) {
        return this.invoke("beforeNavigation" /* BeforeNavigation */, navigationInstruction, viewportInstructions);
    }
    async invokeTransformFromUrl(url, navigationInstruction) {
        return this.invoke("transformFromUrl" /* TransformFromUrl */, navigationInstruction, url);
    }
    async invokeTransformToUrl(state, navigationInstruction) {
        return this.invoke("transformToUrl" /* TransformToUrl */, navigationInstruction, state);
    }
    async invokeSetTitle(title, navigationInstruction) {
        return this.invoke("setTitle" /* SetTitle */, navigationInstruction, title);
    }
    async invoke(type, navigationInstruction, arg) {
        for (const hook of this.hooks[type]) {
            if (!hook.wantsMatch || hook.matches(arg)) {
                const outcome = await hook.invoke(navigationInstruction, arg);
                if (typeof outcome === 'boolean') {
                    if (!outcome) {
                        return false;
                    }
                }
                else {
                    arg = outcome;
                }
            }
        }
        return arg;
    }
}
//# sourceMappingURL=hook-manager.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/hook.js":
/*!*******************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/hook.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hook": () => /* binding */ Hook
/* harmony export */ });
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");


/**
 * @internal - Shouldn't be used directly
 */
class Hook {
    constructor(hook, options, id) {
        this.hook = hook;
        this.id = id;
        this.type = "beforeNavigation" /* BeforeNavigation */;
        this.includeTargets = [];
        this.excludeTargets = [];
        if (options.type !== void 0) {
            this.type = options.type;
        }
        for (const target of options.include || []) {
            this.includeTargets.push(new Target(target));
        }
        for (const target of options.exclude || []) {
            this.excludeTargets.push(new Target(target));
        }
    }
    get wantsMatch() {
        return this.includeTargets.length > 0 || this.excludeTargets.length > 0;
    }
    matches(viewportInstructions) {
        if (this.includeTargets.length && !this.includeTargets.some(target => target.matches(viewportInstructions))) {
            return false;
        }
        if (this.excludeTargets.length && this.excludeTargets.some(target => target.matches(viewportInstructions))) {
            return false;
        }
        return true;
    }
    invoke(navigationInstruction, arg) {
        // TODO: Fix the type here
        return this.hook(arg, navigationInstruction);
    }
}
class Target {
    constructor(target) {
        this.componentType = null;
        this.componentName = null;
        this.viewport = null;
        this.viewportName = null;
        if (typeof target === 'string') {
            this.componentName = target;
        }
        else if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.isType(target)) {
            this.componentType = target;
            this.componentName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.getName(target);
        }
        else {
            const cvTarget = target;
            if (cvTarget.component) {
                this.componentType = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.isType(cvTarget.component)
                    ? _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.getType(cvTarget.component)
                    : null;
                this.componentName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.getName(cvTarget.component);
            }
            if (cvTarget.viewport) {
                this.viewport = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ViewportHandleResolver.isInstance(cvTarget.viewport) ? cvTarget.viewport : null;
                this.viewportName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ViewportHandleResolver.getName(cvTarget.viewport);
            }
        }
    }
    matches(viewportInstructions) {
        const instructions = viewportInstructions.slice();
        if (!instructions.length) {
            // instructions.push(new ViewportInstruction(''));
            instructions.push(_viewport_instruction_js__WEBPACK_IMPORTED_MODULE_1__.ViewportInstruction.create(null, ''));
        }
        for (const instruction of instructions) {
            if ((this.componentName !== null && this.componentName === instruction.componentName) ||
                (this.componentType !== null && this.componentType === instruction.componentType) ||
                (this.viewportName !== null && this.viewportName === instruction.viewportName) ||
                (this.viewport !== null && this.viewport === instruction.viewport)) {
                return true;
            }
        }
        return false;
    }
}
//# sourceMappingURL=hook.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkHandler": () => /* reexport safe */ _link_handler_js__WEBPACK_IMPORTED_MODULE_0__.LinkHandler,
/* harmony export */   "InstructionResolver": () => /* reexport safe */ _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_1__.InstructionResolver,
/* harmony export */   "ReentryBehavior": () => /* reexport safe */ _interfaces_js__WEBPACK_IMPORTED_MODULE_2__.ReentryBehavior,
/* harmony export */   "lifecycleLogger": () => /* reexport safe */ _lifecycle_logger_js__WEBPACK_IMPORTED_MODULE_3__.lifecycleLogger,
/* harmony export */   "LifecycleClass": () => /* reexport safe */ _lifecycle_logger_js__WEBPACK_IMPORTED_MODULE_3__.LifecycleClass,
/* harmony export */   "HookManager": () => /* reexport safe */ _hook_manager_js__WEBPACK_IMPORTED_MODULE_4__.HookManager,
/* harmony export */   "HookTypes": () => /* reexport safe */ _hook_manager_js__WEBPACK_IMPORTED_MODULE_4__.HookTypes,
/* harmony export */   "Nav": () => /* reexport safe */ _nav_js__WEBPACK_IMPORTED_MODULE_5__.Nav,
/* harmony export */   "NavRoute": () => /* reexport safe */ _nav_route_js__WEBPACK_IMPORTED_MODULE_6__.NavRoute,
/* harmony export */   "Navigation": () => /* reexport safe */ _navigation_js__WEBPACK_IMPORTED_MODULE_7__.Navigation,
/* harmony export */   "Navigator": () => /* reexport safe */ _navigator_js__WEBPACK_IMPORTED_MODULE_8__.Navigator,
/* harmony export */   "Runner": () => /* reexport safe */ _runner_js__WEBPACK_IMPORTED_MODULE_9__.Runner,
/* harmony export */   "Queue": () => /* reexport safe */ _queue_js__WEBPACK_IMPORTED_MODULE_10__.Queue,
/* harmony export */   "RouteRecognizer": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.RouteRecognizer,
/* harmony export */   "ConfigurableRoute": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.ConfigurableRoute,
/* harmony export */   "RecognizedRoute": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.RecognizedRoute,
/* harmony export */   "Endpoint": () => /* reexport safe */ _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__.Endpoint,
/* harmony export */   "IRouter": () => /* reexport safe */ _router_js__WEBPACK_IMPORTED_MODULE_12__.IRouter,
/* harmony export */   "Router": () => /* reexport safe */ _router_js__WEBPACK_IMPORTED_MODULE_12__.Router,
/* harmony export */   "RouterOptions": () => /* reexport safe */ _router_options_js__WEBPACK_IMPORTED_MODULE_13__.RouterOptions,
/* harmony export */   "Viewport": () => /* reexport safe */ _viewport_js__WEBPACK_IMPORTED_MODULE_14__.Viewport,
/* harmony export */   "ContentStatus": () => /* reexport safe */ _viewport_content_js__WEBPACK_IMPORTED_MODULE_15__.ContentStatus,
/* harmony export */   "ViewportContent": () => /* reexport safe */ _viewport_content_js__WEBPACK_IMPORTED_MODULE_15__.ViewportContent,
/* harmony export */   "ViewportInstruction": () => /* reexport safe */ _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_16__.ViewportInstruction,
/* harmony export */   "RouterConfiguration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.RouterConfiguration,
/* harmony export */   "RouterRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.RouterRegistration,
/* harmony export */   "DefaultComponents": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.DefaultComponents,
/* harmony export */   "DefaultResources": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.DefaultResources,
/* harmony export */   "ViewportCustomElement": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.ViewportCustomElement,
/* harmony export */   "ViewportCustomElementRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.ViewportCustomElementRegistration,
/* harmony export */   "NavCustomElement": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.NavCustomElement,
/* harmony export */   "NavCustomElementRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.NavCustomElementRegistration,
/* harmony export */   "GotoCustomAttribute": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.GotoCustomAttribute,
/* harmony export */   "GotoCustomAttributeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.GotoCustomAttributeRegistration,
/* harmony export */   "LoadCustomAttribute": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.LoadCustomAttribute,
/* harmony export */   "LoadCustomAttributeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.LoadCustomAttributeRegistration,
/* harmony export */   "HrefCustomAttribute": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.HrefCustomAttribute,
/* harmony export */   "HrefCustomAttributeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_17__.HrefCustomAttributeRegistration
/* harmony export */ });
/* harmony import */ var _link_handler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./link-handler.js */ "./node_modules/@aurelia/router/dist/esm/link-handler.js");
/* harmony import */ var _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instruction-resolver.js */ "./node_modules/@aurelia/router/dist/esm/instruction-resolver.js");
/* harmony import */ var _interfaces_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interfaces.js */ "./node_modules/@aurelia/router/dist/esm/interfaces.js");
/* harmony import */ var _lifecycle_logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lifecycle-logger.js */ "./node_modules/@aurelia/router/dist/esm/lifecycle-logger.js");
/* harmony import */ var _hook_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hook-manager.js */ "./node_modules/@aurelia/router/dist/esm/hook-manager.js");
/* harmony import */ var _nav_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nav.js */ "./node_modules/@aurelia/router/dist/esm/nav.js");
/* harmony import */ var _nav_route_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nav-route.js */ "./node_modules/@aurelia/router/dist/esm/nav-route.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _navigator_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./navigator.js */ "./node_modules/@aurelia/router/dist/esm/navigator.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");
/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./queue.js */ "./node_modules/@aurelia/router/dist/esm/queue.js");
/* harmony import */ var _route_recognizer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./route-recognizer.js */ "./node_modules/@aurelia/router/dist/esm/route-recognizer.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _router_options_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./router-options.js */ "./node_modules/@aurelia/router/dist/esm/router-options.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _viewport_content_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./viewport-content.js */ "./node_modules/@aurelia/router/dist/esm/viewport-content.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");
/* harmony import */ var _configuration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./configuration.js */ "./node_modules/@aurelia/router/dist/esm/configuration.js");


















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/instruction-resolver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/instruction-resolver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstructionResolver": () => /* binding */ InstructionResolver
/* harmony export */ });
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");

class InstructionResolver {
    constructor() {
        this.separators = {
            viewport: '@',
            sibling: '+',
            scope: '/',
            scopeStart: '(',
            scopeEnd: ')',
            noScope: '!',
            parameters: '(',
            parametersEnd: ')',
            parameterSeparator: ',',
            parameterKeySeparator: '=',
            parameter: '&',
            add: '+',
            clear: '-',
            action: '.',
        };
    }
    start(options) {
        options = options || {};
        this.separators = { ...this.separators, ...options.separators };
    }
    get clearViewportInstruction() {
        return this.separators.clear;
    }
    get addViewportInstruction() {
        return this.separators.add;
    }
    isClearViewportInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.clearViewportInstruction && !!instruction.viewportName
            : instruction.startsWith(this.clearViewportInstruction) && instruction !== this.clearViewportInstruction;
    }
    isAddViewportInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.addViewportInstruction
            : (instruction === this.addViewportInstruction
                || instruction.startsWith(`${this.separators.add}${this.separators.viewport}`));
    }
    isClearViewportScopeInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.clearViewportInstruction && !!instruction.viewportScope
            : instruction.startsWith(this.clearViewportInstruction) && instruction !== this.clearViewportInstruction;
    }
    isClearAllViewportsInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.clearViewportInstruction && !instruction.viewportName
            : instruction === this.clearViewportInstruction;
    }
    isAddAllViewportsInstruction(instruction) {
        return instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction
            ? instruction.componentName === this.addViewportInstruction && !instruction.viewportName
            : instruction === this.addViewportInstruction;
    }
    createViewportInstruction(component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
        if (component instanceof Promise) {
            return component.then((resolvedComponent) => {
                return this.createViewportInstruction(resolvedComponent, viewport, parameters, ownsScope, nextScopeInstructions);
            });
        }
        // const instruction: ViewportInstruction = new ViewportInstruction(component, viewport, parameters, ownsScope, nextScopeInstructions);
        // instruction.setInstructionResolver(this);
        // return instruction;
        return _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_0__.ViewportInstruction.create(this, component, viewport, parameters, ownsScope, nextScopeInstructions);
    }
    parseViewportInstructions(instructions) {
        const match = /^[./]+/.exec(instructions);
        let context = '';
        if (Array.isArray(match) && match.length > 0) {
            context = match[0];
            instructions = instructions.slice(context.length);
        }
        const parsedInstructions = this.parseViewportInstructionsWorker(instructions, true).instructions;
        for (const instruction of parsedInstructions) {
            instruction.context = context;
        }
        return parsedInstructions;
    }
    parseViewportInstruction(instruction) {
        const instructions = this.parseViewportInstructions(instruction);
        if (instructions.length) {
            return instructions[0];
        }
        return this.createViewportInstruction('');
    }
    stringifyViewportInstructions(instructions, excludeViewport = false, viewportContext = false) {
        return typeof (instructions) === 'string'
            ? instructions
            : instructions
                .map(instruction => this.stringifyViewportInstruction(instruction, excludeViewport, viewportContext))
                .filter(instruction => instruction && instruction.length)
                .join(this.separators.sibling);
    }
    stringifyViewportInstruction(instruction, excludeViewport = false, viewportContext = false) {
        if (typeof instruction === 'string') {
            return this.stringifyAViewportInstruction(instruction, excludeViewport);
        }
        else {
            let excludeCurrentViewport = excludeViewport;
            let excludeCurrentComponent = false;
            if (viewportContext) {
                if (instruction.viewport && instruction.viewport.options.noLink) {
                    return '';
                }
                if (!instruction.needsViewportDescribed && instruction.viewport && !instruction.viewport.options.forceDescription) {
                    excludeCurrentViewport = true;
                }
                if (instruction.viewport && instruction.viewport.options.fallback === instruction.componentName) {
                    excludeCurrentComponent = true;
                }
                if (!instruction.needsViewportDescribed && instruction.viewportScope) {
                    excludeCurrentViewport = true;
                }
            }
            let route = instruction.route ?? null;
            const nextInstructions = instruction.nextScopeInstructions;
            let stringified = instruction.context;
            // It's a configured route
            if (route !== null) {
                // Already added as part of a configuration, skip to next scope
                if (route === '') {
                    return Array.isArray(nextInstructions)
                        ? this.stringifyViewportInstructions(nextInstructions, excludeViewport, viewportContext)
                        : '';
                }
                route = route.matching;
                stringified += route.endsWith(this.separators.scope) ? route.slice(0, -this.separators.scope.length) : route;
            }
            else {
                stringified += this.stringifyAViewportInstruction(instruction, excludeCurrentViewport, excludeCurrentComponent);
            }
            if (Array.isArray(nextInstructions) && nextInstructions.length) {
                const nextStringified = this.stringifyViewportInstructions(nextInstructions, excludeViewport, viewportContext);
                if (nextStringified.length > 0) {
                    stringified += nextInstructions.length === 1 // TODO: This should really also check that the instructions have value
                        ? `${this.separators.scope}${nextStringified}`
                        : `${this.separators.scope}${this.separators.scopeStart}${nextStringified}${this.separators.scopeEnd}`;
                }
            }
            return stringified;
        }
    }
    stringifyScopedViewportInstructions(instructions) {
        if (!Array.isArray(instructions)) {
            return this.stringifyScopedViewportInstructions([instructions]);
        }
        return instructions.map((instruction) => this.stringifyViewportInstruction(instruction)).join(this.separators.scope);
    }
    encodeViewportInstructions(instructions) {
        return encodeURIComponent(this.stringifyViewportInstructions(instructions)).replace(/\(/g, '%28').replace(/\)/g, '%29');
    }
    decodeViewportInstructions(instructions) {
        return this.parseViewportInstructions(decodeURIComponent(instructions));
    }
    buildScopedLink(scopeContext, href) {
        if (scopeContext) {
            href = `/${scopeContext}${this.separators.scope}${href}`;
        }
        return href;
    }
    shouldClearViewports(path) {
        const clearViewports = (path === this.separators.clear || path.startsWith(this.separators.clear + this.separators.add));
        const newPath = path.startsWith(this.separators.clear) ? path.slice(2) : path;
        return { clearViewports, newPath };
    }
    mergeViewportInstructions(instructions) {
        const merged = [];
        for (let instruction of instructions) {
            if (typeof instruction === 'string') {
                instruction = this.parseViewportInstruction(instruction);
            }
            const index = merged.findIndex(merge => merge.sameViewport(instruction));
            if (index >= 0) {
                merged.splice(index, 1, instruction);
            }
            else {
                merged.push(instruction);
            }
        }
        return merged;
    }
    flattenViewportInstructions(instructions) {
        const flat = [];
        for (const instruction of instructions) {
            flat.push(instruction);
            if (instruction.nextScopeInstructions) {
                flat.push(...this.flattenViewportInstructions(instruction.nextScopeInstructions));
            }
        }
        return flat;
    }
    cloneViewportInstructions(instructions, keepInstances = false, context = false) {
        const clones = [];
        for (const instruction of instructions) {
            const clone = this.createViewportInstruction(instruction.componentName, instruction.viewportName, instruction.typedParameters !== null ? instruction.typedParameters : void 0);
            if (keepInstances) {
                clone.setComponent(instruction.componentInstance ?? instruction.componentType ?? instruction.componentName);
                clone.setViewport(instruction.viewport ?? instruction.viewportName);
            }
            clone.needsViewportDescribed = instruction.needsViewportDescribed;
            clone.route = instruction.route;
            if (context) {
                clone.context = instruction.context;
            }
            clone.viewportScope = keepInstances ? instruction.viewportScope : null;
            clone.scope = keepInstances ? instruction.scope : null;
            if (instruction.nextScopeInstructions) {
                clone.nextScopeInstructions = this.cloneViewportInstructions(instruction.nextScopeInstructions, keepInstances, context);
            }
            clones.push(clone);
        }
        return clones;
    }
    // TODO: Deal with separators in data and complex types
    parseComponentParameters(parameters, uriComponent = false) {
        if (parameters === undefined || parameters === null || parameters.length === 0) {
            return [];
        }
        if (typeof parameters === 'string') {
            const list = [];
            const params = parameters.split(this.separators.parameterSeparator);
            for (const param of params) {
                let key;
                let value;
                [key, value] = param.split(this.separators.parameterKeySeparator);
                if (value === void 0) {
                    value = uriComponent ? decodeURIComponent(key) : key;
                    key = void 0;
                }
                else if (uriComponent) {
                    key = decodeURIComponent(key);
                    value = decodeURIComponent(value);
                }
                list.push({ key, value });
            }
            return list;
        }
        if (Array.isArray(parameters)) {
            return parameters.map(param => ({ key: void 0, value: param }));
        }
        const keys = Object.keys(parameters);
        keys.sort();
        return keys.map(key => ({ key, value: parameters[key] }));
    }
    // TODO: Deal with separators in data and complex types
    stringifyComponentParameters(parameters, uriComponent = false) {
        if (!Array.isArray(parameters) || parameters.length === 0) {
            return '';
        }
        const seps = this.separators;
        return parameters
            .map(param => {
            const key = param.key !== void 0 && uriComponent ? encodeURIComponent(param.key) : param.key;
            const value = uriComponent ? encodeURIComponent(param.value) : param.value;
            return key !== void 0 && key !== value ? key + seps.parameterKeySeparator + value : value;
        })
            .join(seps.parameterSeparator);
    }
    matchScope(instructions, scope) {
        const matching = [];
        matching.push(...instructions.filter(instruction => instruction.scope === scope));
        matching.push(...instructions
            .filter(instr => instr.scope !== scope)
            .map(instr => Array.isArray(instr.nextScopeInstructions) ? this.matchScope(instr.nextScopeInstructions, scope) : [])
            .flat());
        return matching;
    }
    matchChildren(instructions, active) {
        for (const instruction of instructions) {
            const matching = active.filter(instr => instr.sameComponent(instruction));
            if (matching.length === 0) {
                return false;
            }
            if (Array.isArray(instruction.nextScopeInstructions)
                && instruction.nextScopeInstructions.length > 0
                && this.matchChildren(instruction.nextScopeInstructions, matching.map(instr => Array.isArray(instr.nextScopeInstructions) ? instr.nextScopeInstructions : []).flat()) === false) {
                return false;
            }
        }
        return true;
    }
    parseViewportInstructionsWorker(instructions, grouped = false) {
        if (!instructions) {
            return { instructions: [], remaining: '' };
        }
        if (instructions.startsWith(this.separators.scopeStart)) {
            instructions = `${this.separators.scope}${instructions}`;
        }
        const viewportInstructions = [];
        let guard = 1000;
        while (instructions.length && guard) {
            guard--;
            if (instructions.startsWith(this.separators.scope)) {
                instructions = instructions.slice(this.separators.scope.length);
                const scopeStart = instructions.startsWith(this.separators.scopeStart);
                if (scopeStart) {
                    instructions = instructions.slice(this.separators.scopeStart.length);
                }
                const { instructions: found, remaining } = this.parseViewportInstructionsWorker(instructions, scopeStart);
                if (viewportInstructions.length) {
                    viewportInstructions[viewportInstructions.length - 1].nextScopeInstructions = found;
                }
                else {
                    viewportInstructions.push(...found);
                }
                instructions = remaining;
            }
            else if (instructions.startsWith(this.separators.scopeEnd)) {
                if (grouped) {
                    instructions = instructions.slice(this.separators.scopeEnd.length);
                }
                return { instructions: viewportInstructions, remaining: instructions };
            }
            else if (instructions.startsWith(this.separators.sibling) && !this.isAddViewportInstruction(instructions)) {
                if (!grouped) {
                    return { instructions: viewportInstructions, remaining: instructions };
                }
                instructions = instructions.slice(this.separators.sibling.length);
            }
            else {
                const { instruction: viewportInstruction, remaining } = this.parseAViewportInstruction(instructions);
                viewportInstructions.push(viewportInstruction);
                instructions = remaining;
            }
        }
        return { instructions: viewportInstructions, remaining: instructions };
    }
    findNextToken(instruction, tokens) {
        const matches = {};
        // Tokens can have length > 1
        for (const token of tokens) {
            const tokenPos = instruction.indexOf(token);
            if (tokenPos > -1) {
                matches[token] = instruction.indexOf(token);
            }
        }
        const pos = Math.min(...Object.values(matches));
        for (const token in matches) {
            if (matches[token] === pos) {
                return { token, pos };
            }
        }
        return { token: '', pos: -1 };
    }
    parseAViewportInstruction(instruction) {
        const seps = this.separators;
        const tokens = [seps.parameters, seps.viewport, seps.noScope, seps.scopeEnd, seps.scope, seps.sibling];
        let component = void 0;
        let parametersString = void 0;
        let viewport = void 0;
        let scope = true;
        let token;
        let pos;
        const specials = [seps.add, seps.clear];
        for (const special of specials) {
            if (instruction === special) {
                component = instruction;
                instruction = '';
                tokens.shift(); // parameters
                tokens.shift(); // viewport
                token = seps.viewport;
                break;
            }
        }
        if (component === void 0) {
            for (const special of specials) {
                if (instruction.startsWith(`${special}${seps.viewport}`)) {
                    component = special;
                    instruction = instruction.slice(`${special}${seps.viewport}`.length);
                    tokens.shift(); // parameters
                    tokens.shift(); // viewport
                    token = seps.viewport;
                    break;
                }
            }
        }
        if (component === void 0) {
            ({ token, pos } = this.findNextToken(instruction, tokens));
            component = pos !== -1 ? instruction.slice(0, pos) : instruction;
            instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';
            tokens.shift(); // parameters
            if (token === seps.parameters) {
                ({ token, pos } = this.findNextToken(instruction, [seps.parametersEnd]));
                parametersString = instruction.slice(0, pos);
                instruction = instruction.slice(pos + token.length);
                ({ token } = this.findNextToken(instruction, tokens));
                instruction = instruction.slice(token.length);
            }
            tokens.shift(); // viewport
        }
        if (token === seps.viewport) {
            ({ token, pos } = this.findNextToken(instruction, tokens));
            viewport = pos !== -1 ? instruction.slice(0, pos) : instruction;
            instruction = pos !== -1 ? instruction.slice(pos + token.length) : '';
        }
        tokens.shift(); // noScope
        if (token === seps.noScope) {
            scope = false;
        }
        // Restore token that belongs to next instruction
        if (token === seps.scopeEnd || token === seps.scope || token === seps.sibling) {
            instruction = `${token}${instruction}`;
        }
        const viewportInstruction = this.createViewportInstruction(component, viewport, parametersString, scope);
        return { instruction: viewportInstruction, remaining: instruction };
    }
    stringifyAViewportInstruction(instruction, excludeViewport = false, excludeComponent = false) {
        if (typeof instruction === 'string') {
            return this.stringifyViewportInstruction(this.parseViewportInstruction(instruction), excludeViewport, excludeComponent);
        }
        else {
            let instructionString = !excludeComponent ? instruction.componentName : '';
            const specification = instruction.componentType ? instruction.componentType.parameters : null;
            const parameters = this.stringifyComponentParameters(instruction.toSortedParameters(specification));
            if (parameters.length > 0) {
                instructionString += !excludeComponent
                    ? `${this.separators.parameters}${parameters}${this.separators.parametersEnd}`
                    : parameters;
            }
            if (instruction.viewportName !== null && !excludeViewport) {
                instructionString += this.separators.viewport + instruction.viewportName;
            }
            if (!instruction.ownsScope) {
                instructionString += this.separators.noScope;
            }
            return instructionString || '';
        }
    }
}
//# sourceMappingURL=instruction-resolver.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/interfaces.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/interfaces.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReentryBehavior": () => /* binding */ ReentryBehavior
/* harmony export */ });
var ReentryBehavior;
(function (ReentryBehavior) {
    ReentryBehavior["default"] = "default";
    ReentryBehavior["disallow"] = "disallow";
    ReentryBehavior["load"] = "load";
    ReentryBehavior["refresh"] = "refresh";
})(ReentryBehavior || (ReentryBehavior = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/lifecycle-logger.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/lifecycle-logger.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lifecycleLogger": () => /* binding */ lifecycleLogger,
/* harmony export */   "LifecycleClass": () => /* binding */ LifecycleClass
/* harmony export */ });
/**
 * @internal - Will be removed
 */
function lifecycleLogger(name) {
    const lifecycles = [
        'canUnload', 'unload',
        'canLoad', 'load',
        'created',
        'binding', 'bound',
        'beforeAttach', 'attaching',
        'detaching',
        'unbinding',
    ];
    return function (target) {
        for (const lifecycle of lifecycles) {
            const existing = target.prototype[lifecycle];
            if (existing !== void 0) {
                target.prototype[lifecycle] = function (...args) {
                    console.log(`${name} ${lifecycle}`, args);
                    return existing.apply(target, args);
                };
            }
            else {
                target.prototype[lifecycle] = function (...args) {
                    console.log(`${name} ${lifecycle}`, args);
                    if (lifecycle.startsWith('can')) {
                        return true;
                    }
                };
            }
        }
    };
}
class LifecycleClass {
    canLoad() { console.log(`name canLoad`); return true; }
    load(params) { console.log(`name load`); }
    created() { console.log(`name created`); }
    binding() { console.log(`name binding`); }
    bound() { console.log(`name bound`); }
    beforeAttach() { console.log(`name beforeAttach`); }
    attaching() { console.log(`name attaching`); }
    canUnload() { console.log(`name canUnload`); return true; }
    unload() { console.log(`name unload`); }
    detaching() { console.log(`name detaching`); }
    unbinding() { console.log(`name unbinding`); }
}
//# sourceMappingURL=lifecycle-logger.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/link-handler.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/link-handler.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkHandler": () => /* binding */ LinkHandler
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

/**
 * Class responsible for handling interactions that should trigger navigation.
 *
 * @ internal - Shouldn't be used directly.
 * TODO: remove the space between @ and i again at some point (this stripInternal currently screws up the types in the __tests__ package for some reason)
 */
let LinkHandler = class LinkHandler {
    constructor(p) {
        this.options = {
            useHref: true,
            callback: () => { return; }
        };
        this.isActive = false;
        this.handler = (e) => {
            const info = LinkHandler.getEventInfo(e, this.window, this.options);
            if (info.shouldHandleEvent) {
                e.preventDefault();
                this.options.callback(info);
            }
        };
        this.window = p.window;
        this.document = p.document;
    }
    /**
     * Gets the href and a "should handle" recommendation, given an Event.
     *
     * @param event - The Event to inspect for target anchor and href.
     */
    static getEventInfo(event, win, options) {
        const info = {
            shouldHandleEvent: false,
            instruction: null,
            anchor: null
        };
        const target = info.anchor = event.currentTarget;
        // Switch to this for delegation:
        // const target = info.anchor = LinkHandler.closestAnchor(event.target as Element);
        if (!target || !LinkHandler.targetIsThisWindow(target, win)) {
            return info;
        }
        if (target.hasAttribute('external')) {
            return info;
        }
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
            return info;
        }
        const gotoAttr = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(target, 'goto');
        const goto = gotoAttr !== void 0 ? gotoAttr.viewModel.value : null;
        const loadAttr = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(target, 'load');
        const load = loadAttr !== void 0 ? loadAttr.viewModel.value : null;
        const href = options.useHref && target.hasAttribute('href') ? target.getAttribute('href') : null;
        if ((goto === null || goto.length === 0) && (load === null || load.length === 0) && (href === null || href.length === 0)) {
            return info;
        }
        info.anchor = target;
        info.instruction = load ?? goto ?? href;
        const leftButtonClicked = event.button === 0;
        info.shouldHandleEvent = leftButtonClicked;
        return info;
    }
    /**
     * Finds the closest ancestor that's an anchor element.
     *
     * @param el - The element to search upward from.
     * @returns The link element that is the closest ancestor.
     */
    // private static closestAnchor(el: Element): Element | null {
    //   while (el !== null && el !== void 0) {
    //     if (el.tagName === 'A') {
    //       return el;
    //     }
    //     el = el.parentNode as Element;
    //   }
    //   return null;
    // }
    /**
     * Gets a value indicating whether or not an anchor targets the current window.
     *
     * @param target - The anchor element whose target should be inspected.
     * @returns True if the target of the link element is this window; false otherwise.
     */
    static targetIsThisWindow(target, win) {
        const targetWindow = target.getAttribute('target');
        return !targetWindow ||
            targetWindow === win.name ||
            targetWindow === '_self';
    }
    /**
     * Start the instance.
     *
     */
    start(options) {
        if (this.isActive) {
            throw new Error('Link handler has already been started');
        }
        this.isActive = true;
        this.options = { ...options };
    }
    /**
     * Stop the instance. Event handlers and other resources should be cleaned up here.
     */
    stop() {
        if (!this.isActive) {
            throw new Error('Link handler has not been started');
        }
        this.isActive = false;
    }
};
LinkHandler = __decorate([
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IPlatform)
], LinkHandler);

//# sourceMappingURL=link-handler.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/nav-route.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/nav-route.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavRoute": () => /* binding */ NavRoute
/* harmony export */ });
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");

/**
 * @internal - Used by au-nav
 */
class NavRoute {
    constructor(nav, route) {
        this.nav = nav;
        this.instructions = [];
        this.link = null;
        this.linkVisible = null;
        this.linkActive = null;
        this.compareParameters = false;
        this.children = null;
        this.visible = true;
        this.active = '';
        this.title = route.title;
        this.meta = route.meta;
        if (route.route) {
            this.instructions = this.parseRoute(route.route);
            this.link = this.computeLink(this.instructions);
        }
        this.linkActive = route.consideredActive !== null && route.consideredActive !== void 0 ? route.consideredActive : this.link;
        if (this.linkActive !== null && (!(this.linkActive instanceof Function) || _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.ComponentAppellationResolver.isType(this.linkActive))) {
            this.linkActive = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.NavigationInstructionResolver.toViewportInstructions(this.nav.router, this.linkActive);
        }
        this.execute = route.execute;
        this.compareParameters = !!route.compareParameters;
        this.linkVisible = route.condition === undefined ? true : route.condition;
        this.update();
    }
    get hasChildren() {
        return (this.children && this.children.length ? 'nav-has-children' : '');
    }
    update() {
        this.visible = this.computeVisible();
        if ((this.link && this.link.length) || this.execute) {
            this.active = this.computeActive();
        }
        else {
            this.active = (this.active === 'nav-active' ? 'nav-active' : (this.activeChild() ? 'nav-active-child' : ''));
        }
    }
    executeAction(event) {
        if (this.execute) {
            this.execute(this);
        }
        event.stopPropagation();
    }
    toggleActive() {
        this.active = (this.active.startsWith('nav-active') ? '' : 'nav-active');
    }
    parseRoute(routes) {
        return _type_resolvers_js__WEBPACK_IMPORTED_MODULE_0__.NavigationInstructionResolver.toViewportInstructions(this.nav.router, routes);
    }
    computeVisible() {
        if (this.linkVisible instanceof Function) {
            return this.linkVisible(this);
        }
        return !!this.linkVisible;
    }
    computeActive() {
        if (!Array.isArray(this.linkActive)) {
            return this.linkActive(this) ? 'nav-active' : '';
        }
        const components = this.linkActive;
        const activeComponents = this.nav.router.instructionResolver.flattenViewportInstructions(this.nav.router.activeComponents);
        for (const component of components) {
            if (activeComponents.every((active) => !active.sameComponent(component, this.compareParameters && component.typedParameters !== null))) {
                return '';
            }
        }
        return 'nav-active';
    }
    computeLink(instructions) {
        return this.nav.router.instructionResolver.stringifyViewportInstructions(instructions);
    }
    activeChild() {
        if (this.children) {
            for (const child of this.children) {
                if (child.active.startsWith('nav-active') || child.activeChild()) {
                    return true;
                }
            }
        }
        return false;
    }
}
//# sourceMappingURL=nav-route.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/nav.js":
/*!******************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/nav.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Nav": () => /* binding */ Nav
/* harmony export */ });
/* harmony import */ var _nav_route_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nav-route.js */ "./node_modules/@aurelia/router/dist/esm/nav-route.js");

/**
 * Public API - Used by au-nav and Router add/setNav
 */
class Nav {
    constructor(router, name, routes = [], classes = {}) {
        this.router = router;
        this.name = name;
        this.routes = routes;
        this.classes = classes;
        this.update();
    }
    addRoutes(routes) {
        for (const route of routes) {
            this.addRoute(this.routes, route);
        }
        this.update();
    }
    update() {
        this.updateRoutes(this.routes);
        this.routes = this.routes.slice();
    }
    addRoute(routes, route) {
        const newRoute = new _nav_route_js__WEBPACK_IMPORTED_MODULE_0__.NavRoute(this, route);
        routes.push(newRoute);
        if (route.children) {
            newRoute.children = [];
            for (const child of route.children) {
                this.addRoute(newRoute.children, child);
            }
        }
    }
    updateRoutes(routes) {
        for (const route of routes) {
            route.update();
            if (route.children && route.children.length) {
                this.updateRoutes(route.children);
            }
        }
    }
}
//# sourceMappingURL=nav.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/navigation-coordinator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/navigation-coordinator.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavigationCoordinatorOptions": () => /* binding */ NavigationCoordinatorOptions,
/* harmony export */   "NavigationCoordinator": () => /* binding */ NavigationCoordinator
/* harmony export */ });
/* harmony import */ var _state_coordinator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state-coordinator.js */ "./node_modules/@aurelia/router/dist/esm/state-coordinator.js");

class NavigationCoordinatorOptions {
    constructor(input) {
        // console.log('NavigationCoordinatorOptions constructor', input);
        this.syncStates = input.syncStates ?? [];
    }
}
class NavigationCoordinator extends _state_coordinator_js__WEBPACK_IMPORTED_MODULE_0__.StateCoordinator {
    constructor() {
        super(...arguments);
        this.running = false;
    }
    static create(router, navigation, options) {
        const coordinator = new NavigationCoordinator();
        coordinator.router = router;
        coordinator.navigation = navigation;
        // TODO: Set flow options from router
        options.syncStates.forEach((state) => coordinator.addSyncState(state));
        // console.log('NavigationCoordinator created', coordinator);
        return coordinator;
    }
    // public get isRestrictedNavigation(): boolean {
    //   return this.syncStates.has('guardedLoad') ||
    //     this.syncStates.has('unloaded') ||
    //     this.syncStates.has('loaded') ||
    //     this.syncStates.has('guarded') ||
    //     this.syncStates.has('routed');
    // }
    run() {
        if (!this.running) {
            // console.log('NavigationCoordinator RUN' /*, { ...this } */);
            this.running = true;
            for (const entity of this.entities) {
                if (!entity.running) {
                    entity.running = true;
                    entity.entity.transition(this);
                }
            }
        }
    }
    addEntity(entity) {
        const ent = super.addEntity(entity);
        if (this.running) {
            ent.entity.transition(this);
        }
        return ent;
    }
    finalize() {
        this.entities.forEach(entity => entity.entity.finalizeContentChange());
    }
    cancel() {
        // TODO: Take care of disabling viewports when cancelling and stateful!
        this.entities.forEach(entity => {
            const abort = entity.entity.abortContentChange();
            if (abort instanceof Promise) {
                abort.catch(error => { throw error; });
            }
        });
        this.router.navigator.cancel(this.navigation).then(() => {
            this.router.processingNavigation = null;
            this.navigation.resolve();
        }).catch(error => { throw error; });
    }
    // A new navigation should cancel replaced instructions
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    cancelReplaced(navigation) { }
}
//# sourceMappingURL=navigation-coordinator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/navigation.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/navigation.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Navigation": () => /* binding */ Navigation
/* harmony export */ });
class Navigation {
    constructor(entry = {
        instruction: '',
        fullStateInstruction: '',
    }) {
        this.navigation = entry.navigation ?? {
            first: false,
            new: false,
            refresh: false,
            forward: false,
            back: false,
            replace: false,
        };
        this.repeating = entry.repeating;
        // INavigatorEntry
        this.fromBrowser = entry.fromBrowser;
        this.origin = entry.origin;
        this.replacing = entry.replacing;
        this.refreshing = entry.refreshing;
        this.untracked = entry.untracked;
        this.historyMovement = entry.historyMovement;
        this.resolve = entry.resolve;
        this.reject = entry.reject;
        // IStoredNavigatorEntry
        this.instruction = entry.instruction;
        this.fullStateInstruction = entry.fullStateInstruction;
        this.scope = entry.scope;
        this.index = entry.index;
        this.firstEntry = entry.firstEntry;
        this.route = entry.route;
        this.path = entry.path;
        this.title = entry.title;
        this.query = entry.query;
        this.parameters = entry.parameters;
        this.data = entry.data;
    }
    get useFullStateInstruction() {
        return (this.navigation.back ?? false) || (this.navigation.forward ?? false);
    }
    toStored() {
        return {
            navigation: this.navigation,
            repeating: this.repeating,
            // IStoredNavigatorEntry
            instruction: this.instruction,
            fullStateInstruction: this.fullStateInstruction,
            scope: this.scope,
            index: this.index,
            firstEntry: this.firstEntry,
            route: this.route,
            path: this.path,
            title: this.title,
            query: this.query,
            parameters: this.parameters,
            data: this.data,
        };
    }
}
//# sourceMappingURL=navigation.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/navigator.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/navigator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Navigator": () => /* binding */ Navigator
/* harmony export */ });
/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queue.js */ "./node_modules/@aurelia/router/dist/esm/queue.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");



/**
 * @internal - Shouldn't be used directly
 */
class Navigator {
    constructor() {
        this.entries = [];
        this.options = {
            statefulHistoryLength: 0,
        };
        this.isActive = false;
        this.processNavigations = (qEntry) => {
            const entry = qEntry;
            const navigationFlags = {
                first: false,
                new: false,
                refresh: false,
                forward: false,
                back: false,
                replace: false,
            };
            if (this.currentEntry === this.uninitializedEntry) { // Refresh or first entry
                this.loadState();
                if (this.currentEntry !== this.uninitializedEntry) {
                    navigationFlags.refresh = true;
                }
                else {
                    navigationFlags.first = true;
                    navigationFlags.new = true;
                    // TODO: Should this really be created here? Shouldn't it be in the viewer?
                    this.currentEntry = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation({
                        index: 0,
                        instruction: '',
                        fullStateInstruction: '',
                    });
                    this.entries = [];
                }
            }
            if (entry.index !== void 0 && !entry.replacing && !entry.refreshing) { // History navigation
                entry.historyMovement = entry.index - (this.currentEntry.index !== void 0 ? this.currentEntry.index : 0);
                entry.instruction = this.entries[entry.index] !== void 0 && this.entries[entry.index] !== null ? this.entries[entry.index].fullStateInstruction : entry.fullStateInstruction;
                entry.replacing = true;
                if (entry.historyMovement > 0) {
                    navigationFlags.forward = true;
                }
                else if (entry.historyMovement < 0) {
                    navigationFlags.back = true;
                }
            }
            else if (entry.refreshing || navigationFlags.refresh) { // Refreshing
                entry.index = this.currentEntry.index;
            }
            else if (entry.replacing) { // Replacing
                navigationFlags.replace = true;
                navigationFlags.new = true;
                entry.index = this.currentEntry.index;
            }
            else { // New entry
                navigationFlags.new = true;
                entry.index = this.currentEntry.index !== void 0 ? this.currentEntry.index + 1 : this.entries.length;
            }
            this.invokeCallback(entry, navigationFlags, this.currentEntry);
        };
        this.uninitializedEntry = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation({
            instruction: 'NAVIGATOR UNINITIALIZED',
            fullStateInstruction: '',
        });
        this.currentEntry = this.uninitializedEntry;
        this.pendingNavigations = new _queue_js__WEBPACK_IMPORTED_MODULE_0__.Queue(this.processNavigations);
    }
    get queued() {
        return this.pendingNavigations.length;
    }
    start(router, options) {
        if (this.isActive) {
            throw new Error('Navigator has already been started');
        }
        this.isActive = true;
        this.router = router;
        this.options = { ...options };
    }
    stop() {
        if (!this.isActive) {
            throw new Error('Navigator has not been started');
        }
        this.pendingNavigations.clear();
        this.isActive = false;
    }
    async navigate(entry) {
        return this.pendingNavigations.enqueue(entry);
    }
    async refresh() {
        const entry = this.currentEntry;
        if (entry === this.uninitializedEntry) {
            return Promise.reject();
        }
        entry.replacing = true;
        entry.refreshing = true;
        return this.navigate(entry);
    }
    async go(movement) {
        const newIndex = (this.currentEntry.index !== undefined ? this.currentEntry.index : 0) + movement;
        if (newIndex >= this.entries.length) {
            return Promise.reject();
        }
        const entry = this.entries[newIndex];
        return this.navigate(entry);
    }
    async setEntryTitle(title) {
        this.currentEntry.title = title;
        return this.saveState();
    }
    get titles() {
        if (this.currentEntry === this.uninitializedEntry) {
            return [];
        }
        const index = this.currentEntry.index !== void 0 ? this.currentEntry.index : 0;
        return this.entries.slice(0, index + 1).filter((value) => !!value.title).map((value) => value.title ? value.title : '');
    }
    // Get the stored navigator state (json okay)
    getState() {
        const state = this.options.store ? { ...this.options.store.state } : {};
        const entries = (state.entries ?? []);
        const currentEntry = (state.currentEntry ?? null);
        return { state, entries, currentEntry };
    }
    // Load a stored state into Navigation entries
    loadState() {
        const state = this.getState();
        this.entries = state.entries.map(entry => new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation(entry));
        this.currentEntry = state.currentEntry !== null
            ? new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation(state.currentEntry)
            : this.uninitializedEntry;
    }
    // Save storeable versions of Navigation entries
    async saveState(push = false) {
        if (this.currentEntry === this.uninitializedEntry) {
            return Promise.resolve();
        }
        const storedEntry = this.currentEntry.toStored();
        this.entries[storedEntry.index !== void 0 ? storedEntry.index : 0] = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation(storedEntry);
        // If preserving history, serialize entries that aren't preserved
        if (this.options.statefulHistoryLength > 0) {
            const index = this.entries.length - this.options.statefulHistoryLength;
            for (let i = 0; i < index; i++) {
                const entry = this.entries[i];
                if (typeof entry.instruction !== 'string' || typeof entry.fullStateInstruction !== 'string') {
                    await this.serializeEntry(entry, this.entries.slice(index));
                }
            }
        }
        if (!this.options.store) {
            return Promise.resolve();
        }
        const state = {
            entries: (this.entries ?? []).map((entry) => this.toStoreableEntry(entry)),
            currentEntry: this.toStoreableEntry(storedEntry),
        };
        // for (const entry of this.entries) {
        //   state.entries.push(this.toStoreableEntry(entry));
        // }
        if (state.currentEntry.title !== void 0) {
            this.options.store.setTitle(state.currentEntry.title);
        }
        if (push) {
            return this.options.store.pushNavigatorState(state);
        }
        else {
            return this.options.store.replaceNavigatorState(state);
        }
    }
    toStoredEntry(entry) {
        const { previous, fromBrowser, origin, replacing, refreshing, untracked, historyMovement, navigation, scope, resolve, reject, ...storableEntry } = entry;
        return storableEntry;
    }
    async finalize(instruction) {
        this.currentEntry = instruction;
        let index = this.currentEntry.index !== undefined ? this.currentEntry.index : 0;
        if (this.currentEntry.untracked) {
            if (instruction.fromBrowser && this.options.store) {
                await this.options.store.popNavigatorState();
            }
            index--;
            this.currentEntry.index = index;
            this.entries[index] = this.currentEntry;
            await this.saveState();
        }
        else if (this.currentEntry.replacing) {
            this.entries[index] = this.currentEntry;
            await this.saveState();
        }
        else { // New entry (add and discard later entries)
            if (this.options.serializeCallback !== void 0 && this.options.statefulHistoryLength > 0) {
                // Need to clear the instructions we discard!
                const indexPreserve = this.entries.length - this.options.statefulHistoryLength;
                for (const entry of this.entries.slice(index)) {
                    if (typeof entry.instruction !== 'string' || typeof entry.fullStateInstruction !== 'string') {
                        await this.options.serializeCallback(entry, this.entries.slice(indexPreserve, index));
                    }
                }
            }
            this.entries = this.entries.slice(0, index);
            this.entries.push(this.currentEntry);
            await this.saveState(true);
        }
        if (this.currentEntry.resolve) {
            this.currentEntry.resolve();
        }
    }
    async cancel(instruction) {
        if (instruction.fromBrowser && this.options.store) {
            if (instruction.navigation && instruction.navigation.new) {
                await this.options.store.popNavigatorState();
            }
            else {
                await this.options.store.go(-(instruction.historyMovement || 0), true);
            }
        }
        if (this.currentEntry.resolve) {
            this.currentEntry.resolve();
        }
    }
    invokeCallback(entry, navigationFlags, previousEntry) {
        const instruction = new _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation({ ...entry });
        instruction.navigation = navigationFlags;
        instruction.previous = previousEntry;
        if (this.options.callback) {
            this.options.callback(instruction);
        }
    }
    toStoreableEntry(entry) {
        const storeable = entry instanceof _navigation_js__WEBPACK_IMPORTED_MODULE_1__.Navigation ? entry.toStored() : entry;
        storeable.instruction = this.router.instructionResolver.stringifyViewportInstructions(storeable.instruction);
        storeable.fullStateInstruction = this.router.instructionResolver.stringifyViewportInstructions(storeable.fullStateInstruction);
        if (typeof storeable.scope !== 'string') {
            storeable.scope = null;
        }
        return storeable;
    }
    async serializeEntry(entry, preservedEntries) {
        const instructionResolver = this.router.instructionResolver;
        let excludeComponents = [];
        // Components in preserved entries should not be serialized/freed
        for (const preservedEntry of preservedEntries) {
            if (typeof preservedEntry.instruction !== 'string') {
                excludeComponents.push(...instructionResolver.flattenViewportInstructions(preservedEntry.instruction)
                    .filter(instruction => instruction.viewport !== null)
                    .map(instruction => instruction.componentInstance));
            }
            if (typeof preservedEntry.fullStateInstruction !== 'string') {
                excludeComponents.push(...instructionResolver.flattenViewportInstructions(preservedEntry.fullStateInstruction)
                    .filter(instruction => instruction.viewport !== null)
                    .map(instruction => instruction.componentInstance));
            }
        }
        // Make unique
        excludeComponents = excludeComponents.filter((component, i, arr) => component !== null && arr.indexOf(component) === i);
        let instructions = [];
        // The instructions, one or two, with possible components to free
        if (typeof entry.fullStateInstruction !== 'string') {
            instructions.push(...entry.fullStateInstruction);
            entry.fullStateInstruction = instructionResolver.stringifyViewportInstructions(entry.fullStateInstruction);
        }
        if (typeof entry.instruction !== 'string') {
            instructions.push(...entry.instruction);
            entry.instruction = instructionResolver.stringifyViewportInstructions(entry.instruction);
        }
        // Process only those with instances and make unique
        instructions = instructions.filter((instruction, i, arr) => instruction !== null
            && instruction.componentInstance !== null
            && arr.indexOf(instruction) === i);
        // Already freed components (updated when component is freed)
        const alreadyDone = [];
        for (const instruction of instructions) {
            await this.freeInstructionComponents(instruction, excludeComponents, alreadyDone);
        }
    }
    freeInstructionComponents(instruction, excludeComponents, alreadyDone) {
        const component = instruction.componentInstance;
        const viewport = instruction.viewport;
        if (component === null || viewport === null || alreadyDone.some(done => done === component)) {
            return;
        }
        if (!excludeComponents.some(exclude => exclude === component)) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_2__.Runner.run(() => viewport.freeContent(component), () => {
                alreadyDone.push(component);
            });
        }
        if (instruction.nextScopeInstructions !== null) {
            for (const nextInstruction of instruction.nextScopeInstructions) {
                return _runner_js__WEBPACK_IMPORTED_MODULE_2__.Runner.run(() => this.freeInstructionComponents(nextInstruction, excludeComponents, alreadyDone));
            }
        }
    }
}
//# sourceMappingURL=navigator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/open-promise.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/open-promise.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OpenPromise": () => /* binding */ OpenPromise
/* harmony export */ });
class OpenPromise {
    constructor() {
        this.isPending = true;
        this.promise = new Promise((res, rej) => {
            this.res = res;
            this.rej = rej;
        });
    }
    resolve(value) {
        this.res(value);
        this.isPending = false;
    }
    reject(value) {
        this.rej(value);
        this.isPending = false;
    }
}
//# sourceMappingURL=open-promise.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/parser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseQuery": () => /* binding */ parseQuery
/* harmony export */ });
/**
 * @internal - Shouldn't be used directly
 */
function parseQuery(query) {
    if (!query || !query.length) {
        return {};
    }
    const parameters = {};
    // TODO: Deal with complex parameters such as lists and objects
    const params = query.replace('+', ' ').split('&');
    for (const param of params) {
        const [key, value] = param.split('=');
        parameters[decodeURIComponent(key)] = decodeURIComponent(value !== void 0 ? value : key);
    }
    return parameters;
}
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/queue.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/queue.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Queue": () => /* binding */ Queue
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A first-in-first-out queue that only processes the next queued item
 * when the current one has been resolved or rejected. Sends queued items
 * one at a time to a specified callback function. The callback function
 * should resolve or reject the queued item when processing is done.
 * Enqueued items can be awaited. Enqueued items can specify an (arbitrary)
 * execution cost and the queue can be set up (started) to only process
 * a specific amount of execution cost per RAF/tick.
 *
 * @internal - Shouldn't be used directly.
 */
class Queue {
    constructor(callback) {
        this.callback = callback;
        this.pending = [];
        this.processing = null;
        this.allowedExecutionCostWithinTick = null;
        this.currentExecutionCostInCurrentTick = 0;
        this.platform = null;
        this.task = null;
    }
    get isActive() {
        return this.task !== null;
    }
    get length() {
        return this.pending.length;
    }
    start(options) {
        if (this.isActive) {
            throw new Error('Queue has already been started');
        }
        this.platform = options.platform;
        this.allowedExecutionCostWithinTick = options.allowedExecutionCostWithinTick;
        this.task = this.platform.domWriteQueue.queueTask(this.dequeue, { persistent: true });
    }
    stop() {
        if (!this.isActive) {
            throw new Error('Queue has not been started');
        }
        this.task.cancel();
        this.task = null;
        this.allowedExecutionCostWithinTick = null;
        this.clear();
    }
    enqueue(itemOrItems, costOrCosts) {
        const list = Array.isArray(itemOrItems);
        const items = list ? itemOrItems : [itemOrItems];
        const costs = items
            .map((value, index) => !Array.isArray(costOrCosts) ? costOrCosts : costOrCosts[index])
            .map(value => value !== undefined ? value : 1);
        const promises = [];
        for (const item of items) {
            const qItem = { ...item };
            qItem.cost = costs.shift();
            promises.push(new Promise((resolve, reject) => {
                qItem.resolve = () => {
                    resolve();
                    this.processing = null;
                    this.dequeue();
                };
                qItem.reject = (reason) => {
                    reject(reason);
                    this.processing = null;
                    this.dequeue();
                };
            }));
            this.pending.push(qItem);
        }
        this.dequeue();
        return list ? promises : promises[0];
    }
    dequeue(delta) {
        if (this.processing !== null) {
            return;
        }
        if (delta !== undefined) {
            this.currentExecutionCostInCurrentTick = 0;
        }
        if (!this.pending.length) {
            return;
        }
        if (this.allowedExecutionCostWithinTick !== null && delta === undefined && this.currentExecutionCostInCurrentTick + (this.pending[0].cost || 0) > this.allowedExecutionCostWithinTick) {
            return;
        }
        this.processing = this.pending.shift() || null;
        if (this.processing) {
            this.currentExecutionCostInCurrentTick += this.processing.cost || 0;
            this.callback(this.processing);
        }
    }
    clear() {
        this.pending.splice(0, this.pending.length);
    }
}
__decorate([
    _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.bound
], Queue.prototype, "dequeue", null);
//# sourceMappingURL=queue.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/goto.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/goto.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GotoCustomAttribute": () => /* binding */ GotoCustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




let GotoCustomAttribute = class GotoCustomAttribute {
    constructor(element, router) {
        this.element = element;
        this.router = router;
        this.hasHref = null;
        this.activeClass = 'goto-active';
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.deprecationWarning)('"goto" custom attribute', '"load" custom attribute');
    }
    binding() {
        this.element.addEventListener('click', this.router.linkHandler.handler);
        this.updateValue();
        const observerLocator = this.router.container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IObserverLocator);
        this.observer = observerLocator.getObserver(this.router, 'activeComponents');
        this.observer.subscribe(this);
    }
    unbinding() {
        this.element.removeEventListener('click', this.router.linkHandler.handler);
        this.observer.unsubscribe(this);
    }
    valueChanged(newValue) {
        this.updateValue();
    }
    updateValue() {
        if (this.hasHref === null) {
            this.hasHref = this.element.hasAttribute('href');
        }
        if (!this.hasHref) {
            // TODO: Figure out a better value here for non-strings (using InstructionResolver?)
            const value = typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
            this.element.setAttribute('href', value);
        }
    }
    handleChange() {
        const controller = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(this.element, 'goto').parent;
        const created = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.createViewportInstructions(this.router, this.value, { context: controller });
        const instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.toViewportInstructions(this.router, created.instructions);
        for (const instruction of instructions) {
            if (instruction.scope === null) {
                instruction.scope = created.scope;
            }
        }
        // TODO: Use router configuration for class name and update target
        if (this.router.checkActive(instructions)) {
            this.element.classList.add(this.activeClass);
        }
        else {
            this.element.classList.remove(this.activeClass);
        }
    }
};
__decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable)({ mode: _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView })
], GotoCustomAttribute.prototype, "value", void 0);
GotoCustomAttribute = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customAttribute)('goto'),
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(1, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], GotoCustomAttribute);

//# sourceMappingURL=goto.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/href.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/href.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HrefCustomAttribute": () => /* binding */ HrefCustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _configuration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../configuration.js */ "./node_modules/@aurelia/router/dist/esm/configuration.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



let HrefCustomAttribute = class HrefCustomAttribute {
    constructor(element, router) {
        this.element = element;
        this.router = router;
    }
    binding() {
        if (this.router.options.useHref && !this.hasGoto()) {
            this.element.addEventListener('click', this.router.linkHandler.handler);
        }
        this.updateValue();
    }
    unbinding() {
        this.element.removeEventListener('click', this.router.linkHandler.handler);
    }
    valueChanged() {
        this.updateValue();
    }
    updateValue() {
        this.element.setAttribute('href', this.value);
    }
    hasGoto() {
        const parent = this.$controller.parent;
        const siblings = parent.children;
        return siblings !== null
            && siblings.some(c => c.vmKind === 1 /* customAttribute */ && c.viewModel instanceof _configuration_js__WEBPACK_IMPORTED_MODULE_2__.GotoCustomAttribute);
    }
};
__decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable)({ mode: _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView })
], HrefCustomAttribute.prototype, "value", void 0);
HrefCustomAttribute = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customAttribute)({
        name: 'href',
        noMultiBindings: true
    }),
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(1, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], HrefCustomAttribute);

//# sourceMappingURL=href.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/load.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/load.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoadCustomAttribute": () => /* binding */ LoadCustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



let LoadCustomAttribute = class LoadCustomAttribute {
    constructor(element, router) {
        this.element = element;
        this.router = router;
        this.hasHref = null;
        this.activeClass = 'load-active';
    }
    binding() {
        this.element.addEventListener('click', this.router.linkHandler.handler);
        this.updateValue();
        const observerLocator = this.router.container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IObserverLocator);
        this.observer = observerLocator.getObserver(this.router, 'activeComponents');
        this.observer.subscribe(this);
    }
    unbinding() {
        this.element.removeEventListener('click', this.router.linkHandler.handler);
        this.observer.unsubscribe(this);
    }
    valueChanged(newValue) {
        this.updateValue();
    }
    updateValue() {
        if (this.hasHref === null) {
            this.hasHref = this.element.hasAttribute('href');
        }
        if (!this.hasHref) {
            // TODO: Figure out a better value here for non-strings (using InstructionResolver?)
            const value = typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
            this.element.setAttribute('href', value);
        }
    }
    handleChange() {
        const controller = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomAttribute.for(this.element, 'load').parent;
        const created = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.createViewportInstructions(this.router, this.value, { context: controller });
        const instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.toViewportInstructions(this.router, created.instructions);
        for (const instruction of instructions) {
            if (instruction.scope === null) {
                instruction.scope = created.scope;
            }
        }
        // TODO: Use router configuration for class name and update target
        if (this.router.checkActive(instructions)) {
            this.element.classList.add(this.activeClass);
        }
        else {
            this.element.classList.remove(this.activeClass);
        }
    }
};
__decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable)({ mode: _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView })
], LoadCustomAttribute.prototype, "value", void 0);
LoadCustomAttribute = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customAttribute)('load'),
    __param(0, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(1, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], LoadCustomAttribute);

//# sourceMappingURL=load.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/nav.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/nav.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavCustomElement": () => /* binding */ NavCustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


let NavCustomElement = class NavCustomElement {
    constructor(router) {
        this.router = router;
        this.name = null;
        this.routes = null;
        this.level = 0;
        this.classes = {};
    }
    get navRoutes() {
        const nav = this.router.navs[this.name];
        return (nav !== void 0 && nav !== null ? nav.routes : []);
    }
    get navClasses() {
        const nav = this.router.navs[this.name];
        const navClasses = (nav !== void 0 && nav !== null ? nav.classes : {});
        return {
            ...{
                nav: '',
                ul: '',
                li: '',
                a: '',
                ulActive: '',
                liActive: 'nav-active',
                aActive: '',
            }, ...navClasses
        };
    }
    active(route) {
        return 'Active';
    }
};
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "name", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "routes", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "level", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], NavCustomElement.prototype, "classes", void 0);
NavCustomElement = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customElement)({
        name: 'au-nav', template: `<template>
  <nav if.bind="name" class="\${name} \${navClasses.nav}">
    <au-nav routes.bind="navRoutes" classes.bind="navClasses" containerless></au-nav>
  </nav>
  <ul if.bind="routes" class="nav-level-\${level} \${classes.ul}">
    <li repeat.for="route of routes" if.bind="route.visible" class="\${route.active ? classes.liActive : ''} \${route.hasChildren} \${classes.li}">
      <a if.bind="route.link && route.link.length" load="\${route.link}" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <a if.bind="route.execute" click.trigger="route.executeAction($event)" href="" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <span if.bind="(!route.link || !route.link.length) && !route.execute && !route.children" class="\${route.active ? classes.aActive : ''} \${classes.span} nav-separator" innerhtml.bind="route.title"></span>
      <a if.bind="(!route.link || !route.link.length) && !route.execute && route.children" click.delegate="route.toggleActive()" href="" class="\${route.active ? classes.aActive : ''} \${classes.a}" innerhtml.bind="route.title"></a>
      <au-nav if.bind="route.children" routes.bind="route.children" level.bind="level + 1" classes.bind="classes" containerless></au-nav>
    </li>
  </ul>
</template>`
    }),
    __param(0, _router_js__WEBPACK_IMPORTED_MODULE_1__.IRouter)
], NavCustomElement);

//# sourceMappingURL=nav.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParentViewportScope": () => /* binding */ ParentViewportScope,
/* harmony export */   "ViewportScopeCustomElement": () => /* binding */ ViewportScopeCustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ViewportScopeCustomElement_1;




const ParentViewportScope = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.createInjectable();
let ViewportScopeCustomElement = ViewportScopeCustomElement_1 = class ViewportScopeCustomElement {
    constructor(router, element, container, parent, parentController) {
        this.router = router;
        this.element = element;
        this.container = container;
        this.parent = parent;
        this.parentController = parentController;
        this.name = 'default';
        this.catches = '';
        this.collection = false;
        this.source = null;
        this.viewportScope = null;
        this.isBound = false;
    }
    // Maybe this really should be here. Check with Fred
    // public create(
    //   controller: IDryCustomElementController<this>,
    //   parentContainer: IContainer,
    //   definition: CustomElementDefinition,
    //   parts: PartialCustomElementDefinitionParts | undefined,
    // ): PartialCustomElementDefinition {
    //   // TODO(fkleuver): describe this somewhere in the docs instead
    //   // Under the condition that there is no `replace` attribute on this custom element's declaration,
    //   // and this custom element is containerless, its content will be placed in a part named 'default'
    //   // See packages/jit-html/src/template-binder.ts line 411 (`replace = 'default';`) for the logic that governs this.
    //   // We could tidy this up into a formal api in the future. For now, there are two ways to do this:
    //   // 1. inject the `@IInstruction` (IHydrateElementInstruction) and grab .parts['default'] from there, manually creating a view factory from that, etc.
    //   // 2. what we're doing right here: grab the 'default' part from the create hook and return it as the definition, telling the render context to use that part to compile this element instead
    //   // This effectively causes this element to render its declared content as if it was its own template.
    //   // We do need to set `containerless` to true on the part definition so that the correct projector is used since parts default to non-containerless.
    //   // Otherwise, the controller will try to do `appendChild` on a comment node when it has to do `insertBefore`.
    //   // Also, in this particular scenario (specific to viewport-scope) we need to clone the part so as to prevent the resulting compiled definition
    //   // from ever being cached. That's the only reason why we're spreading the part into a new object for `getOrCreate`. If we didn't clone the object, this specific element wouldn't work correctly.
    //   const part = parts!['default'];
    //   return CustomElementDefinition.getOrCreate({ ...part, containerless: true });
    // }
    hydrated(controller) {
        this.controller = controller;
        // Don't update the container here (probably because it wants to be a part of the structure)
        // this.container = controller.context.get(IContainer);
        // console.log('ViewportScope creating', this.getAttribute('name', this.name), this.container, this.parent, controller, this);
        // this.connect();
    }
    bound(initiator, parent, flags) {
        this.isBound = true;
        this.$controller.scope = this.parentController.scope;
        this.connect();
        if (this.viewportScope !== null) {
            this.viewportScope.binding();
        }
    }
    unbinding(initiator, parent, flags) {
        if (this.viewportScope !== null) {
            this.viewportScope.unbinding();
        }
        return Promise.resolve();
    }
    afterUnbind(initiator, parent, flags) {
        this.disconnect();
        return Promise.resolve();
    }
    afterUnbound() {
        this.isBound = false;
    }
    connect() {
        if (this.router.rootScope === null) {
            return;
        }
        const name = this.getAttribute('name', this.name);
        const options = {};
        let value = this.getAttribute('catches', this.catches);
        if (value !== void 0) {
            options.catches = value;
        }
        value = this.getAttribute('collection', this.collection, true);
        if (value !== void 0) {
            options.collection = value;
        }
        // TODO: Needs to be bound? How to solve?
        options.source = this.source || null;
        this.controller.routingContainer = this.container;
        this.viewportScope = this.router.connectViewportScope(this.viewportScope, this, name, options);
    }
    disconnect() {
        if (this.viewportScope) {
            this.router.disconnectViewportScope(this.viewportScope, this);
        }
        this.viewportScope = null;
    }
    getAttribute(key, value, checkExists = false) {
        const result = {};
        if (this.isBound) {
            return value;
        }
        else {
            if (this.element.hasAttribute(key)) {
                if (checkExists) {
                    return true;
                }
                else {
                    value = this.element.getAttribute(key);
                    if (value.length > 0) {
                        return value;
                    }
                }
            }
        }
        return void 0;
    }
    isCustomElementController(value) {
        return (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.isCustomElementController)(value);
    }
    isCustomElementViewModel(value) {
        return (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.isCustomElementViewModel)(value);
    }
    getClosestCustomElement() {
        let parent = this.controller.parent;
        let customElement = null;
        while (parent !== null && customElement === null) {
            if (parent.viewModel instanceof _viewport_js__WEBPACK_IMPORTED_MODULE_3__.ViewportCustomElement || parent.viewModel instanceof ViewportScopeCustomElement_1) {
                customElement = parent.viewModel;
            }
            parent = parent.parent;
        }
        return customElement;
    }
};
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "name", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "catches", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "collection", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.bindable
], ViewportScopeCustomElement.prototype, "source", void 0);
ViewportScopeCustomElement = ViewportScopeCustomElement_1 = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.customElement)({
        name: 'au-viewport-scope',
        template: '<template></template>',
        containerless: false,
        injectable: ParentViewportScope
    }),
    __param(0, _router_js__WEBPACK_IMPORTED_MODULE_2__.IRouter),
    __param(1, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.INode),
    __param(2, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.IContainer),
    __param(3, ParentViewportScope),
    __param(4, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.IController)
], ViewportScopeCustomElement);

//# sourceMappingURL=viewport-scope.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/resources/viewport.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/resources/viewport.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParentViewport": () => /* binding */ ParentViewport,
/* harmony export */   "ViewportCustomElement": () => /* binding */ ViewportCustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../router.js */ "./node_modules/@aurelia/router/dist/esm/router.js");
/* harmony import */ var _viewport_scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/resources/viewport-scope.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ViewportCustomElement_1;





const ParentViewport = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.createInjectable();
let ViewportCustomElement = ViewportCustomElement_1 = class ViewportCustomElement {
    constructor(router, element, container, parentViewport) {
        this.router = router;
        this.element = element;
        this.container = container;
        this.parentViewport = parentViewport;
        this.name = 'default';
        this.usedBy = '';
        this.default = '';
        this.fallback = '';
        this.noScope = false;
        this.noLink = false;
        this.noTitle = false;
        this.noHistory = false;
        this.stateful = false;
        this.viewport = null;
        this.isBound = false;
    }
    hydrated(controller) {
        // console.log('hydrated', this.name, this.router.isActive);
        this.controller = controller;
        this.container = controller.context.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer);
        // The first viewport(s) might be compiled before the router is active
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.waitForRouterStart(), () => {
            if (this.router.isRestrictedNavigation) {
                this.connect();
            }
        });
    }
    binding(initiator, parent, flags) {
        this.isBound = true;
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.waitForRouterStart(), () => {
            if (!this.router.isRestrictedNavigation) {
                this.connect();
            }
        });
    }
    attaching(initiator, parent, flags) {
        if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
            // console.log('attaching', this.viewport?.toString());
            this.viewport.enabled = true;
            return this.viewport.activate(initiator, this.$controller, flags, true);
            // TODO: Restore scroll state
        }
    }
    unbinding(initiator, parent, flags) {
        if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
            // console.log('unbinding', this.viewport?.toString());
            // TODO: Save to cache, something like
            // this.viewport.cacheContent();
            // From viewport-content:
            // public unloadComponent(cache: ViewportContent[], stateful: boolean = false): void {
            //   // TODO: We might want to do something here eventually, who knows?
            //   if (this.contentStatus !== ContentStatus.loaded) {
            //     return;
            //   }
            //   // Don't unload components when stateful
            //   if (!stateful) {
            //     this.contentStatus = ContentStatus.created;
            //   } else {
            //     cache.push(this);
            //   }
            // }
            // TODO: Save scroll state before detach
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.viewport.deactivate(initiator, parent, flags), () => {
                this.isBound = false;
                this.viewport.enabled = false;
            });
            // this.isBound = false;
            // this.viewport.enabled = false;
            // return this.viewport.deactivate(initiator, parent, flags);
            // // this.viewport.enabled = false;
        }
    }
    // public detaching(initiator: IHydratedController, parent: ISyntheticView | ICustomElementController<ICustomElementViewModel> | null, flags: LifecycleFlags): void | Promise<void> {
    //   if (this.viewport !== null && (this.viewport.nextContent ?? null) === null) {
    //     console.log('detaching', this.viewport?.toString());
    //   }
    // }
    dispose() {
        if (this.viewport !== null) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => (this.viewport?.nextContent ?? null) === null ? this.viewport?.dispose() : void 0, () => this.disconnect());
        }
    }
    connect() {
        if (this.router.rootScope === null || (this.viewport !== null && this.router.isRestrictedNavigation)) {
            return;
        }
        // let controllerContainer = (this.controller.context as any).container;
        // let output = '';
        // do {
        //   console.log(output, ':', controllerContainer === this.container, this.controller, controllerContainer, this.container);
        //   if (controllerContainer === this.container) {
        //     break;
        //   }
        //   controllerContainer = controllerContainer.parent;
        //   output += '.parent';
        // } while (controllerContainer);
        const name = this.getAttribute('name', this.name);
        let value = this.getAttribute('no-scope', this.noScope);
        const options = { scope: value === void 0 || !value ? true : false };
        value = this.getAttribute('used-by', this.usedBy);
        if (value !== void 0) {
            options.usedBy = value;
        }
        value = this.getAttribute('default', this.default);
        if (value !== void 0) {
            options.default = value;
        }
        value = this.getAttribute('fallback', this.fallback);
        if (value !== void 0) {
            options.fallback = value;
        }
        value = this.getAttribute('no-link', this.noLink, true);
        if (value !== void 0) {
            options.noLink = value;
        }
        value = this.getAttribute('no-title', this.noTitle, true);
        if (value !== void 0) {
            options.noTitle = value;
        }
        value = this.getAttribute('no-history', this.noHistory, true);
        if (value !== void 0) {
            options.noHistory = value;
        }
        value = this.getAttribute('stateful', this.stateful, true);
        if (value !== void 0) {
            options.stateful = value;
        }
        this.controller.routingContainer = this.container;
        this.viewport = this.router.connectViewport(this.viewport, this, name, options);
    }
    disconnect() {
        if (this.viewport) {
            this.router.disconnectViewport(this.viewport, this);
        }
        this.viewport = null;
    }
    getAttribute(key, value, checkExists = false) {
        const result = {};
        if (this.isBound && !checkExists) {
            return value;
        }
        else {
            if (this.element.hasAttribute(key)) {
                if (checkExists) {
                    return true;
                }
                else {
                    value = this.element.getAttribute(key);
                    if (value.length > 0) {
                        return value;
                    }
                }
            }
        }
        return value;
    }
    getClosestCustomElement() {
        let parent = this.controller.parent;
        let customElement = null;
        while (parent !== null && customElement === null) {
            if (parent.viewModel instanceof ViewportCustomElement_1 || parent.viewModel instanceof _viewport_scope_js__WEBPACK_IMPORTED_MODULE_3__.ViewportScopeCustomElement) {
                customElement = parent.viewModel;
            }
            parent = parent.parent;
        }
        return customElement;
    }
    // TODO: Switch this to use (probably) an event instead
    waitForRouterStart() {
        if (this.router.isActive) {
            return;
        }
        return new Promise((resolve) => {
            this.router.starters.push(resolve);
        });
    }
};
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "name", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "usedBy", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "default", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "fallback", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noScope", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noLink", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noTitle", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "noHistory", void 0);
__decorate([
    _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable
], ViewportCustomElement.prototype, "stateful", void 0);
ViewportCustomElement = ViewportCustomElement_1 = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)({
        name: 'au-viewport',
        injectable: ParentViewport
    }),
    __param(0, _router_js__WEBPACK_IMPORTED_MODULE_2__.IRouter),
    __param(1, _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(2, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer),
    __param(3, ParentViewport)
], ViewportCustomElement);

//# sourceMappingURL=viewport.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/route-recognizer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/route-recognizer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouteRecognizer": () => /* binding */ RouteRecognizer,
/* harmony export */   "ConfigurableRoute": () => /* binding */ ConfigurableRoute,
/* harmony export */   "RecognizedRoute": () => /* binding */ RecognizedRoute,
/* harmony export */   "Endpoint": () => /* binding */ Endpoint
/* harmony export */ });
/* harmony import */ var _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/route-recognizer */ "./node_modules/@aurelia/route-recognizer/dist/esm/index.js");

const RouteRecognizer = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.RouteRecognizer;
const ConfigurableRoute = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.ConfigurableRoute;
const RecognizedRoute = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.RecognizedRoute;
const Endpoint = _aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_0__.Endpoint;
//# sourceMappingURL=route-recognizer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/router-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/router-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouterOptions": () => /* binding */ RouterOptions
/* harmony export */ });
class RouterOptions {
    constructor() {
        this.separators = {
            viewport: '@',
            sibling: '+',
            scope: '/',
            scopeStart: '(',
            scopeEnd: ')',
            noScope: '!',
            parameters: '(',
            parametersEnd: ')',
            parameterSeparator: ',',
            parameterKeySeparator: '=',
            parameter: '&',
            add: '+',
            clear: '-',
            action: '.',
        };
        this.useUrlFragmentHash = true;
        this.useHref = true;
        this.statefulHistoryLength = 0;
        this.useDirectRoutes = true;
        this.useConfiguredRoutes = true;
        this.additiveInstructionDefault = true;
        this.title = {
            // eslint-disable-next-line no-useless-escape
            appTitle: "${componentTitles}\${appTitleSeparator}Aurelia",
            appTitleSeparator: ' | ',
            componentTitleOrder: 'top-down',
            componentTitleSeparator: ' > ',
            useComponentNames: true,
            componentPrefix: 'app-',
        };
        this.navigationSyncStates = ['guardedUnload', 'swapped', 'completed'];
        this.swapStrategy = 'add-first-sequential';
        this.routingHookIntegration = 'integrated';
    }
}
//# sourceMappingURL=router-options.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/router.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/router.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IRouter": () => /* binding */ IRouter,
/* harmony export */   "Router": () => /* binding */ Router
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instruction-resolver.js */ "./node_modules/@aurelia/router/dist/esm/instruction-resolver.js");
/* harmony import */ var _link_handler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./link-handler.js */ "./node_modules/@aurelia/router/dist/esm/link-handler.js");
/* harmony import */ var _nav_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nav.js */ "./node_modules/@aurelia/router/dist/esm/nav.js");
/* harmony import */ var _navigator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./navigator.js */ "./node_modules/@aurelia/router/dist/esm/navigator.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");
/* harmony import */ var _found_route_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./found-route.js */ "./node_modules/@aurelia/router/dist/esm/found-route.js");
/* harmony import */ var _hook_manager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hook-manager.js */ "./node_modules/@aurelia/router/dist/esm/hook-manager.js");
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./scope.js */ "./node_modules/@aurelia/router/dist/esm/scope.js");
/* harmony import */ var _viewport_scope_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/viewport-scope.js");
/* harmony import */ var _browser_viewer_store_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./browser-viewer-store.js */ "./node_modules/@aurelia/router/dist/esm/browser-viewer-store.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _navigation_coordinator_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./navigation-coordinator.js */ "./node_modules/@aurelia/router/dist/esm/navigation-coordinator.js");
/* harmony import */ var _router_options_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./router-options.js */ "./node_modules/@aurelia/router/dist/esm/router-options.js");
/* harmony import */ var _open_promise_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./open-promise.js */ "./node_modules/@aurelia/router/dist/esm/open-promise.js");
/* eslint-disable no-template-curly-in-string */
/* eslint-disable prefer-template */
/* eslint-disable max-lines-per-function */



















// export type SwapStrategy = 'add-first-sequential' | 'add-first-parallel' | 'remove-first-sequential' | 'remove-first-parallel';
// export type RoutingHookIntegration = 'integrated' | 'separate';
// /**
//  * Public API
//  */
// export interface IRouterActivateOptions extends Omit<Partial<IRouterOptions>, 'title'> {
//   title?: string | IRouterTitle;
// }
// /**
//  * Public API
//  */
// export interface IRouterOptions extends INavigatorOptions {
//   separators?: IRouteSeparators;
//   useUrlFragmentHash: boolean;
//   useHref: boolean;
//   statefulHistoryLength: number;
//   useDirectRoutes: boolean;
//   useConfiguredRoutes: boolean;
//   additiveInstructionDefault: boolean;
//   title: ITitleConfiguration;
//   hooks?: IHookDefinition[];
//   reportCallback?(instruction: Navigation): void;
//   navigationSyncStates: NavigationState[];
//   swapStrategy: SwapStrategy;
//   routingHookIntegration: RoutingHookIntegration;
// }
// /**
//  * Public API
//  */
// export interface IRouterTitle extends Partial<ITitleConfiguration> { }
// /**
//  * Public API
//  */
// export interface ITitleConfiguration {
//   appTitle: string;
//   appTitleSeparator: string;
//   componentTitleOrder: 'top-down' | 'bottom-up';
//   componentTitleSeparator: string;
//   useComponentNames: boolean;
//   componentPrefix: string;
//   transformTitle?: (title: string, instruction: string | ViewportInstruction | FoundRoute) => string;
// }
/**
 * Public API
 */
const IRouter = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IRouter', x => x.singleton(Router));
class ClosestViewportCustomElement {
}
/**
 * @internal
 */
class ClosestScope {
}
class Router {
    constructor(
    /**
     * @internal - Shouldn't be used directly.
     */
    container, 
    /**
     * @internal - Shouldn't be used directly.
     */
    navigator, navigation, 
    /**
     * @internal - Shouldn't be used directly.
     */
    linkHandler, 
    /**
     * @internal - Shouldn't be used directly. Probably.
     */
    instructionResolver, 
    /**
     * @internal - Shouldn't be used directly. Probably.
     */
    hookManager, options) {
        this.container = container;
        this.navigator = navigator;
        this.navigation = navigation;
        this.linkHandler = linkHandler;
        this.instructionResolver = instructionResolver;
        this.hookManager = hookManager;
        this.options = options;
        this.rootScope = null;
        /**
         * @internal
         */
        // public hookManager: HookManager;
        /**
         * @internal
         */
        this.navs = {};
        /**
         * Public API
         */
        this.activeComponents = [];
        /**
         * @internal
         */
        this.appendedInstructions = [];
        // /**
        //  * @internal
        //  */
        // public options: IRouterOptions = {
        //   useUrlFragmentHash: true,
        //   useHref: true,
        //   statefulHistoryLength: 0,
        //   useDirectRoutes: true,
        //   useConfiguredRoutes: true,
        //   additiveInstructionDefault: true,
        //   title: {
        //     appTitle: "${componentTitles}\${appTitleSeparator}Aurelia",
        //     appTitleSeparator: ' | ',
        //     componentTitleOrder: 'top-down',
        //     componentTitleSeparator: ' > ',
        //     useComponentNames: true,
        //     componentPrefix: 'app-',
        //   },
        //   swapStrategy: 'add-first-sequential',
        //   routingHookIntegration: 'integrated',
        //   navigationSyncStates: ['guardedUnload', 'swapped', 'completed'],
        // };
        this.processingNavigation = null;
        this.isActive = false;
        this.pendingConnects = new Map();
        this.loadedFirst = false;
        this.lastNavigation = null;
        this.staleChecks = {};
        // TODO: Switch this to use (probably) an event instead
        this.starters = [];
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.linkCallback = (info) => {
            let instruction = info.instruction || '';
            if (typeof instruction === 'string' && instruction.startsWith('#')) {
                instruction = instruction.slice(1);
                // '#' === '/' === '#/'
                if (!instruction.startsWith('/')) {
                    instruction = "/" + instruction;
                }
            }
            // Adds to Navigator's Queue, which makes sure it's serial
            this.load(instruction, { origin: info.anchor }).catch(error => { throw error; });
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.navigatorCallback = (instruction) => {
            // Instructions extracted from queue, one at a time
            this.processNavigations(instruction).catch(error => { throw error; });
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.navigatorSerializeCallback = async (entry, preservedEntries) => {
            let excludeComponents = [];
            for (const preservedEntry of preservedEntries) {
                if (typeof preservedEntry.instruction !== 'string') {
                    excludeComponents.push(...this.instructionResolver.flattenViewportInstructions(preservedEntry.instruction)
                        .filter(instruction => instruction.viewport !== null)
                        .map(instruction => instruction.componentInstance));
                }
                if (typeof preservedEntry.fullStateInstruction !== 'string') {
                    excludeComponents.push(...this.instructionResolver.flattenViewportInstructions(preservedEntry.fullStateInstruction)
                        .filter(instruction => instruction.viewport !== null)
                        .map(instruction => instruction.componentInstance));
                }
            }
            excludeComponents = excludeComponents.filter((component, i, arr) => component !== null && arr.indexOf(component) === i);
            const serialized = { ...entry };
            let instructions = [];
            if (serialized.fullStateInstruction && typeof serialized.fullStateInstruction !== 'string') {
                instructions.push(...serialized.fullStateInstruction);
                serialized.fullStateInstruction = this.instructionResolver.stringifyViewportInstructions(serialized.fullStateInstruction);
            }
            if (serialized.instruction && typeof serialized.instruction !== 'string') {
                instructions.push(...serialized.instruction);
                serialized.instruction = this.instructionResolver.stringifyViewportInstructions(serialized.instruction);
            }
            instructions = instructions.filter((instruction, i, arr) => instruction !== null
                && instruction.componentInstance !== null
                && arr.indexOf(instruction) === i);
            const alreadyDone = [];
            for (const instruction of instructions) {
                await this.freeComponents(instruction, excludeComponents, alreadyDone);
            }
            return serialized;
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.browserNavigatorCallback = (browserNavigationEvent) => {
            const entry = new _navigation_js__WEBPACK_IMPORTED_MODULE_15__.Navigation(browserNavigationEvent.state?.currentEntry);
            entry.instruction = browserNavigationEvent.instruction;
            entry.fromBrowser = true;
            this.navigator.navigate(entry).catch(error => { throw error; });
        };
        /**
         * @internal
         */
        // TODO: use @bound and improve name (eslint-disable is temp)
        this.processNavigations = async (qInstruction) => {
            const instruction = this.processingNavigation = qInstruction;
            // console.log('pendingConnects', [...this.pendingConnects]);
            this.pendingConnects.clear();
            if (this.options.reportCallback) {
                this.options.reportCallback(instruction);
            }
            // let {
            //   fullStateInstruction,
            //   instructionNavigation,
            //   configuredRoute,
            //   configuredRoutePath,
            //   instructions,
            //   clearScopeOwners,
            //   clearViewportScopes,
            // }
            const coordinator = _navigation_coordinator_js__WEBPACK_IMPORTED_MODULE_16__.NavigationCoordinator.create(this, instruction, { syncStates: this.options.navigationSyncStates });
            // const steps = [
            //   () => coordinator.syncState('loaded'),
            //   () => { console.log('SyncState loaded resolved!', steps); },
            //   () => coordinator.syncState('swapped'),
            //   () => { console.log('SyncState swapped resolved!', steps); },
            //   () => coordinator.syncState('left'),
            //   () => { console.log('SyncState left resolved!', steps); },
            // ];
            // run(...steps);
            // const loadedPromise = ;
            // if (loadedPromise !== void 0) {
            //   loadedPromise.then((value: any) => {
            //     console.log('SyncState loaded resolved!', value);
            //   });
            // }
            // console.log(instruction.instruction);
            // console.log(this.rootScope?.scope.toString(true));
            let transformedInstruction = typeof instruction.instruction === 'string' && !instruction.useFullStateInstruction
                ? await this.hookManager.invokeTransformFromUrl(instruction.instruction, this.processingNavigation)
                : instruction.instruction;
            // TODO: Review this
            if (transformedInstruction === '/') {
                transformedInstruction = '';
            }
            instruction.scope = instruction.scope ?? this.rootScope.scope;
            let configuredRoute = instruction.scope.findInstructions(transformedInstruction);
            let configuredRoutePath = null;
            // let configuredRoute = await this.findInstructions(
            //   this.rootScope!.scope,
            //   instruction.instruction,
            //   instruction.scope ?? this.rootScope!.scope,
            //   !instruction.useFullStateInstruction);
            if (instruction.instruction.length > 0 && !configuredRoute.foundConfiguration && !configuredRoute.foundInstructions) {
                // TODO: Do something here!
                this.unknownRoute(configuredRoute.remaining);
            }
            let instructions = configuredRoute.instructions;
            if (configuredRoute.foundConfiguration) {
                instruction.path = instruction.instruction.startsWith('/')
                    ? instruction.instruction.slice(1)
                    : instruction.instruction;
                configuredRoutePath = (configuredRoutePath ?? '') + configuredRoute.matching;
                this.rootScope.path = configuredRoutePath;
            }
            // TODO: Used to have an early exit if no instructions. Restore it?
            if (!this.options.additiveInstructionDefault &&
                instructions.length > 0 &&
                !this.instructionResolver.isAddAllViewportsInstruction(instructions[0]) &&
                !this.instructionResolver.isClearAllViewportsInstruction(instructions[0])) {
                const instr = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction);
                instr.scope = instructions[0].scope;
                instructions.unshift(instr);
            }
            const clearScopeOwners = [];
            let clearViewportScopes = [];
            for (const clearInstruction of instructions.filter(instr => this.instructionResolver.isClearAllViewportsInstruction(instr))) {
                const scope = clearInstruction.scope || this.rootScope.scope;
                const scopes = scope.allScopes().filter(scope => !scope.owner.isEmpty).map(scope => scope.owner);
                // TODO: Tell Fred about the need for reverse
                // scopes.reverse();
                clearScopeOwners.push(...scopes);
                if (scope.viewportScope !== null && scope.viewportScope !== this.rootScope) {
                    clearViewportScopes.push(scope.viewportScope);
                }
            }
            instructions = instructions.filter(instr => !this.instructionResolver.isClearAllViewportsInstruction(instr));
            for (const addInstruction of instructions.filter(instr => this.instructionResolver.isAddAllViewportsInstruction(instr))) {
                addInstruction.setViewport((addInstruction.scope || this.rootScope.scope).viewportScope.name);
                addInstruction.scope = addInstruction.scope.owningScope;
            }
            for (const instr of instructions) {
                instr.topInstruction = true;
            }
            const updatedScopeOwners = [];
            const alreadyFoundInstructions = [];
            // TODO: Take care of cancellations down in subsets/iterations
            let { found: viewportInstructions, remaining: remainingInstructions } = this.findViewports(instructions, alreadyFoundInstructions);
            let guard = 100;
            do {
                if (!guard--) { // Guard against endless loop
                    const err = new Error(remainingInstructions.length + ' remaining instructions after 100 iterations; there is likely an infinite loop.');
                    err['remainingInstructions'] = remainingInstructions;
                    console.log('remainingInstructions', remainingInstructions);
                    throw err;
                }
                const changedScopeOwners = [];
                // TODO: Review whether this await poses a problem (it's currently necessary for new viewports to load)
                const hooked = await this.hookManager.invokeBeforeNavigation(viewportInstructions, instruction);
                if (hooked === false) {
                    coordinator.cancel();
                    return;
                    // return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], instruction);
                }
                else {
                    viewportInstructions = hooked;
                }
                for (const viewportInstruction of viewportInstructions) {
                    const scopeOwner = viewportInstruction.owner;
                    if (scopeOwner !== null) {
                        scopeOwner.path = configuredRoutePath;
                        const action = scopeOwner.setNextContent(viewportInstruction, instruction);
                        if (action !== 'skip') {
                            changedScopeOwners.push(scopeOwner);
                            coordinator.addEntity(scopeOwner);
                        }
                        const dontClear = [scopeOwner];
                        if (action === 'swap') {
                            dontClear.push(...scopeOwner.scope.allScopes(true, true).map(scope => scope.owner));
                        }
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(clearScopeOwners, value => dontClear.includes(value));
                        // arrayRemove(clearScopeOwners, value => value === scopeOwner);
                        if (!this.instructionResolver.isClearViewportInstruction(viewportInstruction)
                            && viewportInstruction.scope !== null
                            && viewportInstruction.scope.parent !== null
                            && viewportInstruction.scope.parent.isViewportScope) {
                            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(clearViewportScopes, value => value === viewportInstruction.scope.parent.viewportScope);
                        }
                    }
                }
                if (!this.isRestrictedNavigation) {
                    coordinator.finalEntity();
                }
                coordinator.run();
                // await coordinator.syncState('routed');
                // // eslint-disable-next-line no-await-in-loop
                // let results = await Promise.all(changedScopeOwners.map((scopeOwner) => scopeOwner.canUnload()));
                // if (results.some(result => result === false)) {
                //   return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], instruction);
                // }
                // // eslint-disable-next-line no-await-in-loop
                // results = await Promise.all(changedScopeOwners.map(async (scopeOwner) => {
                //   const canLoad = await scopeOwner.canLoad();
                //   if (typeof canLoad === 'boolean') {
                //     if (canLoad) {
                //       coordinator.addEntityState(scopeOwner, 'loaded');
                //       return scopeOwner.load();
                //     } else {
                //       return false;
                //     }
                //   }
                //   await this.load(canLoad, { append: true });
                //   await scopeOwner.abortContentChange();
                //   // TODO: Abort content change in the viewports
                //   return true;
                // }));
                // if (results.some(result => result === false)) {
                //   return this.cancelNavigation([...changedScopeOwners, ...updatedScopeOwners], qInstruction);
                // }
                for (const viewport of changedScopeOwners) {
                    if (updatedScopeOwners.every(scopeOwner => scopeOwner !== viewport)) {
                        updatedScopeOwners.push(viewport);
                    }
                }
                // TODO: Fix multi level recursiveness!
                alreadyFoundInstructions.push(...viewportInstructions);
                ({ found: viewportInstructions, remaining: remainingInstructions } = this.findViewports(remainingInstructions, alreadyFoundInstructions));
                // Look for configured child routes (once we've loaded everything so far?)
                if (configuredRoute.hasRemaining &&
                    viewportInstructions.length === 0 &&
                    remainingInstructions.length === 0) {
                    let configured = new _found_route_js__WEBPACK_IMPORTED_MODULE_10__.FoundRoute();
                    const routeScopeOwners = alreadyFoundInstructions
                        .filter(instr => instr.owner !== null && instr.owner.path === configuredRoutePath)
                        .map(instr => instr.owner)
                        .filter((value, index, arr) => arr.indexOf(value) === index);
                    // Need to await new viewports being bound
                    if (!this.isRestrictedNavigation) {
                        // await Promise.resolve();
                        // console.log('Awaiting swapped');
                        await coordinator.syncState('swapped');
                        // console.log('Awaited swapped');
                        // console.log('pendingConnects before find new', [...this.pendingConnects]);
                        // const pending = [...this.pendingConnects.values()].filter(connect => connect.isPending);
                        // if (pending.length > 0) {
                        //   console.log('Beginning await for ', pending.length);
                        //   await Promise.all(pending.map(connect => connect.promise));
                        //   console.log('Await done');
                        // }
                    }
                    for (const owner of routeScopeOwners) {
                        configured = owner.scope.findInstructions(configuredRoute.remaining);
                        // configured = await this.findInstructions(owner.scope, configuredRoute.remaining, owner.scope);
                        if (configured.foundConfiguration) {
                            break;
                        }
                    }
                    if (configured.foundInstructions) {
                        configuredRoute = configured;
                        configuredRoutePath = (configuredRoutePath ?? '') + "/" + configuredRoute.matching;
                    }
                    else {
                        // TODO: Do something here!
                        this.unknownRoute(configured.remaining);
                    }
                    this.appendInstructions(configured.instructions);
                }
                // Don't use defaults when it's a full state navigation
                if (instruction.useFullStateInstruction) {
                    this.appendedInstructions = this.appendedInstructions.filter(instruction => !instruction.default);
                }
                // Process non-defaults first
                let appendedInstructions = this.appendedInstructions.filter(instruction => !instruction.default);
                this.appendedInstructions = this.appendedInstructions.filter(instruction => instruction.default);
                if (appendedInstructions.length === 0) {
                    const index = this.appendedInstructions.findIndex(instruction => instruction.default);
                    if (index >= 0) {
                        appendedInstructions = this.appendedInstructions.splice(index, 1);
                    }
                }
                while (appendedInstructions.length > 0) {
                    const appendedInstruction = appendedInstructions.shift();
                    const existingAlreadyFound = alreadyFoundInstructions.some(instruction => instruction.sameViewport(appendedInstruction));
                    const existingFound = viewportInstructions.find(value => value.sameViewport(appendedInstruction));
                    const existingRemaining = remainingInstructions.find(value => value.sameViewport(appendedInstruction));
                    if (appendedInstruction.default &&
                        (existingAlreadyFound ||
                            (existingFound !== void 0 && !existingFound.default) ||
                            (existingRemaining !== void 0 && !existingRemaining.default))) {
                        continue;
                    }
                    if (existingFound !== void 0) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(viewportInstructions, value => value === existingFound);
                    }
                    if (existingRemaining !== void 0) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.arrayRemove)(remainingInstructions, value => value === existingRemaining);
                    }
                    if (appendedInstruction.viewport !== null) {
                        viewportInstructions.push(appendedInstruction);
                    }
                    else {
                        remainingInstructions.push(appendedInstruction);
                    }
                }
                if (viewportInstructions.length === 0 && remainingInstructions.length === 0) {
                    viewportInstructions = clearScopeOwners.map(owner => {
                        const instruction = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction, owner.isViewport ? owner : void 0);
                        if (owner.isViewportScope) {
                            instruction.viewportScope = owner;
                        }
                        return instruction;
                    });
                    viewportInstructions.push(...clearViewportScopes.map(viewportScope => {
                        const instr = this.createViewportInstruction(this.instructionResolver.clearViewportInstruction);
                        instr.viewportScope = viewportScope;
                        return instr;
                    }));
                    clearViewportScopes = [];
                }
                // await new Promise(res => setTimeout(res, 100));
            } while (viewportInstructions.length > 0 || remainingInstructions.length > 0);
            coordinator.finalEntity();
            // await Promise.all(updatedScopeOwners.map((value) => value.loadContent()));
            await coordinator.syncState('completed');
            coordinator.finalize();
            // updatedScopeOwners.forEach((viewport) => {
            //   viewport.finalizeContentChange();
            // });
            await this.replacePaths(instruction);
            // this.updateNav();
            // Remove history entry if no history viewports updated
            if (instruction.navigation.new && !instruction.navigation.first && !instruction.repeating && updatedScopeOwners.every(viewport => viewport.options.noHistory)) {
                instruction.untracked = true;
            }
            // updatedScopeOwners.forEach((viewport) => {
            //   viewport.finalizeContentChange();
            // });
            this.lastNavigation = this.processingNavigation;
            if (this.lastNavigation?.repeating ?? false) {
                this.lastNavigation.repeating = false;
            }
            this.processingNavigation = null;
            await this.navigator.finalize(instruction);
        };
        // this.hookManager = new HookManager();
    }
    /**
     * Public API
     */
    get isNavigating() {
        return this.processingNavigation !== null;
    }
    get isRestrictedNavigation() {
        const syncStates = this.options.navigationSyncStates;
        return syncStates.includes('guardedLoad') ||
            syncStates.includes('unloaded') ||
            syncStates.includes('loaded') ||
            syncStates.includes('guarded') ||
            syncStates.includes('routed');
    }
    /**
     * @internal
     */
    get statefulHistory() {
        return this.options.statefulHistoryLength !== void 0 && this.options.statefulHistoryLength > 0;
    }
    /**
     * Public API
     */
    start(options) {
        if (this.isActive) {
            throw new Error('Router has already been started');
        }
        this.isActive = true;
        options = options ?? {};
        const titleOptions = {
            ...this.options.title,
            ...(typeof options.title === 'string' ? { appTitle: options.title } : options.title),
        };
        options.title = titleOptions;
        const separatorOptions = {
            ...this.options.separators,
            ...options.separators ?? {},
        };
        options.separators = separatorOptions;
        Object.assign(this.options, options);
        if (this.options.hooks !== void 0) {
            this.addHooks(this.options.hooks);
        }
        this.instructionResolver.start({ separators: this.options.separators });
        this.navigator.start(this, {
            callback: this.navigatorCallback,
            store: this.navigation,
            statefulHistoryLength: this.options.statefulHistoryLength,
            serializeCallback: this.statefulHistory ? this.navigatorSerializeCallback : void 0,
        });
        this.linkHandler.start({ callback: this.linkCallback, useHref: this.options.useHref });
        this.navigation.start({
            callback: this.browserNavigatorCallback,
            useUrlFragmentHash: this.options.useUrlFragmentHash
        });
        this.ensureRootScope();
        // TODO: Switch this to use (probably) an event instead
        for (const starter of this.starters) {
            starter();
        }
    }
    /**
     * Public API
     */
    async loadUrl() {
        const entry = new _navigation_js__WEBPACK_IMPORTED_MODULE_15__.Navigation({
            ...this.navigation.viewerState,
            ...{
                fullStateInstruction: '',
                replacing: true,
                fromBrowser: false,
            }
        });
        const result = this.navigator.navigate(entry);
        this.loadedFirst = true;
        return result;
    }
    /**
     * Public API
     */
    stop() {
        if (!this.isActive) {
            throw new Error('Router has not been started');
        }
        this.linkHandler.stop();
        this.navigator.stop();
        this.navigation.stop();
    }
    /**
     * @internal
     */
    findScope(origin) {
        // this.ensureRootScope();
        if (origin === void 0 || origin === null) {
            return this.rootScope.scope;
        }
        if (origin instanceof _scope_js__WEBPACK_IMPORTED_MODULE_12__.Scope || origin instanceof _viewport_js__WEBPACK_IMPORTED_MODULE_8__.Viewport) {
            return origin.scope;
        }
        return this.getClosestScope(origin) || this.rootScope.scope;
    }
    /**
     * @internal
     */
    findParentScope(container) {
        if (container === null) {
            return this.rootScope.scope;
        }
        // Already (prematurely) set on this view model so get it from container's parent instead
        if (container.has(ClosestScope, false)) {
            container = container.parent;
            if (container === null) {
                return this.rootScope.scope;
            }
        }
        if (container.has(ClosestScope, true)) {
            return container.get(ClosestScope);
        }
        return this.rootScope.scope;
    }
    /**
     * Public API - Get viewport by name
     */
    getViewport(name) {
        return this.allViewports().find(viewport => viewport.name === name) || null;
    }
    /**
     * Public API (not yet implemented)
     */
    addViewport(...args) {
        throw new Error('Not implemented');
    }
    /**
     * Public API (not yet implemented)
     */
    findViewportScope(...args) {
        throw new Error('Not implemented');
    }
    /**
     * Public API (not yet implemented)
     */
    addViewportScope(...args) {
        throw new Error('Not implemented');
    }
    /**
     * @internal - Called from the viewport scope custom element in created()
     */
    setClosestScope(viewModelOrContainer, scope) {
        const container = this.getContainer(viewModelOrContainer);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(ClosestScope, scope).register(container);
    }
    /**
     * @internal
     */
    getClosestScope(viewModelOrElement) {
        const container = 'resourceResolvers' in viewModelOrElement
            ? viewModelOrElement
            : this.getClosestContainer(viewModelOrElement);
        if (container === null) {
            return null;
        }
        if (!container.has(ClosestScope, true)) {
            return null;
        }
        return container.get(ClosestScope) || null;
    }
    /**
     * @internal
     */
    unsetClosestScope(viewModelOrContainer) {
        const container = this.getContainer(viewModelOrContainer);
        // TODO: Get an 'unregister' on container
        container.resolvers.delete(ClosestScope);
    }
    /**
     * @internal - Called from the viewport custom element
     */
    connectViewport(viewport, connectedCE, name, options) {
        const parentScope = this.findParentScope(connectedCE.container);
        // console.log('Viewport parentScope', parentScope.toString(), (connectedCE as any).getClosestCustomElement());
        const parentViewportScope = (connectedCE.parentViewport?.viewport ?? this.rootScope).scope;
        if (parentScope !== parentViewportScope) {
            console.error('Viewport parentScope !== parentViewportScope', parentScope.toString(true), parentViewportScope.toString(true), connectedCE.getClosestCustomElement());
        }
        if (viewport === null) {
            viewport = parentScope.addViewport(name, connectedCE, options);
            this.setClosestScope(connectedCE.container, viewport.connectedScope);
            if (!this.isRestrictedNavigation) {
                this.pendingConnects.set(connectedCE, new _open_promise_js__WEBPACK_IMPORTED_MODULE_18__.OpenPromise());
            }
        }
        else {
            this.pendingConnects.get(connectedCE)?.resolve();
        }
        return viewport;
    }
    /**
     * @internal - Called from the viewport custom element
     */
    disconnectViewport(viewport, connectedCE) {
        if (!viewport.connectedScope.parent.removeViewport(viewport, connectedCE)) {
            throw new Error("Failed to remove viewport: " + viewport.name);
        }
        this.unsetClosestScope(connectedCE.container);
    }
    /**
     * @internal - Called from the viewport scope custom element
     */
    connectViewportScope(viewportScope, connectedCE, name, options) {
        const parentScope = this.findParentScope(connectedCE.container);
        // console.log('ViewportScope parentScope', parentScope.toString(), (connectedCE as any).getClosestCustomElement());
        if (viewportScope === null) {
            viewportScope = parentScope.addViewportScope(name, connectedCE, options);
            this.setClosestScope(connectedCE.container, viewportScope.connectedScope);
        }
        return viewportScope;
    }
    /**
     * @internal - Called from the viewport scope custom element
     */
    disconnectViewportScope(viewportScope, connectedCE) {
        if (!viewportScope.connectedScope.parent.removeViewportScope(viewportScope)) {
            throw new Error("Failed to remove viewport scope: " + viewportScope.path);
        }
        this.unsetClosestScope(connectedCE.container);
    }
    allViewports(includeDisabled = false, includeReplaced = false) {
        // this.ensureRootScope();
        return this.rootScope.scope.allViewports(includeDisabled, includeReplaced);
    }
    /**
     * Public API - THE navigation API
     */
    async goto(instructions, options) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.deprecationWarning)('"goto" method', '"load" method');
        return this.load(instructions, options);
    }
    async load(instructions, options) {
        options = options || {};
        // TODO: Review query extraction; different pos for path and fragment!
        if (typeof instructions === 'string' && !options.query) {
            const [path, search] = instructions.split('?');
            instructions = path;
            options.query = search;
        }
        const toOptions = {};
        if (options.origin) {
            toOptions.context = options.origin;
        }
        let scope = null;
        ({ instructions, scope } = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_6__.NavigationInstructionResolver.createViewportInstructions(this, instructions, toOptions));
        if (options.append && this.processingNavigation) {
            instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_6__.NavigationInstructionResolver.toViewportInstructions(this, instructions);
            this.appendInstructions(instructions, scope);
            // Can't return current navigation promise since it can lead to deadlock in load
            return Promise.resolve();
        }
        const entry = new _navigation_js__WEBPACK_IMPORTED_MODULE_15__.Navigation({
            instruction: instructions,
            fullStateInstruction: '',
            scope: scope,
            title: options.title,
            data: options.data,
            query: options.query,
            replacing: options.replace,
            repeating: options.append,
            fromBrowser: false,
            origin: options.origin,
        });
        return this.navigator.navigate(entry);
    }
    /**
     * Public API
     */
    refresh() {
        return this.navigator.refresh();
    }
    /**
     * Public API
     */
    back() {
        return this.navigator.go(-1);
    }
    /**
     * Public API
     */
    forward() {
        return this.navigator.go(1);
    }
    /**
     * Public API
     */
    go(delta) {
        return this.navigator.go(delta);
    }
    /**
     * Public API
     */
    checkActive(instructions) {
        for (const instruction of instructions) {
            const scopeInstructions = this.instructionResolver.matchScope(this.activeComponents, instruction.scope);
            const matching = scopeInstructions.filter(instr => instr.sameComponent(instruction, true));
            if (matching.length === 0) {
                return false;
            }
            if (Array.isArray(instruction.nextScopeInstructions)
                && instruction.nextScopeInstructions.length > 0
                && this.instructionResolver.matchChildren(instruction.nextScopeInstructions, matching.map(instr => Array.isArray(instr.nextScopeInstructions) ? instr.nextScopeInstructions : []).flat()) === false) {
                return false;
            }
        }
        return true;
    }
    /**
     * Public API
     */
    setNav(name, routes, classes) {
        const nav = this.findNav(name);
        if (nav !== void 0 && nav !== null) {
            nav.routes = [];
        }
        this.addNav(name, routes, classes);
    }
    /**
     * Public API
     */
    addNav(name, routes, classes) {
        let nav = this.navs[name];
        if (nav === void 0 || nav === null) {
            nav = this.navs[name] = new _nav_js__WEBPACK_IMPORTED_MODULE_4__.Nav(this, name, [], classes);
        }
        nav.addRoutes(routes);
        nav.update();
    }
    /**
     * Public API
     */
    updateNav(name) {
        const navs = name
            ? [name]
            : Object.keys(this.navs);
        for (const nav of navs) {
            if (this.navs[nav] !== void 0 && this.navs[nav] !== null) {
                this.navs[nav].update();
            }
        }
    }
    /**
     * Public API
     */
    findNav(name) {
        return this.navs[name];
    }
    /**
     * Public API
     */
    addRoutes(routes, context) {
        // TODO: This should add to the context instead
        // TODO: Add routes without context to rootScope content (which needs to be created)?
        return [];
        // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;
        // return viewport.addRoutes(routes);
    }
    /**
     * Public API
     */
    removeRoutes(routes, context) {
        // TODO: This should remove from the context instead
        // const viewport = (context !== void 0 ? this.closestViewport(context) : this.rootScope) || this.rootScope as Viewport;
        // return viewport.removeRoutes(routes);
    }
    /**
     * Public API
     */
    addHooks(hooks) {
        return hooks.map(hook => this.addHook(hook.hook, hook.options));
    }
    addHook(hook, options) {
        return this.hookManager.addHook(hook, options);
    }
    /**
     * Public API
     */
    removeHooks(hooks) {
        return;
    }
    /**
     * Public API - The right way to create ViewportInstructions
     */
    createViewportInstruction(component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
        return this.instructionResolver.createViewportInstruction(component, viewport, parameters, ownsScope, nextScopeInstructions);
    }
    hasSiblingInstructions(instructions) {
        if (instructions === null) {
            return false;
        }
        if (instructions.length > 1) {
            return true;
        }
        return instructions.some(instruction => this.hasSiblingInstructions(instruction.nextScopeInstructions));
    }
    appendInstructions(instructions, scope = null) {
        if (scope === null) {
            scope = this.rootScope.scope;
        }
        for (const instruction of instructions) {
            if (instruction.scope === null) {
                instruction.scope = scope;
            }
        }
        this.appendedInstructions.push(...instructions);
    }
    checkStale(name, instructions) {
        const staleCheck = this.staleChecks[name];
        if (staleCheck === void 0) {
            this.staleChecks[name] = instructions.slice();
            return false;
        }
        if (staleCheck.length !== instructions.length) {
            this.staleChecks[name] = instructions.slice();
            return false;
        }
        for (let i = 0, ii = instructions.length; i < ii; i++) {
            if (staleCheck[i] !== instructions[i]) {
                this.staleChecks[name] = instructions.slice();
                return false;
            }
        }
        return true;
    }
    unknownRoute(route) {
        if (typeof route !== 'string' || route.length === 0) {
            return;
        }
        if (this.options.useConfiguredRoutes && this.options.useDirectRoutes) {
            // TODO: Add missing/unknown route handling
            throw new Error("No matching configured route or component found for '" + route + "'");
        }
        else if (this.options.useConfiguredRoutes) {
            // TODO: Add missing/unknown route handling
            throw new Error("No matching configured route found for '" + route + "'");
        }
        else {
            // TODO: Add missing/unknown route handling
            throw new Error("No matching route/component found for '" + route + "'");
        }
    }
    findViewports(instructions, alreadyFound, withoutViewports = false) {
        const found = [];
        const remaining = [];
        while (instructions.length) {
            if (instructions[0].scope === null) {
                instructions[0].scope = this.rootScope.scope;
            }
            const scope = instructions[0].scope;
            const { foundViewports, remainingInstructions } = scope.findViewports(instructions.filter(instruction => instruction.scope === scope), alreadyFound, withoutViewports);
            found.push(...foundViewports);
            remaining.push(...remainingInstructions);
            instructions = instructions.filter(instruction => instruction.scope !== scope);
        }
        return { found: found.slice(), remaining };
    }
    async cancelNavigation(updatedScopeOwners, qInstruction) {
        // TODO: Take care of disabling viewports when cancelling and stateful!
        updatedScopeOwners.forEach((viewport) => {
            const abort = viewport.abortContentChange();
            if (abort instanceof Promise) {
                abort.catch(error => { throw error; });
            }
        });
        await this.navigator.cancel(qInstruction);
        this.processingNavigation = null;
        qInstruction.resolve();
    }
    ensureRootScope() {
        if (!this.rootScope) {
            const root = this.container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAppRoot);
            // root.config.component shouldn't be used in the end. Metadata will probably eliminate it
            this.rootScope = new _viewport_scope_js__WEBPACK_IMPORTED_MODULE_13__.ViewportScope('rootScope', this, root.controller.viewModel, null, true, root.config.component);
        }
        return this.rootScope;
    }
    async replacePaths(instruction) {
        this.rootScope.scope.reparentViewportInstructions();
        let instructions = this.rootScope.scope.hoistedChildren
            .filter(scope => scope.viewportInstruction !== null && !scope.viewportInstruction.isEmpty())
            .map(scope => scope.viewportInstruction);
        instructions = this.instructionResolver.cloneViewportInstructions(instructions, true);
        // The following makes sure right viewport/viewport scopes are set and update
        // whether viewport name is necessary or not
        const alreadyFound = [];
        let { found, remaining } = this.findViewports(instructions, alreadyFound, true);
        let guard = 100;
        while (remaining.length > 0) {
            // Guard against endless loop
            if (guard-- === 0) {
                throw new Error('Failed to find viewport when updating viewer paths.');
            }
            alreadyFound.push(...found);
            ({ found, remaining } = this.findViewports(remaining, alreadyFound, true));
        }
        this.activeComponents = instructions;
        this.activeRoute = instruction.route;
        // First invoke with viewport instructions (should it perhaps get full state?)
        let state = await this.hookManager.invokeTransformToUrl(instructions, instruction);
        if (typeof state !== 'string') {
            // Convert to string if necessary
            state = this.instructionResolver.stringifyViewportInstructions(state, false, true);
        }
        // Invoke again with string
        state = await this.hookManager.invokeTransformToUrl(state, instruction);
        const query = (instruction.query && instruction.query.length ? "?" + instruction.query : '');
        // if (instruction.path === void 0 || instruction.path.length === 0 || instruction.path === '/') {
        instruction.path = state + query;
        // }
        const fullViewportStates = [this.createViewportInstruction(this.instructionResolver.clearViewportInstruction)];
        fullViewportStates.push(...this.instructionResolver.cloneViewportInstructions(instructions, this.statefulHistory));
        instruction.fullStateInstruction = fullViewportStates;
        if ((instruction.title ?? null) === null) {
            const title = await this.getTitle(instructions, instruction);
            if (title !== null) {
                instruction.title = title;
            }
        }
        return Promise.resolve();
    }
    async getTitle(instructions, instruction) {
        // First invoke with viewport instructions
        let title = await this.hookManager.invokeSetTitle(instructions, instruction);
        if (typeof title !== 'string') {
            // Hook didn't return a title, so run title logic
            const componentTitles = this.stringifyTitles(title, instruction);
            title = this.options.title.appTitle;
            title = title.replace("${componentTitles}", componentTitles);
            title = title.replace("${appTitleSeparator}", componentTitles !== ''
                ? this.options.title.appTitleSeparator
                : '');
        }
        // Invoke again with complete string
        title = await this.hookManager.invokeSetTitle(title, instruction);
        return title;
    }
    stringifyTitles(instructions, navigationInstruction) {
        const titles = instructions
            .map(instruction => this.stringifyTitle(instruction, navigationInstruction))
            .filter(instruction => (instruction?.length ?? 0) > 0);
        return titles.join(' + ');
    }
    stringifyTitle(instruction, navigationInstruction) {
        if (typeof instruction === 'string') {
            return this.resolveTitle(instruction, navigationInstruction);
        }
        const route = instruction.route ?? null;
        const nextInstructions = instruction.nextScopeInstructions;
        let stringified = '';
        // It's a configured route
        if (route !== null) {
            // Already added as part of a configuration, skip to next scope
            if (route === '') {
                return Array.isArray(nextInstructions)
                    ? this.stringifyTitles(nextInstructions, navigationInstruction)
                    : '';
            }
            else {
                stringified += this.resolveTitle(route, navigationInstruction);
            }
        }
        else {
            stringified += this.resolveTitle(instruction, navigationInstruction);
        }
        if (Array.isArray(nextInstructions) && nextInstructions.length > 0) {
            let nextStringified = this.stringifyTitles(nextInstructions, navigationInstruction);
            if (nextStringified.length > 0) {
                if (nextInstructions.length !== 1) { // TODO: This should really also check that the instructions have value
                    nextStringified = "[ " + nextStringified + " ]";
                }
                if (stringified.length > 0) {
                    stringified = this.options.title.componentTitleOrder === 'top-down'
                        ? stringified + this.options.title.componentTitleSeparator + nextStringified
                        : nextStringified + this.options.title.componentTitleSeparator + stringified;
                }
                else {
                    stringified = nextStringified;
                }
            }
        }
        return stringified;
    }
    resolveTitle(instruction, navigationInstruction) {
        let title = '';
        if (typeof instruction === 'string') {
            title = instruction;
        }
        else if (instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_9__.ViewportInstruction) {
            return instruction.viewport.getTitle(navigationInstruction);
        }
        else if (instruction instanceof _found_route_js__WEBPACK_IMPORTED_MODULE_10__.FoundRoute) {
            const routeTitle = instruction.match?.title;
            if (routeTitle !== void 0) {
                if (typeof routeTitle === 'string') {
                    title = routeTitle;
                }
                else {
                    title = routeTitle.call(instruction, instruction, navigationInstruction);
                }
            }
        }
        if (this.options.title.transformTitle !== void 0) {
            title = this.options.title.transformTitle.call(this, title, instruction);
        }
        return title;
    }
    async freeComponents(instruction, excludeComponents, alreadyDone) {
        const component = instruction.componentInstance;
        const viewport = instruction.viewport;
        if (component === null || viewport === null || alreadyDone.some(done => done === component)) {
            return;
        }
        if (!excludeComponents.some(exclude => exclude === component)) {
            await viewport.freeContent(component);
            alreadyDone.push(component);
            return;
        }
        if (instruction.nextScopeInstructions !== null) {
            for (const nextInstruction of instruction.nextScopeInstructions) {
                await this.freeComponents(nextInstruction, excludeComponents, alreadyDone);
            }
        }
    }
    getClosestContainer(viewModelOrElement) {
        if ('context' in viewModelOrElement) {
            return viewModelOrElement.context;
        }
        if ('$controller' in viewModelOrElement) {
            return viewModelOrElement.$controller.context;
        }
        const controller = this.CustomElementFor(viewModelOrElement);
        if (controller === void 0) {
            return null;
        }
        return controller.context;
    }
    getContainer(viewModelOrContainer) {
        if ('resourceResolvers' in viewModelOrContainer) {
            return viewModelOrContainer;
        }
        if ((0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.isRenderContext)(viewModelOrContainer)) {
            return viewModelOrContainer.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer);
        }
        if ('$controller' in viewModelOrContainer) {
            return viewModelOrContainer.$controller.context.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer);
        }
        return null;
    }
    // TODO: This is probably wrong since it caused test fails when in CustomElement.for
    // Fred probably knows and will need to look at it
    // This can most likely also be changed so that the node traversal isn't necessary
    CustomElementFor(node) {
        let cur = node;
        while (cur !== null) {
            const nodeResourceName = cur.nodeName.toLowerCase();
            const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.name + ":" + nodeResourceName, cur)
                || _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.name, cur);
            if (controller !== void 0) {
                return controller;
            }
            cur = (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.getEffectiveParentNode)(cur);
        }
        return (void 0);
    }
}
Router.inject = [_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer, _navigator_js__WEBPACK_IMPORTED_MODULE_5__.Navigator, _browser_viewer_store_js__WEBPACK_IMPORTED_MODULE_14__.BrowserViewerStore, _link_handler_js__WEBPACK_IMPORTED_MODULE_3__.LinkHandler, _instruction_resolver_js__WEBPACK_IMPORTED_MODULE_2__.InstructionResolver, _hook_manager_js__WEBPACK_IMPORTED_MODULE_11__.HookManager, _router_options_js__WEBPACK_IMPORTED_MODULE_17__.RouterOptions];
//# sourceMappingURL=router.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/runner.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/runner.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Runner": () => /* binding */ Runner
/* harmony export */ });
/**
 * Class for running a sequence of steps with values,
 * functions and promises. Stays sync if possible.
 *
 * Usage:
 *
 * ```ts
 * const promise = Runner.run(
 *   'one',
 *   prev => `${previous}, two`,
 *   prev => createPromise(prev), // creates a promise that resolves to `${prev}, three`
 * );
 *
 * // Run can be cancelled with Runner.cancel(promise);
 *
 * const stepsRunner = Runner.runner(promise);
 * const result = await promise;
 * if (stepsRunner?.isResolved) { // Make sure promise wasn't rejected
 *   // result === 'one, two, three'
 * }
 * ```
 */
class Runner {
    constructor() {
        this.isDone = false;
        this.isCancelled = false;
        this.isResolved = false;
        this.isRejected = false;
        this.isAsync = false;
    }
    get stop() {
        return this.isCancelled || this.isRejected;
    }
    /**
     * Runs a set of steps and retuns the last value
     *
     * Steps are processed in sequence and can be either a
     *
     * - value - which is then propagated as input into the next step
     * - function - which is executed in time. The result is replacing the step which is then reprocessed
     * - promise - which is awaited
     *
     * ```ts
     * result = await Runner.run(
     *   'one',
     *   prev => `${previous}, two`,
     *   prev => createPromise(prev), // creates a promise that resolves to `${prev}, three`
     * ); // result === 'one, two, three'
     * ```
     *
     */
    static run(...steps) {
        // debugger; // FIX ARRAY CHECK!
        const $runner = new Runner();
        const value = Runner.$run($runner, ...steps);
        if (value instanceof Promise) {
            this.runners.set(value, $runner);
            value.then(() => {
                $runner.isDone = true;
                if ($runner.isAsync && !$runner.stop) {
                    $runner.isResolved = true;
                }
                this.runners.delete(value);
                // console.log('$runner done', $runner, this.runners);
            }).catch(err => { throw err; });
        }
        return value;
    }
    /**
     * Gets the runner for a promise returned by Runner.run
     *
     * The runner can be used to check status and outcome of
     * the run as well as cancel it
     *
     */
    static runner(value) {
        if (value instanceof Promise) {
            return Runner.runners.get(value);
        }
    }
    /**
     * Cancels the runner for a promise returned by Runner.run
     *
     * Once a runner has been cancelled, it's no longer possible
     * to retrieve it from the promise
     *
     */
    static cancel(value) {
        const $runner = Runner.runner(value);
        if ($runner !== void 0) {
            $runner.cancel();
        }
    }
    static runAll(steps) {
        const $runner = new Runner();
        const values = Runner.$runAll($runner, steps);
        if ($runner.isAsync) {
            const promise = Promise.all(values);
            this.runners.set(promise, $runner);
            promise.then(() => {
                $runner.isDone = true;
                if ($runner.isAsync && !$runner.stop) {
                    $runner.isResolved = true;
                }
                this.runners.delete(promise);
                // console.log('$runner done', $runner, this.runners);
            }).catch(err => { throw err; });
            return promise;
        }
        return values;
    }
    static runOne(step) {
        let value;
        // Iteratively resolve Functions (until value or Promise)
        while (step instanceof Function) {
            step = step(value);
            if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                value = step;
            }
        }
        // In case there wasn't a Function before the value
        if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
            value = step;
        }
        // If we've got a Promise, run the remaining
        if (step instanceof Promise) {
            return step.then((resolvedValue) => {
                return Runner.runOne(resolvedValue);
            }).catch((err) => { throw err; });
        }
        return value;
    }
    cancel() {
        this.isCancelled = true;
    }
    static $run($runner, ...steps) {
        let step;
        while (steps.length > 0 && !$runner.stop) {
            step = steps.shift();
            // Iteratively resolve Functions (until value or Promise)
            while (step instanceof Function && !$runner.stop) {
                step = step($runner.value);
                if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                    $runner.value = step;
                }
            }
            // In case there wasn't a Function before the value
            if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                $runner.value = step;
            }
            // Run steps until done or we get a Promise
            if (step instanceof Promise) {
                break;
            }
        }
        // If we've got a Promise, run the remaining
        if (step instanceof Promise && !$runner.stop) {
            $runner.isAsync = true;
            return step.then((resolvedValue) => {
                return Runner.$run($runner, resolvedValue, ...steps);
            }).catch((err) => {
                $runner.isRejected = true;
                throw err;
            });
        }
        return $runner.value;
    }
    static $runAll($runner, steps) {
        const results = new Array(steps.length);
        steps.forEach((step, index) => {
            // Iteratively resolve Functions (until value or Promise)
            while (step instanceof Function) {
                step = step(results[index]);
                if (!(step instanceof Function) && !(step instanceof Promise)) { // === isValue(step)
                    results[index] = step;
                }
            }
            // In case there wasn't a Function before the value
            if (!(step instanceof Function)) { // === isValue(step)
                results[index] = step;
            }
            // If we've got a Promise, run the remaining
            if (step instanceof Promise) {
                $runner.isAsync = true;
            }
        });
        return results;
    }
}
Runner.runners = new WeakMap();
//# sourceMappingURL=runner.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/scope.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/scope.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scope": () => /* binding */ Scope
/* harmony export */ });
/* harmony import */ var _viewport_scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewport-scope.js */ "./node_modules/@aurelia/router/dist/esm/viewport-scope.js");
/* harmony import */ var _found_route_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./found-route.js */ "./node_modules/@aurelia/router/dist/esm/found-route.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _collection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./collection.js */ "./node_modules/@aurelia/router/dist/esm/collection.js");
/* harmony import */ var _route_recognizer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./route-recognizer.js */ "./node_modules/@aurelia/router/dist/esm/route-recognizer.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");








/**
 * @internal - Shouldn't be used directly
 */
class Scope {
    constructor(router, hasScope, owningScope, viewport = null, viewportScope = null, rootComponentType = null) {
        this.router = router;
        this.hasScope = hasScope;
        this.owningScope = owningScope;
        this.viewport = viewport;
        this.viewportScope = viewportScope;
        this.rootComponentType = rootComponentType;
        this.id = '.';
        this.parent = null;
        this.children = [];
        this.replacedChildren = [];
        this.path = null;
        this.enabled = true;
        // Support collection feature in viewport scopes
        this.childCollections = {};
        this.owningScope = owningScope ?? this;
        this.scope = this.hasScope ? this : this.owningScope.scope;
        // console.log('Created scope', this.toString());
    }
    toString(recurse = false) {
        return `${this.owningScope !== this ? this.owningScope.toString() : ''}/${this.owner.toString()}` +
            // eslint-disable-next-line prefer-template
            `${recurse ? `\n` + this.children.map(child => child.toString(true)).join('') : ''}`;
    }
    get isViewport() {
        return this.viewport !== null;
    }
    get isViewportScope() {
        return this.viewportScope !== null;
    }
    get passThroughScope() {
        return this.isViewportScope && this.viewportScope.passThroughScope;
    }
    get owner() {
        if (this.isViewport) {
            return this.viewport;
        }
        if (this.isViewportScope) {
            return this.viewportScope;
        }
        return null;
    }
    get enabledChildren() {
        return this.children.filter(scope => scope.enabled);
    }
    get hoistedChildren() {
        const scopes = this.enabledChildren;
        while (scopes.some(scope => scope.passThroughScope)) {
            for (const scope of scopes.slice()) {
                if (scope.passThroughScope) {
                    const index = scopes.indexOf(scope);
                    scopes.splice(index, 1, ...scope.enabledChildren);
                }
            }
        }
        return scopes;
    }
    get enabledViewports() {
        return this.children
            .filter(scope => scope.isViewport && scope.enabled)
            .map(scope => scope.viewport);
    }
    get viewportInstruction() {
        if (this.isViewportScope) {
            return this.viewportScope.content;
        }
        if (this.isViewport) {
            return this.viewport.content.content;
        }
        return null;
    }
    get parentNextContentAction() {
        if (this.parent === null) {
            return '';
        }
        const parentAction = this.parent.owner.nextContentAction;
        if (parentAction === 'swap' || parentAction === 'skip') {
            return parentAction;
        }
        return this.parent.parentNextContentAction;
    }
    getEnabledViewports(viewportScopes) {
        return viewportScopes
            .filter(scope => !scope.isViewportScope)
            .map(scope => scope.viewport)
            .reduce((viewports, viewport) => {
            viewports[viewport.name] = viewport;
            return viewports;
        }, {});
    }
    getOwnedViewports(includeDisabled = false) {
        return this.allViewports(includeDisabled).filter(viewport => viewport.owningScope === this);
    }
    getOwnedScopes(includeDisabled = false) {
        const scopes = this.allScopes(includeDisabled).filter(scope => scope.owningScope === this);
        // Hoist children to pass through scopes
        for (const scope of scopes.slice()) {
            if (scope.passThroughScope) {
                const index = scopes.indexOf(scope);
                scopes.splice(index, 1, ...scope.getOwnedScopes());
            }
        }
        return scopes;
    }
    findInstructions(instruction) {
        let route = new _found_route_js__WEBPACK_IMPORTED_MODULE_1__.FoundRoute();
        if (typeof instruction === 'string') {
            const instructions = this.router.instructionResolver.parseViewportInstructions(instruction);
            if (this.router.options.useConfiguredRoutes && !this.router.hasSiblingInstructions(instructions)) {
                const foundRoute = this.findMatchingRoute(instruction);
                if (foundRoute?.foundConfiguration ?? false) {
                    route = foundRoute;
                }
                else {
                    if (this.router.options.useDirectRoutes) {
                        route.instructions = instructions;
                        if (route.instructions.length > 0) {
                            const nextInstructions = route.instructions[0].nextScopeInstructions ?? [];
                            route.remaining = this.router.instructionResolver.stringifyViewportInstructions(nextInstructions);
                            // TODO: Verify that it's okay to leave this in
                            route.instructions[0].nextScopeInstructions = null;
                        }
                    }
                }
            }
            else if (this.router.options.useDirectRoutes) {
                route.instructions = instructions;
            }
        }
        else {
            route.instructions = instruction;
        }
        for (const instr of route.instructions) {
            if (instr.scope === null) {
                instr.scope = this;
            }
        }
        return route;
    }
    // Note: This can't change state other than the instructions!
    findViewports(instructions, alreadyFound, disregardViewports = false) {
        const foundViewports = [];
        let remainingInstructions = [];
        const ownedScopes = this.getOwnedScopes();
        // Get a shallow copy of all available manual viewport scopes
        const viewportScopes = ownedScopes.filter(scope => scope.isViewportScope).map(scope => scope.viewportScope);
        const availableViewportScopes = viewportScopes.filter(viewportScope => alreadyFound.every(found => found.viewportScope !== viewportScope));
        // Get a shallow copy of all available viewports
        const availableViewports = { ...this.getEnabledViewports(ownedScopes) };
        for (const instruction of alreadyFound.filter(found => found.scope === this)) {
            availableViewports[instruction.viewportName] = null;
        }
        const viewportInstructions = new _collection_js__WEBPACK_IMPORTED_MODULE_5__.Collection(...instructions.slice());
        let instruction = null;
        // The viewport scope is already known
        while ((instruction = viewportInstructions.next()) !== null) {
            if (instruction.viewportScope !== null && !this.router.instructionResolver.isAddViewportInstruction(instruction)) {
                remainingInstructions.push(...this.foundViewportScope(instruction, instruction.viewportScope));
                foundViewports.push(instruction);
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.arrayRemove)(availableViewportScopes, available => available === instruction.viewportScope);
                viewportInstructions.removeCurrent();
            }
        }
        // The viewport is already known
        if (!disregardViewports) {
            while ((instruction = viewportInstructions.next()) !== null) {
                if (instruction.viewport !== null) {
                    remainingInstructions.push(...this.foundViewport(instruction, instruction.viewport, disregardViewports));
                    foundViewports.push(instruction);
                    availableViewports[instruction.viewport.name] = null;
                    viewportInstructions.removeCurrent();
                }
            }
        }
        // Viewport scopes have priority
        while ((instruction = viewportInstructions.next()) !== null) {
            for (let viewportScope of viewportScopes) {
                if (viewportScope.acceptSegment(instruction.componentName)) {
                    if (Array.isArray(viewportScope.source)) {
                        // console.log('available', viewportScope.available, source);
                        let available = availableViewportScopes.find(available => available.name === viewportScope.name);
                        if (available === void 0 || this.router.instructionResolver.isAddViewportInstruction(instruction)) {
                            const item = viewportScope.addSourceItem();
                            available = this.getOwnedScopes()
                                .filter(scope => scope.isViewportScope)
                                .map(scope => scope.viewportScope)
                                .find(viewportScope => viewportScope.sourceItem === item);
                        }
                        viewportScope = available;
                    }
                    remainingInstructions.push(...this.foundViewportScope(instruction, viewportScope));
                    foundViewports.push(instruction);
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.arrayRemove)(availableViewportScopes, available => available === instruction.viewportScope);
                    viewportInstructions.removeCurrent();
                    break;
                }
            }
        }
        // Configured viewport is ruling
        while ((instruction = viewportInstructions.next()) !== null) {
            instruction.needsViewportDescribed = true;
            for (const name in availableViewports) {
                const viewport = availableViewports[name];
                // TODO: Also check if (resolved) component wants a specific viewport
                if (viewport?.wantComponent(instruction.componentName)) {
                    const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
                    foundViewports.push(instruction);
                    remainingInstructions.push(...remaining);
                    availableViewports[name] = null;
                    viewportInstructions.removeCurrent();
                    break;
                }
            }
        }
        // Next in line is specified viewport (but not if we're disregarding viewports)
        if (!disregardViewports) {
            while ((instruction = viewportInstructions.next()) !== null) {
                const name = instruction.viewportName;
                if (!name || !name.length) {
                    continue;
                }
                const newScope = instruction.ownsScope;
                if (!this.getEnabledViewports(ownedScopes)[name]) {
                    continue;
                    // TODO: No longer pre-creating viewports. Evaluate!
                    this.addViewport(name, null, { scope: newScope, forceDescription: true });
                    availableViewports[name] = this.getEnabledViewports(ownedScopes)[name];
                }
                const viewport = availableViewports[name];
                if (viewport?.acceptComponent(instruction.componentName)) {
                    const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
                    foundViewports.push(instruction);
                    remainingInstructions.push(...remaining);
                    availableViewports[name] = null;
                    viewportInstructions.removeCurrent();
                }
            }
        }
        // Finally, only one accepting viewport left?
        while ((instruction = viewportInstructions.next()) !== null) {
            const remainingViewports = [];
            for (const name in availableViewports) {
                const viewport = availableViewports[name];
                if (viewport?.acceptComponent(instruction.componentName)) {
                    remainingViewports.push(viewport);
                }
            }
            if (remainingViewports.length === 1) {
                const viewport = remainingViewports.shift();
                const remaining = this.foundViewport(instruction, viewport, disregardViewports, true);
                foundViewports.push(instruction);
                remainingInstructions.push(...remaining);
                availableViewports[viewport.name] = null;
                viewportInstructions.removeCurrent();
            }
        }
        // If we're ignoring viewports, we now match them anyway
        if (disregardViewports) {
            while ((instruction = viewportInstructions.next()) !== null) {
                let viewport = instruction.viewport;
                if (!viewport) {
                    const name = instruction.viewportName;
                    if ((name?.length ?? 0) === 0) {
                        continue;
                    }
                    const newScope = instruction.ownsScope;
                    if (!this.getEnabledViewports(ownedScopes)[name]) {
                        continue;
                        // TODO: No longer pre-creating viewports. Evaluate!
                        this.addViewport(name, null, { scope: newScope, forceDescription: true });
                        availableViewports[name] = this.getEnabledViewports(ownedScopes)[name];
                    }
                    viewport = availableViewports[name];
                }
                if (viewport?.acceptComponent(instruction.componentName)) {
                    const remaining = this.foundViewport(instruction, viewport, disregardViewports);
                    foundViewports.push(instruction);
                    remainingInstructions.push(...remaining);
                    availableViewports[viewport.name] = null;
                    viewportInstructions.removeCurrent();
                }
            }
        }
        remainingInstructions = [...viewportInstructions, ...remainingInstructions];
        return {
            foundViewports,
            remainingInstructions,
        };
    }
    foundViewportScope(instruction, viewportScope) {
        instruction.viewportScope = viewportScope;
        instruction.needsViewportDescribed = false;
        const remaining = instruction.nextScopeInstructions?.slice() ?? [];
        for (const rem of remaining) {
            if (rem.scope === null) {
                rem.scope = viewportScope.scope.scope;
            }
        }
        return remaining;
    }
    foundViewport(instruction, viewport, withoutViewports, doesntNeedViewportDescribed = false) {
        instruction.setViewport(viewport);
        if (doesntNeedViewportDescribed) {
            instruction.needsViewportDescribed = false;
        }
        const remaining = instruction.nextScopeInstructions?.slice() ?? [];
        for (const rem of remaining) {
            if (rem.scope === null) {
                rem.scope = viewport.scope;
            }
        }
        return remaining;
    }
    addViewport(name, connectedCE, options = {}) {
        let viewport = this.getEnabledViewports(this.getOwnedScopes())[name];
        // Each au-viewport element has its own Viewport
        if (((connectedCE ?? null) !== null) &&
            ((viewport?.connectedCE ?? null) !== null) &&
            viewport.connectedCE !== connectedCE) {
            viewport.enabled = false;
            viewport = this.getOwnedViewports(true).find(child => child.name === name && child.connectedCE === connectedCE) ?? null;
            if ((viewport ?? null) !== null) {
                viewport.enabled = true;
            }
        }
        if ((viewport ?? null) === null) {
            viewport = new _viewport_js__WEBPACK_IMPORTED_MODULE_3__.Viewport(this.router, name, connectedCE, this.scope, !!options.scope, options);
            this.addChild(viewport.connectedScope);
        }
        if ((connectedCE ?? null) !== null) {
            viewport.setConnectedCE(connectedCE, options);
        }
        return viewport;
    }
    removeViewport(viewport, connectedCE) {
        if (((connectedCE ?? null) !== null) || viewport.remove(connectedCE)) {
            this.removeChild(viewport.connectedScope);
            return true;
        }
        return false;
    }
    addViewportScope(name, connectedCE, options = {}) {
        const viewportScope = new _viewport_scope_js__WEBPACK_IMPORTED_MODULE_0__.ViewportScope(name, this.router, connectedCE, this.scope, true, null, options);
        this.addChild(viewportScope.connectedScope);
        return viewportScope;
    }
    removeViewportScope(viewportScope) {
        // viewportScope.remove();
        this.removeChild(viewportScope.connectedScope);
        return true;
    }
    addChild(scope) {
        if (!this.children.some(vp => vp === scope)) {
            if (scope.parent !== null) {
                scope.parent.removeChild(scope);
            }
            this.children.push(scope);
            scope.parent = this;
        }
    }
    removeChild(scope) {
        const index = this.children.indexOf(scope);
        if (index >= 0) {
            this.children.splice(index, 1);
            scope.parent = null;
        }
    }
    clearReplacedChildren() {
        this.replacedChildren = [];
    }
    disableReplacedChildren() {
        this.replacedChildren = this.enabledChildren;
        for (const scope of this.replacedChildren) {
            scope.enabled = false;
        }
    }
    reenableReplacedChildren() {
        for (const scope of this.replacedChildren) {
            scope.enabled = true;
        }
    }
    allViewports(includeDisabled = false, includeReplaced = false) {
        return this.allScopes(includeDisabled, includeReplaced).filter(scope => scope.isViewport).map(scope => scope.viewport);
    }
    allScopes(includeDisabled = false, includeReplaced = false) {
        const scopes = includeDisabled ? this.children.slice() : this.enabledChildren;
        for (const scope of scopes.slice()) {
            scopes.push(...scope.allScopes(includeDisabled, includeReplaced));
        }
        return scopes;
    }
    reparentViewportInstructions() {
        const scopes = this.hoistedChildren
            .filter(scope => scope.viewportInstruction !== null && scope.viewportInstruction.componentName);
        if (!scopes.length) {
            return null;
        }
        for (const scope of scopes) {
            const childInstructions = scope.reparentViewportInstructions();
            scope.viewportInstruction.nextScopeInstructions =
                childInstructions !== null && childInstructions.length > 0 ? childInstructions : null;
        }
        return scopes.map(scope => scope.viewportInstruction);
    }
    findMatchingRoute(path) {
        if (this.isViewportScope && !this.passThroughScope) {
            return this.findMatchingRouteInRoutes(path, this.viewportScope.getRoutes());
        }
        if (this.isViewport) {
            return this.findMatchingRouteInRoutes(path, this.viewport.getRoutes());
        }
        // TODO: Match specified names here
        for (const child of this.enabledChildren) {
            const found = child.findMatchingRoute(path);
            if (found !== null) {
                return found;
            }
        }
        return null;
    }
    canLoad(recurse) {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.canLoad(recurse)
            : child.canLoad(recurse)));
        if (results instanceof Promise) {
            return results.then(resolvedResults => resolvedResults.every(result => result));
        }
        return results.every(result => result);
    }
    canUnload() {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.canUnload()
            : child.canUnload()));
        if (results instanceof Promise) {
            return results.then(resolvedResults => {
                return resolvedResults.every(result => result);
            });
        }
        return results.every(result => result);
    }
    load(recurse) {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.load(recurse)
            : child.load(recurse)));
        if (results instanceof Promise) {
            return results;
        }
    }
    unload(recurse) {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.unload(recurse)
            : child.unload(recurse)));
        if (results instanceof Promise) {
            return results;
        }
    }
    removeContent() {
        const results = _runner_js__WEBPACK_IMPORTED_MODULE_7__.Runner.runAll(this.children.map(child => child.viewport !== null
            ? child.viewport.removeContent()
            : child.removeContent()));
        if (results instanceof Promise) {
            return results;
        }
    }
    findMatchingRouteInRoutes(path, routes) {
        if (!Array.isArray(routes)) {
            return null;
        }
        routes = routes.map(route => this.ensureProperRoute(route));
        const cRoutes = routes.map(route => ({
            path: route.path,
            handler: route,
        }));
        for (let i = 0, ii = cRoutes.length; i < ii; ++i) {
            const cRoute = cRoutes[i];
            cRoutes.push({
                ...cRoute,
                path: `${cRoute.path}/*remainingPath`,
            });
        }
        const found = new _found_route_js__WEBPACK_IMPORTED_MODULE_1__.FoundRoute();
        if (path.startsWith('/') || path.startsWith('+')) {
            path = path.slice(1);
        }
        const recognizer = new _route_recognizer_js__WEBPACK_IMPORTED_MODULE_6__.RouteRecognizer();
        recognizer.add(cRoutes);
        const result = recognizer.recognize(path);
        if (result !== null) {
            found.match = result.endpoint.route.handler;
            found.matching = path;
            const $params = { ...result.params };
            if ($params.remainingPath !== void 0) {
                found.remaining = $params.remainingPath;
                Reflect.deleteProperty($params, 'remainingPath');
                found.matching = found.matching.slice(0, found.matching.indexOf(found.remaining));
            }
            found.params = $params;
        }
        if (found.foundConfiguration) {
            // clone it so config doesn't get modified
            found.instructions = this.router.instructionResolver.cloneViewportInstructions(found.match.instructions, false, true);
            const instructions = found.instructions.slice();
            while (instructions.length > 0) {
                const instruction = instructions.shift();
                instruction.addParameters(found.params);
                instruction.route = '';
                if (instruction.nextScopeInstructions !== null) {
                    instructions.unshift(...instruction.nextScopeInstructions);
                }
            }
            if (found.instructions.length > 0) {
                found.instructions[0].route = found;
            }
        }
        return found;
    }
    ensureProperRoute(route) {
        if (route.id === void 0) {
            route.id = route.path;
        }
        if (route.instructions === void 0) {
            route.instructions = [{
                    component: route.component,
                    viewport: route.viewport,
                    parameters: route.parameters,
                    children: route.children,
                }];
        }
        route.instructions = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_2__.NavigationInstructionResolver.toViewportInstructions(this.router, route.instructions);
        return route;
    }
}
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/state-coordinator.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/state-coordinator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Entity": () => /* binding */ Entity,
/* harmony export */   "StateCoordinator": () => /* binding */ StateCoordinator
/* harmony export */ });
/* harmony import */ var _open_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./open-promise.js */ "./node_modules/@aurelia/router/dist/esm/open-promise.js");

class Entity {
    constructor(entity) {
        this.entity = entity;
        this.running = false;
        this.states = [];
        this.checkedStates = [];
        this.syncState = null;
        this.syncPromise = null;
    }
}
class StateCoordinator {
    constructor() {
        this.entities = [];
        this.hasAllEntities = false;
        this.syncStates = new Map();
        this.checkedSyncStates = new Set();
    }
    // public constructor(@ILogger private readonly logger: ILogger) {
    //   this.logger = logger.root.scopeTo('StateCoordinator');
    //   this.logger.trace('constructor()');
    // }
    addSyncState(state) {
        const openPromise = new _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise();
        this.syncStates.set(state, openPromise);
    }
    addEntity(entity) {
        // console.log('Entity received', entity);
        const ent = new Entity(entity);
        this.entities.push(ent);
        this.resetSyncStates();
        return ent;
    }
    addEntityState(entity, state) {
        // console.log(`#### EntityState received ${state}`, (entity as any).name);
        let ent = this.entities.find(e => e.entity === entity);
        if (ent === void 0) {
            ent = this.addEntity(entity);
        }
        ent.states.push(state);
        this.checkSyncState(state);
    }
    syncState(state, entity = null) {
        const openPromise = this.syncStates.get(state);
        if (openPromise === void 0) {
            return;
        }
        if (entity !== null) {
            const ent = this.entities.find(e => e.entity === entity);
            if (ent?.syncPromise === null && openPromise.isPending) {
                ent.syncState = state;
                ent.syncPromise = new _open_promise_js__WEBPACK_IMPORTED_MODULE_0__.OpenPromise();
                ent.checkedStates.push(state);
                this.checkedSyncStates.add(state);
                Promise.resolve().then(() => { this.checkSyncState(state); }).catch(err => { throw err; });
                return ent.syncPromise.promise;
            }
        }
        // this.checkSyncState(state);
        return openPromise.promise;
    }
    checkingSyncState(state) {
        return this.syncStates.has(state);
    }
    finalEntity() {
        this.hasAllEntities = true;
        // console.log('Final entity received', this.entities.length);
        this.syncStates.forEach((_promise, state) => this.checkSyncState(state));
    }
    finalize() { }
    cancel() { }
    // A new navigation should cancel replaced instructions
    cancelReplaced(navigation) { }
    checkSyncState(state) {
        // console.log('StateCoordinator check state', state, this);
        const openPromise = this.syncStates.get(state);
        if (openPromise === void 0) {
            return;
        }
        if (this.hasAllEntities &&
            openPromise.isPending &&
            // Check that this state has been done by all state entities and if so resolve the promise
            this.entities.every(ent => ent.states.includes(state)) &&
            // Check that this state has been checked (reached) by all state entities and if so resolve the promise
            (!this.checkedSyncStates.has(state) || this.entities.every(ent => ent.checkedStates.includes(state)))) {
            for (const entity of this.entities) {
                if (entity.syncState === state) {
                    // console.log('Resolving entity promise for ', state, (entity.entity as any).toString());
                    entity.syncPromise?.resolve();
                    entity.syncPromise = null;
                    entity.syncState = null;
                }
            }
            openPromise.resolve();
            // console.log('#### StateCoordinator state resolved', state /*, this */);
        }
    }
    resetSyncStates() {
        this.syncStates.forEach((promise, state) => {
            if (!promise.isPending &&
                !this.entities.every(entity => entity.states.includes(state))) {
                this.addSyncState(state);
            }
        });
    }
}
//# sourceMappingURL=state-coordinator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/task-queue.js":
/*!*************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/task-queue.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueueTask": () => /* binding */ QueueTask,
/* harmony export */   "TaskQueue": () => /* binding */ TaskQueue
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * @internal - Shouldn't be used directly
 */
class QueueTask {
    constructor(taskQueue, item, cost = 0) {
        this.taskQueue = taskQueue;
        this.item = item;
        this.cost = cost;
        this.done = false;
        this.promise = new Promise((resolve, reject) => {
            this.resolve = () => {
                this.taskQueue.resolve(this, resolve);
            };
            this.reject = (reason) => {
                this.taskQueue.reject(this, reject, reason);
            };
        });
    }
    async execute() {
        if ('execute' in this.item) {
            await this.item.execute(this);
        }
        else {
            await this.item(this);
        }
    }
    wait() {
        return this.promise;
    }
}
/**
 * A first-in-first-out task queue that only processes the next queued item
 * when the current one has been resolved or rejected. If a callback function
 * is specified, it receives the queued items as tasks one at a time. If no
 * callback is specified, the tasks themselves are either executed (if a
 * function) or the execute method in them are run. The executed function
 * should resolve or reject the task when processing is done.
 * Enqueued items' tasks can be awaited. Enqueued items can specify an
 * (arbitrary) execution cost and the queue can be set up (started) to
 * only process a specific amount of execution cost per RAF/tick.
 *
 * @internal - Shouldn't be used directly.
 */
class TaskQueue {
    constructor(callback) {
        this.callback = callback;
        this.pending = [];
        this.processing = null;
        this.allowedExecutionCostWithinTick = null;
        this.currentExecutionCostInCurrentTick = 0;
        this.platform = null;
        this.task = null;
    }
    get isActive() {
        return this.task !== null;
    }
    get length() {
        return this.pending.length;
    }
    start(options) {
        if (this.isActive) {
            throw new Error('TaskQueue has already been started');
        }
        this.platform = options.platform;
        this.allowedExecutionCostWithinTick = options.allowedExecutionCostWithinTick;
        this.task = this.platform.domWriteQueue.queueTask(this.dequeue, { persistent: true });
    }
    stop() {
        if (!this.isActive) {
            throw new Error('TaskQueue has not been started');
        }
        this.task.cancel();
        this.task = null;
        this.allowedExecutionCostWithinTick = null;
        this.clear();
    }
    enqueue(itemOrItems, costOrCosts) {
        const list = Array.isArray(itemOrItems);
        const items = (list ? itemOrItems : [itemOrItems]);
        const costs = items
            .map((value, index) => !Array.isArray(costOrCosts) ? costOrCosts : costOrCosts[index])
            .map((value) => value !== undefined ? value : 1);
        const tasks = [];
        for (const item of items) {
            tasks.push(item instanceof QueueTask
                ? item
                : this.createQueueTask(item, costs.shift())); // TODO: Get cancellable in as well
        }
        this.pending.push(...tasks);
        this.dequeue();
        return list ? tasks : tasks[0];
    }
    createQueueTask(item, cost) {
        return new QueueTask(this, item, cost);
    }
    dequeue(delta) {
        if (this.processing !== null) {
            return;
        }
        if (delta !== undefined) {
            this.currentExecutionCostInCurrentTick = 0;
        }
        if (!this.pending.length) {
            return;
        }
        if (this.allowedExecutionCostWithinTick !== null && delta === undefined && this.currentExecutionCostInCurrentTick + (this.pending[0].cost || 0) > this.allowedExecutionCostWithinTick) {
            return;
        }
        this.processing = this.pending.shift() || null;
        if (this.processing) {
            this.currentExecutionCostInCurrentTick += this.processing.cost ?? 0;
            if (this.callback !== void 0) {
                this.callback(this.processing);
            }
            else {
                // Don't need to await this since next task won't be dequeued until
                // executed function is resolved
                this.processing.execute().catch(error => { throw error; });
            }
        }
    }
    clear() {
        this.pending.splice(0, this.pending.length);
    }
    resolve(task, resolve) {
        resolve();
        this.processing = null;
        this.dequeue();
    }
    reject(task, reject, reason) {
        reject(reason);
        this.processing = null;
        this.dequeue();
    }
}
__decorate([
    _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.bound
], TaskQueue.prototype, "dequeue", null);
//# sourceMappingURL=task-queue.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/type-resolvers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComponentAppellationResolver": () => /* binding */ ComponentAppellationResolver,
/* harmony export */   "ViewportHandleResolver": () => /* binding */ ViewportHandleResolver,
/* harmony export */   "NavigationInstructionResolver": () => /* binding */ NavigationInstructionResolver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _viewport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewport.js */ "./node_modules/@aurelia/router/dist/esm/viewport.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");



const ComponentAppellationResolver = {
    isName(component) {
        return typeof component === 'string';
    },
    isType(component) {
        return _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.isType(component);
    },
    isInstance(component) {
        return !ComponentAppellationResolver.isName(component) && !ComponentAppellationResolver.isType(component);
    },
    getName(component) {
        if (ComponentAppellationResolver.isName(component)) {
            return component;
        }
        else if (ComponentAppellationResolver.isType(component)) {
            return _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.getDefinition(component).name;
        }
        else {
            return ComponentAppellationResolver.getName(component.constructor);
        }
    },
    getType(component) {
        if (ComponentAppellationResolver.isName(component)) {
            return null;
        }
        else if (ComponentAppellationResolver.isType(component)) {
            return component;
        }
        else {
            return component.constructor;
        }
    },
    getInstance(component) {
        if (ComponentAppellationResolver.isName(component) || ComponentAppellationResolver.isType(component)) {
            return null;
        }
        else {
            return component;
        }
    },
};
const ViewportHandleResolver = {
    isName(viewport) {
        return typeof viewport === 'string';
    },
    isInstance(viewport) {
        return viewport instanceof _viewport_js__WEBPACK_IMPORTED_MODULE_1__.Viewport;
    },
    getName(viewport) {
        if (ViewportHandleResolver.isName(viewport)) {
            return viewport;
        }
        else {
            return viewport ? (viewport).name : null;
        }
    },
    getInstance(viewport) {
        if (ViewportHandleResolver.isName(viewport)) {
            return null;
        }
        else {
            return viewport;
        }
    },
};
const NavigationInstructionResolver = {
    createViewportInstructions(router, navigationInstructions, options) {
        options = options || {};
        let scope = null;
        if (options.context) {
            scope = router.findScope(options.context);
            if (typeof navigationInstructions === 'string') {
                // If it's not from scope root, figure out which scope
                if (!navigationInstructions.startsWith('/')) {
                    // Scope modifications
                    if (navigationInstructions.startsWith('.')) {
                        // The same as no scope modification
                        if (navigationInstructions.startsWith('./')) {
                            navigationInstructions = navigationInstructions.slice(2);
                        }
                        // Find out how many scopes upwards we should move
                        while (navigationInstructions.startsWith('../')) {
                            scope = scope.parent || scope;
                            navigationInstructions = navigationInstructions.slice(3);
                        }
                    }
                    if (scope.path !== null) {
                        navigationInstructions = `${scope.path}/${navigationInstructions}`;
                        scope = router.rootScope.scope;
                    }
                }
                else { // Specified root scope with /
                    scope = router.rootScope.scope;
                }
            }
            else {
                navigationInstructions = NavigationInstructionResolver.toViewportInstructions(router, navigationInstructions);
                for (const instruction of navigationInstructions) {
                    if (instruction.scope === null) {
                        instruction.scope = scope;
                    }
                }
            }
        }
        return {
            instructions: navigationInstructions,
            scope,
        };
    },
    toViewportInstructions(router, navigationInstructions) {
        if (!Array.isArray(navigationInstructions)) {
            return NavigationInstructionResolver.toViewportInstructions(router, [navigationInstructions]);
        }
        const instructions = [];
        for (const instruction of navigationInstructions) {
            if (typeof instruction === 'string') {
                instructions.push(...router.instructionResolver.parseViewportInstructions(instruction));
            }
            else if (instruction instanceof _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__.ViewportInstruction) {
                instructions.push(instruction);
            }
            else if (instruction.component) {
                const viewportComponent = instruction;
                const newInstruction = router.createViewportInstruction(viewportComponent.component, viewportComponent.viewport, viewportComponent.parameters);
                if (viewportComponent.children !== void 0 && viewportComponent.children !== null) {
                    newInstruction.nextScopeInstructions = NavigationInstructionResolver.toViewportInstructions(router, viewportComponent.children);
                }
                instructions.push(newInstruction);
            }
            else {
                instructions.push(router.createViewportInstruction(instruction));
            }
        }
        return instructions;
    },
};
//# sourceMappingURL=type-resolvers.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayRemove": () => /* binding */ arrayRemove,
/* harmony export */   "resolvePossiblePromise": () => /* binding */ resolvePossiblePromise,
/* harmony export */   "deprecationWarning": () => /* binding */ deprecationWarning
/* harmony export */ });
/**
 * @internal - Shouldn't be used directly
 */
function arrayRemove(arr, func) {
    const removed = [];
    let arrIndex = arr.findIndex(func);
    while (arrIndex >= 0) {
        removed.push(arr.splice(arrIndex, 1)[0]);
        arrIndex = arr.findIndex(func);
    }
    return removed;
}
function resolvePossiblePromise(value, callback) {
    // If we've got a Promise, wait for it's resolve
    if (value instanceof Promise) {
        return value.then((resolvedValue) => {
            if (callback !== void 0) {
                callback(resolvedValue);
            }
            return resolvedValue;
        });
    }
    if (callback !== void 0) {
        callback(value);
    }
    return value;
}
function deprecationWarning(oldFeature, newFeature) {
    console.warn(`[Deprecated] The ${oldFeature} has been deprecated. Please use the ${newFeature} instead.`);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport-content.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport-content.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentStatus": () => /* binding */ ContentStatus,
/* harmony export */   "ViewportContent": () => /* binding */ ViewportContent
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser.js */ "./node_modules/@aurelia/router/dist/esm/parser.js");
/* harmony import */ var _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewport-instruction.js */ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js");
/* harmony import */ var _navigation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./navigation.js */ "./node_modules/@aurelia/router/dist/esm/navigation.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");
/* harmony import */ var _awaitable_map_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./awaitable-map.js */ "./node_modules/@aurelia/router/dist/esm/awaitable-map.js");






/**
 * @internal - Shouldn't be used directly
 */
var ContentStatus;
(function (ContentStatus) {
    ContentStatus[ContentStatus["none"] = 0] = "none";
    ContentStatus[ContentStatus["created"] = 1] = "created";
    ContentStatus[ContentStatus["activated"] = 3] = "activated";
})(ContentStatus || (ContentStatus = {}));
/**
 * @internal - Shouldn't be used directly
 */
class ViewportContent {
    constructor(
    // Can (and wants) be a (resolved) type or a string (to be resolved later)
    // public content: ViewportInstruction = new ViewportInstruction(''),
    content = _viewport_instruction_js__WEBPACK_IMPORTED_MODULE_2__.ViewportInstruction.create(null, ''), instruction = new _navigation_js__WEBPACK_IMPORTED_MODULE_3__.Navigation({
        instruction: '',
        fullStateInstruction: '',
    }), connectedCE = null) {
        this.content = content;
        this.instruction = instruction;
        // public contentStatus: ContentStatus = ContentStatus.none;
        this.contentStates = new _awaitable_map_js__WEBPACK_IMPORTED_MODULE_5__.AwaitableMap();
        // public contentStates: Map<ContentState, undefined> = new Map();
        this.loaded = false;
        this.fromCache = false;
        this.fromHistory = false;
        this.reentry = false;
        // If we've got a container, we're good to resolve type
        if (!this.content.isComponentType() && (connectedCE?.container ?? null) !== null) {
            this.content.componentType = this.toComponentType(connectedCE.container);
        }
    }
    get componentInstance() {
        return this.content.componentInstance;
    }
    get viewport() {
        return this.content.viewport;
    }
    equalComponent(other) {
        return this.content.sameComponent(other.content);
    }
    equalParameters(other) {
        return this.content.sameComponent(other.content, true) &&
            // TODO: Review whether query is relevant
            this.instruction.query === other.instruction.query;
    }
    reentryBehavior() {
        return (this.content.componentInstance !== null &&
            'reentryBehavior' in this.content.componentInstance &&
            this.content.componentInstance.reentryBehavior !== void 0)
            ? this.content.componentInstance.reentryBehavior
            : "default" /* default */;
    }
    isCacheEqual(other) {
        return this.content.sameComponent(other.content, true);
    }
    contentController(connectedCE) {
        return _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.Controller.forCustomElement(null, connectedCE.container, this.content.componentInstance, connectedCE.element, null, void 0);
    }
    createComponent(connectedCE, fallback) {
        // if (this.contentStatus !== ContentStatus.none) {
        if (this.contentStates.has('created')) {
            return;
        }
        // Don't load cached content or instantiated history content
        if (!this.fromCache && !this.fromHistory) {
            try {
                this.content.componentInstance = this.toComponentInstance(connectedCE.container);
            }
            catch (e) {
                if (fallback !== void 0) {
                    this.content.setParameters({ id: this.content.componentName });
                    this.content.setComponent(fallback);
                    try {
                        this.content.componentInstance = this.toComponentInstance(connectedCE.container);
                    }
                    catch (ee) {
                        throw e;
                    }
                }
                else {
                    throw e;
                }
            }
        }
        this.contentStates.set('created', void 0);
        // this.contentStatus = ContentStatus.created;
        // if (this.contentStatus !== ContentStatus.created || !this.loaded || !this.content.componentInstance) {
        // if (this.contentStatus !== ContentStatus.created || this.loaded || !this.content.componentInstance) {
        if (this.contentStates.has('loaded') || !this.content.componentInstance) {
            return;
        }
        // this.contentStatus = ContentStatus.loaded;
        // Don't load cached content or instantiated history content
        if (!this.fromCache || !this.fromHistory) {
            const controller = this.contentController(connectedCE);
            controller.parent = connectedCE.controller; // CustomElement.for(connectedCE.element)!;
        }
    }
    // public destroyComponent(): void {
    //   // TODO: We might want to do something here eventually, who knows?
    //   // if (this.contentStatus !== ContentStatus.created) {
    //   if (!this.contentStates.has('created')) {
    //     return;
    //   }
    //   // Don't destroy components when stateful
    //   // this.contentStatus = ContentStatus.none;
    //   this.contentStates.delete('created');
    // }
    canLoad(viewport, previousInstruction) {
        if (!this.contentStates.has('created') || (this.contentStates.has('guarded') && !this.reentry)) {
            return true;
        }
        this.contentStates.set('guarded', void 0);
        if (!this.content.componentInstance) {
            return false;
        }
        if (!this.content.componentInstance.canLoad) {
            return true;
        }
        const typeParameters = this.content.componentType ? this.content.componentType.parameters : null;
        this.instruction.parameters = this.content.toSpecifiedParameters(typeParameters);
        const merged = { ...(0,_parser_js__WEBPACK_IMPORTED_MODULE_1__.parseQuery)(this.instruction.query), ...this.instruction.parameters };
        const result = this.content.componentInstance.canLoad(merged, this.instruction, previousInstruction);
        if (typeof result === 'boolean') {
            return result;
        }
        if (typeof result === 'string') {
            return [viewport.router.createViewportInstruction(result, viewport)];
        }
        return result;
    }
    canUnload(nextInstruction) {
        if (!this.content.componentInstance || !this.content.componentInstance.canUnload) {
            return true;
        }
        if (!this.contentStates.has('loaded')) {
            return true;
        }
        return this.content.componentInstance.canUnload(nextInstruction, this.instruction);
    }
    // public async canUnload(nextInstruction: Navigation | null): Promise<boolean> {
    //   if (!this.content.componentInstance || !this.content.componentInstance.canUnload) {
    //     return true;
    //   }
    //   const result = this.content.componentInstance.canUnload(nextInstruction, this.instruction);
    //   if (typeof result === 'boolean') {
    //     return result;
    //   }
    //   return result;
    // }
    load(previousInstruction) {
        // if (!this.reentry && (this.contentStatus !== ContentStatus.created || this.loaded)) {
        // if (!this.reentry && this.loaded) {
        // if (!this.contentStates.has('created') || (this.contentStates.has('loaded') && !this.reentry)) {
        //   return;
        // }
        // this.reentry = false;
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.contentStates.await('guarded'), () => {
            if (!this.contentStates.has('created') || (this.contentStates.has('loaded') && !this.reentry)) {
                return;
            }
            this.reentry = false;
            // this.loaded = true;
            // console.log('loaded', this.content.componentName);
            this.contentStates.set('loaded', void 0);
            if (this.content.componentInstance && this.content.componentInstance.load) {
                const typeParameters = this.content.componentType ? this.content.componentType.parameters : null;
                this.instruction.parameters = this.content.toSpecifiedParameters(typeParameters);
                const merged = { ...(0,_parser_js__WEBPACK_IMPORTED_MODULE_1__.parseQuery)(this.instruction.query), ...this.instruction.parameters };
                return this.content.componentInstance.load(merged, this.instruction, previousInstruction);
            }
        });
    }
    unload(nextInstruction) {
        // if (!this.loaded) {
        if (!this.contentStates.has('loaded')) {
            return;
        }
        // this.loaded = false;
        // console.log('loaded', this.content.componentName, 'deleted');
        this.contentStates.delete('loaded');
        if (this.content.componentInstance && this.content.componentInstance.unload) {
            return this.content.componentInstance.unload(nextInstruction, this.instruction);
        }
    }
    // public unloadComponent(cache: ViewportContent[], stateful: boolean = false): void {
    //   // TODO: We might want to do something here eventually, who knows?
    //   // if (this.contentStatus !== ContentStatus.activated) {
    //   if (!this.contentStates.has('created')) {
    //     return;
    //   }
    //   // Don't unload components when stateful
    //   // TODO: We're missing stuff here
    //   if (!stateful) {
    //     // this.contentStatus = ContentStatus.created;
    //     this.contentStates.delete('created');
    //   } else {
    //     cache.push(this);
    //   }
    // }
    activateComponent(initiator, parent, flags, connectedCE, parentActivated) {
        // if (this.contentStates.has('activated') || !this.contentStates.has('created')) {
        // if (this.contentStates.has('activated')) {
        //   return;
        // }
        // this.contentStates.set('activated', void 0);
        // // if (parentActivated) { // Parent is already part of an activation
        // //   return ;
        // // }
        // const contentController = this.contentController(connectedCE);
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.contentStates.await('loaded'), () => {
            if (this.contentStates.has('activated')) {
                return;
            }
            this.contentStates.set('activated', void 0);
            // if (parentActivated) { // Parent is already part of an activation
            //   return ;
            // }
            const contentController = this.contentController(connectedCE);
            return contentController.activate(initiator ?? contentController, null /* TODO: take back: parent! */, flags);
        }, () => {
            if (this.fromCache || this.fromHistory) {
                const elements = Array.from(connectedCE.element.getElementsByTagName('*'));
                for (const el of elements) {
                    const attr = el.getAttribute('au-element-scroll');
                    if (attr) {
                        const [top, left] = attr.split(',');
                        el.removeAttribute('au-element-scroll');
                        el.scrollTo(+left, +top);
                    }
                }
            }
        });
    }
    // public async activateComponent(initiator: IHydratedController | null, parent: ICustomElementController<ICustomElementViewModel> | null, flags: LifecycleFlags, connectedCE: IConnectedCustomElement): Promise<void> {
    //   // if (this.contentStatus !== ContentStatus.created) {
    //   if (!this.contentStates.has('created')) {
    //     return;
    //   }
    //   // this.contentStatus = ContentStatus.activated;
    //   this.contentStates.add('activated');
    //   const contentController = this.contentController(connectedCE);
    //   await contentController.activate(initiator ?? contentController, parent!, flags);
    //   if (this.fromCache || this.fromHistory) {
    //     const elements = Array.from(connectedCE.element.getElementsByTagName('*'));
    //     for (const el of elements) {
    //       const attr = el.getAttribute('au-element-scroll');
    //       if (attr) {
    //         const [top, left] = attr.split(',');
    //         el.removeAttribute('au-element-scroll');
    //         el.scrollTo(+left, +top);
    //       }
    //     }
    //   }
    // }
    deactivateComponent(initiator, parent, flags, connectedCE, stateful = false) {
        // if (this.contentStatus !== ContentStatus.activated) {
        if (!this.contentStates.has('activated')) {
            return;
        }
        // this.contentStatus = ContentStatus.created;
        this.contentStates.delete('activated');
        if (stateful && connectedCE.element !== null) {
            // const contentController = this.content.componentInstance!.$controller!;
            const elements = Array.from(connectedCE.element.getElementsByTagName('*'));
            for (const el of elements) {
                if (el.scrollTop > 0 || el.scrollLeft) {
                    el.setAttribute('au-element-scroll', `${el.scrollTop},${el.scrollLeft}`);
                }
            }
        }
        const contentController = this.contentController(connectedCE);
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => contentController.deactivate(initiator ?? contentController, parent, flags));
    }
    disposeComponent(connectedCE, cache, stateful = false) {
        if (!this.contentStates.has('created')) {
            return;
        }
        // Don't unload components when stateful
        // TODO: We're missing stuff here
        if (!stateful) {
            this.contentStates.delete('created');
            const contentController = this.contentController(connectedCE);
            return contentController.dispose();
        }
        else {
            cache.push(this);
        }
    }
    freeContent(connectedCE, nextInstruction, cache, stateful = false) {
        // switch (this.contentStatus) {
        //   case ContentStatus.activated:
        //     await this.unload(nextInstruction);
        //     await this.deactivateComponent(null, connectedCE!.controller, LifecycleFlags.none, connectedCE!, stateful);
        //     this.unloadComponent(cache, stateful); // TODO: Hook up to new dispose
        //   case ContentStatus.created:
        //     this.destroyComponent();
        // }
        // TODO: Fix execution order on these
        // These are all safe to run
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.unload(nextInstruction), () => this.deactivateComponent(null, connectedCE.controller, 0 /* none */, connectedCE, stateful), 
        // () => this.unloadComponent(cache, stateful), // TODO: Hook up to new dispose
        // () => this.destroyComponent(),
        () => this.disposeComponent(connectedCE, cache, stateful));
    }
    toComponentName() {
        return this.content.componentName;
    }
    toComponentType(container) {
        if (this.content.isEmpty()) {
            return null;
        }
        return this.content.toComponentType(container);
    }
    toComponentInstance(container) {
        if (this.content.isEmpty()) {
            return null;
        }
        return this.content.toComponentInstance(container);
    }
}
//# sourceMappingURL=viewport-content.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport-instruction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport-instruction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParametersType": () => /* binding */ ParametersType,
/* harmony export */   "ViewportInstruction": () => /* binding */ ViewportInstruction
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type-resolvers.js */ "./node_modules/@aurelia/router/dist/esm/type-resolvers.js");
/* harmony import */ var _router_options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router-options.js */ "./node_modules/@aurelia/router/dist/esm/router-options.js");



/**
 * @internal - Shouldn't be used directly
 */
var ParametersType;
(function (ParametersType) {
    ParametersType["none"] = "none";
    ParametersType["string"] = "string";
    ParametersType["array"] = "array";
    ParametersType["object"] = "object";
})(ParametersType || (ParametersType = {}));
/**
 * Public API - The viewport instructions are the core of the router's navigations
 */
class ViewportInstruction {
    constructor() {
        this.componentName = null;
        this.componentType = null;
        this.componentInstance = null;
        this.viewportName = null;
        this.viewport = null;
        this.parametersString = null;
        this.parametersRecord = null;
        this.parametersList = null;
        this.parametersType = "none" /* none */;
        this.ownsScope = true;
        this.nextScopeInstructions = null;
        this.scope = null;
        this.context = '';
        this.viewportScope = null;
        this.needsViewportDescribed = false;
        this.route = null;
        this.default = false;
        this.topInstruction = false;
        this.instructionResolver = null;
    }
    // public constructor(
    //   component: ComponentAppellation,
    //   viewport?: ViewportHandle,
    //   parameters?: ComponentParameters,
    //   public ownsScope: boolean = true,
    //   public nextScopeInstructions: ViewportInstruction[] | null = null,
    // ) {
    //   this.setComponent(component);
    //   this.setViewport(viewport);
    //   this.setParameters(parameters);
    // }
    static create(instructionResolver, component, viewport, parameters, ownsScope = true, nextScopeInstructions = null) {
        // if (component instanceof Promise) {
        //   return component.then((resolvedComponent) => {
        //     return ViewportInstruction.create(instructionResolver, resolvedComponent, viewport, parameters, ownsScope, nextScopeInstructions);
        //   });
        // }
        const instruction = new ViewportInstruction();
        instruction.setComponent(component);
        instruction.setViewport(viewport);
        instruction.setParameters(parameters);
        instruction.ownsScope = ownsScope;
        instruction.nextScopeInstructions = nextScopeInstructions;
        instruction.setInstructionResolver(instructionResolver);
        return instruction;
    }
    get owner() {
        return this.viewport ?? this.viewportScope ?? null;
    }
    get typedParameters() {
        switch (this.parametersType) {
            case "string" /* string */:
                return this.parametersString;
            case "array" /* array */:
                return this.parametersList;
            case "object" /* object */:
                return this.parametersRecord;
            default:
                return null;
        }
    }
    get parameters() {
        if (this.instructionResolver !== null) {
            return this.instructionResolver.parseComponentParameters(this.typedParameters);
        }
        return [];
    }
    get normalizedParameters() {
        if (this.instructionResolver !== null && this.typedParameters !== null) {
            return this.instructionResolver.stringifyComponentParameters(this.parameters);
        }
        return '';
    }
    setComponent(component) {
        if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.isName(component)) {
            this.componentName = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getName(component);
            this.componentType = null;
            this.componentInstance = null;
        }
        else if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.isType(component)) {
            this.componentName = this.getNewName(component);
            this.componentType = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getType(component);
            this.componentInstance = null;
        }
        else if (_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.isInstance(component)) {
            this.componentName = this.getNewName(_type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getType(component));
            this.componentType = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getType(component);
            this.componentInstance = _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getInstance(component);
        }
    }
    setViewport(viewport) {
        if (viewport === undefined || viewport === '') {
            viewport = null;
        }
        if (typeof viewport === 'string') {
            this.viewportName = viewport;
            this.viewport = null;
        }
        else {
            this.viewport = viewport;
            if (viewport !== null) {
                this.viewportName = viewport.name;
                this.scope = viewport.owningScope;
            }
        }
    }
    setParameters(parameters) {
        if (parameters === undefined || parameters === null || parameters === '') {
            this.parametersType = "none" /* none */;
            parameters = null;
        }
        else if (typeof parameters === 'string') {
            this.parametersType = "string" /* string */;
            this.parametersString = parameters;
        }
        else if (Array.isArray(parameters)) {
            this.parametersType = "array" /* array */;
            this.parametersList = parameters;
        }
        else {
            this.parametersType = "object" /* object */;
            this.parametersRecord = parameters;
        }
    }
    // This only works with objects added to objects!
    addParameters(parameters) {
        if (this.parametersType === "none" /* none */) {
            return this.setParameters(parameters);
        }
        if (this.parametersType !== "object" /* object */) {
            throw new Error('Can\'t add object parameters to existing non-object parameters!');
        }
        this.setParameters({ ...this.parametersRecord, ...parameters });
    }
    setInstructionResolver(instructionResolver) {
        this.instructionResolver = instructionResolver;
    }
    isEmpty() {
        return !this.isComponentName() && !this.isComponentType() && !this.isComponentInstance();
    }
    isComponentName() {
        return !!this.componentName && !this.isComponentType() && !this.isComponentInstance();
    }
    isComponentType() {
        return this.componentType !== null && !this.isComponentInstance();
    }
    isComponentInstance() {
        return this.componentInstance !== null;
    }
    toComponentType(container) {
        if (this.componentType !== null) {
            return this.componentType;
        }
        if (this.componentName !== null
            && typeof this.componentName === 'string'
            && container !== null
            && container.has(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.keyFrom(this.componentName), true)) {
            const resolver = container.getResolver(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.keyFrom(this.componentName));
            if (resolver !== null && resolver.getFactory !== void 0) {
                const factory = resolver.getFactory(container);
                if (factory) {
                    return factory.Type;
                }
            }
        }
        return null;
    }
    toComponentInstance(container) {
        if (this.componentInstance !== null) {
            return this.componentInstance;
        }
        if (container !== void 0 && container !== null) {
            const instance = this.isComponentType()
                ? container.get(this.componentType)
                : container.get(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.keyFrom(this.componentName));
            if (this.isComponentType() &&
                !(instance instanceof this.componentType)) {
                console.warn('Failed to instantiate', this.componentType, instance);
            }
            return instance ?? null;
        }
        return null;
    }
    toViewportInstance(router) {
        if (this.viewport !== null) {
            return this.viewport;
        }
        return router.getViewport(this.viewportName);
    }
    toSpecifiedParameters(specifications) {
        specifications = specifications || [];
        const parameters = this.parameters;
        const specified = {};
        for (const spec of specifications) {
            // First get named if it exists
            let index = parameters.findIndex(param => param.key === spec);
            if (index >= 0) {
                const [parameter] = parameters.splice(index, 1);
                specified[spec] = parameter.value;
            }
            else {
                // Otherwise get first unnamed
                index = parameters.findIndex(param => param.key === void 0);
                if (index >= 0) {
                    const [parameter] = parameters.splice(index, 1);
                    specified[spec] = parameter.value;
                }
            }
        }
        // Add all remaining named
        for (const parameter of parameters.filter(param => param.key !== void 0)) {
            specified[parameter.key] = parameter.value;
        }
        let index = specifications.length;
        // Add all remaining unnamed...
        for (const parameter of parameters.filter(param => param.key === void 0)) {
            // ..with an index
            specified[index++] = parameter.value;
        }
        return specified;
    }
    toSortedParameters(specifications) {
        specifications = specifications || [];
        const parameters = this.parameters;
        const sorted = [];
        for (const spec of specifications) {
            // First get named if it exists
            let index = parameters.findIndex(param => param.key === spec);
            if (index >= 0) {
                const parameter = { ...parameters.splice(index, 1)[0] };
                parameter.key = void 0;
                sorted.push(parameter);
            }
            else {
                // Otherwise get first unnamed
                index = parameters.findIndex(param => param.key === void 0);
                if (index >= 0) {
                    const parameter = { ...parameters.splice(index, 1)[0] };
                    sorted.push(parameter);
                }
                else {
                    // Or an empty
                    sorted.push({ value: void 0 });
                }
            }
        }
        // Add all remaining named
        const params = parameters.filter(param => param.key !== void 0);
        params.sort((a, b) => (a.key || '') < (b.key || '') ? 1 : (b.key || '') < (a.key || '') ? -1 : 0);
        sorted.push(...params);
        // Add all remaining unnamed...
        sorted.push(...parameters.filter(param => param.key === void 0));
        return sorted;
    }
    sameComponent(other, compareParameters = false, compareType = false) {
        if (compareParameters && !this.sameParameters(other, compareType)) {
            return false;
        }
        return compareType ? this.componentType === other.componentType : this.componentName === other.componentName;
    }
    // TODO: Somewhere we need to check for format such as spaces etc
    sameParameters(other, compareType = false) {
        if (!this.sameComponent(other, false, compareType)) {
            return false;
        }
        const typeParameters = this.componentType ? this.componentType.parameters : [];
        const mine = this.toSpecifiedParameters(typeParameters);
        const others = other.toSpecifiedParameters(typeParameters);
        return Object.keys(mine).every(key => mine[key] === others[key])
            && Object.keys(others).every(key => others[key] === mine[key]);
    }
    sameViewport(other) {
        if (this.viewport !== null && other.viewport !== null) {
            return this.viewport === other.viewport;
        }
        return this.scope === other.scope &&
            (this.viewport ? this.viewport.name : this.viewportName) === (other.viewport ? other.viewport.name : other.viewportName);
    }
    getNewName(type) {
        if (this.componentName === null
        // || !type.aliases?.includes(this.componentName)
        ) {
            return _type_resolvers_js__WEBPACK_IMPORTED_MODULE_1__.ComponentAppellationResolver.getName(type);
        }
        return this.componentName;
    }
}
ViewportInstruction.inject = [_router_options_js__WEBPACK_IMPORTED_MODULE_2__.RouterOptions];
//# sourceMappingURL=viewport-instruction.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport-scope.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport-scope.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewportScope": () => /* binding */ ViewportScope
/* harmony export */ });
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scope.js */ "./node_modules/@aurelia/router/dist/esm/scope.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");



class ViewportScope {
    constructor(name, router, connectedCE, owningScope, scope, rootComponentType = null, // temporary. Metadata will probably eliminate it
    options = {
        catches: [],
        source: null,
    }) {
        this.name = name;
        this.router = router;
        this.connectedCE = connectedCE;
        this.rootComponentType = rootComponentType;
        this.options = options;
        this.path = null;
        this.content = null;
        this.nextContent = null;
        this.available = true;
        this.sourceItem = null;
        this.sourceItemIndex = -1;
        this.remove = false;
        this.add = false;
        this.connectedScope = new _scope_js__WEBPACK_IMPORTED_MODULE_0__.Scope(router, scope, owningScope, null, this);
        if (this.catches.length > 0) {
            this.content = router.createViewportInstruction(this.catches[0], this.name);
        }
    }
    get scope() {
        return this.connectedScope.scope;
    }
    get owningScope() {
        return this.connectedScope.owningScope;
    }
    get enabled() {
        return this.connectedScope.enabled;
    }
    set enabled(enabled) {
        this.connectedScope.enabled = enabled;
    }
    get isViewport() {
        return false;
    }
    get isViewportScope() {
        return true;
    }
    get isEmpty() {
        return this.content === null;
    }
    get passThroughScope() {
        return this.rootComponentType === null && this.catches.length === 0;
    }
    get siblings() {
        const parent = this.connectedScope.parent;
        if (parent === null) {
            return [this];
        }
        return parent.enabledChildren
            .filter(child => child.isViewportScope && child.viewportScope.name === this.name)
            .map(child => child.viewportScope);
    }
    get source() {
        return this.options.source || null;
    }
    get catches() {
        let catches = this.options.catches || [];
        if (typeof catches === 'string') {
            catches = catches.split(',');
        }
        return catches;
    }
    get default() {
        if (this.catches.length > 0) {
            return this.catches[0];
        }
    }
    get nextContentActivated() {
        return this.scope.parent?.owner?.nextContentActivated ?? false;
    }
    get parentNextContentActivated() {
        return this.scope.parent?.owner?.nextContentActivated ?? false;
    }
    get nextContentAction() {
        return '';
    }
    toString() {
        const contentName = this.content?.componentName ?? '';
        const nextContentName = this.nextContent?.componentName ?? '';
        return `vs:${this.name}[${contentName}->${nextContentName}]`;
    }
    setNextContent(viewportInstruction, navigation) {
        viewportInstruction.viewportScope = this;
        this.remove = this.router.instructionResolver.isClearViewportInstruction(viewportInstruction)
            || this.router.instructionResolver.isClearAllViewportsInstruction(viewportInstruction);
        this.add = this.router.instructionResolver.isAddViewportInstruction(viewportInstruction)
            && Array.isArray(this.source);
        if (this.add) {
            viewportInstruction.componentName = null;
        }
        if (this.default !== void 0 && viewportInstruction.componentName === null) {
            viewportInstruction.componentName = this.default;
        }
        this.nextContent = viewportInstruction;
        return 'swap';
    }
    transition(coordinator) {
        // console.log('ViewportScope swap'/*, this, coordinator*/);
        _runner_js__WEBPACK_IMPORTED_MODULE_2__.Runner.run(() => coordinator.addEntityState(this, 'guardedUnload'), () => coordinator.addEntityState(this, 'guardedLoad'), () => coordinator.addEntityState(this, 'guarded'), () => coordinator.addEntityState(this, 'loaded'), () => coordinator.addEntityState(this, 'unloaded'), () => coordinator.addEntityState(this, 'routed'), () => coordinator.addEntityState(this, 'swapped'), () => {
            this.content = !this.remove ? this.nextContent : null;
            this.nextContent = null;
            coordinator.addEntityState(this, 'completed');
        });
    }
    canUnload() {
        return true;
    }
    canLoad() {
        return true;
    }
    unload() {
        return;
    }
    load() {
        return;
    }
    // public loadContent(): Promise<boolean> {
    //   this.content = !this.remove ? this.nextContent : null;
    //   this.nextContent = null;
    //   return Promise.resolve(true);
    // }
    finalizeContentChange() {
        // console.log('ViewportScope finalizing', this.content);
        if (this.remove && Array.isArray(this.source)) {
            this.removeSourceItem();
        }
    }
    abortContentChange() {
        this.nextContent = null;
        if (this.add) {
            const index = this.source.indexOf(this.sourceItem);
            this.source.splice(index, 1);
            this.sourceItem = null;
        }
        return Promise.resolve();
    }
    acceptSegment(segment) {
        if (segment === null && segment === void 0 || segment.length === 0) {
            return true;
        }
        if (segment === this.router.instructionResolver.clearViewportInstruction
            || segment === this.router.instructionResolver.addViewportInstruction
            || segment === this.name) {
            return true;
        }
        if (this.catches.length === 0) {
            return true;
        }
        if (this.catches.includes(segment)) {
            return true;
        }
        if (this.catches.filter((value) => value.includes('*')).length) {
            return true;
        }
        return false;
    }
    binding() {
        const source = this.source || [];
        if (source.length > 0 && this.sourceItem === null) {
            this.sourceItem = this.getAvailableSourceItem();
        }
    }
    unbinding() {
        if (this.sourceItem !== null && this.source !== null) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.arrayRemove)(this.source, (item) => item === this.sourceItem);
        }
        this.sourceItem = null;
    }
    getAvailableSourceItem() {
        if (this.source === null) {
            return null;
        }
        const siblings = this.siblings;
        for (const item of this.source) {
            if (siblings.every(sibling => sibling.sourceItem !== item)) {
                return item;
            }
        }
        return null;
    }
    addSourceItem() {
        const item = {};
        this.source.push(item);
        return item;
    }
    removeSourceItem() {
        this.sourceItemIndex = this.source.indexOf(this.sourceItem);
        if (this.sourceItemIndex >= 0) {
            this.source.splice(this.sourceItemIndex, 1);
        }
    }
    getRoutes() {
        if (this.rootComponentType !== null) {
            return this.rootComponentType.routes;
        }
        return null;
    }
}
//# sourceMappingURL=viewport-scope.js.map

/***/ }),

/***/ "./node_modules/@aurelia/router/dist/esm/viewport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@aurelia/router/dist/esm/viewport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Viewport": () => /* binding */ Viewport
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@aurelia/router/dist/esm/utils.js");
/* harmony import */ var _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewport-content.js */ "./node_modules/@aurelia/router/dist/esm/viewport-content.js");
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scope.js */ "./node_modules/@aurelia/router/dist/esm/scope.js");
/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./runner.js */ "./node_modules/@aurelia/router/dist/esm/runner.js");





class Viewport {
    constructor(router, name, connectedCE, owningScope, scope, options = {}) {
        this.router = router;
        this.name = name;
        this.connectedCE = connectedCE;
        this.options = options;
        this.nextContent = null;
        this.nextContentAction = '';
        this.forceRemove = false;
        this.path = null;
        this.clear = false;
        this.connectionResolve = null;
        this.previousViewportState = null;
        this.cache = [];
        this.historyCache = [];
        this.content = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent();
        this.connectedScope = new _scope_js__WEBPACK_IMPORTED_MODULE_3__.Scope(router, scope, owningScope, this);
    }
    get scope() {
        return this.connectedScope.scope;
    }
    get owningScope() {
        return this.connectedScope.owningScope;
    }
    get connectedController() {
        return this.connectedCE?.$controller ?? null;
    }
    get enabled() {
        return this.connectedScope.enabled;
    }
    set enabled(enabled) {
        this.connectedScope.enabled = enabled;
    }
    get isViewport() {
        return true;
    }
    get isViewportScope() {
        return false;
    }
    get isEmpty() {
        return this.content.componentInstance === null;
    }
    get doForceRemove() {
        let scope = this.connectedScope;
        while (scope !== null) {
            if (scope.viewport !== null && scope.viewport.forceRemove) {
                return true;
            }
            scope = scope.parent;
        }
        return false;
    }
    get activeContent() {
        return this.nextContent ?? this.content;
    }
    get nextContentActivated() {
        return this.nextContent?.contentStates.has('activated') ?? false;
    }
    get parentNextContentActivated() {
        return this.scope.parent?.owner?.nextContentActivated ?? false;
    }
    get performLoad() {
        return true;
        // return this.nextContentAction !== 'skip' && this.connectedScope.parentNextContentAction !== 'swap';
        // // return this.nextContentAction !== 'skip' && ((this.nextContent?.content.topInstruction ?? false) || this.clear);
    }
    get performSwap() {
        return true;
        // return this.nextContentAction !== 'skip' && this.connectedScope.parentNextContentAction !== 'swap';
        // // return this.nextContentAction !== 'skip' && ((this.nextContent?.content.topInstruction ?? false) || this.clear);
    }
    toString() {
        const contentName = this.content?.content.componentName ?? '';
        const nextContentName = this.nextContent?.content.componentName ?? '';
        return `v:${this.name}[${contentName}->${nextContentName}]`;
    }
    setNextContent(viewportInstruction, navigation) {
        viewportInstruction.setViewport(this);
        this.clear = this.router.instructionResolver.isClearViewportInstruction(viewportInstruction);
        // Can have a (resolved) type or a string (to be resolved later)
        this.nextContent = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent(!this.clear ? viewportInstruction : void 0, navigation, this.connectedCE ?? null);
        this.nextContent.fromHistory = this.nextContent.componentInstance && navigation.navigation
            ? !!navigation.navigation.back || !!navigation.navigation.forward
            : false;
        if (this.options.stateful) {
            // TODO: Add a parameter here to decide required equality
            const cached = this.cache.find((item) => this.nextContent.isCacheEqual(item));
            if (cached) {
                this.nextContent = cached;
                this.nextContent.fromCache = true;
            }
            else {
                this.cache.push(this.nextContent);
            }
        }
        // Children that will be replaced (unless added again) by next content. Will
        // be re-enabled on cancel
        this.connectedScope.clearReplacedChildren();
        // If we get the same _instance_, don't do anything (happens with cached and history)
        if (this.nextContent.componentInstance !== null && this.content.componentInstance === this.nextContent.componentInstance) {
            this.nextContent = null;
            return this.nextContentAction = 'skip'; // false;
        }
        if (!this.content.equalComponent(this.nextContent) ||
            this.connectedScope.parentNextContentAction === 'swap' || // Some parent has been swapped, need to be new component
            navigation.navigation.refresh || // Navigation 'refresh' performed
            this.content.reentryBehavior() === "refresh" /* refresh */ // ReentryBehavior 'refresh' takes precedence
        ) {
            this.connectedScope.disableReplacedChildren();
            return this.nextContentAction = 'swap'; // true;
        }
        // Component is the same name/type
        // Explicitly don't allow navigation back to the same component again
        if (this.content.reentryBehavior() === "disallow" /* disallow */) {
            this.nextContent = null;
            return this.nextContentAction = 'skip'; // false;
        }
        // Explicitly re-load same component again
        if (this.content.reentryBehavior() === "load" /* load */) {
            this.content.reentry = true;
            this.nextContent.content.setComponent(this.content.componentInstance);
            // this.nextContent.contentStatus = this.content.contentStatus;
            this.nextContent.contentStates = this.content.contentStates.clone();
            // this.nextContent.contentStates = new Map(this.content.contentStates);
            this.nextContent.reentry = this.content.reentry;
            return this.nextContentAction = 'reload'; // true;
        }
        // ReentryBehavior is now 'default'
        // Requires updated parameters if viewport stateful
        if (this.options.stateful &&
            this.content.equalParameters(this.nextContent)) {
            this.nextContent = null;
            return this.nextContentAction = 'skip'; // false;
        }
        if (!this.content.equalParameters(this.nextContent)) {
            // TODO: Fix a config option for this
            // eslint-disable-next-line no-constant-condition
            if (false) {}
            else { // Perform a full swap
                this.connectedScope.disableReplacedChildren();
                return this.nextContentAction = 'swap';
            }
        }
        // Default is to do nothing
        return 'skip';
        // // Default is to trigger a refresh (without a check of parameters)
        // this.connectedScope.disableReplacedChildren();
        // return this.nextContentAction = 'reload'; // true;
    }
    setConnectedCE(connectedCE, options) {
        options = options || {};
        if (this.connectedCE !== connectedCE) {
            // TODO: Restore this state on navigation cancel
            this.previousViewportState = { ...this };
            this.clearState();
            this.connectedCE = connectedCE;
            if (options.usedBy) {
                this.options.usedBy = options.usedBy;
            }
            if (options.default) {
                this.options.default = options.default;
            }
            if (options.fallback) {
                this.options.fallback = options.fallback;
            }
            if (options.noLink) {
                this.options.noLink = options.noLink;
            }
            if (options.noTitle) {
                this.options.noTitle = options.noTitle;
            }
            if (options.noHistory) {
                this.options.noHistory = options.noHistory;
            }
            if (options.stateful) {
                this.options.stateful = options.stateful;
            }
            if (this.connectionResolve) {
                this.connectionResolve();
            }
        }
        // TODO: Might not need this? Figure it out
        // if (container) {
        //   container['viewportName'] = this.name;
        // }
        if (!this.content.componentInstance && (!this.nextContent || !this.nextContent.componentInstance) && this.options.default) {
            const instructions = this.router.instructionResolver.parseViewportInstructions(this.options.default);
            for (const instruction of instructions) {
                // Set to name to be delayed one turn
                instruction.setViewport(this.name);
                instruction.scope = this.owningScope;
                instruction.default = true;
            }
            this.router.load(instructions, { append: true }).catch(error => { throw error; });
        }
    }
    remove(connectedCE) {
        if (this.connectedCE === connectedCE) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => {
                if (this.content.componentInstance) {
                    return this.content.freeContent(this.connectedCE, (this.nextContent ? this.nextContent.instruction : null), this.historyCache, this.doForceRemove ? false : this.router.statefulHistory || this.options.stateful); // .catch(error => { throw error; });
                }
            }, () => {
                if (this.doForceRemove) {
                    const removes = [];
                    for (const content of this.historyCache) {
                        removes.push(() => content.freeContent(null, null, this.historyCache, false));
                    }
                    removes.push(() => { this.historyCache = []; });
                    return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(...removes);
                    // return Promise.all(this.historyCache.map(content => content.freeContent(
                    //   null,
                    //   null,
                    //   this.historyCache,
                    //   false,
                    // )));
                    // this.historyCache = [];
                }
                return true;
            });
        }
        return false;
    }
    transition(coordinator) {
        // console.log('Viewport transition', this.toString());
        // let run: unknown;
        const guarded = coordinator.checkingSyncState('guarded');
        const performLoad = this.performLoad || !guarded;
        const performSwap = this.performSwap || !guarded;
        // const performSwap = this.performSwap || !this.router.isRestrictedNavigation || this.clear;
        const guardSteps = [
            () => performLoad ? this.canUnload() : true,
            (canUnloadResult) => {
                if (!canUnloadResult) {
                    _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.cancel(void 0);
                    coordinator.cancel();
                    return;
                }
                if (this.router.isRestrictedNavigation) {
                    this.nextContent.createComponent(this.connectedCE, this.options.fallback);
                }
                coordinator.addEntityState(this, 'guardedUnload');
            },
            () => coordinator.syncState('guardedUnload', this),
            () => performLoad ? this.canLoad(guarded) : true,
            (canLoadResult) => {
                if (typeof canLoadResult === 'boolean') {
                    if (!canLoadResult) {
                        _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.cancel(void 0);
                        coordinator.cancel();
                        return;
                    }
                    coordinator.addEntityState(this, 'guardedLoad');
                    coordinator.addEntityState(this, 'guarded');
                }
                else { // Denied and (probably) redirected
                    _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.router.load(canLoadResult, { append: true }), () => this.abortContentChange());
                }
            },
        ];
        const routingSteps = [
            // () => { console.log("I'm waiting for guarded", this.toString()); },
            () => coordinator.syncState('guarded', this),
            // () => { console.log("I'm guarded", this.toString()); },
            // TODO: For consistency it should probably be this option with 'routed'
            // () => performSwap ? this.unload(coordinator.checkingSyncState('routed')) : true,
            () => performLoad ? this.unload(true) : true,
            () => coordinator.addEntityState(this, 'unloaded'),
            // () => { console.log("I'm waiting for unloaded", this.toString()); },
            () => coordinator.syncState('unloaded', this),
            // () => { console.log("I'm done waiting for unloaded", this.toString()); },
            () => performLoad ? this.load(coordinator.checkingSyncState('routed')) : true,
            () => coordinator.addEntityState(this, 'loaded'),
            () => coordinator.addEntityState(this, 'routed'),
        ];
        const lifecycleSteps = [
            () => coordinator.syncState('routed', this),
        ];
        if (performSwap) {
            if (this.router.options.swapStrategy.includes('parallel')) {
                lifecycleSteps.push(() => {
                    if (this.router.options.swapStrategy.includes('add')) {
                        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(this.addContent(), this.removeContent());
                    }
                    else {
                        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(this.removeContent(), this.addContent());
                    }
                });
            }
            else {
                lifecycleSteps.push(() => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.addContent() : this.removeContent()) : void 0, () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.removeContent() : this.addContent()) : void 0);
            }
        }
        lifecycleSteps.push(() => coordinator.addEntityState(this, 'swapped'));
        // const lifecycleSteps = [
        //   () => coordinator.syncState('routed'),
        //   // () => coordinator.addEntityState(this, 'bound'),
        //   () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.addContent() : this.removeContent()) : true,
        //   () => performSwap ? (this.router.options.swapStrategy.includes('add') ? this.removeContent() : this.addContent()) : true,
        //   () => coordinator.addEntityState(this, 'swapped'),
        // ];
        // run =
        _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(...guardSteps, ...routingSteps, ...lifecycleSteps, () => coordinator.addEntityState(this, 'completed'));
    }
    canUnload() {
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => {
            // console.log('viewport canUnload run', this.name, 'before');
            const result = this.connectedScope.canUnload();
            // console.log('viewport canUnload run', this.name, 'after');
            return result;
        }, (canUnloadChildren) => {
            // console.log('viewport canUnload result', this.name, canUnloadChildren);
            if (!canUnloadChildren) {
                return false;
            }
            // This shouldn't happen
            // // Don't stop it because we're not going to actually do anything
            // if (this.content.componentInstance === this.nextContent?.componentInstance) {
            //   return true;
            // }
            return this.content.canUnload(this.nextContent?.instruction ?? null);
        });
    }
    canLoad(recurse) {
        // console.log(this.connectedScope.toString(), 'viewport content canLoad', this.nextContent?.content?.componentName);
        if (this.clear) {
            return true;
        }
        if ((this.nextContent?.content ?? null) === null) {
            return true;
        }
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.waitForConnected(), () => {
            this.nextContent.createComponent(this.connectedCE, this.options.fallback);
            // This shouldn't happen
            // // Don't stop it because we're not going to actually do anything
            // if (this.content.componentInstance === this.nextContent!.componentInstance) {
            //   return true;
            // }
            return this.nextContent.canLoad(this, this.content.instruction);
        });
    }
    load(recurse) {
        // console.log(this.connectedScope.toString(), 'viewport content load', this.nextContent?.content?.componentName);
        if (this.clear || (this.nextContent?.componentInstance ?? null) === null) {
            return;
        }
        // This shouldn't happen
        // // TODO: Verify this
        // if (this.nextContent === this.content) {
        //   return;
        // }
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.nextContent?.load(this.content.instruction));
        // return this.nextContent?.load(this.content.instruction);
        // await this.nextContent.activateComponent(null, this.connectedCE!.$controller as ICustomElementController<ICustomElementViewModel>, LifecycleFlags.none, this.connectedCE!);
        // return true;
    }
    addContent() {
        // console.log('addContent', this.toString());
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.activate(null, this.connectedController, 0 /* none */, this.parentNextContentActivated));
    }
    removeContent() {
        if (this.isEmpty) {
            return;
        }
        // console.log('removeContent', this.toString());
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.connectedScope.removeContent(), () => this.deactivate(null, null /* TODO: verify this.connectedController */, 0 /* none */), () => this.dispose());
    }
    removeChildrenContent() {
        // console.log(this.name, 'removeContent', this.content.content);
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => !this.isEmpty ? this.connectedScope.removeContent() : void 0);
    }
    activate(initiator, parent, flags, fromParent) {
        // console.log('activate' /* , { ...this } */);
        if (this.activeContent.componentInstance !== null) {
            this.connectedScope.reenableReplacedChildren();
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.activeContent.load(this.activeContent.instruction), // Only acts if not already loaded
            () => this.activeContent.activateComponent(initiator, parent, flags, this.connectedCE, fromParent));
        }
    }
    deactivate(initiator, parent, flags) {
        if (this.content.componentInstance &&
            !this.content.reentry &&
            this.content.componentInstance !== this.nextContent?.componentInstance) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.content?.unload(this.content.instruction), // Only acts if not already unloaded
            () => this.content?.deactivateComponent(initiator, parent, flags, this.connectedCE, this.router.statefulHistory || this.options.stateful));
        }
    }
    unload(recurse) {
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => recurse ? this.connectedScope.unload(recurse) : true, () => {
            // console.log(this.connectedScope.toString(), 'viewport content unload', this.content.content.componentName);
            // This shouldn't happen
            // // TODO: Verify this
            // if (this.nextContent === this.content) {
            //   return;
            // }
            if (this.content.componentInstance) {
                return this.content.unload(this.nextContent?.instruction ?? null);
            }
        });
    }
    dispose() {
        if (this.content.componentInstance &&
            !this.content.reentry &&
            this.content.componentInstance !== this.nextContent?.componentInstance) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(
            // () => this.content!.unloadComponent(
            //   this.historyCache,
            //   this.router.statefulHistory || this.options.stateful),
            // () => this.content!.destroyComponent(),
            () => this.content.disposeComponent(this.connectedCE, this.historyCache, this.router.statefulHistory || this.options.stateful));
            // await this.content!.freeContent(
            //   this.connectedCE,
            //   this.nextContent!.instruction,
            //   this.historyCache,
            //   this.router.statefulHistory || this.options.stateful);
        }
    }
    finalizeContentChange() {
        // console.log('finalizeContent', this.nextContent!.content?.componentName);
        if (this.nextContent.componentInstance) {
            this.content = this.nextContent;
            this.content.reentry = false;
        }
        if (this.clear) {
            this.content = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent(void 0, this.nextContent.instruction);
        }
        this.nextContent = null;
        this.nextContentAction = '';
        this.previousViewportState = null;
        this.connectedScope.clearReplacedChildren();
    }
    abortContentChange() {
        this.connectedScope.reenableReplacedChildren();
        return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => this.nextContent.freeContent(this.connectedCE, this.nextContent.instruction, this.historyCache, this.router.statefulHistory || this.options.stateful), () => {
            if (this.previousViewportState) {
                Object.assign(this, this.previousViewportState);
            }
            this.nextContentAction = '';
        });
    }
    // TODO: Deal with non-string components
    wantComponent(component) {
        let usedBy = this.options.usedBy || [];
        if (typeof usedBy === 'string') {
            usedBy = usedBy.split(',');
        }
        return usedBy.includes(component);
    }
    // TODO: Deal with non-string components
    acceptComponent(component) {
        if (component === '-' || component === null) {
            return true;
        }
        let usedBy = this.options.usedBy;
        if (!usedBy || !usedBy.length) {
            return true;
        }
        if (typeof usedBy === 'string') {
            usedBy = usedBy.split(',');
        }
        if (usedBy.includes(component)) {
            return true;
        }
        if (usedBy.filter((value) => value.includes('*')).length) {
            return true;
        }
        return false;
    }
    freeContent(component) {
        const content = this.historyCache.find(cached => cached.componentInstance === component);
        if (content !== void 0) {
            return _runner_js__WEBPACK_IMPORTED_MODULE_4__.Runner.run(() => {
                this.forceRemove = true;
                return content.freeContent(null, null, this.historyCache, false);
            }, () => {
                this.forceRemove = false;
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.arrayRemove)(this.historyCache, (cached => cached === content));
            });
        }
    }
    getRoutes() {
        const componentType = this.getComponentType();
        if (componentType === null) {
            return null;
        }
        const routes = componentType.routes;
        return Array.isArray(routes) ? routes : null;
    }
    getTitle(navigationInstruction) {
        if (this.options.noTitle) {
            return '';
        }
        const componentType = this.getComponentType();
        if (componentType === null) {
            return '';
        }
        let title = '';
        const typeTitle = componentType.title;
        if (typeTitle !== void 0) {
            if (typeof typeTitle === 'string') {
                title = typeTitle;
            }
            else {
                const component = this.getComponentInstance();
                title = typeTitle.call(component, component, navigationInstruction);
            }
        }
        else if (this.router.options.title.useComponentNames) {
            let name = this.getContentInstruction().componentName ?? '';
            const prefix = this.router.options.title.componentPrefix ?? '';
            if (name.startsWith(prefix)) {
                name = name.slice(prefix.length);
            }
            name = name.replace('-', ' ');
            title = name.slice(0, 1).toLocaleUpperCase() + name.slice(1);
        }
        if (this.router.options.title.transformTitle !== void 0) {
            title = this.router.options.title.transformTitle.call(this, title, this.getContentInstruction());
        }
        return title;
    }
    getComponentType() {
        let componentType = this.getContentInstruction().componentType ?? null;
        // TODO: This is going away once Metadata is in!
        if (componentType === null) {
            const controller = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.for(this.connectedCE.element);
            componentType = controller.context
                .componentType;
        }
        return componentType ?? null;
    }
    getComponentInstance() {
        return this.getContentInstruction().componentInstance ?? null;
    }
    getContentInstruction() {
        return this.nextContent?.content ?? this.content.content ?? null;
    }
    clearState() {
        this.options = {};
        this.content = new _viewport_content_js__WEBPACK_IMPORTED_MODULE_2__.ViewportContent();
        this.cache = [];
    }
    waitForConnected() {
        if (this.connectedCE === null) {
            return new Promise((resolve) => {
                this.connectionResolve = resolve;
            });
        }
    }
}
//# sourceMappingURL=viewport.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/app-root.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAppRoot": () => /* binding */ IAppRoot,
/* harmony export */   "AppRoot": () => /* binding */ AppRoot
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _app_task_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-task.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");





const IAppRoot = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAppRoot');
class AppRoot {
    constructor(config, platform, container, rootProvider, enhance = false) {
        this.config = config;
        this.platform = platform;
        this.container = container;
        this.controller = (void 0);
        this.hydratePromise = void 0;
        this.host = config.host;
        rootProvider.prepare(this);
        if (container.has(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode, false) && container.get(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode) !== config.host) {
            this.container = container.createChild();
        }
        this.container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode, config.host));
        if (enhance) {
            const component = config.component;
            this.enhanceDefinition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.getDefinition(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.isType(component)
                ? _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.define({ ..._resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.getDefinition(component), template: this.host, enhance: true }, component)
                : _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.define({ name: (void 0), template: this.host, enhance: true }));
        }
        this.hydratePromise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('beforeCreate'), () => {
            const instance = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.isType(config.component)
                ? this.container.get(config.component)
                : config.component;
            const controller = (this.controller = _templating_controller_js__WEBPACK_IMPORTED_MODULE_4__.Controller.forCustomElement(this, container, instance, this.host, null, 0 /* none */, false, this.enhanceDefinition));
            controller.hydrateCustomElement(container, null);
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('hydrating'), () => {
                controller.hydrate(null);
                return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('hydrated'), () => {
                    controller.hydrateChildren();
                    this.hydratePromise = void 0;
                });
            });
        });
    }
    activate() {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.hydratePromise, () => {
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('beforeActivate'), () => {
                return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.controller.activate(this.controller, null, 32 /* fromBind */, void 0), () => {
                    return this.runAppTasks('afterActivate');
                });
            });
        });
    }
    deactivate() {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.runAppTasks('beforeDeactivate'), () => {
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.controller.deactivate(this.controller, null, 0 /* none */), () => {
                return this.runAppTasks('afterDeactivate');
            });
        });
    }
    /** @internal */
    runAppTasks(slot) {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.resolveAll)(...this.container.getAll(_app_task_js__WEBPACK_IMPORTED_MODULE_2__.IAppTask).reduce((results, task) => {
            if (task.slot === slot) {
                results.push(task.run());
            }
            return results;
        }, []));
    }
    dispose() {
        this.controller?.dispose();
    }
}
//# sourceMappingURL=app-root.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/app-task.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAppTask": () => /* binding */ IAppTask,
/* harmony export */   "AppTask": () => /* binding */ AppTask
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const IAppTask = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAppTask');
class $AppTask {
    constructor(key) {
        this.key = key;
        this.slot = (void 0);
        this.callback = (void 0);
        this.container = (void 0);
    }
    static with(key) {
        return new $AppTask(key);
    }
    beforeCreate() {
        return this.at('beforeCreate');
    }
    hydrating() {
        return this.at('hydrating');
    }
    hydrated() {
        return this.at('hydrated');
    }
    beforeActivate() {
        return this.at('beforeActivate');
    }
    afterActivate() {
        return this.at('afterActivate');
    }
    beforeDeactivate() {
        return this.at('beforeDeactivate');
    }
    afterDeactivate() {
        return this.at('afterDeactivate');
    }
    at(slot) {
        this.slot = slot;
        return this;
    }
    call(fn) {
        this.callback = fn;
        return this;
    }
    register(container) {
        return this.container = container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IAppTask, this));
    }
    run() {
        const callback = this.callback;
        const instance = this.container.get(this.key);
        return callback(instance);
    }
}
const AppTask = $AppTask;
//# sourceMappingURL=app-task.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAttrSyntaxTransformer": () => /* binding */ IAttrSyntaxTransformer,
/* harmony export */   "AttrSyntaxTransformer": () => /* binding */ AttrSyntaxTransformer
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const IAttrSyntaxTransformer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAttrSyntaxTransformer', x => x.singleton(AttrSyntaxTransformer));
class AttrSyntaxTransformer {
    constructor() {
        /**
         * @internal
         */
        this.fns = [];
    }
    /**
     * Add a given function to a list of fns that will be used
     * to check if `'bind'` command can be transformed to `'two-way'` command.
     *
     * If one of those functions in this lists returns true, the `'bind'` command
     * will be transformed into `'two-way'` command.
     *
     * The function will be called with 2 parameters:
     * - element: the element that the template compiler is currently working with
     * - property: the target property name
     */
    useTwoWay(fn) {
        this.fns.push(fn);
    }
    /**
     * @internal
     */
    transform(node, attrSyntax) {
        if (attrSyntax.command === 'bind' &&
            (
            // note: even though target could possibly be mapped to a different name
            // the final property name shouldn't affect the two way transformation
            // as they both should work with original source attribute name
            shouldDefaultToTwoWay(node, attrSyntax.target) ||
                this.fns.length > 0 && this.fns.some(fn => fn(node, attrSyntax.target)))) {
            attrSyntax.command = 'two-way';
        }
        attrSyntax.target = this.map(node.tagName, attrSyntax.target);
    }
    /**
     * todo: this should be in the form of a lookup. the following is not extensible
     *
     * @internal
     */
    map(tagName, attr) {
        switch (tagName) {
            case 'LABEL':
                switch (attr) {
                    case 'for':
                        return 'htmlFor';
                    default:
                        return attr;
                }
            case 'IMG':
                switch (attr) {
                    case 'usemap':
                        return 'useMap';
                    default:
                        return attr;
                }
            case 'INPUT':
                switch (attr) {
                    case 'maxlength':
                        return 'maxLength';
                    case 'minlength':
                        return 'minLength';
                    case 'formaction':
                        return 'formAction';
                    case 'formenctype':
                        return 'formEncType';
                    case 'formmethod':
                        return 'formMethod';
                    case 'formnovalidate':
                        return 'formNoValidate';
                    case 'formtarget':
                        return 'formTarget';
                    case 'inputmode':
                        return 'inputMode';
                    default:
                        return attr;
                }
            case 'TEXTAREA':
                switch (attr) {
                    case 'maxlength':
                        return 'maxLength';
                    default:
                        return attr;
                }
            case 'TD':
            case 'TH':
                switch (attr) {
                    case 'rowspan':
                        return 'rowSpan';
                    case 'colspan':
                        return 'colSpan';
                    default:
                        return attr;
                }
            default:
                switch (attr) {
                    case 'accesskey':
                        return 'accessKey';
                    case 'contenteditable':
                        return 'contentEditable';
                    case 'tabindex':
                        return 'tabIndex';
                    case 'textcontent':
                        return 'textContent';
                    case 'innerhtml':
                        return 'innerHTML';
                    case 'scrolltop':
                        return 'scrollTop';
                    case 'scrollleft':
                        return 'scrollLeft';
                    case 'readonly':
                        return 'readOnly';
                    default:
                        return attr;
                }
        }
    }
}
function shouldDefaultToTwoWay(element, attr) {
    switch (element.tagName) {
        case 'INPUT':
            switch (element.type) {
                case 'checkbox':
                case 'radio':
                    return attr === 'checked';
                default:
                    return attr === 'value' || attr === 'files';
            }
        case 'TEXTAREA':
        case 'SELECT':
            return attr === 'value';
        default:
            switch (attr) {
                case 'textcontent':
                case 'innerhtml':
                    return element.hasAttribute('contenteditable');
                case 'scrolltop':
                case 'scrollleft':
                    return true;
                default:
                    return false;
            }
    }
}
//# sourceMappingURL=attribute-syntax-transformer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/aurelia.js":
/*!****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/aurelia.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IAurelia": () => /* binding */ IAurelia,
/* harmony export */   "Aurelia": () => /* binding */ Aurelia
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform-browser */ "./node_modules/@aurelia/platform-browser/dist/esm/index.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");




const IAurelia = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAurelia');
class Aurelia {
    constructor(container = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer()) {
        this.container = container;
        this._isRunning = false;
        this._isStarting = false;
        this._isStopping = false;
        this._root = void 0;
        this.next = void 0;
        this.startPromise = void 0;
        this.stopPromise = void 0;
        if (container.has(IAurelia, true)) {
            throw new Error('An instance of Aurelia is already registered with the container or an ancestor of it.');
        }
        container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IAurelia, this));
        container.registerResolver(_app_root_js__WEBPACK_IMPORTED_MODULE_2__.IAppRoot, this.rootProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IAppRoot'));
    }
    get isRunning() { return this._isRunning; }
    get isStarting() { return this._isStarting; }
    get isStopping() { return this._isStopping; }
    get root() {
        if (this._root == void 0) {
            if (this.next == void 0) {
                throw new Error(`root is not defined`); // TODO: create error code
            }
            return this.next;
        }
        return this._root;
    }
    register(...params) {
        this.container.register(...params);
        return this;
    }
    app(config) {
        this.next = new _app_root_js__WEBPACK_IMPORTED_MODULE_2__.AppRoot(config, this.initPlatform(config.host), this.container, this.rootProvider, false);
        return this;
    }
    enhance(config) {
        this.next = new _app_root_js__WEBPACK_IMPORTED_MODULE_2__.AppRoot(config, this.initPlatform(config.host), this.container, this.rootProvider, true);
        return this;
    }
    async waitForIdle() {
        const platform = this.root.platform;
        await platform.domWriteQueue.yield();
        await platform.domReadQueue.yield();
        await platform.macroTaskQueue.yield();
    }
    initPlatform(host) {
        let p;
        if (!this.container.has(_platform_js__WEBPACK_IMPORTED_MODULE_3__.IPlatform, false)) {
            if (host.ownerDocument.defaultView === null) {
                throw new Error(`Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView`);
            }
            p = new _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserPlatform(host.ownerDocument.defaultView);
            this.container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(_platform_js__WEBPACK_IMPORTED_MODULE_3__.IPlatform, p));
        }
        else {
            p = this.container.get(_platform_js__WEBPACK_IMPORTED_MODULE_3__.IPlatform);
        }
        return p;
    }
    start(root = this.next) {
        if (root == void 0) {
            throw new Error(`There is no composition root`);
        }
        if (this.startPromise instanceof Promise) {
            return this.startPromise;
        }
        return this.startPromise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.stop(), () => {
            Reflect.set(root.host, '$aurelia', this);
            this.rootProvider.prepare(this._root = root);
            this._isStarting = true;
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(root.activate(), () => {
                this._isRunning = true;
                this._isStarting = false;
                this.startPromise = void 0;
                this.dispatchEvent(root, 'au-started', root.host);
            });
        });
    }
    stop(dispose = false) {
        if (this.stopPromise instanceof Promise) {
            return this.stopPromise;
        }
        if (this._isRunning === true) {
            const root = this._root;
            this._isRunning = false;
            this._isStopping = true;
            return this.stopPromise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(root.deactivate(), () => {
                Reflect.deleteProperty(root.host, '$aurelia');
                if (dispose) {
                    root.dispose();
                }
                this._root = void 0;
                this.rootProvider.dispose();
                this._isStopping = false;
                this.dispatchEvent(root, 'au-stopped', root.host);
            });
        }
    }
    dispose() {
        if (this._isRunning || this._isStopping) {
            throw new Error(`The aurelia instance must be fully stopped before it can be disposed`);
        }
        this.container.dispose();
    }
    dispatchEvent(root, name, target) {
        const ev = new root.platform.window.CustomEvent(name, { detail: this, bubbles: true, cancelable: true });
        target.dispatchEvent(ev);
    }
}
//# sourceMappingURL=aurelia.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/bindable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bindable": () => /* binding */ bindable,
/* harmony export */   "Bindable": () => /* binding */ Bindable,
/* harmony export */   "BindableDefinition": () => /* binding */ BindableDefinition
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


function bindable(configOrTarget, prop) {
    let config;
    function decorator($target, $prop) {
        if (arguments.length > 1) {
            // Non invocation:
            // - @bindable
            // Invocation with or w/o opts:
            // - @bindable()
            // - @bindable({...opts})
            config.property = $prop;
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Bindable.name, BindableDefinition.create($prop, config), $target.constructor, $prop);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo($target.constructor, Bindable.keyFrom($prop));
    }
    if (arguments.length > 1) {
        // Non invocation:
        // - @bindable
        config = {};
        decorator(configOrTarget, prop);
        return;
    }
    else if (typeof configOrTarget === 'string') {
        // ClassDecorator
        // - @bindable('bar')
        // Direct call:
        // - @bindable('bar')(Foo)
        config = {};
        return decorator;
    }
    // Invocation with or w/o opts:
    // - @bindable()
    // - @bindable({...opts})
    config = configOrTarget === void 0 ? {} : configOrTarget;
    return decorator;
}
function isBindableAnnotation(key) {
    return key.startsWith(Bindable.name);
}
const Bindable = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('bindable'),
    keyFrom(name) {
        return `${Bindable.name}:${name}`;
    },
    from(...bindableLists) {
        const bindables = {};
        const isArray = Array.isArray;
        function addName(name) {
            bindables[name] = BindableDefinition.create(name);
        }
        function addDescription(name, def) {
            bindables[name] = def instanceof BindableDefinition ? def : BindableDefinition.create(name, def);
        }
        function addList(maybeList) {
            if (isArray(maybeList)) {
                maybeList.forEach(addName);
            }
            else if (maybeList instanceof BindableDefinition) {
                bindables[maybeList.property] = maybeList;
            }
            else if (maybeList !== void 0) {
                Object.keys(maybeList).forEach(name => addDescription(name, maybeList[name]));
            }
        }
        bindableLists.forEach(addList);
        return bindables;
    },
    for(Type) {
        let def;
        const builder = {
            add(configOrProp) {
                let prop;
                let config;
                if (typeof configOrProp === 'string') {
                    prop = configOrProp;
                    config = { property: prop };
                }
                else {
                    prop = configOrProp.property;
                    config = configOrProp;
                }
                def = BindableDefinition.create(prop, config);
                if (!_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(Bindable.name, Type, prop)) {
                    _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo(Type, Bindable.keyFrom(prop));
                }
                _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Bindable.name, def, Type, prop);
                return builder;
            },
            mode(mode) {
                def.mode = mode;
                return builder;
            },
            callback(callback) {
                def.callback = callback;
                return builder;
            },
            attribute(attribute) {
                def.attribute = attribute;
                return builder;
            },
            primary() {
                def.primary = true;
                return builder;
            },
            set(setInterpreter) {
                def.set = setInterpreter;
                return builder;
            }
        };
        return builder;
    },
    getAll(Type) {
        const propStart = Bindable.name.length + 1;
        const defs = [];
        const prototypeChain = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.getPrototypeChain)(Type);
        let iProto = prototypeChain.length;
        let iDefs = 0;
        let keys;
        let keysLen;
        let Class;
        while (--iProto >= 0) {
            Class = prototypeChain[iProto];
            keys = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.getKeys(Class).filter(isBindableAnnotation);
            keysLen = keys.length;
            for (let i = 0; i < keysLen; ++i) {
                defs[iDefs++] = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Bindable.name, Class, keys[i].slice(propStart));
            }
        }
        return defs;
    },
};
class BindableDefinition {
    constructor(attribute, callback, mode, primary, property, set) {
        this.attribute = attribute;
        this.callback = callback;
        this.mode = mode;
        this.primary = primary;
        this.property = property;
        this.set = set;
    }
    static create(prop, def = {}) {
        return new BindableDefinition((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.attribute, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(prop)), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.callback, `${prop}Changed`), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.mode, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.primary, false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.property, prop), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.set, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop));
    }
}
/* eslint-disable @typescript-eslint/no-unused-vars,spaced-comment */
/**
 * This function serves two purposes:
 * - A playground for contributors to try their changes to the APIs.
 * - Cause the API surface to be properly type-checked and protected against accidental type regressions.
 *
 * It will be automatically removed by dead code elimination.
 */
function apiTypeCheck() {
    let Foo = 
    // > expected error - class decorator only accepts a string
    //@bindable({})
    class Foo {
    };
    __decorate([
        bindable,
        bindable(),
        bindable({})
        // > expected error - 'property' does not exist on decorator input object
        //@bindable({ property: 'prop' })
        ,
        bindable({ mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay }),
        bindable({ callback: 'propChanged' }),
        bindable({ attribute: 'prop' }),
        bindable({ primary: true }),
        bindable({ set: value => String(value) }),
        bindable({ set: value => Number(value) }),
        bindable({
            mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay,
            callback: 'propChanged',
            attribute: 'prop',
            primary: true,
            set: value => String(value)
        })
    ], Foo.prototype, "prop", void 0);
    Foo = __decorate([
        bindable('prop')
        // > expected error - class decorator only accepts a string
        //@bindable({})
    ], Foo);
    Bindable.for(Foo)
        // > expected error - there is no add() function with only optional params on the fluent api
        //.add()
        // > expected error - 'property' is a required property on the fluent api
        //.add({})
        .add({ property: 'prop' })
        .add({ property: 'prop', mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay })
        .add({ property: 'prop', callback: 'propChanged' })
        .add({ property: 'prop', attribute: 'prop' })
        .add({ property: 'prop', primary: true })
        .add({ property: 'prop', mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay, callback: 'propChanged', attribute: 'prop', primary: true })
        .add('prop')
        // > expected error - the add() method that accepts an object literal does not return a fluent api
        //.add({ property: 'prop' }).mode(BindingMode.twoWay)
        //.add({ property: 'prop' }).callback('propChanged')
        //.add({ property: 'prop' }).attribute('prop')
        //.add({ property: 'prop' }).primary()
        // > expected error - fluent api methods can only be invoked once per bindable
        //.add('prop').mode(BindingMode.twoWay).mode(BindingMode.twoWay)
        //.add('prop').mode(BindingMode.twoWay).callback('propChanged').mode(BindingMode.twoWay)
        //.add('prop').mode(BindingMode.twoWay).callback('propChanged').callback('propChanged') // etc
        // > expected error - wrong invocation order
        //.add('prop').callback('propChanged').mode(BindingMode.twoWay)
        //.add('prop').primary().mode(BindingMode.twoWay)  // etc
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay)
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged')
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged').attribute('prop')
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged').attribute('prop').primary()
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).set((value) => Number(value))
        .add('prop').mode(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay).callback('propChanged').set(value => Number(value))
        .add('prop').callback('propChanged')
        .add('prop').callback('propChanged').attribute('prop')
        .add('prop').callback('propChanged').attribute('prop').primary()
        .add('prop').attribute('prop')
        .add('prop').attribute('prop').primary()
        .add('prop').primary();
}
/* eslint-enable @typescript-eslint/no-unused-vars,spaced-comment */
//# sourceMappingURL=bindable.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingModeBehavior": () => /* binding */ BindingModeBehavior,
/* harmony export */   "OneTimeBindingBehavior": () => /* binding */ OneTimeBindingBehavior,
/* harmony export */   "ToViewBindingBehavior": () => /* binding */ ToViewBindingBehavior,
/* harmony export */   "FromViewBindingBehavior": () => /* binding */ FromViewBindingBehavior,
/* harmony export */   "TwoWayBindingBehavior": () => /* binding */ TwoWayBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

class BindingModeBehavior {
    constructor(mode) {
        this.mode = mode;
        this.originalModes = new Map();
    }
    bind(flags, scope, hostScope, binding) {
        this.originalModes.set(binding, binding.mode);
        binding.mode = this.mode;
    }
    unbind(flags, scope, hostScope, binding) {
        binding.mode = this.originalModes.get(binding);
        this.originalModes.delete(binding);
    }
}
class OneTimeBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.oneTime);
    }
}
class ToViewBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView);
    }
}
class FromViewBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.fromView);
    }
}
class TwoWayBindingBehavior extends BindingModeBehavior {
    constructor() {
        super(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.twoWay);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('oneTime')(OneTimeBindingBehavior);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('toView')(ToViewBindingBehavior);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('fromView')(FromViewBindingBehavior);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('twoWay')(TwoWayBindingBehavior);
//# sourceMappingURL=binding-mode.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebounceBindingBehavior": () => /* binding */ DebounceBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


class DebounceBindingBehavior extends _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingInterceptor {
    constructor(binding, expr) {
        super(binding, expr);
        this.opts = { delay: 0 };
        this.firstArg = null;
        this.task = null;
        this.taskQueue = binding.locator.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform).macroTaskQueue;
        if (expr.args.length > 0) {
            this.firstArg = expr.args[0];
        }
    }
    callSource(args) {
        this.queueTask(() => this.binding.callSource(args));
        return void 0;
    }
    handleChange(newValue, previousValue, flags) {
        this.queueTask(() => this.binding.handleChange(newValue, previousValue, flags));
    }
    queueTask(callback) {
        if (this.task !== null) {
            this.task.cancel();
        }
        this.task = this.taskQueue.queueTask(() => {
            this.task = null;
            return callback();
        }, this.opts);
    }
    $bind(flags, scope, hostScope) {
        if (this.firstArg !== null) {
            const delay = Number(this.firstArg.evaluate(flags, scope, hostScope, this.locator, null));
            if (!isNaN(delay)) {
                this.opts.delay = delay;
            }
        }
        this.binding.$bind(flags, scope, hostScope);
    }
    $unbind(flags) {
        this.task?.cancel();
        this.task = null;
        this.binding.$unbind(flags);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.bindingBehavior)('debounce')(DebounceBindingBehavior);
//# sourceMappingURL=debounce.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SignalBindingBehavior": () => /* binding */ SignalBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

let SignalBindingBehavior = class SignalBindingBehavior {
    constructor(signaler) {
        this.signaler = signaler;
        this.lookup = new Map();
    }
    bind(flags, scope, hostScope, binding, ...names) {
        if (!('handleChange' in binding)) {
            throw new Error(`The signal behavior can only be used with bindings that have a 'handleChange' method`);
        }
        if (names.length === 0) {
            throw new Error(`At least one signal name must be passed to the signal behavior, e.g. \`expr & signal:'my-signal'\``);
        }
        this.lookup.set(binding, names);
        for (const name of names) {
            this.signaler.addSignalListener(name, binding);
        }
    }
    unbind(flags, scope, hostScope, binding) {
        const names = this.lookup.get(binding);
        this.lookup.delete(binding);
        for (const name of names) {
            this.signaler.removeSignalListener(name, binding);
        }
    }
};
SignalBindingBehavior = __decorate([
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.ISignaler)
], SignalBindingBehavior);

(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('signal')(SignalBindingBehavior);
//# sourceMappingURL=signals.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThrottleBindingBehavior": () => /* binding */ ThrottleBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


class ThrottleBindingBehavior extends _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingInterceptor {
    constructor(binding, expr) {
        super(binding, expr);
        this.opts = { delay: 0 };
        this.firstArg = null;
        this.task = null;
        this.lastCall = 0;
        this.platform = binding.locator.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform);
        this.taskQueue = this.platform.macroTaskQueue;
        if (expr.args.length > 0) {
            this.firstArg = expr.args[0];
        }
    }
    callSource(args) {
        this.queueTask(() => this.binding.callSource(args));
        return void 0;
    }
    handleChange(newValue, previousValue, flags) {
        this.queueTask(() => this.binding.handleChange(newValue, previousValue, flags));
    }
    queueTask(callback) {
        const opts = this.opts;
        const platform = this.platform;
        const nextDelay = this.lastCall + opts.delay - platform.performanceNow();
        if (nextDelay > 0) {
            if (this.task !== null) {
                this.task.cancel();
            }
            opts.delay = nextDelay;
            this.task = this.taskQueue.queueTask(() => {
                this.lastCall = platform.performanceNow();
                this.task = null;
                callback();
            }, opts);
        }
        else {
            this.lastCall = platform.performanceNow();
            callback();
        }
    }
    $bind(flags, scope, hostScope) {
        if (this.firstArg !== null) {
            const delay = Number(this.firstArg.evaluate(flags, scope, hostScope, this.locator, null));
            if (!isNaN(delay)) {
                this.opts.delay = delay;
            }
        }
        this.binding.$bind(flags, scope, hostScope);
    }
    $unbind(flags) {
        this.task?.cancel();
        this.task = null;
        super.$unbind(flags);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.bindingBehavior)('throttle')(ThrottleBindingBehavior);
//# sourceMappingURL=throttle.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeBinding": () => /* binding */ AttributeBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_element_attribute_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/element-attribute-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");



// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak
const { oneTime, toView, fromView } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode;
// pre-combining flags for bitwise checks is a minor perf tweak
const toViewOrOneTime = toView | oneTime;
const taskOptions = {
    reusable: false,
    preempt: true,
};
/**
 * Attribute binding. Handle attribute binding betwen view/view model. Understand Html special attributes
 */
class AttributeBinding {
    constructor(sourceExpression, target, 
    // some attributes may have inner structure
    // such as class -> collection of class names
    // such as style -> collection of style rules
    //
    // for normal attributes, targetAttribute and targetProperty are the same and can be ignore
    targetAttribute, targetProperty, mode, observerLocator, locator) {
        this.sourceExpression = sourceExpression;
        this.targetAttribute = targetAttribute;
        this.targetProperty = targetProperty;
        this.mode = mode;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = null;
        this.$hostScope = null;
        this.task = null;
        this.persistentFlags = 0 /* none */;
        this.value = void 0;
        this.target = target;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
        this.$platform = locator.get(_platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform);
    }
    updateTarget(value, flags) {
        flags |= this.persistentFlags;
        this.targetObserver.setValue(value, flags | 8 /* updateTarget */, this.target, this.targetProperty);
    }
    updateSource(value, flags) {
        flags |= this.persistentFlags;
        this.sourceExpression.assign(flags | 16 /* updateSource */, this.$scope, this.$hostScope, this.locator, value);
    }
    handleChange(newValue, _previousValue, flags) {
        if (!this.isBound) {
            return;
        }
        flags |= this.persistentFlags;
        const mode = this.mode;
        const interceptor = this.interceptor;
        const sourceExpression = this.sourceExpression;
        const $scope = this.$scope;
        const locator = this.locator;
        if (mode === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.fromView) {
            flags &= ~8 /* updateTarget */;
            flags |= 16 /* updateSource */;
        }
        if (flags & 8 /* updateTarget */) {
            const targetObserver = this.targetObserver;
            // Alpha: during bind a simple strategy for bind is always flush immediately
            // todo:
            //  (1). determine whether this should be the behavior
            //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start()
            const shouldQueueFlush = (flags & 32 /* fromBind */) === 0 && (targetObserver.type & 4 /* Layout */) > 0;
            if (sourceExpression.$kind !== 10082 /* AccessScope */ || this.obs.count > 1) {
                const shouldConnect = (mode & oneTime) === 0;
                if (shouldConnect) {
                    this.obs.version++;
                }
                newValue = sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, interceptor);
                if (shouldConnect) {
                    this.obs.clear(false);
                }
            }
            if (newValue !== this.value) {
                this.value = newValue;
                if (shouldQueueFlush) {
                    this.task?.cancel();
                    this.task = this.$platform.domWriteQueue.queueTask(() => {
                        this.task = null;
                        interceptor.updateTarget(newValue, flags);
                    }, taskOptions);
                }
                else {
                    interceptor.updateTarget(newValue, flags);
                }
            }
            return;
        }
        if (flags & 16 /* updateSource */) {
            if (newValue !== sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, null)) {
                interceptor.updateSource(newValue, flags);
            }
            return;
        }
        throw new Error('Unexpected handleChange context in AttributeBinding');
    }
    $bind(flags, scope, hostScope, projection) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        // Store flags which we can only receive during $bind and need to pass on
        // to the AST during evaluate/connect/assign
        this.persistentFlags = flags & 15367 /* persistentBindingFlags */;
        this.$scope = scope;
        this.$hostScope = hostScope;
        this.projection = projection;
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        let targetObserver = this.targetObserver;
        if (!targetObserver) {
            targetObserver = this.targetObserver = new _observation_element_attribute_observer_js__WEBPACK_IMPORTED_MODULE_1__.AttributeObserver(this.$platform, this.observerLocator, this.target, this.targetProperty, this.targetAttribute);
        }
        // during bind, binding behavior might have changed sourceExpression
        sourceExpression = this.sourceExpression;
        const $mode = this.mode;
        const interceptor = this.interceptor;
        if ($mode & toViewOrOneTime) {
            const shouldConnect = ($mode & toView) > 0;
            interceptor.updateTarget(this.value = sourceExpression.evaluate(flags, scope, this.$hostScope, this.locator, shouldConnect ? interceptor : null), flags);
        }
        if ($mode & fromView) {
            targetObserver[this.id] |= 16 /* updateSource */;
            targetObserver.subscribe(interceptor);
        }
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        // clear persistent flags
        this.persistentFlags = 0 /* none */;
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope
            = this.$hostScope
                = null;
        this.value = void 0;
        const targetObserver = this.targetObserver;
        if (targetObserver.unsubscribe) {
            targetObserver.unsubscribe(this.interceptor);
            targetObserver[this.id] &= ~16 /* updateSource */;
        }
        this.task?.cancel();
        this.task = null;
        this.obs.clear(true);
        // remove isBound and isUnbinding flags
        this.isBound = false;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(AttributeBinding);
//# sourceMappingURL=attribute.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallBinding": () => /* binding */ CallBinding
/* harmony export */ });
class CallBinding {
    constructor(sourceExpression, target, targetProperty, observerLocator, locator) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = targetProperty;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$hostScope = null;
        this.targetObserver = observerLocator.getObserver(target, targetProperty);
    }
    callSource(args) {
        const overrideContext = this.$scope.overrideContext;
        // really need to delete the following line
        // and the for..in loop below
        // convenience in the template won't outweight the draw back of such confusing feature
        // OR, at the very least, use getter/setter for each property in args to get/set original source
        // ---
        Object.assign(overrideContext, args);
        const result = this.sourceExpression.evaluate(128 /* mustEvaluate */, this.$scope, this.$hostScope, this.locator, null);
        for (const prop in args) {
            Reflect.deleteProperty(overrideContext, prop);
        }
        return result;
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        if (this.sourceExpression.hasBind) {
            this.sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        this.targetObserver.setValue(($args) => this.interceptor.callSource($args), flags, this.target, this.targetProperty);
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.targetObserver.setValue(null, flags, this.target, this.targetProperty);
        this.isBound = false;
    }
    observeProperty(obj, propertyName) {
        return;
    }
    handleChange(newValue, previousValue, flags) {
        return;
    }
}
//# sourceMappingURL=call-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InterpolationBinding": () => /* binding */ InterpolationBinding,
/* harmony export */   "ContentBinding": () => /* binding */ ContentBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

const { toView } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode;
const queueTaskOptions = {
    reusable: false,
    preempt: true,
};
// a pseudo binding to manage multiple InterpolationBinding s
// ========
// Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include
// value converters and binding behaviors.
// Each expression represents one ${interpolation}, and for each we create a child TextBinding unless there is only one,
// in which case the renderer will create the TextBinding directly
class InterpolationBinding {
    constructor(observerLocator, interpolation, target, targetProperty, mode, locator, taskQueue) {
        this.observerLocator = observerLocator;
        this.interpolation = interpolation;
        this.target = target;
        this.targetProperty = targetProperty;
        this.mode = mode;
        this.locator = locator;
        this.taskQueue = taskQueue;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
        this.task = null;
        this.targetObserver = observerLocator.getAccessor(target, targetProperty);
        const expressions = interpolation.expressions;
        const partBindings = this.partBindings = Array(expressions.length);
        for (let i = 0, ii = expressions.length; i < ii; ++i) {
            partBindings[i] = new ContentBinding(expressions[i], target, targetProperty, locator, observerLocator, this);
        }
    }
    updateTarget(value, flags) {
        const partBindings = this.partBindings;
        const staticParts = this.interpolation.parts;
        const ii = partBindings.length;
        let result = '';
        if (ii === 1) {
            result = staticParts[0] + partBindings[0].value + staticParts[1];
        }
        else {
            result = staticParts[0];
            for (let i = 0; ii > i; ++i) {
                result += partBindings[i].value + staticParts[i + 1];
            }
        }
        const targetObserver = this.targetObserver;
        // Alpha: during bind a simple strategy for bind is always flush immediately
        // todo:
        //  (1). determine whether this should be the behavior
        //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start().wait()
        const shouldQueueFlush = (flags & 32 /* fromBind */) === 0 && (targetObserver.type & 4 /* Layout */) > 0;
        if (shouldQueueFlush) {
            this.task?.cancel();
            this.task = this.taskQueue.queueTask(() => {
                this.task = null;
                targetObserver.setValue(result, flags, this.target, this.targetProperty);
            }, queueTaskOptions);
        }
        else {
            targetObserver.setValue(result, flags, this.target, this.targetProperty);
        }
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags);
        }
        this.isBound = true;
        this.$scope = scope;
        const partBindings = this.partBindings;
        for (let i = 0, ii = partBindings.length; ii > i; ++i) {
            partBindings[i].$bind(flags, scope, hostScope);
        }
        this.updateTarget(void 0, flags);
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.$scope = void 0;
        const partBindings = this.partBindings;
        for (let i = 0, ii = partBindings.length; i < ii; ++i) {
            partBindings[i].interceptor.$unbind(flags);
        }
        this.task?.cancel();
        this.task = null;
    }
}
class ContentBinding {
    constructor(sourceExpression, target, targetProperty, locator, observerLocator, owner) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = targetProperty;
        this.locator = locator;
        this.observerLocator = observerLocator;
        this.owner = owner;
        this.interceptor = this;
        // at runtime, mode may be overriden by binding behavior
        // but it wouldn't matter here, just start with something for later check
        this.mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.toView;
        this.value = '';
        this.$hostScope = null;
        this.task = null;
        this.isBound = false;
    }
    handleChange(newValue, oldValue, flags) {
        if (!this.isBound) {
            return;
        }
        const sourceExpression = this.sourceExpression;
        const obsRecord = this.obs;
        const canOptimize = sourceExpression.$kind === 10082 /* AccessScope */ && obsRecord.count === 1;
        if (!canOptimize) {
            const shouldConnect = (this.mode & toView) > 0;
            if (shouldConnect) {
                obsRecord.version++;
            }
            newValue = sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, shouldConnect ? this.interceptor : null);
            if (shouldConnect) {
                obsRecord.clear(false);
            }
        }
        if (newValue != this.value) {
            this.value = newValue;
            if (newValue instanceof Array) {
                this.observeCollection(newValue);
            }
            this.owner.updateTarget(newValue, flags);
        }
    }
    handleCollectionChange(indexMap, flags) {
        this.owner.updateTarget(void 0, flags);
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags);
        }
        this.isBound = true;
        this.$scope = scope;
        this.$hostScope = hostScope;
        if (this.sourceExpression.hasBind) {
            this.sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        const v = this.value = this.sourceExpression.evaluate(flags, scope, hostScope, this.locator, (this.mode & toView) > 0 ? this.interceptor : null);
        if (v instanceof Array) {
            this.observeCollection(v);
        }
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        this.obs.clear(true);
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(ContentBinding);
//# sourceMappingURL=interpolation-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LetBinding": () => /* binding */ LetBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

class LetBinding {
    constructor(sourceExpression, targetProperty, observerLocator, locator, toBindingContext = false) {
        this.sourceExpression = sourceExpression;
        this.targetProperty = targetProperty;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.toBindingContext = toBindingContext;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
        this.task = null;
        this.target = null;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    handleChange(_newValue, _previousValue, flags) {
        if (!this.isBound) {
            return;
        }
        if (flags & 8 /* updateTarget */) {
            const target = this.target;
            const targetProperty = this.targetProperty;
            const previousValue = target[targetProperty];
            this.obs.version++;
            const newValue = this.sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, this.interceptor);
            this.obs.clear(false);
            if (newValue !== previousValue) {
                target[targetProperty] = newValue;
            }
            return;
        }
        throw new Error('Unexpected handleChange context in LetBinding');
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        this.target = (this.toBindingContext ? (hostScope ?? scope).bindingContext : (hostScope ?? scope).overrideContext);
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        // sourceExpression might have been changed during bind
        this.target[this.targetProperty]
            = this.sourceExpression.evaluate(flags | 32 /* fromBind */, scope, hostScope, this.locator, this.interceptor);
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasUnbind) {
            sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        this.obs.clear(true);
        // remove isBound and isUnbinding flags
        this.isBound = false;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(LetBinding);
//# sourceMappingURL=let-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Listener": () => /* binding */ Listener
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");


const options = {
    [_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.capturing]: { capture: true },
    [_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.bubbling]: { capture: false },
};
/**
 * Listener binding. Handle event binding between view and view model
 */
class Listener {
    constructor(platform, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, eventDelegator, locator) {
        this.platform = platform;
        this.targetEvent = targetEvent;
        this.delegationStrategy = delegationStrategy;
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.preventDefault = preventDefault;
        this.eventDelegator = eventDelegator;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$hostScope = null;
        this.handler = null;
    }
    callSource(event) {
        const overrideContext = this.$scope.overrideContext;
        overrideContext.$event = event;
        const result = this.sourceExpression.evaluate(128 /* mustEvaluate */, this.$scope, this.$hostScope, this.locator, null);
        Reflect.deleteProperty(overrideContext, '$event');
        if (result !== true && this.preventDefault) {
            event.preventDefault();
        }
        return result;
    }
    handleEvent(event) {
        this.interceptor.callSource(event);
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        if (this.delegationStrategy === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.none) {
            this.target.addEventListener(this.targetEvent, this);
        }
        else {
            const eventTarget = this.locator.get(_dom_js__WEBPACK_IMPORTED_MODULE_1__.IEventTarget);
            this.handler = this.eventDelegator.addEventListener(eventTarget, this.target, this.targetEvent, this, options[this.delegationStrategy]);
        }
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        const sourceExpression = this.sourceExpression;
        if (sourceExpression.hasUnbind) {
            sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = null;
        if (this.delegationStrategy === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.DelegationStrategy.none) {
            this.target.removeEventListener(this.targetEvent, this);
        }
        else {
            this.handler.dispose();
            this.handler = null;
        }
        // remove isBound and isUnbinding flags
        this.isBound = false;
    }
    observeProperty(obj, propertyName) {
        return;
    }
    handleChange(newValue, previousValue, flags) {
        return;
    }
}
//# sourceMappingURL=listener.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyBinding": () => /* binding */ PropertyBinding
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

// BindingMode is not a const enum (and therefore not inlined), so assigning them to a variable to save a member accessor is a minor perf tweak
const { oneTime, toView, fromView } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode;
// pre-combining flags for bitwise checks is a minor perf tweak
const toViewOrOneTime = toView | oneTime;
const updateTaskOpts = {
    reusable: false,
    preempt: true,
};
class PropertyBinding {
    constructor(sourceExpression, target, targetProperty, mode, observerLocator, locator, taskQueue) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.targetProperty = targetProperty;
        this.mode = mode;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.taskQueue = taskQueue;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
        this.targetObserver = void 0;
        this.persistentFlags = 0 /* none */;
        this.task = null;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    updateTarget(value, flags) {
        flags |= this.persistentFlags;
        this.targetObserver.setValue(value, flags, this.target, this.targetProperty);
    }
    updateSource(value, flags) {
        flags |= this.persistentFlags;
        this.sourceExpression.assign(flags, this.$scope, this.$hostScope, this.locator, value);
    }
    handleChange(newValue, _previousValue, flags) {
        if (!this.isBound) {
            return;
        }
        flags |= this.persistentFlags;
        const targetObserver = this.targetObserver;
        const interceptor = this.interceptor;
        const sourceExpression = this.sourceExpression;
        const $scope = this.$scope;
        const locator = this.locator;
        if ((flags & 8 /* updateTarget */) > 0) {
            // Alpha: during bind a simple strategy for bind is always flush immediately
            // todo:
            //  (1). determine whether this should be the behavior
            //  (2). if not, then fix tests to reflect the changes/platform to properly yield all with aurelia.start()
            const shouldQueueFlush = (flags & 32 /* fromBind */) === 0 && (targetObserver.type & 4 /* Layout */) > 0;
            const obsRecord = this.obs;
            // if the only observable is an AccessScope then we can assume the passed-in newValue is the correct and latest value
            if (sourceExpression.$kind !== 10082 /* AccessScope */ || obsRecord.count > 1) {
                // todo: in VC expressions, from view also requires connect
                const shouldConnect = this.mode > oneTime;
                if (shouldConnect) {
                    obsRecord.version++;
                }
                newValue = sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, interceptor);
                if (shouldConnect) {
                    obsRecord.clear(false);
                }
            }
            if (shouldQueueFlush) {
                this.task?.cancel();
                this.task = this.taskQueue.queueTask(() => {
                    interceptor.updateTarget(newValue, flags);
                    this.task = null;
                }, updateTaskOpts);
            }
            else {
                interceptor.updateTarget(newValue, flags);
            }
            return;
        }
        if ((flags & 16 /* updateSource */) > 0) {
            if (newValue !== sourceExpression.evaluate(flags, $scope, this.$hostScope, locator, null)) {
                interceptor.updateSource(newValue, flags);
            }
            return;
        }
        throw new Error('Unexpected handleChange context in PropertyBinding');
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        // Force property binding to always be strict
        flags |= 4 /* isStrictBindingStrategy */;
        // Store flags which we can only receive during $bind and need to pass on
        // to the AST during evaluate/connect/assign
        this.persistentFlags = flags & 15367 /* persistentBindingFlags */;
        this.$scope = scope;
        this.$hostScope = hostScope;
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.hasBind) {
            sourceExpression.bind(flags, scope, hostScope, this.interceptor);
        }
        const $mode = this.mode;
        let targetObserver = this.targetObserver;
        if (!targetObserver) {
            const observerLocator = this.observerLocator;
            if ($mode & fromView) {
                targetObserver = observerLocator.getObserver(this.target, this.targetProperty);
            }
            else {
                targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);
            }
            this.targetObserver = targetObserver;
        }
        // during bind, binding behavior might have changed sourceExpression
        // deepscan-disable-next-line
        sourceExpression = this.sourceExpression;
        const interceptor = this.interceptor;
        const shouldConnect = ($mode & toView) > 0;
        if ($mode & toViewOrOneTime) {
            interceptor.updateTarget(sourceExpression.evaluate(flags, scope, this.$hostScope, this.locator, shouldConnect ? interceptor : null), flags);
        }
        if ($mode & fromView) {
            targetObserver.subscribe(interceptor);
            if (!shouldConnect) {
                interceptor.updateSource(targetObserver.getValue(this.target, this.targetProperty), flags);
            }
            targetObserver[this.id] |= 16 /* updateSource */;
        }
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        this.persistentFlags = 0 /* none */;
        if (this.sourceExpression.hasUnbind) {
            this.sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        const targetObserver = this.targetObserver;
        const task = this.task;
        if (targetObserver.unsubscribe) {
            targetObserver.unsubscribe(this.interceptor);
            targetObserver[this.id] &= ~16 /* updateSource */;
        }
        if (task != null) {
            task.cancel();
            this.task = null;
        }
        this.obs.clear(true);
        this.isBound = false;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(PropertyBinding);
//# sourceMappingURL=property-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RefBinding": () => /* binding */ RefBinding
/* harmony export */ });
class RefBinding {
    constructor(sourceExpression, target, locator) {
        this.sourceExpression = sourceExpression;
        this.target = target;
        this.locator = locator;
        this.interceptor = this;
        this.isBound = false;
        this.$scope = void 0;
        this.$hostScope = null;
    }
    $bind(flags, scope, hostScope) {
        if (this.isBound) {
            if (this.$scope === scope) {
                return;
            }
            this.interceptor.$unbind(flags | 32 /* fromBind */);
        }
        this.$scope = scope;
        this.$hostScope = hostScope;
        if (this.sourceExpression.hasBind) {
            this.sourceExpression.bind(flags, scope, hostScope, this);
        }
        this.sourceExpression.assign(flags | 16 /* updateSource */, this.$scope, hostScope, this.locator, this.target);
        // add isBound flag and remove isBinding flag
        this.isBound = true;
    }
    $unbind(flags) {
        if (!this.isBound) {
            return;
        }
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.evaluate(flags, this.$scope, this.$hostScope, this.locator, null) === this.target) {
            sourceExpression.assign(flags, this.$scope, this.$hostScope, this.locator, null);
        }
        // source expression might have been modified durring assign, via a BB
        // deepscan-disable-next-line
        sourceExpression = this.sourceExpression;
        if (sourceExpression.hasUnbind) {
            sourceExpression.unbind(flags, this.$scope, this.$hostScope, this.interceptor);
        }
        this.$scope = void 0;
        this.$hostScope = null;
        this.isBound = false;
    }
    observeProperty(obj, propertyName) {
        return;
    }
    handleChange(newValue, previousValue, flags) {
        return;
    }
}
//# sourceMappingURL=ref-binding.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/configuration.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/configuration.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebounceBindingBehaviorRegistration": () => /* binding */ DebounceBindingBehaviorRegistration,
/* harmony export */   "OneTimeBindingBehaviorRegistration": () => /* binding */ OneTimeBindingBehaviorRegistration,
/* harmony export */   "ToViewBindingBehaviorRegistration": () => /* binding */ ToViewBindingBehaviorRegistration,
/* harmony export */   "FromViewBindingBehaviorRegistration": () => /* binding */ FromViewBindingBehaviorRegistration,
/* harmony export */   "SignalBindingBehaviorRegistration": () => /* binding */ SignalBindingBehaviorRegistration,
/* harmony export */   "ThrottleBindingBehaviorRegistration": () => /* binding */ ThrottleBindingBehaviorRegistration,
/* harmony export */   "TwoWayBindingBehaviorRegistration": () => /* binding */ TwoWayBindingBehaviorRegistration,
/* harmony export */   "ITemplateCompilerRegistration": () => /* binding */ ITemplateCompilerRegistration,
/* harmony export */   "INodeObserverLocatorRegistration": () => /* binding */ INodeObserverLocatorRegistration,
/* harmony export */   "DefaultComponents": () => /* binding */ DefaultComponents,
/* harmony export */   "SVGAnalyzerRegistration": () => /* binding */ SVGAnalyzerRegistration,
/* harmony export */   "AtPrefixedTriggerAttributePatternRegistration": () => /* binding */ AtPrefixedTriggerAttributePatternRegistration,
/* harmony export */   "ColonPrefixedBindAttributePatternRegistration": () => /* binding */ ColonPrefixedBindAttributePatternRegistration,
/* harmony export */   "RefAttributePatternRegistration": () => /* binding */ RefAttributePatternRegistration,
/* harmony export */   "DotSeparatedAttributePatternRegistration": () => /* binding */ DotSeparatedAttributePatternRegistration,
/* harmony export */   "DefaultBindingSyntax": () => /* binding */ DefaultBindingSyntax,
/* harmony export */   "ShortHandBindingSyntax": () => /* binding */ ShortHandBindingSyntax,
/* harmony export */   "CallBindingCommandRegistration": () => /* binding */ CallBindingCommandRegistration,
/* harmony export */   "DefaultBindingCommandRegistration": () => /* binding */ DefaultBindingCommandRegistration,
/* harmony export */   "ForBindingCommandRegistration": () => /* binding */ ForBindingCommandRegistration,
/* harmony export */   "FromViewBindingCommandRegistration": () => /* binding */ FromViewBindingCommandRegistration,
/* harmony export */   "OneTimeBindingCommandRegistration": () => /* binding */ OneTimeBindingCommandRegistration,
/* harmony export */   "ToViewBindingCommandRegistration": () => /* binding */ ToViewBindingCommandRegistration,
/* harmony export */   "TwoWayBindingCommandRegistration": () => /* binding */ TwoWayBindingCommandRegistration,
/* harmony export */   "RefBindingCommandRegistration": () => /* binding */ RefBindingCommandRegistration,
/* harmony export */   "TriggerBindingCommandRegistration": () => /* binding */ TriggerBindingCommandRegistration,
/* harmony export */   "DelegateBindingCommandRegistration": () => /* binding */ DelegateBindingCommandRegistration,
/* harmony export */   "CaptureBindingCommandRegistration": () => /* binding */ CaptureBindingCommandRegistration,
/* harmony export */   "AttrBindingCommandRegistration": () => /* binding */ AttrBindingCommandRegistration,
/* harmony export */   "ClassBindingCommandRegistration": () => /* binding */ ClassBindingCommandRegistration,
/* harmony export */   "StyleBindingCommandRegistration": () => /* binding */ StyleBindingCommandRegistration,
/* harmony export */   "DefaultBindingLanguage": () => /* binding */ DefaultBindingLanguage,
/* harmony export */   "SanitizeValueConverterRegistration": () => /* binding */ SanitizeValueConverterRegistration,
/* harmony export */   "ViewValueConverterRegistration": () => /* binding */ ViewValueConverterRegistration,
/* harmony export */   "FrequentMutationsRegistration": () => /* binding */ FrequentMutationsRegistration,
/* harmony export */   "ObserveShallowRegistration": () => /* binding */ ObserveShallowRegistration,
/* harmony export */   "IfRegistration": () => /* binding */ IfRegistration,
/* harmony export */   "ElseRegistration": () => /* binding */ ElseRegistration,
/* harmony export */   "RepeatRegistration": () => /* binding */ RepeatRegistration,
/* harmony export */   "WithRegistration": () => /* binding */ WithRegistration,
/* harmony export */   "SwitchRegistration": () => /* binding */ SwitchRegistration,
/* harmony export */   "CaseRegistration": () => /* binding */ CaseRegistration,
/* harmony export */   "DefaultCaseRegistration": () => /* binding */ DefaultCaseRegistration,
/* harmony export */   "AttrBindingBehaviorRegistration": () => /* binding */ AttrBindingBehaviorRegistration,
/* harmony export */   "SelfBindingBehaviorRegistration": () => /* binding */ SelfBindingBehaviorRegistration,
/* harmony export */   "UpdateTriggerBindingBehaviorRegistration": () => /* binding */ UpdateTriggerBindingBehaviorRegistration,
/* harmony export */   "ComposeRegistration": () => /* binding */ ComposeRegistration,
/* harmony export */   "PortalRegistration": () => /* binding */ PortalRegistration,
/* harmony export */   "FocusRegistration": () => /* binding */ FocusRegistration,
/* harmony export */   "BlurRegistration": () => /* binding */ BlurRegistration,
/* harmony export */   "ShowRegistration": () => /* binding */ ShowRegistration,
/* harmony export */   "DefaultResources": () => /* binding */ DefaultResources,
/* harmony export */   "CallBindingRendererRegistration": () => /* binding */ CallBindingRendererRegistration,
/* harmony export */   "CustomAttributeRendererRegistration": () => /* binding */ CustomAttributeRendererRegistration,
/* harmony export */   "CustomElementRendererRegistration": () => /* binding */ CustomElementRendererRegistration,
/* harmony export */   "InterpolationBindingRendererRegistration": () => /* binding */ InterpolationBindingRendererRegistration,
/* harmony export */   "IteratorBindingRendererRegistration": () => /* binding */ IteratorBindingRendererRegistration,
/* harmony export */   "LetElementRendererRegistration": () => /* binding */ LetElementRendererRegistration,
/* harmony export */   "PropertyBindingRendererRegistration": () => /* binding */ PropertyBindingRendererRegistration,
/* harmony export */   "RefBindingRendererRegistration": () => /* binding */ RefBindingRendererRegistration,
/* harmony export */   "SetPropertyRendererRegistration": () => /* binding */ SetPropertyRendererRegistration,
/* harmony export */   "TemplateControllerRendererRegistration": () => /* binding */ TemplateControllerRendererRegistration,
/* harmony export */   "ListenerBindingRendererRegistration": () => /* binding */ ListenerBindingRendererRegistration,
/* harmony export */   "AttributeBindingRendererRegistration": () => /* binding */ AttributeBindingRendererRegistration,
/* harmony export */   "SetAttributeRendererRegistration": () => /* binding */ SetAttributeRendererRegistration,
/* harmony export */   "SetClassAttributeRendererRegistration": () => /* binding */ SetClassAttributeRendererRegistration,
/* harmony export */   "SetStyleAttributeRendererRegistration": () => /* binding */ SetStyleAttributeRendererRegistration,
/* harmony export */   "StylePropertyBindingRendererRegistration": () => /* binding */ StylePropertyBindingRendererRegistration,
/* harmony export */   "TextBindingRendererRegistration": () => /* binding */ TextBindingRendererRegistration,
/* harmony export */   "DefaultRenderers": () => /* binding */ DefaultRenderers,
/* harmony export */   "StandardConfiguration": () => /* binding */ StandardConfiguration
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/attribute-pattern.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js");
/* harmony import */ var _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/binding-command.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js");
/* harmony import */ var _template_compiler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template-compiler.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-compiler.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding-behaviors/binding-mode.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js");
/* harmony import */ var _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./binding-behaviors/debounce.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js");
/* harmony import */ var _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./binding-behaviors/signals.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js");
/* harmony import */ var _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./binding-behaviors/throttle.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js");
/* harmony import */ var _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./observation/svg-analyzer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js");
/* harmony import */ var _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resources/binding-behaviors/attr.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js");
/* harmony import */ var _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./resources/binding-behaviors/self.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js");
/* harmony import */ var _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./resources/binding-behaviors/update-trigger.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js");
/* harmony import */ var _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resources/custom-attributes/blur.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js");
/* harmony import */ var _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./resources/custom-attributes/focus.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js");
/* harmony import */ var _resources_custom_attributes_show_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./resources/custom-attributes/show.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js");
/* harmony import */ var _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./resources/template-controllers/portal.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js");
/* harmony import */ var _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./resources/template-controllers/flags.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js");
/* harmony import */ var _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./resources/template-controllers/if.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js");
/* harmony import */ var _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./resources/template-controllers/repeat.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js");
/* harmony import */ var _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./resources/template-controllers/with.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js");
/* harmony import */ var _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./resources/template-controllers/switch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js");
/* harmony import */ var _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./resources/custom-elements/compose.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./resources/value-converters/sanitize.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js");
/* harmony import */ var _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./resources/value-converters/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./observation/observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");



























const DebounceBindingBehaviorRegistration = _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__.DebounceBindingBehavior;
const OneTimeBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.OneTimeBindingBehavior;
const ToViewBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.ToViewBindingBehavior;
const FromViewBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.FromViewBindingBehavior;
const SignalBindingBehaviorRegistration = _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__.SignalBindingBehavior;
const ThrottleBindingBehaviorRegistration = _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__.ThrottleBindingBehavior;
const TwoWayBindingBehaviorRegistration = _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.TwoWayBindingBehavior;
const ITemplateCompilerRegistration = _template_compiler_js__WEBPACK_IMPORTED_MODULE_3__.TemplateCompiler;
const INodeObserverLocatorRegistration = _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_26__.NodeObserverLocator;
/**
 * Default HTML-specific (but environment-agnostic) implementations for the following interfaces:
 * - `ITemplateCompiler`
 * - `ITargetAccessorLocator`
 * - `ITargetObserverLocator`
 */
const DefaultComponents = [
    ITemplateCompilerRegistration,
    INodeObserverLocatorRegistration,
];
const SVGAnalyzerRegistration = _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_9__.SVGAnalyzer;
const AtPrefixedTriggerAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.AtPrefixedTriggerAttributePattern;
const ColonPrefixedBindAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.ColonPrefixedBindAttributePattern;
const RefAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.RefAttributePattern;
const DotSeparatedAttributePatternRegistration = _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_1__.DotSeparatedAttributePattern;
/**
 * Default binding syntax for the following attribute name patterns:
 * - `ref`
 * - `target.command` (dot-separated)
 */
const DefaultBindingSyntax = [
    RefAttributePatternRegistration,
    DotSeparatedAttributePatternRegistration
];
/**
 * Binding syntax for short-hand attribute name patterns:
 * - `@target` (short-hand for `target.trigger`)
 * - `:target` (short-hand for `target.bind`)
 */
const ShortHandBindingSyntax = [
    AtPrefixedTriggerAttributePatternRegistration,
    ColonPrefixedBindAttributePatternRegistration
];
const CallBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.CallBindingCommand;
const DefaultBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.DefaultBindingCommand;
const ForBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.ForBindingCommand;
const FromViewBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.FromViewBindingCommand;
const OneTimeBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.OneTimeBindingCommand;
const ToViewBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.ToViewBindingCommand;
const TwoWayBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.TwoWayBindingCommand;
const RefBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.RefBindingCommand;
const TriggerBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.TriggerBindingCommand;
const DelegateBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.DelegateBindingCommand;
const CaptureBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.CaptureBindingCommand;
const AttrBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.AttrBindingCommand;
const ClassBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.ClassBindingCommand;
const StyleBindingCommandRegistration = _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.StyleBindingCommand;
/**
 * Default HTML-specific (but environment-agnostic) binding commands:
 * - Property observation: `.bind`, `.one-time`, `.from-view`, `.to-view`, `.two-way`
 * - Function call: `.call`
 * - Collection observation: `.for`
 * - Event listeners: `.trigger`, `.delegate`, `.capture`
 */
const DefaultBindingLanguage = [
    DefaultBindingCommandRegistration,
    OneTimeBindingCommandRegistration,
    FromViewBindingCommandRegistration,
    ToViewBindingCommandRegistration,
    TwoWayBindingCommandRegistration,
    CallBindingCommandRegistration,
    ForBindingCommandRegistration,
    RefBindingCommandRegistration,
    TriggerBindingCommandRegistration,
    DelegateBindingCommandRegistration,
    CaptureBindingCommandRegistration,
    ClassBindingCommandRegistration,
    StyleBindingCommandRegistration,
    AttrBindingCommandRegistration,
];
const SanitizeValueConverterRegistration = _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_24__.SanitizeValueConverter;
const ViewValueConverterRegistration = _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_25__.ViewValueConverter;
const FrequentMutationsRegistration = _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_17__.FrequentMutations;
const ObserveShallowRegistration = _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_17__.ObserveShallow;
const IfRegistration = _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_18__.If;
const ElseRegistration = _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_18__.Else;
const RepeatRegistration = _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_19__.Repeat;
const WithRegistration = _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_20__.With;
const SwitchRegistration = _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__.Switch;
const CaseRegistration = _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__.Case;
const DefaultCaseRegistration = _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_21__.DefaultCase;
const AttrBindingBehaviorRegistration = _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_10__.AttrBindingBehavior;
const SelfBindingBehaviorRegistration = _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_11__.SelfBindingBehavior;
const UpdateTriggerBindingBehaviorRegistration = _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_12__.UpdateTriggerBindingBehavior;
const ComposeRegistration = _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_22__.Compose;
const PortalRegistration = _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_16__.Portal;
const FocusRegistration = _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_14__.Focus;
const BlurRegistration = _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_13__.Blur;
const ShowRegistration = _resources_custom_attributes_show_js__WEBPACK_IMPORTED_MODULE_15__.Show;
/**
 * Default HTML-specific (but environment-agnostic) resources:
 * - Binding Behaviors: `oneTime`, `toView`, `fromView`, `twoWay`, `signal`, `debounce`, `throttle`, `attr`, `self`, `updateTrigger`
 * - Custom Elements: `au-compose`, `au-slot`
 * - Custom Attributes: `blur`, `focus`, `portal`
 * - Template controllers: `if`/`else`, `repeat`, `with`
 * - Value Converters: `sanitize`
 */
const DefaultResources = [
    DebounceBindingBehaviorRegistration,
    OneTimeBindingBehaviorRegistration,
    ToViewBindingBehaviorRegistration,
    FromViewBindingBehaviorRegistration,
    SignalBindingBehaviorRegistration,
    ThrottleBindingBehaviorRegistration,
    TwoWayBindingBehaviorRegistration,
    SanitizeValueConverterRegistration,
    ViewValueConverterRegistration,
    FrequentMutationsRegistration,
    ObserveShallowRegistration,
    IfRegistration,
    ElseRegistration,
    RepeatRegistration,
    WithRegistration,
    SwitchRegistration,
    CaseRegistration,
    DefaultCaseRegistration,
    AttrBindingBehaviorRegistration,
    SelfBindingBehaviorRegistration,
    UpdateTriggerBindingBehaviorRegistration,
    ComposeRegistration,
    PortalRegistration,
    FocusRegistration,
    BlurRegistration,
    ShowRegistration,
    _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_23__.AuSlot,
];
const CallBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.CallBindingRenderer;
const CustomAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.CustomAttributeRenderer;
const CustomElementRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.CustomElementRenderer;
const InterpolationBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBindingRenderer;
const IteratorBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.IteratorBindingRenderer;
const LetElementRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.LetElementRenderer;
const PropertyBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.PropertyBindingRenderer;
const RefBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.RefBindingRenderer;
const SetPropertyRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetPropertyRenderer;
const TemplateControllerRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.TemplateControllerRenderer;
const ListenerBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.ListenerBindingRenderer;
const AttributeBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.AttributeBindingRenderer;
const SetAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetAttributeRenderer;
const SetClassAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetClassAttributeRenderer;
const SetStyleAttributeRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.SetStyleAttributeRenderer;
const StylePropertyBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.StylePropertyBindingRenderer;
const TextBindingRendererRegistration = _renderer_js__WEBPACK_IMPORTED_MODULE_4__.TextBindingRenderer;
/**
 * Default renderers for:
 * - PropertyBinding: `bind`, `one-time`, `to-view`, `from-view`, `two-way`
 * - IteratorBinding: `for`
 * - CallBinding: `call`
 * - RefBinding: `ref`
 * - InterpolationBinding: `${}`
 * - SetProperty
 * - `customElement` hydration
 * - `customAttribute` hydration
 * - `templateController` hydration
 * - `let` element hydration
 * - Listener Bindings: `trigger`, `capture`, `delegate`
 * - SetAttribute
 * - StyleProperty: `style`, `css`
 * - TextBinding: `${}`
 */
const DefaultRenderers = [
    PropertyBindingRendererRegistration,
    IteratorBindingRendererRegistration,
    CallBindingRendererRegistration,
    RefBindingRendererRegistration,
    InterpolationBindingRendererRegistration,
    SetPropertyRendererRegistration,
    CustomElementRendererRegistration,
    CustomAttributeRendererRegistration,
    TemplateControllerRendererRegistration,
    LetElementRendererRegistration,
    ListenerBindingRendererRegistration,
    AttributeBindingRendererRegistration,
    SetAttributeRendererRegistration,
    SetClassAttributeRendererRegistration,
    SetStyleAttributeRendererRegistration,
    StylePropertyBindingRendererRegistration,
    TextBindingRendererRegistration,
];
/**
 * A DI configuration object containing html-specific (but environment-agnostic) registrations:
 * - `RuntimeConfiguration` from `@aurelia/runtime`
 * - `DefaultComponents`
 * - `DefaultResources`
 * - `DefaultRenderers`
 */
const StandardConfiguration = {
    /**
     * Apply this configuration to the provided container.
     */
    register(container) {
        return container.register(...DefaultComponents, ...DefaultResources, ...DefaultBindingSyntax, ...DefaultBindingLanguage, ...DefaultRenderers);
    },
    /**
     * Create a new container with this configuration applied to it.
     */
    createContainer() {
        return this.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer());
    }
};
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/create-element.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/create-element.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createElement": () => /* binding */ createElement,
/* harmony export */   "RenderPlan": () => /* binding */ RenderPlan
/* harmony export */ });
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");



function createElement(p, tagOrType, props, children) {
    if (typeof tagOrType === 'string') {
        return createElementForTag(p, tagOrType, props, children);
    }
    else if (_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElement.isType(tagOrType)) {
        return createElementForType(p, tagOrType, props, children);
    }
    else {
        throw new Error(`Invalid tagOrType.`);
    }
}
/**
 * RenderPlan. Todo: describe goal of this class
 */
class RenderPlan {
    constructor(node, instructions, dependencies) {
        this.node = node;
        this.instructions = instructions;
        this.dependencies = dependencies;
        this.lazyDefinition = void 0;
    }
    get definition() {
        if (this.lazyDefinition === void 0) {
            this.lazyDefinition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElementDefinition.create({
                name: _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElement.generateName(),
                template: this.node,
                needsCompile: typeof this.node === 'string',
                instructions: this.instructions,
                dependencies: this.dependencies,
            });
        }
        return this.lazyDefinition;
    }
    getContext(parentContainer) {
        return (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_2__.getRenderContext)(this.definition, parentContainer);
    }
    createView(parentContainer) {
        return this.getViewFactory(parentContainer).create();
    }
    getViewFactory(parentContainer) {
        return this.getContext(parentContainer).getViewFactory();
    }
    /** @internal */
    mergeInto(parent, instructions, dependencies) {
        parent.appendChild(this.node);
        instructions.push(...this.instructions);
        dependencies.push(...this.dependencies);
    }
}
function createElementForTag(p, tagName, props, children) {
    const instructions = [];
    const allInstructions = [];
    const dependencies = [];
    const element = p.document.createElement(tagName);
    let hasInstructions = false;
    if (props) {
        Object.keys(props)
            .forEach(to => {
            const value = props[to];
            if ((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.isInstruction)(value)) {
                hasInstructions = true;
                instructions.push(value);
            }
            else {
                element.setAttribute(to, value);
            }
        });
    }
    if (hasInstructions) {
        element.className = 'au';
        allInstructions.push(instructions);
    }
    if (children) {
        addChildren(p, element, children, allInstructions, dependencies);
    }
    return new RenderPlan(element, allInstructions, dependencies);
}
function createElementForType(p, Type, props, children) {
    const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_1__.CustomElement.getDefinition(Type);
    const tagName = definition.name;
    const instructions = [];
    const allInstructions = [instructions];
    const dependencies = [];
    const childInstructions = [];
    const bindables = definition.bindables;
    const element = p.document.createElement(tagName);
    element.className = 'au';
    if (!dependencies.includes(Type)) {
        dependencies.push(Type);
    }
    instructions.push(new _renderer_js__WEBPACK_IMPORTED_MODULE_0__.HydrateElementInstruction(tagName, void 0, childInstructions, null));
    if (props) {
        Object.keys(props)
            .forEach(to => {
            const value = props[to];
            if ((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.isInstruction)(value)) {
                childInstructions.push(value);
            }
            else {
                const bindable = bindables[to];
                if (bindable !== void 0) {
                    childInstructions.push({
                        type: "re" /* setProperty */,
                        to,
                        value
                    });
                }
                else {
                    childInstructions.push(new _renderer_js__WEBPACK_IMPORTED_MODULE_0__.SetAttributeInstruction(value, to));
                }
            }
        });
    }
    if (children) {
        addChildren(p, element, children, allInstructions, dependencies);
    }
    return new RenderPlan(element, allInstructions, dependencies);
}
function addChildren(p, parent, children, allInstructions, dependencies) {
    for (let i = 0, ii = children.length; i < ii; ++i) {
        const current = children[i];
        switch (typeof current) {
            case 'string':
                parent.appendChild(p.document.createTextNode(current));
                break;
            case 'object':
                if (current instanceof p.Node) {
                    parent.appendChild(current);
                }
                else if ('mergeInto' in current) {
                    current.mergeInto(parent, allInstructions, dependencies);
                }
        }
    }
}
//# sourceMappingURL=create-element.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js":
/*!************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/dom.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INode": () => /* binding */ INode,
/* harmony export */   "IEventTarget": () => /* binding */ IEventTarget,
/* harmony export */   "IRenderLocation": () => /* binding */ IRenderLocation,
/* harmony export */   "NodeType": () => /* binding */ NodeType,
/* harmony export */   "getEffectiveParentNode": () => /* binding */ getEffectiveParentNode,
/* harmony export */   "setEffectiveParentNode": () => /* binding */ setEffectiveParentNode,
/* harmony export */   "convertToRenderLocation": () => /* binding */ convertToRenderLocation,
/* harmony export */   "isRenderLocation": () => /* binding */ isRenderLocation,
/* harmony export */   "FragmentNodeSequence": () => /* binding */ FragmentNodeSequence,
/* harmony export */   "IWindow": () => /* binding */ IWindow,
/* harmony export */   "ILocation": () => /* binding */ ILocation,
/* harmony export */   "IHistory": () => /* binding */ IHistory
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");




const INode = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('INode');
const IEventTarget = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IEventTarget', x => x.cachedCallback(handler => {
    if (handler.has(_app_root_js__WEBPACK_IMPORTED_MODULE_1__.IAppRoot, true)) {
        return handler.get(_app_root_js__WEBPACK_IMPORTED_MODULE_1__.IAppRoot).host;
    }
    return handler.get(_platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform).document;
}));
const IRenderLocation = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IRenderLocation');
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Element"] = 1] = "Element";
    NodeType[NodeType["Attr"] = 2] = "Attr";
    NodeType[NodeType["Text"] = 3] = "Text";
    NodeType[NodeType["CDATASection"] = 4] = "CDATASection";
    NodeType[NodeType["EntityReference"] = 5] = "EntityReference";
    NodeType[NodeType["Entity"] = 6] = "Entity";
    NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    NodeType[NodeType["Comment"] = 8] = "Comment";
    NodeType[NodeType["Document"] = 9] = "Document";
    NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
    NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
    NodeType[NodeType["Notation"] = 12] = "Notation";
})(NodeType || (NodeType = {}));
const effectiveParentNodeOverrides = new WeakMap();
/**
 * Returns the effective parentNode according to Aurelia's component hierarchy.
 *
 * Used by Aurelia to find the closest parent controller relative to a node.
 *
 * This method supports 3 additional scenarios that `node.parentNode` does not support:
 * - Containerless elements. The parentNode in this case is a comment precending the element under specific conditions, rather than a node wrapping the element.
 * - ShadowDOM. If a `ShadowRoot` is encountered, this method retrieves the associated controller via the metadata api to locate the original host.
 * - Portals. If the provided node was moved to a different location in the DOM by a `portal` attribute, then the original parent of the node will be returned.
 *
 * @param node - The node to get the parent for.
 * @returns Either the closest parent node, the closest `IRenderLocation` (comment node that is the containerless host), original portal host, or `null` if this is either the absolute document root or a disconnected node.
 */
function getEffectiveParentNode(node) {
    // TODO: this method needs more tests!
    // First look for any overrides
    if (effectiveParentNodeOverrides.has(node)) {
        return effectiveParentNodeOverrides.get(node);
    }
    // Then try to get the nearest au-start render location, which would be the containerless parent,
    // again looking for any overrides along the way.
    // otherwise return the normal parent node
    let containerlessOffset = 0;
    let next = node.nextSibling;
    while (next !== null) {
        if (next.nodeType === 8 /* Comment */) {
            switch (next.textContent) {
                case 'au-start':
                    // If we see an au-start before we see au-end, it will precede the host of a sibling containerless element rather than a parent.
                    // So we use the offset to ignore the next au-end
                    ++containerlessOffset;
                    break;
                case 'au-end':
                    if (containerlessOffset-- === 0) {
                        return next;
                    }
            }
        }
        next = next.nextSibling;
    }
    if (node.parentNode === null && node.nodeType === 11 /* DocumentFragment */) {
        // Could be a shadow root; see if there's a controller and if so, get the original host via the projector
        const controller = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElement.for(node);
        if (controller === void 0) {
            // Not a shadow root (or at least, not one created by Aurelia)
            // Nothing more we can try, just return null
            return null;
        }
        if (controller.mountTarget === 2 /* shadowRoot */) {
            return getEffectiveParentNode(controller.host);
        }
    }
    return node.parentNode;
}
function setEffectiveParentNode(childNodeOrNodeSequence, parentNode) {
    if (childNodeOrNodeSequence.platform !== void 0 && !(childNodeOrNodeSequence instanceof childNodeOrNodeSequence.platform.Node)) {
        const nodes = childNodeOrNodeSequence.childNodes;
        for (let i = 0, ii = nodes.length; i < ii; ++i) {
            effectiveParentNodeOverrides.set(nodes[i], parentNode);
        }
    }
    else {
        effectiveParentNodeOverrides.set(childNodeOrNodeSequence, parentNode);
    }
}
function convertToRenderLocation(node) {
    if (isRenderLocation(node)) {
        return node; // it's already a IRenderLocation (converted by FragmentNodeSequence)
    }
    const locationEnd = node.ownerDocument.createComment('au-end');
    const locationStart = node.ownerDocument.createComment('au-start');
    if (node.parentNode !== null) {
        node.parentNode.replaceChild(locationEnd, node);
        locationEnd.parentNode.insertBefore(locationStart, locationEnd);
    }
    locationEnd.$start = locationStart;
    return locationEnd;
}
function isRenderLocation(node) {
    return node.textContent === 'au-end';
}
class FragmentNodeSequence {
    constructor(platform, fragment) {
        this.platform = platform;
        this.fragment = fragment;
        this.isMounted = false;
        this.isLinked = false;
        this.next = void 0;
        this.refNode = void 0;
        const targetNodeList = fragment.querySelectorAll('.au');
        let i = 0;
        let ii = targetNodeList.length;
        const targets = this.targets = Array(ii);
        while (i < ii) {
            // eagerly convert all markers to RenderLocations (otherwise the renderer
            // will do it anyway) and store them in the target list (since the comments
            // can't be queried)
            const target = targetNodeList[i];
            if (target.nodeName === 'AU-M') {
                // note the renderer will still call this method, but it will just return the
                // location if it sees it's already a location
                targets[i] = convertToRenderLocation(target);
            }
            else {
                // also store non-markers for consistent ordering
                targets[i] = target;
            }
            ++i;
        }
        const childNodeList = fragment.childNodes;
        i = 0;
        ii = childNodeList.length;
        const childNodes = this.childNodes = Array(ii);
        while (i < ii) {
            childNodes[i] = childNodeList[i];
            ++i;
        }
        this.firstChild = fragment.firstChild;
        this.lastChild = fragment.lastChild;
    }
    findTargets() {
        return this.targets;
    }
    insertBefore(refNode) {
        if (this.isLinked && !!this.refNode) {
            this.addToLinked();
        }
        else {
            const parent = refNode.parentNode;
            if (this.isMounted) {
                let current = this.firstChild;
                const end = this.lastChild;
                let next;
                while (current != null) {
                    next = current.nextSibling;
                    parent.insertBefore(current, refNode);
                    if (current === end) {
                        break;
                    }
                    current = next;
                }
            }
            else {
                this.isMounted = true;
                refNode.parentNode.insertBefore(this.fragment, refNode);
            }
        }
    }
    appendTo(parent, enhance = false) {
        if (this.isMounted) {
            let current = this.firstChild;
            const end = this.lastChild;
            let next;
            while (current != null) {
                next = current.nextSibling;
                parent.appendChild(current);
                if (current === end) {
                    break;
                }
                current = next;
            }
        }
        else {
            this.isMounted = true;
            if (!enhance) {
                parent.appendChild(this.fragment);
            }
        }
    }
    remove() {
        if (this.isMounted) {
            this.isMounted = false;
            const fragment = this.fragment;
            const end = this.lastChild;
            let next;
            let current = this.firstChild;
            while (current !== null) {
                next = current.nextSibling;
                fragment.appendChild(current);
                if (current === end) {
                    break;
                }
                current = next;
            }
        }
    }
    addToLinked() {
        const refNode = this.refNode;
        const parent = refNode.parentNode;
        if (this.isMounted) {
            let current = this.firstChild;
            const end = this.lastChild;
            let next;
            while (current != null) {
                next = current.nextSibling;
                parent.insertBefore(current, refNode);
                if (current === end) {
                    break;
                }
                current = next;
            }
        }
        else {
            this.isMounted = true;
            parent.insertBefore(this.fragment, refNode);
        }
    }
    unlink() {
        this.isLinked = false;
        this.next = void 0;
        this.refNode = void 0;
    }
    link(next) {
        this.isLinked = true;
        if (isRenderLocation(next)) {
            this.refNode = next;
        }
        else {
            this.next = next;
            this.obtainRefNode();
        }
    }
    obtainRefNode() {
        if (this.next !== void 0) {
            this.refNode = this.next.firstChild;
        }
        else {
            this.refNode = void 0;
        }
    }
}
const IWindow = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IWindow', x => x.callback(handler => handler.get(_platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform).window));
const ILocation = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ILocation', x => x.callback(handler => handler.get(IWindow).location));
const IHistory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IHistory', x => x.callback(handler => handler.get(IWindow).history));
//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Platform": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.Platform,
/* harmony export */   "TaskQueue": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueue,
/* harmony export */   "Task": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.Task,
/* harmony export */   "TaskAbortError": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskAbortError,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskQueuePriority,
/* harmony export */   "TaskStatus": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__.TaskStatus,
/* harmony export */   "BrowserPlatform": () => /* reexport safe */ _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserPlatform,
/* harmony export */   "bindable": () => /* reexport safe */ _bindable_js__WEBPACK_IMPORTED_MODULE_2__.bindable,
/* harmony export */   "Bindable": () => /* reexport safe */ _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable,
/* harmony export */   "BindableDefinition": () => /* reexport safe */ _bindable_js__WEBPACK_IMPORTED_MODULE_2__.BindableDefinition,
/* harmony export */   "BindableObserver": () => /* reexport safe */ _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_3__.BindableObserver,
/* harmony export */   "DebounceBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DebounceBindingBehaviorRegistration,
/* harmony export */   "OneTimeBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.OneTimeBindingBehaviorRegistration,
/* harmony export */   "ToViewBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ToViewBindingBehaviorRegistration,
/* harmony export */   "FromViewBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.FromViewBindingBehaviorRegistration,
/* harmony export */   "SignalBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SignalBindingBehaviorRegistration,
/* harmony export */   "ThrottleBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ThrottleBindingBehaviorRegistration,
/* harmony export */   "TwoWayBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TwoWayBindingBehaviorRegistration,
/* harmony export */   "BindingModeBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.BindingModeBehavior,
/* harmony export */   "OneTimeBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.OneTimeBindingBehavior,
/* harmony export */   "ToViewBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.ToViewBindingBehavior,
/* harmony export */   "FromViewBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.FromViewBindingBehavior,
/* harmony export */   "TwoWayBindingBehavior": () => /* reexport safe */ _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__.TwoWayBindingBehavior,
/* harmony export */   "DebounceBindingBehavior": () => /* reexport safe */ _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__.DebounceBindingBehavior,
/* harmony export */   "SignalBindingBehavior": () => /* reexport safe */ _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__.SignalBindingBehavior,
/* harmony export */   "ThrottleBindingBehavior": () => /* reexport safe */ _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__.ThrottleBindingBehavior,
/* harmony export */   "alias": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.alias,
/* harmony export */   "registerAliases": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.registerAliases,
/* harmony export */   "CallFunctionExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CallFunctionExpression,
/* harmony export */   "CustomExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CustomExpression,
/* harmony export */   "BindingBehaviorExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorExpression,
/* harmony export */   "ValueConverterExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ValueConverterExpression,
/* harmony export */   "AssignExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AssignExpression,
/* harmony export */   "ConditionalExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ConditionalExpression,
/* harmony export */   "AccessThisExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessThisExpression,
/* harmony export */   "AccessScopeExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessScopeExpression,
/* harmony export */   "AccessMemberExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessMemberExpression,
/* harmony export */   "AccessKeyedExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessKeyedExpression,
/* harmony export */   "CallScopeExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CallScopeExpression,
/* harmony export */   "CallMemberExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CallMemberExpression,
/* harmony export */   "BinaryExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BinaryExpression,
/* harmony export */   "UnaryExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.UnaryExpression,
/* harmony export */   "PrimitiveLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.PrimitiveLiteralExpression,
/* harmony export */   "HtmlLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.HtmlLiteralExpression,
/* harmony export */   "ArrayLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayLiteralExpression,
/* harmony export */   "ObjectLiteralExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ObjectLiteralExpression,
/* harmony export */   "TemplateExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.TemplateExpression,
/* harmony export */   "TaggedTemplateExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.TaggedTemplateExpression,
/* harmony export */   "ArrayBindingPattern": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayBindingPattern,
/* harmony export */   "ObjectBindingPattern": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ObjectBindingPattern,
/* harmony export */   "BindingIdentifier": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingIdentifier,
/* harmony export */   "ForOfStatement": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ForOfStatement,
/* harmony export */   "Interpolation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Interpolation,
/* harmony export */   "connectable": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.connectable,
/* harmony export */   "BindingMediator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingMediator,
/* harmony export */   "IExpressionParser": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.IExpressionParser,
/* harmony export */   "BindingType": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingType,
/* harmony export */   "parseExpression": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.parseExpression,
/* harmony export */   "Char": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Char,
/* harmony export */   "Access": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Access,
/* harmony export */   "Precedence": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Precedence,
/* harmony export */   "parse": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.parse,
/* harmony export */   "ParserState": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ParserState,
/* harmony export */   "ArrayObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayObserver,
/* harmony export */   "ArrayIndexObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ArrayIndexObserver,
/* harmony export */   "enableArrayObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.enableArrayObservation,
/* harmony export */   "disableArrayObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.disableArrayObservation,
/* harmony export */   "applyMutationsToIndices": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.applyMutationsToIndices,
/* harmony export */   "synchronizeIndices": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.synchronizeIndices,
/* harmony export */   "MapObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.MapObserver,
/* harmony export */   "enableMapObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.enableMapObservation,
/* harmony export */   "disableMapObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.disableMapObservation,
/* harmony export */   "SetObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.SetObserver,
/* harmony export */   "enableSetObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.enableSetObservation,
/* harmony export */   "disableSetObservation": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.disableSetObservation,
/* harmony export */   "BindingContext": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingContext,
/* harmony export */   "Scope": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.Scope,
/* harmony export */   "OverrideContext": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.OverrideContext,
/* harmony export */   "CollectionLengthObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CollectionLengthObserver,
/* harmony export */   "CollectionSizeObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CollectionSizeObserver,
/* harmony export */   "IDirtyChecker": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.IDirtyChecker,
/* harmony export */   "DirtyCheckProperty": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.DirtyCheckProperty,
/* harmony export */   "DirtyCheckSettings": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.DirtyCheckSettings,
/* harmony export */   "ComputedObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ComputedObserver,
/* harmony export */   "observable": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.observable,
/* harmony export */   "IObserverLocator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.IObserverLocator,
/* harmony export */   "INodeObserverLocator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.INodeObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.getCollectionObserver,
/* harmony export */   "ObserverLocator": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ObserverLocator,
/* harmony export */   "PrimitiveObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.PrimitiveObserver,
/* harmony export */   "PropertyAccessor": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.PropertyAccessor,
/* harmony export */   "SetterObserver": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.SetterObserver,
/* harmony export */   "ISignaler": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ISignaler,
/* harmony export */   "subscriberCollection": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.subscriberCollection,
/* harmony export */   "bindingBehavior": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.bindingBehavior,
/* harmony export */   "BindingBehavior": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehavior,
/* harmony export */   "BindingBehaviorDefinition": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorDefinition,
/* harmony export */   "BindingInterceptor": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingInterceptor,
/* harmony export */   "BindingBehaviorFactory": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorFactory,
/* harmony export */   "BindingBehaviorStrategy": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingBehaviorStrategy,
/* harmony export */   "ValueConverter": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ValueConverter,
/* harmony export */   "ValueConverterDefinition": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ValueConverterDefinition,
/* harmony export */   "valueConverter": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.valueConverter,
/* harmony export */   "BindingMode": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.BindingMode,
/* harmony export */   "ExpressionKind": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.ExpressionKind,
/* harmony export */   "LifecycleFlags": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.LifecycleFlags,
/* harmony export */   "AccessorType": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.AccessorType,
/* harmony export */   "CollectionKind": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.CollectionKind,
/* harmony export */   "DelegationStrategy": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.DelegationStrategy,
/* harmony export */   "isIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.isIndexMap,
/* harmony export */   "copyIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.copyIndexMap,
/* harmony export */   "cloneIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.cloneIndexMap,
/* harmony export */   "createIndexMap": () => /* reexport safe */ _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__.createIndexMap,
/* harmony export */   "Aurelia": () => /* reexport safe */ _aurelia_js__WEBPACK_IMPORTED_MODULE_10__.Aurelia,
/* harmony export */   "IAurelia": () => /* reexport safe */ _aurelia_js__WEBPACK_IMPORTED_MODULE_10__.IAurelia,
/* harmony export */   "AppRoot": () => /* reexport safe */ _app_root_js__WEBPACK_IMPORTED_MODULE_11__.AppRoot,
/* harmony export */   "IAppRoot": () => /* reexport safe */ _app_root_js__WEBPACK_IMPORTED_MODULE_11__.IAppRoot,
/* harmony export */   "AppTask": () => /* reexport safe */ _app_task_js__WEBPACK_IMPORTED_MODULE_12__.AppTask,
/* harmony export */   "IAppTask": () => /* reexport safe */ _app_task_js__WEBPACK_IMPORTED_MODULE_12__.IAppTask,
/* harmony export */   "AttrSyntax": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.AttrSyntax,
/* harmony export */   "IAttributeParser": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.IAttributeParser,
/* harmony export */   "attributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.attributePattern,
/* harmony export */   "IAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.IAttributePattern,
/* harmony export */   "AttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.AttributePattern,
/* harmony export */   "Interpretation": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.Interpretation,
/* harmony export */   "ISyntaxInterpreter": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.ISyntaxInterpreter,
/* harmony export */   "AtPrefixedTriggerAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.AtPrefixedTriggerAttributePattern,
/* harmony export */   "ColonPrefixedBindAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.ColonPrefixedBindAttributePattern,
/* harmony export */   "DotSeparatedAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.DotSeparatedAttributePattern,
/* harmony export */   "RefAttributePattern": () => /* reexport safe */ _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__.RefAttributePattern,
/* harmony export */   "bindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.bindingCommand,
/* harmony export */   "BindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.BindingCommand,
/* harmony export */   "BindingCommandDefinition": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.BindingCommandDefinition,
/* harmony export */   "getTarget": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.getTarget,
/* harmony export */   "CallBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.CallBindingCommand,
/* harmony export */   "DefaultBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.DefaultBindingCommand,
/* harmony export */   "ForBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.ForBindingCommand,
/* harmony export */   "FromViewBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.FromViewBindingCommand,
/* harmony export */   "OneTimeBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.OneTimeBindingCommand,
/* harmony export */   "ToViewBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.ToViewBindingCommand,
/* harmony export */   "TwoWayBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.TwoWayBindingCommand,
/* harmony export */   "TriggerBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.TriggerBindingCommand,
/* harmony export */   "DelegateBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.DelegateBindingCommand,
/* harmony export */   "CaptureBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.CaptureBindingCommand,
/* harmony export */   "AttrBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.AttrBindingCommand,
/* harmony export */   "ClassBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.ClassBindingCommand,
/* harmony export */   "StyleBindingCommand": () => /* reexport safe */ _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__.StyleBindingCommand,
/* harmony export */   "IAttrSyntaxTransformer": () => /* reexport safe */ _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_15__.IAttrSyntaxTransformer,
/* harmony export */   "Listener": () => /* reexport safe */ _binding_listener_js__WEBPACK_IMPORTED_MODULE_16__.Listener,
/* harmony export */   "AttributeBinding": () => /* reexport safe */ _binding_attribute_js__WEBPACK_IMPORTED_MODULE_17__.AttributeBinding,
/* harmony export */   "CallBinding": () => /* reexport safe */ _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_18__.CallBinding,
/* harmony export */   "InterpolationBinding": () => /* reexport safe */ _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_19__.InterpolationBinding,
/* harmony export */   "LetBinding": () => /* reexport safe */ _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_20__.LetBinding,
/* harmony export */   "PropertyBinding": () => /* reexport safe */ _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_21__.PropertyBinding,
/* harmony export */   "RefBinding": () => /* reexport safe */ _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_22__.RefBinding,
/* harmony export */   "IRenderer": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.IRenderer,
/* harmony export */   "ITemplateCompiler": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.ITemplateCompiler,
/* harmony export */   "renderer": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.renderer,
/* harmony export */   "CallBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.CallBindingInstruction,
/* harmony export */   "HydrateAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateAttributeInstruction,
/* harmony export */   "HydrateElementInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateElementInstruction,
/* harmony export */   "HydrateTemplateController": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateTemplateController,
/* harmony export */   "InterpolationInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.InterpolationInstruction,
/* harmony export */   "IteratorBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.IteratorBindingInstruction,
/* harmony export */   "LetBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.LetBindingInstruction,
/* harmony export */   "HydrateLetElementInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.HydrateLetElementInstruction,
/* harmony export */   "RefBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.RefBindingInstruction,
/* harmony export */   "SetPropertyInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetPropertyInstruction,
/* harmony export */   "AttributeBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.AttributeBindingInstruction,
/* harmony export */   "ListenerBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.ListenerBindingInstruction,
/* harmony export */   "PropertyBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.PropertyBindingInstruction,
/* harmony export */   "SetAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetAttributeInstruction,
/* harmony export */   "SetClassAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetClassAttributeInstruction,
/* harmony export */   "SetStyleAttributeInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.SetStyleAttributeInstruction,
/* harmony export */   "StylePropertyBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.StylePropertyBindingInstruction,
/* harmony export */   "TextBindingInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.TextBindingInstruction,
/* harmony export */   "isInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.isInstruction,
/* harmony export */   "IInstruction": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.IInstruction,
/* harmony export */   "InstructionType": () => /* reexport safe */ _renderer_js__WEBPACK_IMPORTED_MODULE_23__.InstructionType,
/* harmony export */   "AttributeNSAccessor": () => /* reexport safe */ _observation_attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_24__.AttributeNSAccessor,
/* harmony export */   "CheckedObserver": () => /* reexport safe */ _observation_checked_observer_js__WEBPACK_IMPORTED_MODULE_25__.CheckedObserver,
/* harmony export */   "ClassAttributeAccessor": () => /* reexport safe */ _observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_26__.ClassAttributeAccessor,
/* harmony export */   "DataAttributeAccessor": () => /* reexport safe */ _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_27__.DataAttributeAccessor,
/* harmony export */   "IEventDelegator": () => /* reexport safe */ _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__.IEventDelegator,
/* harmony export */   "EventSubscriber": () => /* reexport safe */ _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__.EventSubscriber,
/* harmony export */   "EventDelegator": () => /* reexport safe */ _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__.EventDelegator,
/* harmony export */   "NodeObserverConfig": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_29__.NodeObserverConfig,
/* harmony export */   "NodeObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_29__.NodeObserverLocator,
/* harmony export */   "SelectValueObserver": () => /* reexport safe */ _observation_select_value_observer_js__WEBPACK_IMPORTED_MODULE_30__.SelectValueObserver,
/* harmony export */   "StyleAttributeAccessor": () => /* reexport safe */ _observation_style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_31__.StyleAttributeAccessor,
/* harmony export */   "ISVGAnalyzer": () => /* reexport safe */ _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__.ISVGAnalyzer,
/* harmony export */   "SVGAnalyzer": () => /* reexport safe */ _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__.SVGAnalyzer,
/* harmony export */   "NoopSVGAnalyzer": () => /* reexport safe */ _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__.NoopSVGAnalyzer,
/* harmony export */   "ValueAttributeObserver": () => /* reexport safe */ _observation_value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_33__.ValueAttributeObserver,
/* harmony export */   "AttrBindingBehavior": () => /* reexport safe */ _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_34__.AttrBindingBehavior,
/* harmony export */   "SelfBindingBehavior": () => /* reexport safe */ _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_35__.SelfBindingBehavior,
/* harmony export */   "UpdateTriggerBindingBehavior": () => /* reexport safe */ _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_36__.UpdateTriggerBindingBehavior,
/* harmony export */   "customAttribute": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.customAttribute,
/* harmony export */   "CustomAttribute": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.CustomAttribute,
/* harmony export */   "CustomAttributeDefinition": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.CustomAttributeDefinition,
/* harmony export */   "templateController": () => /* reexport safe */ _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__.templateController,
/* harmony export */   "FrequentMutations": () => /* reexport safe */ _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_38__.FrequentMutations,
/* harmony export */   "ObserveShallow": () => /* reexport safe */ _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_38__.ObserveShallow,
/* harmony export */   "If": () => /* reexport safe */ _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_39__.If,
/* harmony export */   "Else": () => /* reexport safe */ _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_39__.Else,
/* harmony export */   "Repeat": () => /* reexport safe */ _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_40__.Repeat,
/* harmony export */   "With": () => /* reexport safe */ _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_41__.With,
/* harmony export */   "Switch": () => /* reexport safe */ _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__.Switch,
/* harmony export */   "Case": () => /* reexport safe */ _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__.Case,
/* harmony export */   "DefaultCase": () => /* reexport safe */ _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__.DefaultCase,
/* harmony export */   "Blur": () => /* reexport safe */ _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_43__.Blur,
/* harmony export */   "BlurManager": () => /* reexport safe */ _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_43__.BlurManager,
/* harmony export */   "Focus": () => /* reexport safe */ _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_44__.Focus,
/* harmony export */   "Portal": () => /* reexport safe */ _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_45__.Portal,
/* harmony export */   "AuSlot": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.AuSlot,
/* harmony export */   "IProjections": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.IProjections,
/* harmony export */   "SlotInfo": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.SlotInfo,
/* harmony export */   "AuSlotContentType": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.AuSlotContentType,
/* harmony export */   "RegisteredProjections": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.RegisteredProjections,
/* harmony export */   "IProjectionProvider": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.IProjectionProvider,
/* harmony export */   "ProjectionContext": () => /* reexport safe */ _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__.ProjectionContext,
/* harmony export */   "containerless": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.containerless,
/* harmony export */   "customElement": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.customElement,
/* harmony export */   "CustomElement": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.CustomElement,
/* harmony export */   "CustomElementDefinition": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.CustomElementDefinition,
/* harmony export */   "useShadowDOM": () => /* reexport safe */ _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__.useShadowDOM,
/* harmony export */   "Compose": () => /* reexport safe */ _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_48__.Compose,
/* harmony export */   "ISanitizer": () => /* reexport safe */ _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_49__.ISanitizer,
/* harmony export */   "SanitizeValueConverter": () => /* reexport safe */ _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_49__.SanitizeValueConverter,
/* harmony export */   "ViewValueConverter": () => /* reexport safe */ _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_50__.ViewValueConverter,
/* harmony export */   "ITemplateCompilerRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ITemplateCompilerRegistration,
/* harmony export */   "INodeObserverLocatorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.INodeObserverLocatorRegistration,
/* harmony export */   "DefaultComponents": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultComponents,
/* harmony export */   "RefAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RefAttributePatternRegistration,
/* harmony export */   "DotSeparatedAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DotSeparatedAttributePatternRegistration,
/* harmony export */   "DefaultBindingSyntax": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultBindingSyntax,
/* harmony export */   "AtPrefixedTriggerAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AtPrefixedTriggerAttributePatternRegistration,
/* harmony export */   "ColonPrefixedBindAttributePatternRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ColonPrefixedBindAttributePatternRegistration,
/* harmony export */   "ShortHandBindingSyntax": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ShortHandBindingSyntax,
/* harmony export */   "SVGAnalyzerRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SVGAnalyzerRegistration,
/* harmony export */   "CallBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CallBindingCommandRegistration,
/* harmony export */   "DefaultBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultBindingCommandRegistration,
/* harmony export */   "ForBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ForBindingCommandRegistration,
/* harmony export */   "RefBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RefBindingCommandRegistration,
/* harmony export */   "FromViewBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.FromViewBindingCommandRegistration,
/* harmony export */   "OneTimeBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.OneTimeBindingCommandRegistration,
/* harmony export */   "ToViewBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ToViewBindingCommandRegistration,
/* harmony export */   "TwoWayBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TwoWayBindingCommandRegistration,
/* harmony export */   "TriggerBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TriggerBindingCommandRegistration,
/* harmony export */   "DelegateBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DelegateBindingCommandRegistration,
/* harmony export */   "CaptureBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CaptureBindingCommandRegistration,
/* harmony export */   "AttrBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AttrBindingCommandRegistration,
/* harmony export */   "ClassBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ClassBindingCommandRegistration,
/* harmony export */   "StyleBindingCommandRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.StyleBindingCommandRegistration,
/* harmony export */   "DefaultBindingLanguage": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultBindingLanguage,
/* harmony export */   "ViewValueConverterRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ViewValueConverterRegistration,
/* harmony export */   "SanitizeValueConverterRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SanitizeValueConverterRegistration,
/* harmony export */   "IfRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.IfRegistration,
/* harmony export */   "ElseRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ElseRegistration,
/* harmony export */   "RepeatRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RepeatRegistration,
/* harmony export */   "WithRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.WithRegistration,
/* harmony export */   "AttrBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AttrBindingBehaviorRegistration,
/* harmony export */   "SelfBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SelfBindingBehaviorRegistration,
/* harmony export */   "UpdateTriggerBindingBehaviorRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.UpdateTriggerBindingBehaviorRegistration,
/* harmony export */   "ComposeRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ComposeRegistration,
/* harmony export */   "DefaultResources": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultResources,
/* harmony export */   "AttributeBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.AttributeBindingRendererRegistration,
/* harmony export */   "ListenerBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.ListenerBindingRendererRegistration,
/* harmony export */   "SetAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetAttributeRendererRegistration,
/* harmony export */   "SetClassAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetClassAttributeRendererRegistration,
/* harmony export */   "SetStyleAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetStyleAttributeRendererRegistration,
/* harmony export */   "StylePropertyBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.StylePropertyBindingRendererRegistration,
/* harmony export */   "TextBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TextBindingRendererRegistration,
/* harmony export */   "RefBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.RefBindingRendererRegistration,
/* harmony export */   "CallBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CallBindingRendererRegistration,
/* harmony export */   "CustomAttributeRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CustomAttributeRendererRegistration,
/* harmony export */   "CustomElementRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.CustomElementRendererRegistration,
/* harmony export */   "InterpolationBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBindingRendererRegistration,
/* harmony export */   "IteratorBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.IteratorBindingRendererRegistration,
/* harmony export */   "LetElementRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.LetElementRendererRegistration,
/* harmony export */   "PropertyBindingRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.PropertyBindingRendererRegistration,
/* harmony export */   "SetPropertyRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.SetPropertyRendererRegistration,
/* harmony export */   "TemplateControllerRendererRegistration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.TemplateControllerRendererRegistration,
/* harmony export */   "DefaultRenderers": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.DefaultRenderers,
/* harmony export */   "StandardConfiguration": () => /* reexport safe */ _configuration_js__WEBPACK_IMPORTED_MODULE_4__.StandardConfiguration,
/* harmony export */   "TemplateBinder": () => /* reexport safe */ _template_binder_js__WEBPACK_IMPORTED_MODULE_51__.TemplateBinder,
/* harmony export */   "ITemplateElementFactory": () => /* reexport safe */ _template_element_factory_js__WEBPACK_IMPORTED_MODULE_52__.ITemplateElementFactory,
/* harmony export */   "ChildrenDefinition": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.ChildrenDefinition,
/* harmony export */   "Children": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.Children,
/* harmony export */   "children": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.children,
/* harmony export */   "ChildrenObserver": () => /* reexport safe */ _templating_children_js__WEBPACK_IMPORTED_MODULE_53__.ChildrenObserver,
/* harmony export */   "Controller": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.Controller,
/* harmony export */   "isCustomElementController": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.isCustomElementController,
/* harmony export */   "isCustomElementViewModel": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.isCustomElementViewModel,
/* harmony export */   "ViewModelKind": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.ViewModelKind,
/* harmony export */   "IController": () => /* reexport safe */ _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__.IController,
/* harmony export */   "getRenderContext": () => /* reexport safe */ _templating_render_context_js__WEBPACK_IMPORTED_MODULE_55__.getRenderContext,
/* harmony export */   "isRenderContext": () => /* reexport safe */ _templating_render_context_js__WEBPACK_IMPORTED_MODULE_55__.isRenderContext,
/* harmony export */   "ViewFactory": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.ViewFactory,
/* harmony export */   "IViewFactory": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.IViewFactory,
/* harmony export */   "IViewLocator": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.IViewLocator,
/* harmony export */   "ViewLocator": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.ViewLocator,
/* harmony export */   "view": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.view,
/* harmony export */   "Views": () => /* reexport safe */ _templating_view_js__WEBPACK_IMPORTED_MODULE_56__.Views,
/* harmony export */   "createElement": () => /* reexport safe */ _create_element_js__WEBPACK_IMPORTED_MODULE_57__.createElement,
/* harmony export */   "RenderPlan": () => /* reexport safe */ _create_element_js__WEBPACK_IMPORTED_MODULE_57__.RenderPlan,
/* harmony export */   "INode": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.INode,
/* harmony export */   "IEventTarget": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IEventTarget,
/* harmony export */   "IRenderLocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IRenderLocation,
/* harmony export */   "NodeType": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.NodeType,
/* harmony export */   "FragmentNodeSequence": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.FragmentNodeSequence,
/* harmony export */   "IHistory": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IHistory,
/* harmony export */   "IWindow": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.IWindow,
/* harmony export */   "ILocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.ILocation,
/* harmony export */   "getEffectiveParentNode": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.getEffectiveParentNode,
/* harmony export */   "setEffectiveParentNode": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.setEffectiveParentNode,
/* harmony export */   "convertToRenderLocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.convertToRenderLocation,
/* harmony export */   "isRenderLocation": () => /* reexport safe */ _dom_js__WEBPACK_IMPORTED_MODULE_58__.isRenderLocation,
/* harmony export */   "IPlatform": () => /* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_59__.IPlatform,
/* harmony export */   "BindableInfo": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.BindableInfo,
/* harmony export */   "ElementInfo": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.ElementInfo,
/* harmony export */   "AttrInfo": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.AttrInfo,
/* harmony export */   "BindingSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.BindingSymbol,
/* harmony export */   "CustomAttributeSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.CustomAttributeSymbol,
/* harmony export */   "CustomElementSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.CustomElementSymbol,
/* harmony export */   "LetElementSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.LetElementSymbol,
/* harmony export */   "PlainAttributeSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.PlainAttributeSymbol,
/* harmony export */   "PlainElementSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.PlainElementSymbol,
/* harmony export */   "SymbolFlags": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.SymbolFlags,
/* harmony export */   "TemplateControllerSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.TemplateControllerSymbol,
/* harmony export */   "TextSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.TextSymbol,
/* harmony export */   "ProjectionSymbol": () => /* reexport safe */ _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__.ProjectionSymbol,
/* harmony export */   "CSSModulesProcessorRegistry": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.CSSModulesProcessorRegistry,
/* harmony export */   "cssModules": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.cssModules,
/* harmony export */   "ShadowDOMRegistry": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.ShadowDOMRegistry,
/* harmony export */   "IShadowDOMStyleFactory": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.IShadowDOMStyleFactory,
/* harmony export */   "shadowCSS": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.shadowCSS,
/* harmony export */   "StyleConfiguration": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.StyleConfiguration,
/* harmony export */   "AdoptedStyleSheetsStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.AdoptedStyleSheetsStyles,
/* harmony export */   "StyleElementStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.StyleElementStyles,
/* harmony export */   "IShadowDOMStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.IShadowDOMStyles,
/* harmony export */   "IShadowDOMGlobalStyles": () => /* reexport safe */ _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__.IShadowDOMGlobalStyles,
/* harmony export */   "Watch": () => /* reexport safe */ _watch_js__WEBPACK_IMPORTED_MODULE_62__.Watch,
/* harmony export */   "watch": () => /* reexport safe */ _watch_js__WEBPACK_IMPORTED_MODULE_62__.watch,
/* harmony export */   "ComputedWatcher": () => /* reexport safe */ _templating_watchers_js__WEBPACK_IMPORTED_MODULE_63__.ComputedWatcher,
/* harmony export */   "ExpressionWatcher": () => /* reexport safe */ _templating_watchers_js__WEBPACK_IMPORTED_MODULE_63__.ExpressionWatcher
/* harmony export */ });
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");
/* harmony import */ var _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform-browser */ "./node_modules/@aurelia/platform-browser/dist/esm/index.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observation/bindable-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js");
/* harmony import */ var _configuration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./configuration.js */ "./node_modules/@aurelia/runtime-html/dist/esm/configuration.js");
/* harmony import */ var _binding_behaviors_binding_mode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding-behaviors/binding-mode.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/binding-mode.js");
/* harmony import */ var _binding_behaviors_debounce_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./binding-behaviors/debounce.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/debounce.js");
/* harmony import */ var _binding_behaviors_signals_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./binding-behaviors/signals.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/signals.js");
/* harmony import */ var _binding_behaviors_throttle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./binding-behaviors/throttle.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding-behaviors/throttle.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _aurelia_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./aurelia.js */ "./node_modules/@aurelia/runtime-html/dist/esm/aurelia.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _app_task_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./app-task.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js");
/* harmony import */ var _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resources/attribute-pattern.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js");
/* harmony import */ var _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./resources/binding-command.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js");
/* harmony import */ var _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./attribute-syntax-transformer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js");
/* harmony import */ var _binding_listener_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./binding/listener.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js");
/* harmony import */ var _binding_attribute_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./binding/attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js");
/* harmony import */ var _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./binding/call-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js");
/* harmony import */ var _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./binding/interpolation-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js");
/* harmony import */ var _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./binding/let-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js");
/* harmony import */ var _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./binding/property-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js");
/* harmony import */ var _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./binding/ref-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _observation_attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./observation/attribute-ns-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js");
/* harmony import */ var _observation_checked_observer_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./observation/checked-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js");
/* harmony import */ var _observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./observation/class-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js");
/* harmony import */ var _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./observation/data-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js");
/* harmony import */ var _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./observation/event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./observation/observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");
/* harmony import */ var _observation_select_value_observer_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./observation/select-value-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js");
/* harmony import */ var _observation_style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./observation/style-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js");
/* harmony import */ var _observation_svg_analyzer_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./observation/svg-analyzer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js");
/* harmony import */ var _observation_value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./observation/value-attribute-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js");
/* harmony import */ var _resources_binding_behaviors_attr_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./resources/binding-behaviors/attr.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js");
/* harmony import */ var _resources_binding_behaviors_self_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./resources/binding-behaviors/self.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js");
/* harmony import */ var _resources_binding_behaviors_update_trigger_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./resources/binding-behaviors/update-trigger.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _resources_template_controllers_flags_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./resources/template-controllers/flags.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js");
/* harmony import */ var _resources_template_controllers_if_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./resources/template-controllers/if.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js");
/* harmony import */ var _resources_template_controllers_repeat_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./resources/template-controllers/repeat.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js");
/* harmony import */ var _resources_template_controllers_with_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./resources/template-controllers/with.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js");
/* harmony import */ var _resources_template_controllers_switch_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./resources/template-controllers/switch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js");
/* harmony import */ var _resources_custom_attributes_blur_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./resources/custom-attributes/blur.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js");
/* harmony import */ var _resources_custom_attributes_focus_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./resources/custom-attributes/focus.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js");
/* harmony import */ var _resources_template_controllers_portal_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./resources/template-controllers/portal.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _resources_custom_elements_compose_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./resources/custom-elements/compose.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js");
/* harmony import */ var _resources_value_converters_sanitize_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./resources/value-converters/sanitize.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js");
/* harmony import */ var _resources_value_converters_view_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./resources/value-converters/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js");
/* harmony import */ var _template_binder_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./template-binder.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js");
/* harmony import */ var _template_element_factory_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./template-element-factory.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js");
/* harmony import */ var _templating_children_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./templating/children.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _create_element_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./create-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/create-element.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _semantic_model_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./semantic-model.js */ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js");
/* harmony import */ var _templating_styles_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./templating/styles.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js");
/* harmony import */ var _watch_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./watch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js");
/* harmony import */ var _templating_watchers_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./templating/watchers.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js");























































// These exports are temporary until we have a proper way to unit test them










//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeNSAccessor": () => /* binding */ AttributeNSAccessor
/* harmony export */ });
const nsMap = Object.create(null);
/**
 * Attribute accessor in a XML document/element that can be accessed via a namespace.
 * Wraps [`getAttributeNS`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS).
 */
class AttributeNSAccessor {
    constructor(namespace) {
        this.namespace = namespace;
        this.currentValue = null;
        // ObserverType.Layout is not always true, it depends on the property
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    static forNs(ns) {
        return nsMap[ns] ?? (nsMap[ns] = new AttributeNSAccessor(ns));
    }
    getValue(obj, propertyKey) {
        return obj.getAttributeNS(this.namespace, propertyKey);
    }
    setValue(newValue, flags, obj, key) {
        if (newValue == void 0) {
            obj.removeAttributeNS(this.namespace, key);
        }
        else {
            obj.setAttributeNS(this.namespace, key, newValue);
        }
    }
}
//# sourceMappingURL=attribute-ns-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindableObserver": () => /* binding */ BindableObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


class BindableObserver {
    constructor(obj, propertyKey, cbName, set, $controller) {
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.set = set;
        this.$controller = $controller;
        this.currentValue = void 0;
        this.oldValue = void 0;
        const cb = obj[cbName];
        const cbAll = obj.propertyChanged;
        const hasCb = this.hasCb = typeof cb === 'function';
        const hasCbAll = this.hasCbAll = typeof cbAll === 'function';
        const hasSetter = this.hasSetter = set !== _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop;
        this.cb = hasCb ? cb : _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop;
        this.cbAll = this.hasCbAll ? cbAll : _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop;
        // when user declare @bindable({ set })
        // it's expected to work from the start,
        // regardless where the assignment comes from: either direct view model assignment or from binding during render
        // so if either getter/setter config is present, alter the accessor straight await
        if (this.cb === void 0 && !hasCbAll && !hasSetter) {
            this.observing = false;
        }
        else {
            this.observing = true;
            const val = obj[propertyKey];
            this.currentValue = hasSetter && val !== void 0 ? set(val) : val;
            this.createGetterSetter();
        }
    }
    get type() { return 1 /* Observer */; }
    getValue() {
        return this.currentValue;
    }
    setValue(newValue, flags) {
        if (this.hasSetter) {
            newValue = this.set(newValue);
        }
        if (this.observing) {
            const currentValue = this.currentValue;
            if (Object.is(newValue, currentValue)) {
                return;
            }
            this.currentValue = newValue;
            // todo: controller (if any) state should determine the invocation instead
            if ((flags & 32 /* fromBind */) === 0 || (flags & 16 /* updateSource */) > 0) {
                if (this.hasCb) {
                    this.cb.call(this.obj, newValue, currentValue, flags);
                }
                if (this.hasCbAll) {
                    this.cbAll.call(this.obj, this.propertyKey, newValue, currentValue, flags);
                }
            }
            this.subs.notify(newValue, currentValue, flags);
        }
        else {
            // See SetterObserver.setValue for explanation
            this.obj[this.propertyKey] = newValue;
        }
    }
    subscribe(subscriber) {
        if (!this.observing === false) {
            this.observing = true;
            const currentValue = this.obj[this.propertyKey];
            this.currentValue = this.hasSetter
                ? this.set(currentValue)
                : currentValue;
            this.createGetterSetter();
        }
        this.subs.add(subscriber);
    }
    createGetterSetter() {
        Reflect.defineProperty(this.obj, this.propertyKey, {
            enumerable: true,
            configurable: true,
            get: ( /* Bindable Observer */) => this.currentValue,
            set: (/* Bindable Observer */ value) => {
                this.setValue(value, 0 /* none */);
            }
        });
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)(BindableObserver);
//# sourceMappingURL=bindable-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CheckedObserver": () => /* binding */ CheckedObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observer_locator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");


function defaultMatcher(a, b) {
    return a === b;
}
class CheckedObserver {
    constructor(obj, 
    // deepscan-disable-next-line
    _key, handler, observerLocator) {
        this.handler = handler;
        this.observerLocator = observerLocator;
        this.value = void 0;
        this.oldValue = void 0;
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
        this.collectionObserver = void 0;
        this.valueObserver = void 0;
        this.obj = obj;
    }
    getValue() {
        return this.value;
    }
    setValue(newValue, flags) {
        const currentValue = this.value;
        if (newValue === currentValue) {
            return;
        }
        this.value = newValue;
        this.oldValue = currentValue;
        this.observe();
        this.synchronizeElement();
        this.subs.notify(newValue, currentValue, flags);
    }
    handleCollectionChange(indexMap, flags) {
        this.synchronizeElement();
    }
    handleChange(newValue, previousValue, flags) {
        this.synchronizeElement();
    }
    synchronizeElement() {
        const currentValue = this.value;
        const obj = this.obj;
        const elementValue = Object.prototype.hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;
        const isRadio = obj.type === 'radio';
        const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
        if (isRadio) {
            obj.checked = !!matcher(currentValue, elementValue);
        }
        else if (currentValue === true) {
            obj.checked = true;
        }
        else {
            let hasMatch = false;
            if (currentValue instanceof Array) {
                hasMatch = currentValue.findIndex(item => !!matcher(item, elementValue)) !== -1;
            }
            else if (currentValue instanceof Set) {
                for (const v of currentValue) {
                    if (matcher(v, elementValue)) {
                        hasMatch = true;
                        break;
                    }
                }
            }
            else if (currentValue instanceof Map) {
                for (const pair of currentValue) {
                    const existingItem = pair[0];
                    const $isChecked = pair[1];
                    // a potential complain, when only `true` is supported
                    // but it's consistent with array
                    if (matcher(existingItem, elementValue) && $isChecked === true) {
                        hasMatch = true;
                        break;
                    }
                }
            }
            obj.checked = hasMatch;
        }
    }
    handleEvent() {
        let currentValue = this.oldValue = this.value;
        const obj = this.obj;
        const elementValue = Object.prototype.hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;
        const isChecked = obj.checked;
        const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
        if (obj.type === 'checkbox') {
            if (currentValue instanceof Array) {
                // Array binding steps on a change event:
                // 1. find corresponding item INDEX in the Set based on current model/value and matcher
                // 2. is the checkbox checked?
                //    2.1. Yes: is the corresponding item in the Array (index === -1)?
                //        2.1.1 No: push the current model/value to the Array
                //    2.2. No: is the corresponding item in the Array (index !== -1)?
                //        2.2.1: Yes: remove the corresponding item
                // =================================================
                const index = currentValue.findIndex(item => !!matcher(item, elementValue));
                // if the checkbox is checkde, and there's no matching value in the existing array
                // add the checkbox model/value to the array
                if (isChecked && index === -1) {
                    currentValue.push(elementValue);
                }
                else if (!isChecked && index !== -1) {
                    // if the checkbox is not checked, and found a matching item in the array
                    // based on the checkbox model/value
                    // remove the existing item
                    currentValue.splice(index, 1);
                }
                // when existing currentValue is an array,
                // do not invoke callback as only the array obj has changed
                return;
            }
            else if (currentValue instanceof Set) {
                // Set binding steps on a change event:
                // 1. find corresponding item in the Set based on current model/value and matcher
                // 2. is the checkbox checked?
                //    2.1. Yes: is the corresponding item in the Set?
                //        2.1.1 No: add the current model/value to the Set
                //    2.2. No: is the corresponding item in the Set?
                //        2.2.1: Yes: remove the corresponding item
                // =================================================
                // 1. find corresponding item
                const unset = {};
                let existingItem = unset;
                for (const value of currentValue) {
                    if (matcher(value, elementValue) === true) {
                        existingItem = value;
                        break;
                    }
                }
                // 2.1. Checkbox is checked, is the corresponding item in the Set?
                //
                // if checkbox is checked and there's no value in the existing Set
                // add the checkbox model/value to the Set
                if (isChecked && existingItem === unset) {
                    // 2.1.1. add the current model/value to the Set
                    currentValue.add(elementValue);
                }
                else if (!isChecked && existingItem !== unset) {
                    // 2.2.1 Checkbox is unchecked, corresponding is in the Set
                    //
                    // if checkbox is not checked, and found a matching item in the Set
                    // based on the checkbox model/value
                    // remove the existing item
                    currentValue.delete(existingItem);
                }
                // when existing value is a Set,
                // do not invoke callback as only the Set has been mutated
                return;
            }
            else if (currentValue instanceof Map) {
                // Map binding steps on a change event
                // 1. find corresponding item in the Map based on current model/value and matcher
                // 2. Set the value of the corresponding item in the Map based on checked state of the checkbox
                // =================================================
                // 1. find the corresponding item
                let existingItem;
                for (const pair of currentValue) {
                    const currItem = pair[0];
                    if (matcher(currItem, elementValue) === true) {
                        existingItem = currItem;
                        break;
                    }
                }
                // 2. set the value of the corresponding item in the map
                // if checkbox is checked and there's no value in the existing Map
                // add the checkbox model/value to the Map as key,
                // and value will be checked state of the checkbox
                currentValue.set(existingItem, isChecked);
                // when existing value is a Map,
                // do not invoke callback as only the Map has been mutated
                return;
            }
            currentValue = isChecked;
        }
        else if (isChecked) {
            currentValue = elementValue;
        }
        else {
            // if it's a radio and it has been unchecked
            // do nothing, as the radio that was checked will fire change event and it will be handle there
            // a radio cannot be unchecked by user
            return;
        }
        this.value = currentValue;
        this.subs.notify(this.value, this.oldValue, 0 /* none */);
    }
    start() {
        this.handler.subscribe(this.obj, this);
        this.observe();
    }
    stop() {
        this.handler.dispose();
        this.collectionObserver?.unsubscribe(this);
        this.collectionObserver = void 0;
        this.valueObserver?.unsubscribe(this);
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.start();
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.stop();
        }
    }
    observe() {
        const obj = this.obj;
        (this.valueObserver ?? (this.valueObserver = obj.$observers?.model ?? obj.$observers?.value))?.subscribe(this);
        this.collectionObserver?.unsubscribe(this);
        this.collectionObserver = void 0;
        if (obj.type === 'checkbox') {
            (this.collectionObserver = (0,_observer_locator_js__WEBPACK_IMPORTED_MODULE_1__.getCollectionObserver)(this.value, this.observerLocator))?.subscribe(this);
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(CheckedObserver);
//# sourceMappingURL=checked-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClassAttributeAccessor": () => /* binding */ ClassAttributeAccessor,
/* harmony export */   "getClassesToAdd": () => /* binding */ getClassesToAdd
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

class ClassAttributeAccessor {
    constructor(obj) {
        this.obj = obj;
        this.currentValue = '';
        this.oldValue = '';
        this.doNotCache = true;
        this.nameIndex = {};
        this.version = 0;
        this.hasChanges = false;
        this.isActive = false;
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.currentValue;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            const nameIndex = this.nameIndex;
            let version = this.version;
            this.oldValue = currentValue;
            const classesToAdd = getClassesToAdd(currentValue);
            // Get strings split on a space not including empties
            if (classesToAdd.length > 0) {
                this.addClassesAndUpdateIndex(classesToAdd);
            }
            this.version += 1;
            // First call to setValue?  We're done.
            if (version === 0) {
                return;
            }
            // Remove classes from previous version.
            version -= 1;
            for (const name in nameIndex) {
                if (!Object.prototype.hasOwnProperty.call(nameIndex, name) || nameIndex[name] !== version) {
                    continue;
                }
                // TODO: this has the side-effect that classes already present which are added again,
                // will be removed if they're not present in the next update.
                // Better would be do have some configurability for this behavior, allowing the user to
                // decide whether initial classes always need to be kept, always removed, or something in between
                this.obj.classList.remove(name);
            }
        }
    }
    addClassesAndUpdateIndex(classes) {
        const node = this.obj;
        for (let i = 0, ii = classes.length; i < ii; i++) {
            const className = classes[i];
            if (className.length === 0) {
                continue;
            }
            this.nameIndex[className] = this.version;
            node.classList.add(className);
        }
    }
}
function getClassesToAdd(object) {
    if (typeof object === 'string') {
        return splitClassString(object);
    }
    if (typeof object !== 'object') {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    if (object instanceof Array) {
        const len = object.length;
        if (len > 0) {
            const classes = [];
            for (let i = 0; i < len; ++i) {
                classes.push(...getClassesToAdd(object[i]));
            }
            return classes;
        }
        else {
            return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
    }
    const classes = [];
    for (const property in object) {
        // Let non typical values also evaluate true so disable bool check
        if (Boolean(object[property])) {
            // We must do this in case object property has a space in the name which results in two classes
            if (property.includes(' ')) {
                classes.push(...splitClassString(property));
            }
            else {
                classes.push(property);
            }
        }
    }
    return classes;
}
function splitClassString(classString) {
    const matches = classString.match(/\S+/g);
    if (matches === null) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    return matches;
}
//# sourceMappingURL=class-attribute-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataAttributeAccessor": () => /* binding */ DataAttributeAccessor,
/* harmony export */   "attrAccessor": () => /* binding */ attrAccessor
/* harmony export */ });
/**
 * Attribute accessor for HTML elements.
 * Note that Aurelia works with properties, so in all case it will try to assign to property instead of attributes.
 * Unless the property falls into a special set, then it will use attribute for it.
 *
 * @see ElementPropertyAccessor
 */
class DataAttributeAccessor {
    constructor() {
        this.propertyKey = '';
        this.currentValue = null;
        // ObserverType.Layout is not always true, it depends on the property
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    getValue(obj, key) {
        return obj.getAttribute(key);
    }
    setValue(newValue, flags, obj, key) {
        if (newValue == void 0) {
            obj.removeAttribute(key);
        }
        else {
            obj.setAttribute(key, newValue);
        }
    }
}
const attrAccessor = new DataAttributeAccessor();
//# sourceMappingURL=data-attribute-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/element-attribute-observer.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeObserver": () => /* binding */ AttributeObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

/**
 * Observer for handling two-way binding with attributes
 * Has different strategy for class/style and normal attributes
 * TODO: handle SVG/attributes with namespace
 */
class AttributeObserver {
    constructor(platform, observerLocator, obj, propertyKey, targetAttribute) {
        this.platform = platform;
        this.observerLocator = observerLocator;
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.targetAttribute = targetAttribute;
        this.currentValue = null;
        this.oldValue = null;
        this.hasChanges = false;
        // layout is not certain, depends on the attribute being flushed to owner element
        // but for simple start, always treat as such
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.currentValue;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            this.oldValue = currentValue;
            switch (this.targetAttribute) {
                case 'class': {
                    // Why does class attribute observer setValue look different with class attribute accessor?
                    // ==============
                    // For class list
                    // newValue is simply checked if truthy or falsy
                    // and toggle the class accordingly
                    // -- the rule of this is quite different to normal attribute
                    //
                    // for class attribute, observer is different in a way that it only observes one class at a time
                    // this also comes from syntax, where it would typically be my-class.class="someProperty"
                    //
                    // so there is no need for separating class by space and add all of them like class accessor
                    //
                    // note: not using .toggle API so that environment with broken impl (IE11) won't need to polfyfill by default
                    if (!!currentValue) {
                        this.obj.classList.add(this.propertyKey);
                    }
                    else {
                        this.obj.classList.remove(this.propertyKey);
                    }
                    break;
                }
                case 'style': {
                    let priority = '';
                    let newValue = currentValue;
                    if (typeof newValue === 'string' && newValue.includes('!important')) {
                        priority = 'important';
                        newValue = newValue.replace('!important', '');
                    }
                    this.obj.style.setProperty(this.propertyKey, newValue, priority);
                }
            }
        }
    }
    handleMutation(mutationRecords) {
        let shouldProcess = false;
        for (let i = 0, ii = mutationRecords.length; ii > i; ++i) {
            const record = mutationRecords[i];
            if (record.type === 'attributes' && record.attributeName === this.propertyKey) {
                shouldProcess = true;
                break;
            }
        }
        if (shouldProcess) {
            let newValue;
            switch (this.targetAttribute) {
                case 'class':
                    newValue = this.obj.classList.contains(this.propertyKey);
                    break;
                case 'style':
                    newValue = this.obj.style.getPropertyValue(this.propertyKey);
                    break;
                default:
                    throw new Error(`Unsupported targetAttribute: ${this.targetAttribute}`);
            }
            if (newValue !== this.currentValue) {
                const { currentValue } = this;
                this.currentValue = this.oldValue = newValue;
                this.hasChanges = false;
                this.subs.notify(newValue, currentValue, 0 /* none */);
            }
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.currentValue = this.oldValue = this.obj.getAttribute(this.propertyKey);
            startObservation(this.obj.ownerDocument.defaultView.MutationObserver, this.obj, this);
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            stopObservation(this.obj, this);
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(AttributeObserver);
const startObservation = ($MutationObserver, element, subscription) => {
    if (element.$eMObservers === undefined) {
        element.$eMObservers = new Set();
    }
    if (element.$mObserver === undefined) {
        (element.$mObserver = new $MutationObserver(handleMutation)).observe(element, { attributes: true });
    }
    element.$eMObservers.add(subscription);
};
const stopObservation = (element, subscription) => {
    const $eMObservers = element.$eMObservers;
    if ($eMObservers && $eMObservers.delete(subscription)) {
        if ($eMObservers.size === 0) {
            element.$mObserver.disconnect();
            element.$mObserver = undefined;
        }
        return true;
    }
    return false;
};
const handleMutation = (mutationRecords) => {
    mutationRecords[0].target.$eMObservers.forEach(invokeHandleMutation, mutationRecords);
};
function invokeHandleMutation(s) {
    s.handleMutation(this);
}
//# sourceMappingURL=element-attribute-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DelegateSubscription": () => /* binding */ DelegateSubscription,
/* harmony export */   "EventSubscriber": () => /* binding */ EventSubscriber,
/* harmony export */   "IEventDelegator": () => /* binding */ IEventDelegator,
/* harmony export */   "EventDelegator": () => /* binding */ EventDelegator
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const defaultOptions = {
    capture: false,
};
class ListenerTracker {
    constructor(publisher, eventName, options = defaultOptions) {
        this.publisher = publisher;
        this.eventName = eventName;
        this.options = options;
        this.count = 0;
        this.captureLookups = new Map();
        this.bubbleLookups = new Map();
    }
    increment() {
        if (++this.count === 1) {
            this.publisher.addEventListener(this.eventName, this, this.options);
        }
    }
    decrement() {
        if (--this.count === 0) {
            this.publisher.removeEventListener(this.eventName, this, this.options);
        }
    }
    dispose() {
        if (this.count > 0) {
            this.count = 0;
            this.publisher.removeEventListener(this.eventName, this, this.options);
        }
        this.captureLookups.clear();
        this.bubbleLookups.clear();
    }
    /** @internal */
    getLookup(target) {
        const lookups = this.options.capture === true ? this.captureLookups : this.bubbleLookups;
        let lookup = lookups.get(target);
        if (lookup === void 0) {
            lookups.set(target, lookup = Object.create(null));
        }
        return lookup;
    }
    /** @internal */
    handleEvent(event) {
        const lookups = this.options.capture === true ? this.captureLookups : this.bubbleLookups;
        const path = event.composedPath();
        if (this.options.capture === true) {
            path.reverse();
        }
        for (const target of path) {
            const lookup = lookups.get(target);
            if (lookup === void 0) {
                continue;
            }
            const listener = lookup[this.eventName];
            if (listener === void 0) {
                continue;
            }
            if (typeof listener === 'function') {
                listener(event);
            }
            else {
                listener.handleEvent(event);
            }
            if (event.cancelBubble === true) {
                return;
            }
        }
    }
}
/**
 * Enable dispose() pattern for `delegate` & `capture` commands
 */
class DelegateSubscription {
    constructor(tracker, lookup, eventName, callback) {
        this.tracker = tracker;
        this.lookup = lookup;
        this.eventName = eventName;
        tracker.increment();
        lookup[eventName] = callback;
    }
    dispose() {
        this.tracker.decrement();
        this.lookup[this.eventName] = void 0;
    }
}
class EventSubscriber {
    constructor(config) {
        this.config = config;
        this.target = null;
        this.handler = null;
    }
    subscribe(node, callbackOrListener) {
        this.target = node;
        this.handler = callbackOrListener;
        for (const event of this.config.events) {
            node.addEventListener(event, callbackOrListener);
        }
    }
    dispose() {
        const { target, handler } = this;
        if (target !== null && handler !== null) {
            for (const event of this.config.events) {
                target.removeEventListener(event, handler);
            }
        }
        this.target = this.handler = null;
    }
}
const IEventDelegator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IEventDelegator', x => x.singleton(EventDelegator));
class EventDelegator {
    // eslint-disable-next-line @typescript-eslint/no-useless-constructor
    constructor() {
        this.trackerMaps = Object.create(null);
    }
    addEventListener(publisher, target, eventName, listener, options) {
        var _a;
        const trackerMap = (_a = this.trackerMaps)[eventName] ?? (_a[eventName] = new Map());
        let tracker = trackerMap.get(publisher);
        if (tracker === void 0) {
            trackerMap.set(publisher, tracker = new ListenerTracker(publisher, eventName, options));
        }
        return new DelegateSubscription(tracker, tracker.getLookup(target), eventName, listener);
    }
    dispose() {
        for (const eventName in this.trackerMaps) {
            const trackerMap = this.trackerMaps[eventName];
            for (const tracker of trackerMap.values()) {
                tracker.dispose();
            }
            trackerMap.clear();
        }
    }
}
//# sourceMappingURL=event-delegator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeObserverConfig": () => /* binding */ NodeObserverConfig,
/* harmony export */   "NodeObserverLocator": () => /* binding */ NodeObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* binding */ getCollectionObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attribute-ns-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/attribute-ns-accessor.js");
/* harmony import */ var _checked_observer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./checked-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/checked-observer.js");
/* harmony import */ var _class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./class-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js");
/* harmony import */ var _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js");
/* harmony import */ var _event_delegator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _select_value_observer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select-value-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js");
/* harmony import */ var _style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./style-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js");
/* harmony import */ var _svg_analyzer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./svg-analyzer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js");
/* harmony import */ var _value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./value-attribute-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js");












// https://infra.spec.whatwg.org/#namespaces
const htmlNS = 'http://www.w3.org/1999/xhtml';
const mathmlNS = 'http://www.w3.org/1998/Math/MathML';
const svgNS = 'http://www.w3.org/2000/svg';
const xlinkNS = 'http://www.w3.org/1999/xlink';
const xmlNS = 'http://www.w3.org/XML/1998/namespace';
const xmlnsNS = 'http://www.w3.org/2000/xmlns/';
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
const nsAttributes = Object.assign(createLookup(), {
    'xlink:actuate': ['actuate', xlinkNS],
    'xlink:arcrole': ['arcrole', xlinkNS],
    'xlink:href': ['href', xlinkNS],
    'xlink:role': ['role', xlinkNS],
    'xlink:show': ['show', xlinkNS],
    'xlink:title': ['title', xlinkNS],
    'xlink:type': ['type', xlinkNS],
    'xml:lang': ['lang', xmlNS],
    'xml:space': ['space', xmlNS],
    'xmlns': ['xmlns', xmlnsNS],
    'xmlns:xlink': ['xlink', xmlnsNS],
});
const elementPropertyAccessor = new _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.PropertyAccessor();
elementPropertyAccessor.type = 2 /* Node */ | 4 /* Layout */;
class NodeObserverConfig {
    constructor(config) {
        this.type = config.type ?? _value_attribute_observer_js__WEBPACK_IMPORTED_MODULE_11__.ValueAttributeObserver;
        this.events = config.events;
        this.readonly = config.readonly;
        this.default = config.default;
    }
}
class NodeObserverLocator {
    constructor(locator, platform, dirtyChecker, svgAnalyzer) {
        this.locator = locator;
        this.platform = platform;
        this.dirtyChecker = dirtyChecker;
        this.svgAnalyzer = svgAnalyzer;
        this.allowDirtyCheck = true;
        this.events = createLookup();
        this.globalEvents = createLookup();
        this.overrides = createLookup();
        this.globalOverrides = createLookup();
        // todo: atm, platform is required to be resolved too eagerly for the `.handles()` check
        // also a lot of tests assume default availability of observation
        // those 2 assumptions make it not the right time to extract the following line into a
        // default configuration for NodeObserverLocator yet
        // but in the future, they should be, so apps that don't use check box/select, or implement a different
        // observer don't have to pay the of the default implementation
        const inputEvents = ['change', 'input'];
        const inputEventsConfig = { events: inputEvents, default: '' };
        this.useConfig({
            INPUT: {
                value: inputEventsConfig,
                checked: { type: _checked_observer_js__WEBPACK_IMPORTED_MODULE_4__.CheckedObserver, events: inputEvents },
                files: { events: inputEvents, readonly: true },
            },
            SELECT: {
                value: { type: _select_value_observer_js__WEBPACK_IMPORTED_MODULE_8__.SelectValueObserver, events: ['change'], default: '' },
            },
            TEXTAREA: {
                value: inputEventsConfig,
            },
        });
        const contentEventsConfig = { events: ['change', 'input', 'blur', 'keyup', 'paste'], default: '' };
        const scrollEventsConfig = { events: ['scroll'], default: 0 };
        this.useConfigGlobal({
            scrollTop: scrollEventsConfig,
            scrollLeft: scrollEventsConfig,
            textContent: contentEventsConfig,
            innerHTML: contentEventsConfig,
        });
        this.overrideAccessorGlobal('css', 'style', 'class');
        this.overrideAccessor({
            INPUT: ['value', 'checked', 'model'],
            SELECT: ['value'],
            TEXTAREA: ['value'],
        });
    }
    static register(container) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.INodeObserverLocator, NodeObserverLocator).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.INodeObserverLocator, NodeObserverLocator).register(container);
    }
    // deepscan-disable-next-line
    handles(obj, _key) {
        return obj instanceof this.platform.Node;
    }
    useConfig(nodeNameOrConfig, key, eventsConfig) {
        const lookup = this.events;
        let existingMapping;
        if (typeof nodeNameOrConfig === 'string') {
            existingMapping = lookup[nodeNameOrConfig] ?? (lookup[nodeNameOrConfig] = createLookup());
            if (existingMapping[key] == null) {
                existingMapping[key] = new NodeObserverConfig(eventsConfig);
            }
            else {
                throwMappingExisted(nodeNameOrConfig, key);
            }
        }
        else {
            for (const nodeName in nodeNameOrConfig) {
                existingMapping = lookup[nodeName] ?? (lookup[nodeName] = createLookup());
                const newMapping = nodeNameOrConfig[nodeName];
                for (key in newMapping) {
                    if (existingMapping[key] == null) {
                        existingMapping[key] = new NodeObserverConfig(newMapping[key]);
                    }
                    else {
                        throwMappingExisted(nodeName, key);
                    }
                }
            }
        }
    }
    useConfigGlobal(configOrKey, eventsConfig) {
        const lookup = this.globalEvents;
        if (typeof configOrKey === 'object') {
            for (const key in configOrKey) {
                if (lookup[key] == null) {
                    lookup[key] = new NodeObserverConfig(configOrKey[key]);
                }
                else {
                    throwMappingExisted('*', key);
                }
            }
        }
        else {
            if (lookup[configOrKey] == null) {
                lookup[configOrKey] = new NodeObserverConfig(eventsConfig);
            }
            else {
                throwMappingExisted('*', configOrKey);
            }
        }
    }
    // deepscan-disable-nextline
    getAccessor(obj, key, requestor) {
        if (key in this.globalOverrides || (key in (this.overrides[obj.tagName] ?? _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyObject))) {
            return this.getObserver(obj, key, requestor);
        }
        switch (key) {
            // class / style / css attribute will be observed using .getObserver() per overrides
            //
            // TODO: there are (many) more situation where we want to default to DataAttributeAccessor,
            // but for now stick to what vCurrent does
            case 'src':
            case 'href':
            // https://html.spec.whatwg.org/multipage/dom.html#wai-aria
            case 'role':
                return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
            default: {
                const nsProps = nsAttributes[key];
                if (nsProps !== undefined) {
                    return _attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_3__.AttributeNSAccessor.forNs(nsProps[1]);
                }
                if (isDataAttribute(obj, key, this.svgAnalyzer)) {
                    return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
                }
                return elementPropertyAccessor;
            }
        }
    }
    overrideAccessor(tagNameOrOverrides, key) {
        var _a, _b;
        let existingTagOverride;
        if (typeof tagNameOrOverrides === 'string') {
            existingTagOverride = (_a = this.overrides)[tagNameOrOverrides] ?? (_a[tagNameOrOverrides] = createLookup());
            existingTagOverride[key] = true;
        }
        else {
            for (const tagName in tagNameOrOverrides) {
                for (const key of tagNameOrOverrides[tagName]) {
                    existingTagOverride = (_b = this.overrides)[tagName] ?? (_b[tagName] = createLookup());
                    existingTagOverride[key] = true;
                }
            }
        }
    }
    /**
     * For all elements:
     * compose a list of properties,
     * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`
     */
    overrideAccessorGlobal(...keys) {
        for (const key of keys) {
            this.globalOverrides[key] = true;
        }
    }
    getObserver(el, key, requestor) {
        switch (key) {
            case 'role':
                return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
            case 'class':
                return new _class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_5__.ClassAttributeAccessor(el);
            case 'css':
            case 'style':
                return new _style_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_9__.StyleAttributeAccessor(el);
        }
        const eventsConfig = this.events[el.tagName]?.[key] ?? this.globalEvents[key];
        if (eventsConfig != null) {
            return new eventsConfig.type(el, key, new _event_delegator_js__WEBPACK_IMPORTED_MODULE_7__.EventSubscriber(eventsConfig), requestor, this.locator);
        }
        const nsProps = nsAttributes[key];
        if (nsProps !== undefined) {
            return _attribute_ns_accessor_js__WEBPACK_IMPORTED_MODULE_3__.AttributeNSAccessor.forNs(nsProps[1]);
        }
        if (isDataAttribute(el, key, this.svgAnalyzer)) {
            // todo: should observe
            return _data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_6__.attrAccessor;
        }
        if (key in el.constructor.prototype) {
            if (this.allowDirtyCheck) {
                return this.dirtyChecker.createProperty(el, key);
            }
            // consider:
            // - maybe add a adapter API to handle unknown obj/key combo
            throw new Error(`Unable to observe property ${String(key)}. Register observation mapping with .useConfig().`);
        }
        else {
            // todo: probably still needs to get the property descriptor via getOwnPropertyDescriptor
            // but let's start with simplest scenario
            return new _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.SetterObserver(el, key);
        }
    }
}
NodeObserverLocator.inject = [_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IServiceLocator, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IDirtyChecker, _svg_analyzer_js__WEBPACK_IMPORTED_MODULE_10__.ISVGAnalyzer];
function getCollectionObserver(collection, observerLocator) {
    if (collection instanceof Array) {
        return observerLocator.getArrayObserver(collection);
    }
    if (collection instanceof Map) {
        return observerLocator.getMapObserver(collection);
    }
    if (collection instanceof Set) {
        return observerLocator.getSetObserver(collection);
    }
}
function throwMappingExisted(nodeName, key) {
    throw new Error(`Mapping for property ${String(key)} of <${nodeName} /> already exists`);
}
const IsDataAttribute = createLookup();
function isDataAttribute(obj, key, svgAnalyzer) {
    if (IsDataAttribute[key] === true) {
        return true;
    }
    if (typeof key !== 'string') {
        return false;
    }
    const prefix = key.slice(0, 5);
    // https://html.spec.whatwg.org/multipage/dom.html#wai-aria
    // https://html.spec.whatwg.org/multipage/dom.html#custom-data-attribute
    return IsDataAttribute[key] =
        prefix === 'aria-' ||
            prefix === 'data-' ||
            svgAnalyzer.isStandardSvgAttribute(obj, key);
}
function createLookup() {
    return Object.create(null);
}
//# sourceMappingURL=observer-locator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/select-value-observer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectValueObserver": () => /* binding */ SelectValueObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

const hasOwn = Object.prototype.hasOwnProperty;
const childObserverOptions = {
    childList: true,
    subtree: true,
    characterData: true
};
function defaultMatcher(a, b) {
    return a === b;
}
class SelectValueObserver {
    constructor(obj, 
    // deepscan-disable-next-line
    _key, handler, observerLocator) {
        this.handler = handler;
        this.observerLocator = observerLocator;
        this.currentValue = void 0;
        this.oldValue = void 0;
        this.hasChanges = false;
        // ObserverType.Layout is not always true
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
        this.arrayObserver = void 0;
        this.nodeObserver = void 0;
        this.observing = false;
        this.obj = obj;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.observing
            ? this.currentValue
            : this.obj.multiple
                ? Array.from(this.obj.options).map(o => o.value)
                : this.obj.value;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        this.observeArray(newValue instanceof Array ? newValue : null);
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            this.synchronizeOptions();
        }
    }
    handleCollectionChange() {
        // always sync "selected" property of <options/>
        // immediately whenever the array notifies its mutation
        this.synchronizeOptions();
    }
    notify(flags) {
        if ((flags & 32 /* fromBind */) > 0) {
            return;
        }
        const oldValue = this.oldValue;
        const newValue = this.currentValue;
        if (newValue === oldValue) {
            return;
        }
        this.subs.notify(newValue, oldValue, flags);
    }
    handleEvent() {
        const shouldNotify = this.synchronizeValue();
        if (shouldNotify) {
            this.subs.notify(this.currentValue, this.oldValue, 0 /* none */);
        }
    }
    synchronizeOptions(indexMap) {
        const { currentValue, obj } = this;
        const isArray = Array.isArray(currentValue);
        const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
        const options = obj.options;
        let i = options.length;
        while (i-- > 0) {
            const option = options[i];
            const optionValue = hasOwn.call(option, 'model') ? option.model : option.value;
            if (isArray) {
                option.selected = currentValue.findIndex(item => !!matcher(optionValue, item)) !== -1;
                continue;
            }
            option.selected = !!matcher(optionValue, currentValue);
        }
    }
    synchronizeValue() {
        // Spec for synchronizing value from `<select/>`  to `SelectObserver`
        // When synchronizing value to observed <select/> element, do the following steps:
        // A. If `<select/>` is multiple
        //    1. Check if current value, called `currentValue` is an array
        //      a. If not an array, return true to signal value has changed
        //      b. If is an array:
        //        i. gather all current selected <option/>, in to array called `values`
        //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher
        //        iii. loop through the `values` array and add items that are selected based on matcher
        //        iv. Return false to signal value hasn't changed
        // B. If the select is single
        //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`
        //    2. assign `this.currentValue` to `this.oldValue`
        //    3. assign `value` to `this.currentValue`
        //    4. return `true` to signal value has changed
        const obj = this.obj;
        const options = obj.options;
        const len = options.length;
        const currentValue = this.currentValue;
        let i = 0;
        if (obj.multiple) {
            // A.
            if (!(currentValue instanceof Array)) {
                // A.1.a
                return true;
            }
            // A.1.b
            // multi select
            let option;
            const matcher = obj.matcher || defaultMatcher;
            // A.1.b.i
            const values = [];
            while (i < len) {
                option = options[i];
                if (option.selected) {
                    values.push(hasOwn.call(option, 'model')
                        ? option.model
                        : option.value);
                }
                ++i;
            }
            // A.1.b.ii
            i = 0;
            while (i < currentValue.length) {
                const a = currentValue[i];
                // Todo: remove arrow fn
                if (values.findIndex(b => !!matcher(a, b)) === -1) {
                    currentValue.splice(i, 1);
                }
                else {
                    ++i;
                }
            }
            // A.1.b.iii
            i = 0;
            while (i < values.length) {
                const a = values[i];
                // Todo: remove arrow fn
                if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {
                    currentValue.push(a);
                }
                ++i;
            }
            // A.1.b.iv
            return false;
        }
        // B. single select
        // B.1
        let value = null;
        while (i < len) {
            const option = options[i];
            if (option.selected) {
                value = hasOwn.call(option, 'model')
                    ? option.model
                    : option.value;
                break;
            }
            ++i;
        }
        // B.2
        this.oldValue = this.currentValue;
        // B.3
        this.currentValue = value;
        // B.4
        return true;
    }
    start() {
        (this.nodeObserver = new this.obj.ownerDocument.defaultView.MutationObserver(this.handleNodeChange.bind(this)))
            .observe(this.obj, childObserverOptions);
        this.observeArray(this.currentValue instanceof Array ? this.currentValue : null);
        this.observing = true;
    }
    stop() {
        this.nodeObserver.disconnect();
        this.arrayObserver?.unsubscribe(this);
        this.nodeObserver
            = this.arrayObserver
                = void 0;
        this.observing = false;
    }
    // todo: observe all kind of collection
    observeArray(array) {
        this.arrayObserver?.unsubscribe(this);
        this.arrayObserver = void 0;
        if (array != null) {
            if (!this.obj.multiple) {
                throw new Error('Only null or Array instances can be bound to a multi-select.');
            }
            (this.arrayObserver = this.observerLocator.getArrayObserver(array)).subscribe(this);
        }
    }
    handleNodeChange() {
        this.synchronizeOptions();
        const shouldNotify = this.synchronizeValue();
        if (shouldNotify) {
            this.notify(0 /* none */);
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.handler.subscribe(this.obj, this);
            this.start();
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.handler.dispose();
            this.stop();
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(SelectValueObserver);
//# sourceMappingURL=select-value-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/style-attribute-accessor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyleAttributeAccessor": () => /* binding */ StyleAttributeAccessor
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const customPropertyPrefix = '--';
class StyleAttributeAccessor {
    constructor(obj) {
        this.obj = obj;
        this.currentValue = '';
        this.oldValue = '';
        this.styles = {};
        this.version = 0;
        this.hasChanges = false;
        this.type = 2 /* Node */ | 4 /* Layout */;
    }
    getValue() {
        return this.obj.style.cssText;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if ((flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    getStyleTuplesFromString(currentValue) {
        const styleTuples = [];
        const urlRegexTester = /url\([^)]+$/;
        let offset = 0;
        let currentChunk = '';
        let nextSplit;
        let indexOfColon;
        let attribute;
        let value;
        while (offset < currentValue.length) {
            nextSplit = currentValue.indexOf(';', offset);
            if (nextSplit === -1) {
                nextSplit = currentValue.length;
            }
            currentChunk += currentValue.substring(offset, nextSplit);
            offset = nextSplit + 1;
            // Make sure we never split a url so advance to next
            if (urlRegexTester.test(currentChunk)) {
                currentChunk += ';';
                continue;
            }
            indexOfColon = currentChunk.indexOf(':');
            attribute = currentChunk.substring(0, indexOfColon).trim();
            value = currentChunk.substring(indexOfColon + 1).trim();
            styleTuples.push([attribute, value]);
            currentChunk = '';
        }
        return styleTuples;
    }
    getStyleTuplesFromObject(currentValue) {
        let value;
        const styles = [];
        for (const property in currentValue) {
            value = currentValue[property];
            if (value == null) {
                continue;
            }
            if (typeof value === 'string') {
                // Custom properties should not be tampered with
                if (property.startsWith(customPropertyPrefix)) {
                    styles.push([property, value]);
                    continue;
                }
                styles.push([(0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(property), value]);
                continue;
            }
            styles.push(...this.getStyleTuples(value));
        }
        return styles;
    }
    getStyleTuplesFromArray(currentValue) {
        const len = currentValue.length;
        if (len > 0) {
            const styles = [];
            for (let i = 0; i < len; ++i) {
                styles.push(...this.getStyleTuples(currentValue[i]));
            }
            return styles;
        }
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    getStyleTuples(currentValue) {
        if (typeof currentValue === 'string') {
            return this.getStyleTuplesFromString(currentValue);
        }
        if (currentValue instanceof Array) {
            return this.getStyleTuplesFromArray(currentValue);
        }
        if (currentValue instanceof Object) {
            return this.getStyleTuplesFromObject(currentValue);
        }
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            const styles = this.styles;
            const styleTuples = this.getStyleTuples(currentValue);
            let style;
            let version = this.version;
            this.oldValue = currentValue;
            let tuple;
            let name;
            let value;
            const len = styleTuples.length;
            for (let i = 0; i < len; ++i) {
                tuple = styleTuples[i];
                name = tuple[0];
                value = tuple[1];
                this.setProperty(name, value);
                styles[name] = version;
            }
            this.styles = styles;
            this.version += 1;
            if (version === 0) {
                return;
            }
            version -= 1;
            for (style in styles) {
                if (!Object.prototype.hasOwnProperty.call(styles, style) || styles[style] !== version) {
                    continue;
                }
                this.obj.style.removeProperty(style);
            }
        }
    }
    setProperty(style, value) {
        let priority = '';
        if (value != null && typeof value.indexOf === 'function' && value.includes('!important')) {
            priority = 'important';
            value = value.replace('!important', '');
        }
        this.obj.style.setProperty(style, value, priority);
    }
    bind(flags) {
        this.currentValue = this.oldValue = this.obj.style.cssText;
    }
}
//# sourceMappingURL=style-attribute-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/svg-analyzer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISVGAnalyzer": () => /* binding */ ISVGAnalyzer,
/* harmony export */   "NoopSVGAnalyzer": () => /* binding */ NoopSVGAnalyzer,
/* harmony export */   "SVGAnalyzer": () => /* binding */ SVGAnalyzer
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");


const ISVGAnalyzer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISVGAnalyzer', x => x.singleton(NoopSVGAnalyzer));
class NoopSVGAnalyzer {
    isStandardSvgAttribute(node, attributeName) {
        return false;
    }
}
function o(keys) {
    const lookup = Object.create(null);
    for (const key of keys) {
        lookup[key] = true;
    }
    return lookup;
}
class SVGAnalyzer {
    constructor(platform) {
        this.svgElements = Object.assign(Object.create(null), {
            'a': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'altGlyph': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'altglyph': Object.create(null),
            'altGlyphDef': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'altglyphdef': Object.create(null),
            'altGlyphItem': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'altglyphitem': Object.create(null),
            'animate': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'animateColor': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'animateMotion': o(['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'animateTransform': o(['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'circle': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'clipPath': o(['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'color-profile': o(['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'cursor': o(['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'defs': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'desc': o(['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space']),
            'ellipse': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'feBlend': o(['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feColorMatrix': o(['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feComponentTransfer': o(['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feComposite': o(['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feConvolveMatrix': o(['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feDiffuseLighting': o(['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feDisplacementMap': o(['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector']),
            'feDistantLight': o(['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space']),
            'feFlood': o(['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feFuncA': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feFuncB': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feFuncG': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feFuncR': o(['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'feGaussianBlur': o(['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feImage': o(['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feMerge': o(['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feMergeNode': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'feMorphology': o(['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feOffset': o(['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'fePointLight': o(['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z']),
            'feSpecularLighting': o(['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feSpotLight': o(['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z']),
            'feTile': o(['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'feTurbulence': o(['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'filter': o(['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'font': o(['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face': o(['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-format': o(['id', 'string', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-name': o(['id', 'name', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-src': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'font-face-uri': o(['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'foreignObject': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'g': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'glyph': o(['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
            'glyphRef': o(['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'glyphref': Object.create(null),
            'hkern': o(['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']),
            'image': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'line': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2']),
            'linearGradient': o(['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2']),
            'marker': o(['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space']),
            'mask': o(['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'metadata': o(['id', 'xml:base', 'xml:lang', 'xml:space']),
            'missing-glyph': o(['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space']),
            'mpath': o(['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'path': o(['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'pattern': o(['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'polygon': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'polyline': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'radialGradient': o(['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'rect': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'script': o(['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'set': o(['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'stop': o(['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space']),
            'style': o(['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space']),
            'svg': o(['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan']),
            'switch': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space']),
            'symbol': o(['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space']),
            'text': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'textPath': o(['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space']),
            'title': o(['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space']),
            'tref': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'tspan': o(['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'use': o(['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y']),
            'view': o(['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan']),
            'vkern': o(['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']),
        });
        this.svgPresentationElements = o([
            'a',
            'altGlyph',
            'animate',
            'animateColor',
            'circle',
            'clipPath',
            'defs',
            'ellipse',
            'feBlend',
            'feColorMatrix',
            'feComponentTransfer',
            'feComposite',
            'feConvolveMatrix',
            'feDiffuseLighting',
            'feDisplacementMap',
            'feFlood',
            'feGaussianBlur',
            'feImage',
            'feMerge',
            'feMorphology',
            'feOffset',
            'feSpecularLighting',
            'feTile',
            'feTurbulence',
            'filter',
            'font',
            'foreignObject',
            'g',
            'glyph',
            'glyphRef',
            'image',
            'line',
            'linearGradient',
            'marker',
            'mask',
            'missing-glyph',
            'path',
            'pattern',
            'polygon',
            'polyline',
            'radialGradient',
            'rect',
            'stop',
            'svg',
            'switch',
            'symbol',
            'text',
            'textPath',
            'tref',
            'tspan',
            'use',
        ]);
        this.svgPresentationAttributes = o([
            'alignment-baseline',
            'baseline-shift',
            'clip-path',
            'clip-rule',
            'clip',
            'color-interpolation-filters',
            'color-interpolation',
            'color-profile',
            'color-rendering',
            'color',
            'cursor',
            'direction',
            'display',
            'dominant-baseline',
            'enable-background',
            'fill-opacity',
            'fill-rule',
            'fill',
            'filter',
            'flood-color',
            'flood-opacity',
            'font-family',
            'font-size-adjust',
            'font-size',
            'font-stretch',
            'font-style',
            'font-variant',
            'font-weight',
            'glyph-orientation-horizontal',
            'glyph-orientation-vertical',
            'image-rendering',
            'kerning',
            'letter-spacing',
            'lighting-color',
            'marker-end',
            'marker-mid',
            'marker-start',
            'mask',
            'opacity',
            'overflow',
            'pointer-events',
            'shape-rendering',
            'stop-color',
            'stop-opacity',
            'stroke-dasharray',
            'stroke-dashoffset',
            'stroke-linecap',
            'stroke-linejoin',
            'stroke-miterlimit',
            'stroke-opacity',
            'stroke-width',
            'stroke',
            'text-anchor',
            'text-decoration',
            'text-rendering',
            'unicode-bidi',
            'visibility',
            'word-spacing',
            'writing-mode',
        ]);
        this.SVGElement = platform.globalThis.SVGElement;
        const div = platform.document.createElement('div');
        div.innerHTML = '<svg><altGlyph /></svg>';
        if (div.firstElementChild.nodeName === 'altglyph') {
            // handle chrome casing inconsistencies.
            const svg = this.svgElements;
            let tmp = svg.altGlyph;
            svg.altGlyph = svg.altglyph;
            svg.altglyph = tmp;
            tmp = svg.altGlyphDef;
            svg.altGlyphDef = svg.altglyphdef;
            svg.altglyphdef = tmp;
            tmp = svg.altGlyphItem;
            svg.altGlyphItem = svg.altglyphitem;
            svg.altglyphitem = tmp;
            tmp = svg.glyphRef;
            svg.glyphRef = svg.glyphref;
            svg.glyphref = tmp;
        }
    }
    static register(container) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(ISVGAnalyzer, this).register(container);
    }
    isStandardSvgAttribute(node, attributeName) {
        if (!(node instanceof this.SVGElement)) {
            return false;
        }
        return (this.svgPresentationElements[node.nodeName] === true && this.svgPresentationAttributes[attributeName] === true ||
            this.svgElements[node.nodeName]?.[attributeName] === true);
    }
}
/**
 * @internal
 */
SVGAnalyzer.inject = [_platform_js__WEBPACK_IMPORTED_MODULE_1__.IPlatform];
//# sourceMappingURL=svg-analyzer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/observation/value-attribute-observer.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValueAttributeObserver": () => /* binding */ ValueAttributeObserver
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

/**
 * Observer for non-radio, non-checkbox input.
 */
class ValueAttributeObserver {
    constructor(obj, propertyKey, handler) {
        this.propertyKey = propertyKey;
        this.handler = handler;
        this.currentValue = '';
        this.oldValue = '';
        this.hasChanges = false;
        // ObserverType.Layout is not always true, it depends on the element & property combo
        // but for simplicity, always treat as such
        this.type = 2 /* Node */ | 1 /* Observer */ | 4 /* Layout */;
        this.obj = obj;
    }
    getValue() {
        // is it safe to assume the observer has the latest value?
        // todo: ability to turn on/off cache based on type
        return this.currentValue;
    }
    setValue(newValue, flags) {
        this.currentValue = newValue;
        this.hasChanges = newValue !== this.oldValue;
        if (!this.handler.config.readonly && (flags & 4096 /* noFlush */) === 0) {
            this.flushChanges(flags);
        }
    }
    flushChanges(flags) {
        if (this.hasChanges) {
            this.hasChanges = false;
            const currentValue = this.currentValue;
            const oldValue = this.oldValue;
            this.oldValue = currentValue;
            this.obj[this.propertyKey] = currentValue ?? this.handler.config.default;
            if ((flags & 32 /* fromBind */) === 0) {
                this.subs.notify(currentValue, oldValue, flags);
            }
        }
    }
    handleEvent() {
        const oldValue = this.oldValue = this.currentValue;
        const currentValue = this.currentValue = this.obj[this.propertyKey];
        if (oldValue !== currentValue) {
            this.oldValue = currentValue;
            this.subs.notify(currentValue, oldValue, 0 /* none */);
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.handler.subscribe(this.obj, this);
            this.currentValue = this.oldValue = this.obj[this.propertyKey];
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.handler.dispose();
        }
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(ValueAttributeObserver);
//# sourceMappingURL=value-attribute-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/platform.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IPlatform": () => /* binding */ IPlatform
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const IPlatform = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform;
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/renderer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InstructionType": () => /* binding */ InstructionType,
/* harmony export */   "IInstruction": () => /* binding */ IInstruction,
/* harmony export */   "isInstruction": () => /* binding */ isInstruction,
/* harmony export */   "InterpolationInstruction": () => /* binding */ InterpolationInstruction,
/* harmony export */   "PropertyBindingInstruction": () => /* binding */ PropertyBindingInstruction,
/* harmony export */   "IteratorBindingInstruction": () => /* binding */ IteratorBindingInstruction,
/* harmony export */   "CallBindingInstruction": () => /* binding */ CallBindingInstruction,
/* harmony export */   "RefBindingInstruction": () => /* binding */ RefBindingInstruction,
/* harmony export */   "SetPropertyInstruction": () => /* binding */ SetPropertyInstruction,
/* harmony export */   "HydrateElementInstruction": () => /* binding */ HydrateElementInstruction,
/* harmony export */   "HydrateAttributeInstruction": () => /* binding */ HydrateAttributeInstruction,
/* harmony export */   "HydrateTemplateController": () => /* binding */ HydrateTemplateController,
/* harmony export */   "HydrateLetElementInstruction": () => /* binding */ HydrateLetElementInstruction,
/* harmony export */   "LetBindingInstruction": () => /* binding */ LetBindingInstruction,
/* harmony export */   "TextBindingInstruction": () => /* binding */ TextBindingInstruction,
/* harmony export */   "ListenerBindingInstruction": () => /* binding */ ListenerBindingInstruction,
/* harmony export */   "StylePropertyBindingInstruction": () => /* binding */ StylePropertyBindingInstruction,
/* harmony export */   "SetAttributeInstruction": () => /* binding */ SetAttributeInstruction,
/* harmony export */   "SetClassAttributeInstruction": () => /* binding */ SetClassAttributeInstruction,
/* harmony export */   "SetStyleAttributeInstruction": () => /* binding */ SetStyleAttributeInstruction,
/* harmony export */   "AttributeBindingInstruction": () => /* binding */ AttributeBindingInstruction,
/* harmony export */   "ITemplateCompiler": () => /* binding */ ITemplateCompiler,
/* harmony export */   "IRenderer": () => /* binding */ IRenderer,
/* harmony export */   "renderer": () => /* binding */ renderer,
/* harmony export */   "SetPropertyRenderer": () => /* binding */ SetPropertyRenderer,
/* harmony export */   "CustomElementRenderer": () => /* binding */ CustomElementRenderer,
/* harmony export */   "CustomAttributeRenderer": () => /* binding */ CustomAttributeRenderer,
/* harmony export */   "TemplateControllerRenderer": () => /* binding */ TemplateControllerRenderer,
/* harmony export */   "LetElementRenderer": () => /* binding */ LetElementRenderer,
/* harmony export */   "CallBindingRenderer": () => /* binding */ CallBindingRenderer,
/* harmony export */   "RefBindingRenderer": () => /* binding */ RefBindingRenderer,
/* harmony export */   "InterpolationBindingRenderer": () => /* binding */ InterpolationBindingRenderer,
/* harmony export */   "PropertyBindingRenderer": () => /* binding */ PropertyBindingRenderer,
/* harmony export */   "IteratorBindingRenderer": () => /* binding */ IteratorBindingRenderer,
/* harmony export */   "applyBindingBehavior": () => /* binding */ applyBindingBehavior,
/* harmony export */   "TextBindingRenderer": () => /* binding */ TextBindingRenderer,
/* harmony export */   "ListenerBindingRenderer": () => /* binding */ ListenerBindingRenderer,
/* harmony export */   "SetAttributeRenderer": () => /* binding */ SetAttributeRenderer,
/* harmony export */   "SetClassAttributeRenderer": () => /* binding */ SetClassAttributeRenderer,
/* harmony export */   "SetStyleAttributeRenderer": () => /* binding */ SetStyleAttributeRenderer,
/* harmony export */   "StylePropertyBindingRenderer": () => /* binding */ StylePropertyBindingRenderer,
/* harmony export */   "AttributeBindingRenderer": () => /* binding */ AttributeBindingRenderer
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binding/call-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/call-binding.js");
/* harmony import */ var _binding_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./binding/attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/attribute.js");
/* harmony import */ var _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binding/interpolation-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/interpolation-binding.js");
/* harmony import */ var _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding/let-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/let-binding.js");
/* harmony import */ var _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./binding/property-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/property-binding.js");
/* harmony import */ var _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./binding/ref-binding.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/ref-binding.js");
/* harmony import */ var _binding_listener_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./binding/listener.js */ "./node_modules/@aurelia/runtime-html/dist/esm/binding/listener.js");
/* harmony import */ var _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./observation/event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
















var InstructionType;
(function (InstructionType) {
    InstructionType["hydrateElement"] = "ra";
    InstructionType["hydrateAttribute"] = "rb";
    InstructionType["hydrateTemplateController"] = "rc";
    InstructionType["hydrateLetElement"] = "rd";
    InstructionType["setProperty"] = "re";
    InstructionType["interpolation"] = "rf";
    InstructionType["propertyBinding"] = "rg";
    InstructionType["callBinding"] = "rh";
    InstructionType["letBinding"] = "ri";
    InstructionType["refBinding"] = "rj";
    InstructionType["iteratorBinding"] = "rk";
    InstructionType["textBinding"] = "ha";
    InstructionType["listenerBinding"] = "hb";
    InstructionType["attributeBinding"] = "hc";
    InstructionType["stylePropertyBinding"] = "hd";
    InstructionType["setAttribute"] = "he";
    InstructionType["setClassAttribute"] = "hf";
    InstructionType["setStyleAttribute"] = "hg";
})(InstructionType || (InstructionType = {}));
const IInstruction = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('Instruction');
function isInstruction(value) {
    const type = value.type;
    return typeof type === 'string' && type.length === 2;
}
class InterpolationInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rf" /* interpolation */; }
}
class PropertyBindingInstruction {
    constructor(from, to, mode) {
        this.from = from;
        this.to = to;
        this.mode = mode;
    }
    get type() { return "rg" /* propertyBinding */; }
}
class IteratorBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rk" /* iteratorBinding */; }
}
class CallBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rh" /* callBinding */; }
}
class RefBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "rj" /* refBinding */; }
}
class SetPropertyInstruction {
    constructor(value, to) {
        this.value = value;
        this.to = to;
    }
    get type() { return "re" /* setProperty */; }
}
class HydrateElementInstruction {
    constructor(res, alias, instructions, slotInfo) {
        this.res = res;
        this.alias = alias;
        this.instructions = instructions;
        this.slotInfo = slotInfo;
    }
    get type() { return "ra" /* hydrateElement */; }
}
class HydrateAttributeInstruction {
    constructor(res, alias, instructions) {
        this.res = res;
        this.alias = alias;
        this.instructions = instructions;
    }
    get type() { return "rb" /* hydrateAttribute */; }
}
class HydrateTemplateController {
    constructor(def, res, alias, instructions) {
        this.def = def;
        this.res = res;
        this.alias = alias;
        this.instructions = instructions;
    }
    get type() { return "rc" /* hydrateTemplateController */; }
}
class HydrateLetElementInstruction {
    constructor(instructions, toBindingContext) {
        this.instructions = instructions;
        this.toBindingContext = toBindingContext;
    }
    get type() { return "rd" /* hydrateLetElement */; }
}
class LetBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "ri" /* letBinding */; }
}
class TextBindingInstruction {
    constructor(from) {
        this.from = from;
    }
    get type() { return "ha" /* textBinding */; }
}
class ListenerBindingInstruction {
    constructor(from, to, preventDefault, strategy) {
        this.from = from;
        this.to = to;
        this.preventDefault = preventDefault;
        this.strategy = strategy;
    }
    get type() { return "hb" /* listenerBinding */; }
}
class StylePropertyBindingInstruction {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    get type() { return "hd" /* stylePropertyBinding */; }
}
class SetAttributeInstruction {
    constructor(value, to) {
        this.value = value;
        this.to = to;
    }
    get type() { return "he" /* setAttribute */; }
}
class SetClassAttributeInstruction {
    constructor(value) {
        this.value = value;
        this.type = "hf" /* setClassAttribute */;
    }
}
class SetStyleAttributeInstruction {
    constructor(value) {
        this.value = value;
        this.type = "hg" /* setStyleAttribute */;
    }
}
class AttributeBindingInstruction {
    constructor(
    /**
     * `attr` and `to` have the same value on a normal attribute
     * Will be different on `class` and `style`
     * on `class`: attr = `class` (from binding command), to = attribute name
     * on `style`: attr = `style` (from binding command), to = attribute name
     */
    attr, from, to) {
        this.attr = attr;
        this.from = from;
        this.to = to;
    }
    get type() { return "hc" /* attributeBinding */; }
}
const ITemplateCompiler = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ITemplateCompiler');
const IRenderer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IRenderer');
function renderer(instructionType) {
    return function decorator(target) {
        // wrap the constructor to set the instructionType to the instance (for better performance than when set on the prototype)
        const decoratedTarget = function (...args) {
            const instance = new target(...args);
            instance.instructionType = instructionType;
            return instance;
        };
        // make sure we register the decorated constructor with DI
        decoratedTarget.register = function register(container) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(IRenderer, decoratedTarget).register(container);
        };
        // copy over any metadata such as annotations (set by preceding decorators) as well as static properties set by the user
        // also copy the name, to be less confusing to users (so they can still use constructor.name for whatever reason)
        // the length (number of ctor arguments) is copied for the same reason
        const metadataKeys = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwnKeys(target);
        for (const key of metadataKeys) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, target), decoratedTarget);
        }
        const ownProperties = Object.getOwnPropertyDescriptors(target);
        Object.keys(ownProperties).filter(prop => prop !== 'prototype').forEach(prop => {
            Reflect.defineProperty(decoratedTarget, prop, ownProperties[prop]);
        });
        return decoratedTarget;
    };
}
function ensureExpression(parser, srcOrExpr, bindingType) {
    if (typeof srcOrExpr === 'string') {
        return parser.parse(srcOrExpr, bindingType);
    }
    return srcOrExpr;
}
function getTarget(potentialTarget) {
    if (potentialTarget.viewModel != null) {
        return potentialTarget.viewModel;
    }
    return potentialTarget;
}
function getRefTarget(refHost, refTargetName) {
    if (refTargetName === 'element') {
        return refHost;
    }
    switch (refTargetName) {
        case 'controller':
            // this means it supports returning undefined
            return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.for(refHost);
        case 'view':
            // todo: returns node sequences for fun?
            throw new Error('Not supported API');
        case 'view-model':
            // this means it supports returning undefined
            return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.for(refHost).viewModel;
        default: {
            const caController = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__.CustomAttribute.for(refHost, refTargetName);
            if (caController !== void 0) {
                return caController.viewModel;
            }
            const ceController = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.for(refHost, { name: refTargetName });
            if (ceController === void 0) {
                throw new Error(`Attempted to reference "${refTargetName}", but it was not found amongst the target's API.`);
            }
            return ceController.viewModel;
        }
    }
}
let SetPropertyRenderer = 
/** @internal */
class SetPropertyRenderer {
    render(flags, context, controller, target, instruction) {
        const obj = getTarget(target);
        if (obj.$observers !== void 0 && obj.$observers[instruction.to] !== void 0) {
            obj.$observers[instruction.to].setValue(instruction.value, 32 /* fromBind */);
        }
        else {
            obj[instruction.to] = instruction.value;
        }
    }
};
SetPropertyRenderer = __decorate([
    renderer("re" /* setProperty */)
    /** @internal */
], SetPropertyRenderer);

let CustomElementRenderer = 
/** @internal */
class CustomElementRenderer {
    render(flags, context, controller, target, instruction) {
        let viewFactory;
        const slotInfo = instruction.slotInfo;
        if (slotInfo !== null) {
            const projectionCtx = slotInfo.projectionContext;
            viewFactory = (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_11__.getRenderContext)(projectionCtx.content, context).getViewFactory(void 0, slotInfo.type, projectionCtx.scope);
        }
        const factory = context.getComponentFactory(
        /* parentController */ controller, 
        /* host             */ target, 
        /* instruction      */ instruction, 
        /* viewFactory      */ viewFactory, 
        /* location         */ target);
        const key = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.keyFrom(instruction.res);
        const component = factory.createComponent(key);
        const childController = _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__.Controller.forCustomElement(
        /* root                */ controller.root, 
        /* container           */ context, 
        /* viewModel           */ component, 
        /* host                */ target, 
        /* targetedProjections */ context.getProjectionFor(instruction), 
        /* flags               */ flags);
        flags = childController.flags;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, childController, target);
        context.renderChildren(
        /* flags        */ flags, 
        /* instructions */ instruction.instructions, 
        /* controller   */ controller, 
        /* target       */ childController);
        controller.addController(childController);
        factory.dispose();
    }
};
CustomElementRenderer = __decorate([
    renderer("ra" /* hydrateElement */)
    /** @internal */
], CustomElementRenderer);

let CustomAttributeRenderer = 
/** @internal */
class CustomAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        const factory = context.getComponentFactory(
        /* parentController */ controller, 
        /* host             */ target, 
        /* instruction      */ instruction, 
        /* viewFactory      */ void 0, 
        /* location         */ void 0);
        const key = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__.CustomAttribute.keyFrom(instruction.res);
        const component = factory.createComponent(key);
        const childController = _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__.Controller.forCustomAttribute(
        /* root      */ controller.root, 
        /* container */ context, 
        /* viewModel */ component, 
        /* host      */ target, 
        /* flags     */ flags);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, childController, target);
        context.renderChildren(
        /* flags        */ flags, 
        /* instructions */ instruction.instructions, 
        /* controller   */ controller, 
        /* target       */ childController);
        controller.addController(childController);
        factory.dispose();
    }
};
CustomAttributeRenderer = __decorate([
    renderer("rb" /* hydrateAttribute */)
    /** @internal */
], CustomAttributeRenderer);

let TemplateControllerRenderer = 
/** @internal */
class TemplateControllerRenderer {
    render(flags, context, controller, target, instruction) {
        const viewFactory = (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_11__.getRenderContext)(instruction.def, context).getViewFactory();
        const renderLocation = (0,_dom_js__WEBPACK_IMPORTED_MODULE_13__.convertToRenderLocation)(target);
        const componentFactory = context.getComponentFactory(
        /* parentController */ controller, 
        /* host             */ target, 
        /* instruction      */ instruction, 
        /* viewFactory      */ viewFactory, 
        /* location         */ renderLocation);
        const key = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_12__.CustomAttribute.keyFrom(instruction.res);
        const component = componentFactory.createComponent(key);
        const childController = _templating_controller_js__WEBPACK_IMPORTED_MODULE_14__.Controller.forCustomAttribute(
        /* root      */ controller.root, 
        /* container */ context, 
        /* viewModel */ component, 
        /* host      */ target, 
        /* flags     */ flags);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, childController, renderLocation);
        component.link?.(flags, context, controller, childController, target, instruction);
        context.renderChildren(
        /* flags        */ flags, 
        /* instructions */ instruction.instructions, 
        /* controller   */ controller, 
        /* target       */ childController);
        controller.addController(childController);
        componentFactory.dispose();
    }
};
TemplateControllerRenderer = __decorate([
    renderer("rc" /* hydrateTemplateController */)
    /** @internal */
], TemplateControllerRenderer);

let LetElementRenderer = 
/** @internal */
class LetElementRenderer {
    constructor(parser, observerLocator) {
        this.parser = parser;
        this.observerLocator = observerLocator;
    }
    render(flags, context, controller, target, instruction) {
        target.remove();
        const childInstructions = instruction.instructions;
        const toBindingContext = instruction.toBindingContext;
        let childInstruction;
        let expr;
        let binding;
        for (let i = 0, ii = childInstructions.length; i < ii; ++i) {
            childInstruction = childInstructions[i];
            expr = ensureExpression(this.parser, childInstruction.from, 48 /* IsPropertyCommand */);
            binding = applyBindingBehavior(new _binding_let_binding_js__WEBPACK_IMPORTED_MODULE_5__.LetBinding(expr, childInstruction.to, this.observerLocator, context, toBindingContext), expr, context);
            controller.addBinding(binding);
        }
    }
};
LetElementRenderer = __decorate([
    renderer("rd" /* hydrateLetElement */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator)
], LetElementRenderer);

let CallBindingRenderer = 
/** @internal */
class CallBindingRenderer {
    constructor(parser, observerLocator) {
        this.parser = parser;
        this.observerLocator = observerLocator;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 153 /* CallCommand */);
        const binding = applyBindingBehavior(new _binding_call_binding_js__WEBPACK_IMPORTED_MODULE_2__.CallBinding(expr, getTarget(target), instruction.to, this.observerLocator, context), expr, context);
        controller.addBinding(binding);
    }
};
CallBindingRenderer = __decorate([
    renderer("rh" /* callBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator)
], CallBindingRenderer);

let RefBindingRenderer = 
/** @internal */
class RefBindingRenderer {
    constructor(parser) {
        this.parser = parser;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 5376 /* IsRef */);
        const binding = applyBindingBehavior(new _binding_ref_binding_js__WEBPACK_IMPORTED_MODULE_7__.RefBinding(expr, getRefTarget(target, instruction.to), context), expr, context);
        controller.addBinding(binding);
    }
};
RefBindingRenderer = __decorate([
    renderer("rj" /* refBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser)
], RefBindingRenderer);

let InterpolationBindingRenderer = 
/** @internal */
class InterpolationBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 2048 /* Interpolation */);
        const binding = new _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBinding(this.observerLocator, expr, getTarget(target), instruction.to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, context, this.platform.domWriteQueue);
        const partBindings = binding.partBindings;
        let partBinding;
        for (let i = 0, ii = partBindings.length; ii > i; ++i) {
            partBinding = partBindings[i];
            partBindings[i] = applyBindingBehavior(partBinding, partBinding.sourceExpression, context);
        }
        controller.addBinding(binding);
    }
};
InterpolationBindingRenderer = __decorate([
    renderer("rf" /* interpolation */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], InterpolationBindingRenderer);

let PropertyBindingRenderer = 
/** @internal */
class PropertyBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 48 /* IsPropertyCommand */ | instruction.mode);
        const binding = applyBindingBehavior(new _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__.PropertyBinding(expr, getTarget(target), instruction.to, instruction.mode, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
        controller.addBinding(binding);
    }
};
PropertyBindingRenderer = __decorate([
    renderer("rg" /* propertyBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], PropertyBindingRenderer);

let IteratorBindingRenderer = 
/** @internal */
class IteratorBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 539 /* ForCommand */);
        const binding = applyBindingBehavior(new _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__.PropertyBinding(expr, getTarget(target), instruction.to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
        controller.addBinding(binding);
    }
};
IteratorBindingRenderer = __decorate([
    renderer("rk" /* iteratorBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], IteratorBindingRenderer);

let behaviorExpressionIndex = 0;
const behaviorExpressions = [];
function applyBindingBehavior(binding, expression, locator) {
    while (expression instanceof _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingBehaviorExpression) {
        behaviorExpressions[behaviorExpressionIndex++] = expression;
        expression = expression.expression;
    }
    while (behaviorExpressionIndex > 0) {
        const behaviorExpression = behaviorExpressions[--behaviorExpressionIndex];
        const behaviorOrFactory = locator.get(behaviorExpression.behaviorKey);
        if (behaviorOrFactory instanceof _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingBehaviorFactory) {
            binding = behaviorOrFactory.construct(binding, behaviorExpression);
        }
    }
    behaviorExpressions.length = 0;
    return binding;
}
let TextBindingRenderer = 
/** @internal */
class TextBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const next = target.nextSibling;
        if (target.nodeName === 'AU-M') {
            target.remove();
        }
        const expr = ensureExpression(this.parser, instruction.from, 2048 /* Interpolation */);
        const binding = new _binding_interpolation_binding_js__WEBPACK_IMPORTED_MODULE_4__.InterpolationBinding(this.observerLocator, expr, next, 'textContent', _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, context, this.platform.domWriteQueue);
        const partBindings = binding.partBindings;
        let partBinding;
        for (let i = 0, ii = partBindings.length; ii > i; ++i) {
            partBinding = partBindings[i];
            partBindings[i] = applyBindingBehavior(partBinding, partBinding.sourceExpression, context);
        }
        controller.addBinding(binding);
    }
};
TextBindingRenderer = __decorate([
    renderer("ha" /* textBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], TextBindingRenderer);

let ListenerBindingRenderer = 
/** @internal */
class ListenerBindingRenderer {
    constructor(parser, eventDelegator) {
        this.parser = parser;
        this.eventDelegator = eventDelegator;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 80 /* IsEventCommand */ | (instruction.strategy + 6 /* DelegationStrategyDelta */));
        const binding = applyBindingBehavior(new _binding_listener_js__WEBPACK_IMPORTED_MODULE_8__.Listener(context.platform, instruction.to, instruction.strategy, expr, target, instruction.preventDefault, this.eventDelegator, context), expr, context);
        controller.addBinding(binding);
    }
};
ListenerBindingRenderer = __decorate([
    renderer("hb" /* listenerBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_9__.IEventDelegator)
], ListenerBindingRenderer);

let SetAttributeRenderer = 
/** @internal */
class SetAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        target.setAttribute(instruction.to, instruction.value);
    }
};
SetAttributeRenderer = __decorate([
    renderer("he" /* setAttribute */)
    /** @internal */
], SetAttributeRenderer);

let SetClassAttributeRenderer = class SetClassAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        addClasses(target.classList, instruction.value);
    }
};
SetClassAttributeRenderer = __decorate([
    renderer("hf" /* setClassAttribute */)
], SetClassAttributeRenderer);

let SetStyleAttributeRenderer = class SetStyleAttributeRenderer {
    render(flags, context, controller, target, instruction) {
        target.style.cssText += instruction.value;
    }
};
SetStyleAttributeRenderer = __decorate([
    renderer("hg" /* setStyleAttribute */)
], SetStyleAttributeRenderer);

let StylePropertyBindingRenderer = 
/** @internal */
class StylePropertyBindingRenderer {
    constructor(parser, observerLocator, platform) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.platform = platform;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 48 /* IsPropertyCommand */ | _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
        const binding = applyBindingBehavior(new _binding_property_binding_js__WEBPACK_IMPORTED_MODULE_6__.PropertyBinding(expr, target.style, instruction.to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, this.observerLocator, context, this.platform.domWriteQueue), expr, context);
        controller.addBinding(binding);
    }
};
StylePropertyBindingRenderer = __decorate([
    renderer("hd" /* stylePropertyBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_15__.IPlatform)
], StylePropertyBindingRenderer);

let AttributeBindingRenderer = 
/** @internal */
class AttributeBindingRenderer {
    constructor(parser, observerLocator) {
        this.parser = parser;
        this.observerLocator = observerLocator;
    }
    render(flags, context, controller, target, instruction) {
        const expr = ensureExpression(this.parser, instruction.from, 48 /* IsPropertyCommand */ | _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
        const binding = applyBindingBehavior(new _binding_attribute_js__WEBPACK_IMPORTED_MODULE_3__.AttributeBinding(expr, target, instruction.attr /* targetAttribute */, instruction.to /* targetKey */, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView, this.observerLocator, context), expr, context);
        controller.addBinding(binding);
    }
};
AttributeBindingRenderer = __decorate([
    renderer("hc" /* attributeBinding */)
    /** @internal */
    ,
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator)
], AttributeBindingRenderer);

// http://jsben.ch/7n5Kt
function addClasses(classList, className) {
    const len = className.length;
    let start = 0;
    for (let i = 0; i < len; ++i) {
        if (className.charCodeAt(i) === 0x20) {
            if (i !== start) {
                classList.add(className.slice(start, i));
            }
            start = i + 1;
        }
        else if (i + 1 === len) {
            classList.add(className.slice(start));
        }
    }
}
//# sourceMappingURL=renderer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharSpec": () => /* binding */ CharSpec,
/* harmony export */   "Interpretation": () => /* binding */ Interpretation,
/* harmony export */   "State": () => /* binding */ State,
/* harmony export */   "StaticSegment": () => /* binding */ StaticSegment,
/* harmony export */   "DynamicSegment": () => /* binding */ DynamicSegment,
/* harmony export */   "SymbolSegment": () => /* binding */ SymbolSegment,
/* harmony export */   "SegmentTypes": () => /* binding */ SegmentTypes,
/* harmony export */   "ISyntaxInterpreter": () => /* binding */ ISyntaxInterpreter,
/* harmony export */   "SyntaxInterpreter": () => /* binding */ SyntaxInterpreter,
/* harmony export */   "AttrSyntax": () => /* binding */ AttrSyntax,
/* harmony export */   "IAttributePattern": () => /* binding */ IAttributePattern,
/* harmony export */   "IAttributeParser": () => /* binding */ IAttributeParser,
/* harmony export */   "AttributeParser": () => /* binding */ AttributeParser,
/* harmony export */   "attributePattern": () => /* binding */ attributePattern,
/* harmony export */   "AttributePatternResourceDefinition": () => /* binding */ AttributePatternResourceDefinition,
/* harmony export */   "AttributePattern": () => /* binding */ AttributePattern,
/* harmony export */   "DotSeparatedAttributePattern": () => /* binding */ DotSeparatedAttributePattern,
/* harmony export */   "RefAttributePattern": () => /* binding */ RefAttributePattern,
/* harmony export */   "ColonPrefixedBindAttributePattern": () => /* binding */ ColonPrefixedBindAttributePattern,
/* harmony export */   "AtPrefixedTriggerAttributePattern": () => /* binding */ AtPrefixedTriggerAttributePattern
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

/** @internal */
class CharSpec {
    constructor(chars, repeat, isSymbol, isInverted) {
        this.chars = chars;
        this.repeat = repeat;
        this.isSymbol = isSymbol;
        this.isInverted = isInverted;
        if (isInverted) {
            switch (chars.length) {
                case 0:
                    this.has = this.hasOfNoneInverse;
                    break;
                case 1:
                    this.has = this.hasOfSingleInverse;
                    break;
                default:
                    this.has = this.hasOfMultipleInverse;
            }
        }
        else {
            switch (chars.length) {
                case 0:
                    this.has = this.hasOfNone;
                    break;
                case 1:
                    this.has = this.hasOfSingle;
                    break;
                default:
                    this.has = this.hasOfMultiple;
            }
        }
    }
    equals(other) {
        return this.chars === other.chars
            && this.repeat === other.repeat
            && this.isSymbol === other.isSymbol
            && this.isInverted === other.isInverted;
    }
    hasOfMultiple(char) {
        return this.chars.includes(char);
    }
    hasOfSingle(char) {
        return this.chars === char;
    }
    hasOfNone(char) {
        return false;
    }
    hasOfMultipleInverse(char) {
        return !this.chars.includes(char);
    }
    hasOfSingleInverse(char) {
        return this.chars !== char;
    }
    hasOfNoneInverse(char) {
        return true;
    }
}
class Interpretation {
    constructor() {
        this.parts = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        this._pattern = '';
        this.currentRecord = {};
        this.partsRecord = {};
    }
    get pattern() {
        const value = this._pattern;
        if (value === '') {
            return null;
        }
        else {
            return value;
        }
    }
    set pattern(value) {
        if (value == null) {
            this._pattern = '';
            this.parts = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        else {
            this._pattern = value;
            this.parts = this.partsRecord[value];
        }
    }
    append(pattern, ch) {
        const { currentRecord } = this;
        if (currentRecord[pattern] === undefined) {
            currentRecord[pattern] = ch;
        }
        else {
            currentRecord[pattern] += ch;
        }
    }
    next(pattern) {
        const { currentRecord } = this;
        if (currentRecord[pattern] !== undefined) {
            const { partsRecord } = this;
            if (partsRecord[pattern] === undefined) {
                partsRecord[pattern] = [currentRecord[pattern]];
            }
            else {
                partsRecord[pattern].push(currentRecord[pattern]);
            }
            currentRecord[pattern] = undefined;
        }
    }
}
/** @internal */
class State {
    constructor(charSpec, ...patterns) {
        this.charSpec = charSpec;
        this.nextStates = [];
        this.types = null;
        this.isEndpoint = false;
        this.patterns = patterns;
    }
    get pattern() {
        return this.isEndpoint ? this.patterns[0] : null;
    }
    findChild(charSpec) {
        const nextStates = this.nextStates;
        const len = nextStates.length;
        let child = null;
        for (let i = 0; i < len; ++i) {
            child = nextStates[i];
            if (charSpec.equals(child.charSpec)) {
                return child;
            }
        }
        return null;
    }
    append(charSpec, pattern) {
        const { patterns } = this;
        if (!patterns.includes(pattern)) {
            patterns.push(pattern);
        }
        let state = this.findChild(charSpec);
        if (state == null) {
            state = new State(charSpec, pattern);
            this.nextStates.push(state);
            if (charSpec.repeat) {
                state.nextStates.push(state);
            }
        }
        return state;
    }
    findMatches(ch, interpretation) {
        // TODO: reuse preallocated arrays
        const results = [];
        const nextStates = this.nextStates;
        const len = nextStates.length;
        let childLen = 0;
        let child = null;
        let i = 0;
        let j = 0;
        for (; i < len; ++i) {
            child = nextStates[i];
            if (child.charSpec.has(ch)) {
                results.push(child);
                childLen = child.patterns.length;
                j = 0;
                if (child.charSpec.isSymbol) {
                    for (; j < childLen; ++j) {
                        interpretation.next(child.patterns[j]);
                    }
                }
                else {
                    for (; j < childLen; ++j) {
                        interpretation.append(child.patterns[j], ch);
                    }
                }
            }
        }
        return results;
    }
}
/** @internal */
class StaticSegment {
    constructor(text) {
        this.text = text;
        const len = this.len = text.length;
        const specs = this.specs = [];
        for (let i = 0; i < len; ++i) {
            specs.push(new CharSpec(text[i], false, false, false));
        }
    }
    eachChar(callback) {
        const { len, specs } = this;
        for (let i = 0; i < len; ++i) {
            callback(specs[i]);
        }
    }
}
/** @internal */
class DynamicSegment {
    constructor(symbols) {
        this.text = 'PART';
        this.spec = new CharSpec(symbols, true, false, true);
    }
    eachChar(callback) {
        callback(this.spec);
    }
}
/** @internal */
class SymbolSegment {
    constructor(text) {
        this.text = text;
        this.spec = new CharSpec(text, false, true, false);
    }
    eachChar(callback) {
        callback(this.spec);
    }
}
/** @internal */
class SegmentTypes {
    constructor() {
        this.statics = 0;
        this.dynamics = 0;
        this.symbols = 0;
    }
}
const ISyntaxInterpreter = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISyntaxInterpreter', x => x.singleton(SyntaxInterpreter));
class SyntaxInterpreter {
    constructor() {
        this.rootState = new State(null);
        this.initialStates = [this.rootState];
    }
    add(defOrDefs) {
        let i = 0;
        if (Array.isArray(defOrDefs)) {
            const ii = defOrDefs.length;
            for (; i < ii; ++i) {
                this.add(defOrDefs[i]);
            }
            return;
        }
        let currentState = this.rootState;
        const def = defOrDefs;
        const pattern = def.pattern;
        const types = new SegmentTypes();
        const segments = this.parse(def, types);
        const len = segments.length;
        const callback = (ch) => {
            currentState = currentState.append(ch, pattern);
        };
        for (i = 0; i < len; ++i) {
            segments[i].eachChar(callback);
        }
        currentState.types = types;
        currentState.isEndpoint = true;
    }
    interpret(name) {
        const interpretation = new Interpretation();
        let states = this.initialStates;
        const len = name.length;
        for (let i = 0; i < len; ++i) {
            states = this.getNextStates(states, name.charAt(i), interpretation);
            if (states.length === 0) {
                break;
            }
        }
        states.sort((a, b) => {
            if (a.isEndpoint) {
                if (!b.isEndpoint) {
                    return -1;
                }
            }
            else if (b.isEndpoint) {
                return 1;
            }
            else {
                return 0;
            }
            const aTypes = a.types;
            const bTypes = b.types;
            if (aTypes.statics !== bTypes.statics) {
                return bTypes.statics - aTypes.statics;
            }
            if (aTypes.dynamics !== bTypes.dynamics) {
                return bTypes.dynamics - aTypes.dynamics;
            }
            if (aTypes.symbols !== bTypes.symbols) {
                return bTypes.symbols - aTypes.symbols;
            }
            return 0;
        });
        if (states.length > 0) {
            const state = states[0];
            if (!state.charSpec.isSymbol) {
                interpretation.next(state.pattern);
            }
            interpretation.pattern = state.pattern;
        }
        return interpretation;
    }
    getNextStates(states, ch, interpretation) {
        // TODO: reuse preallocated arrays
        const nextStates = [];
        let state = null;
        const len = states.length;
        for (let i = 0; i < len; ++i) {
            state = states[i];
            nextStates.push(...state.findMatches(ch, interpretation));
        }
        return nextStates;
    }
    parse(def, types) {
        const result = [];
        const pattern = def.pattern;
        const len = pattern.length;
        let i = 0;
        let start = 0;
        let c = '';
        while (i < len) {
            c = pattern.charAt(i);
            if (!def.symbols.includes(c)) {
                if (i === start) {
                    if (c === 'P' && pattern.slice(i, i + 4) === 'PART') {
                        start = i = (i + 4);
                        result.push(new DynamicSegment(def.symbols));
                        ++types.dynamics;
                    }
                    else {
                        ++i;
                    }
                }
                else {
                    ++i;
                }
            }
            else if (i !== start) {
                result.push(new StaticSegment(pattern.slice(start, i)));
                ++types.statics;
                start = i;
            }
            else {
                result.push(new SymbolSegment(pattern.slice(start, i + 1)));
                ++types.symbols;
                start = ++i;
            }
        }
        if (start !== i) {
            result.push(new StaticSegment(pattern.slice(start, i)));
            ++types.statics;
        }
        return result;
    }
}
class AttrSyntax {
    constructor(rawName, rawValue, target, command) {
        this.rawName = rawName;
        this.rawValue = rawValue;
        this.target = target;
        this.command = command;
    }
}
const IAttributePattern = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAttributePattern');
const IAttributeParser = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IAttributeParser', x => x.singleton(AttributeParser));
let AttributeParser = class AttributeParser {
    constructor(interpreter, attrPatterns) {
        this.interpreter = interpreter;
        this.cache = {};
        const patterns = this.patterns = {};
        attrPatterns.forEach(attrPattern => {
            const defs = AttributePattern.getPatternDefinitions(attrPattern.constructor);
            interpreter.add(defs);
            defs.forEach(def => {
                patterns[def.pattern] = attrPattern;
            });
        });
    }
    parse(name, value) {
        let interpretation = this.cache[name];
        if (interpretation == null) {
            interpretation = this.cache[name] = this.interpreter.interpret(name);
        }
        const pattern = interpretation.pattern;
        if (pattern == null) {
            return new AttrSyntax(name, value, name, null);
        }
        else {
            return this.patterns[pattern][pattern](name, value, interpretation.parts);
        }
    }
};
AttributeParser = __decorate([
    __param(0, ISyntaxInterpreter),
    __param(1, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.all)(IAttributePattern))
], AttributeParser);

function attributePattern(...patternDefs) {
    return function decorator(target) {
        return AttributePattern.define(patternDefs, target);
    };
}
class AttributePatternResourceDefinition {
    constructor(Type) {
        this.Type = Type;
        this.name = (void 0);
    }
    register(container) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(IAttributePattern, this.Type).register(container);
    }
}
const AttributePattern = Object.freeze({
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('attribute-pattern'),
    definitionAnnotationKey: 'attribute-pattern-definitions',
    define(patternDefs, Type) {
        const definition = new AttributePatternResourceDefinition(Type);
        const { name, definitionAnnotationKey } = AttributePattern;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(name, definition, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, name);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.set(Type, definitionAnnotationKey, patternDefs);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo(Type, definitionAnnotationKey);
        return Type;
    },
    getPatternDefinitions(Type) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.get(Type, AttributePattern.definitionAnnotationKey);
    }
});
let DotSeparatedAttributePattern = class DotSeparatedAttributePattern {
    'PART.PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);
    }
    'PART.PART.PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], parts[2]);
    }
};
DotSeparatedAttributePattern = __decorate([
    attributePattern({ pattern: 'PART.PART', symbols: '.' }, { pattern: 'PART.PART.PART', symbols: '.' })
], DotSeparatedAttributePattern);

let RefAttributePattern = class RefAttributePattern {
    'ref'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, 'element', 'ref');
    }
    'PART.ref'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], 'ref');
    }
};
RefAttributePattern = __decorate([
    attributePattern({ pattern: 'ref', symbols: '' }, { pattern: 'PART.ref', symbols: '.' })
], RefAttributePattern);

let ColonPrefixedBindAttributePattern = class ColonPrefixedBindAttributePattern {
    ':PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], 'bind');
    }
};
ColonPrefixedBindAttributePattern = __decorate([
    attributePattern({ pattern: ':PART', symbols: ':' })
], ColonPrefixedBindAttributePattern);

let AtPrefixedTriggerAttributePattern = class AtPrefixedTriggerAttributePattern {
    '@PART'(rawName, rawValue, parts) {
        return new AttrSyntax(rawName, rawValue, parts[0], 'trigger');
    }
};
AtPrefixedTriggerAttributePattern = __decorate([
    attributePattern({ pattern: '@PART', symbols: '@' })
], AtPrefixedTriggerAttributePattern);

//# sourceMappingURL=attribute-pattern.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/attr.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttrBindingBehavior": () => /* binding */ AttrBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../observation/data-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/data-attribute-accessor.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let AttrBindingBehavior = class AttrBindingBehavior {
    bind(flags, _scope, _hostScope, binding) {
        binding.targetObserver = _observation_data_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_1__.attrAccessor;
    }
    unbind(flags, _scope, _hostScope, binding) {
        return;
    }
};
AttrBindingBehavior = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('attr')
], AttrBindingBehavior);

//# sourceMappingURL=attr.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/self.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "handleSelfEvent": () => /* binding */ handleSelfEvent,
/* harmony export */   "SelfBindingBehavior": () => /* binding */ SelfBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/** @internal */
function handleSelfEvent(event) {
    const target = event.composedPath()[0];
    if (this.target !== target) {
        return;
    }
    return this.selfEventCallSource(event);
}
let SelfBindingBehavior = class SelfBindingBehavior {
    bind(flags, _scope, _hostScope, binding) {
        if (!binding.callSource || !binding.targetEvent) {
            throw new Error('Self binding behavior only supports events.');
        }
        binding.selfEventCallSource = binding.callSource;
        binding.callSource = handleSelfEvent;
    }
    unbind(flags, _scope, _hostScope, binding) {
        binding.callSource = binding.selfEventCallSource;
        binding.selfEventCallSource = null;
    }
};
SelfBindingBehavior = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('self')
], SelfBindingBehavior);

//# sourceMappingURL=self.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-behaviors/update-trigger.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UpdateTriggerBindingBehavior": () => /* binding */ UpdateTriggerBindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../observation/event-delegator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/event-delegator.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../observation/observer-locator.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/observer-locator.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};



let UpdateTriggerBindingBehavior = class UpdateTriggerBindingBehavior {
    constructor(observerLocator) {
        this.observerLocator = observerLocator;
    }
    bind(flags, _scope, _hostScope, binding, ...events) {
        if (events.length === 0) {
            throw new Error('The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">');
        }
        if (binding.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.twoWay && binding.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.fromView) {
            throw new Error('The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.');
        }
        // ensure the binding's target observer has been set.
        const targetObserver = this.observerLocator.getObserver(binding.target, binding.targetProperty);
        if (!targetObserver.handler) {
            throw new Error('The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.');
        }
        binding.targetObserver = targetObserver;
        // stash the original element subscribe function.
        const originalHandler = targetObserver.handler;
        targetObserver.originalHandler = originalHandler;
        // replace the element subscribe function with one that uses the correct events.
        targetObserver.handler = new _observation_event_delegator_js__WEBPACK_IMPORTED_MODULE_1__.EventSubscriber(new _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_2__.NodeObserverConfig({
            default: originalHandler.config.default,
            events,
            readonly: originalHandler.config.readonly
        }));
    }
    unbind(flags, _scope, _hostScope, binding) {
        // restore the state of the binding.
        binding.targetObserver.handler.dispose();
        binding.targetObserver.handler = binding.targetObserver.originalHandler;
        binding.targetObserver.originalHandler = null;
    }
};
UpdateTriggerBindingBehavior = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.bindingBehavior)('updateTrigger'),
    __param(0, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.IObserverLocator)
], UpdateTriggerBindingBehavior);

//# sourceMappingURL=update-trigger.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bindingCommand": () => /* binding */ bindingCommand,
/* harmony export */   "BindingCommandDefinition": () => /* binding */ BindingCommandDefinition,
/* harmony export */   "BindingCommand": () => /* binding */ BindingCommand,
/* harmony export */   "getTarget": () => /* binding */ getTarget,
/* harmony export */   "OneTimeBindingCommand": () => /* binding */ OneTimeBindingCommand,
/* harmony export */   "ToViewBindingCommand": () => /* binding */ ToViewBindingCommand,
/* harmony export */   "FromViewBindingCommand": () => /* binding */ FromViewBindingCommand,
/* harmony export */   "TwoWayBindingCommand": () => /* binding */ TwoWayBindingCommand,
/* harmony export */   "DefaultBindingCommand": () => /* binding */ DefaultBindingCommand,
/* harmony export */   "CallBindingCommand": () => /* binding */ CallBindingCommand,
/* harmony export */   "ForBindingCommand": () => /* binding */ ForBindingCommand,
/* harmony export */   "TriggerBindingCommand": () => /* binding */ TriggerBindingCommand,
/* harmony export */   "DelegateBindingCommand": () => /* binding */ DelegateBindingCommand,
/* harmony export */   "CaptureBindingCommand": () => /* binding */ CaptureBindingCommand,
/* harmony export */   "AttrBindingCommand": () => /* binding */ AttrBindingCommand,
/* harmony export */   "StyleBindingCommand": () => /* binding */ StyleBindingCommand,
/* harmony export */   "ClassBindingCommand": () => /* binding */ ClassBindingCommand,
/* harmony export */   "RefBindingCommand": () => /* binding */ RefBindingCommand
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _semantic_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../semantic-model.js */ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




function bindingCommand(nameOrDefinition) {
    return function (target) {
        return BindingCommand.define(nameOrDefinition, target);
    };
}
class BindingCommandDefinition {
    constructor(Type, name, aliases, key, type) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.type = type;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        return new BindingCommandDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(BindingCommand.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(BindingCommand.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), BindingCommand.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(BindingCommand.getAnnotation(Type, 'type'), def.type, Type.type, null));
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, BindingCommand, key, container);
    }
}
const BindingCommand = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('binding-command'),
    keyFrom(name) {
        return `${BindingCommand.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(BindingCommand.name, value);
    },
    define(nameOrDef, Type) {
        const definition = BindingCommandDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingCommand.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingCommand.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, BindingCommand.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(BindingCommand.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
function getTarget(binding, makeCamelCase) {
    if (binding.flags & 256 /* isBinding */) {
        return binding.bindable.propName;
    }
    else if (makeCamelCase) {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(binding.syntax.target);
    }
    else {
        return binding.syntax.target;
    }
}
let OneTimeBindingCommand = class OneTimeBindingCommand {
    constructor() {
        this.bindingType = 49 /* OneTimeCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime);
    }
};
OneTimeBindingCommand = __decorate([
    bindingCommand('one-time')
], OneTimeBindingCommand);

let ToViewBindingCommand = class ToViewBindingCommand {
    constructor() {
        this.bindingType = 50 /* ToViewCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
    }
};
ToViewBindingCommand = __decorate([
    bindingCommand('to-view')
], ToViewBindingCommand);

let FromViewBindingCommand = class FromViewBindingCommand {
    constructor() {
        this.bindingType = 51 /* FromViewCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView);
    }
};
FromViewBindingCommand = __decorate([
    bindingCommand('from-view')
], FromViewBindingCommand);

let TwoWayBindingCommand = class TwoWayBindingCommand {
    constructor() {
        this.bindingType = 52 /* TwoWayCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay);
    }
};
TwoWayBindingCommand = __decorate([
    bindingCommand('two-way')
], TwoWayBindingCommand);

let DefaultBindingCommand = class DefaultBindingCommand {
    constructor() {
        this.bindingType = 53 /* BindCommand */;
    }
    compile(binding) {
        let mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default;
        if (binding instanceof _semantic_model_js__WEBPACK_IMPORTED_MODULE_3__.BindingSymbol) {
            mode = binding.bindable.mode;
        }
        else {
            const command = binding.syntax.command;
            switch (command) {
                case 'bind':
                case 'to-view':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
                    break;
                case 'one-time':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime;
                    break;
                case 'from-view':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView;
                    break;
                case 'two-way':
                    mode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay;
                    break;
            }
        }
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBindingInstruction(binding.expression, getTarget(binding, false), mode === _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default ? _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView : mode);
    }
};
DefaultBindingCommand = __decorate([
    bindingCommand('bind')
], DefaultBindingCommand);

let CallBindingCommand = class CallBindingCommand {
    constructor() {
        this.bindingType = 153 /* CallCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.CallBindingInstruction(binding.expression, getTarget(binding, true));
    }
};
CallBindingCommand = __decorate([
    bindingCommand('call')
], CallBindingCommand);

let ForBindingCommand = class ForBindingCommand {
    constructor() {
        this.bindingType = 539 /* ForCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.IteratorBindingInstruction(binding.expression, getTarget(binding, false));
    }
};
ForBindingCommand = __decorate([
    bindingCommand('for')
], ForBindingCommand);

let TriggerBindingCommand = class TriggerBindingCommand {
    constructor() {
        this.bindingType = 4182 /* TriggerCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.ListenerBindingInstruction(binding.expression, getTarget(binding, false), true, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.DelegationStrategy.none);
    }
};
TriggerBindingCommand = __decorate([
    bindingCommand('trigger')
], TriggerBindingCommand);

let DelegateBindingCommand = class DelegateBindingCommand {
    constructor() {
        this.bindingType = 4184 /* DelegateCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.ListenerBindingInstruction(binding.expression, getTarget(binding, false), false, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.DelegationStrategy.bubbling);
    }
};
DelegateBindingCommand = __decorate([
    bindingCommand('delegate')
], DelegateBindingCommand);

let CaptureBindingCommand = class CaptureBindingCommand {
    constructor() {
        this.bindingType = 4183 /* CaptureCommand */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.ListenerBindingInstruction(binding.expression, getTarget(binding, false), false, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.DelegationStrategy.capturing);
    }
};
CaptureBindingCommand = __decorate([
    bindingCommand('capture')
], CaptureBindingCommand);

/**
 * Attr binding command. Compile attr with binding symbol with command `attr` to `AttributeBindingInstruction`
 */
let AttrBindingCommand = class AttrBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */;
    }
    compile(binding) {
        const target = getTarget(binding, false);
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.AttributeBindingInstruction(target, binding.expression, target);
    }
};
AttrBindingCommand = __decorate([
    bindingCommand('attr')
], AttrBindingCommand);

/**
 * Style binding command. Compile attr with binding symbol with command `style` to `AttributeBindingInstruction`
 */
let StyleBindingCommand = class StyleBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.AttributeBindingInstruction('style', binding.expression, getTarget(binding, false));
    }
};
StyleBindingCommand = __decorate([
    bindingCommand('style')
], StyleBindingCommand);

/**
 * Class binding command. Compile attr with binding symbol with command `class` to `AttributeBindingInstruction`
 */
let ClassBindingCommand = class ClassBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.AttributeBindingInstruction('class', binding.expression, getTarget(binding, false));
    }
};
ClassBindingCommand = __decorate([
    bindingCommand('class')
], ClassBindingCommand);

/**
 * Binding command to refer different targets (element, custom element/attribute view models, controller) attached to an element
 */
let RefBindingCommand = class RefBindingCommand {
    constructor() {
        this.bindingType = 32 /* IsProperty */ | 4096 /* IgnoreCustomAttr */;
    }
    compile(binding) {
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_2__.RefBindingInstruction(binding.expression, getTarget(binding, false));
    }
};
RefBindingCommand = __decorate([
    bindingCommand('ref')
], RefBindingCommand);

//# sourceMappingURL=binding-command.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customAttribute": () => /* binding */ customAttribute,
/* harmony export */   "templateController": () => /* binding */ templateController,
/* harmony export */   "CustomAttributeDefinition": () => /* binding */ CustomAttributeDefinition,
/* harmony export */   "CustomAttribute": () => /* binding */ CustomAttribute
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _watch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../watch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js");




function customAttribute(nameOrDef) {
    return function (target) {
        return CustomAttribute.define(nameOrDef, target);
    };
}
function templateController(nameOrDef) {
    return function (target) {
        return CustomAttribute.define(typeof nameOrDef === 'string'
            ? { isTemplateController: true, name: nameOrDef }
            : { isTemplateController: true, ...nameOrDef }, target);
    };
}
class CustomAttributeDefinition {
    constructor(Type, name, aliases, key, defaultBindingMode, isTemplateController, bindables, noMultiBindings, watches) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.defaultBindingMode = defaultBindingMode;
        this.isTemplateController = isTemplateController;
        this.bindables = bindables;
        this.noMultiBindings = noMultiBindings;
        this.watches = watches;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        return new CustomAttributeDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomAttribute.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), CustomAttribute.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'defaultBindingMode'), def.defaultBindingMode, Type.defaultBindingMode, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'isTemplateController'), def.isTemplateController, Type.isTemplateController, false), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(..._bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.getAll(Type), CustomAttribute.getAnnotation(Type, 'bindables'), Type.bindables, def.bindables), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(CustomAttribute.getAnnotation(Type, 'noMultiBindings'), def.noMultiBindings, Type.noMultiBindings, false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(_watch_js__WEBPACK_IMPORTED_MODULE_3__.Watch.getAnnotation(Type), Type.watches));
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.transient(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, CustomAttribute, key, container);
    }
}
const CustomAttribute = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('custom-attribute'),
    keyFrom(name) {
        return `${CustomAttribute.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(CustomAttribute.name, value);
    },
    for(node, name) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomAttribute.keyFrom(name), node);
    },
    define(nameOrDef, Type) {
        const definition = CustomAttributeDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomAttribute.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomAttribute.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, CustomAttribute.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomAttribute.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
//# sourceMappingURL=custom-attribute.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/blur.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlurManager": () => /* binding */ BlurManager,
/* harmony export */   "Blur": () => /* binding */ Blur
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





const unset = Symbol();
// Using passive to help with performance
const defaultCaptureEventInit = {
    passive: true,
    capture: true
};
// Using passive to help with performance
const defaultBubbleEventInit = {
    passive: true
};
// weakly connect a document to a blur manager
// to avoid polluting the document properties
const blurDocMap = new WeakMap();
class BlurManager {
    constructor(platform) {
        this.platform = platform;
        this.blurs = [];
        blurDocMap.set(platform.document, this);
        this.handler = createHandler(this, this.blurs);
    }
    static createFor(platform) {
        return blurDocMap.get(platform.document) || new BlurManager(platform);
    }
    register(blur) {
        const blurs = this.blurs;
        if (!blurs.includes(blur) && blurs.push(blur) === 1) {
            this.addListeners();
        }
    }
    unregister(blur) {
        const blurs = this.blurs;
        const index = blurs.indexOf(blur);
        if (index > -1) {
            blurs.splice(index, 1);
        }
        if (blurs.length === 0) {
            this.removeListeners();
        }
    }
    addListeners() {
        const p = this.platform;
        const doc = p.document;
        const win = p.window;
        const handler = this.handler;
        if (win.navigator.pointerEnabled) {
            doc.addEventListener('pointerdown', handler, defaultCaptureEventInit);
        }
        doc.addEventListener('touchstart', handler, defaultCaptureEventInit);
        doc.addEventListener('mousedown', handler, defaultCaptureEventInit);
        doc.addEventListener('focus', handler, defaultCaptureEventInit);
        win.addEventListener('blur', handler, defaultBubbleEventInit);
    }
    removeListeners() {
        const p = this.platform;
        const doc = p.document;
        const win = p.window;
        const handler = this.handler;
        if (win.navigator.pointerEnabled) {
            doc.removeEventListener('pointerdown', handler, defaultCaptureEventInit);
        }
        doc.removeEventListener('touchstart', handler, defaultCaptureEventInit);
        doc.removeEventListener('mousedown', handler, defaultCaptureEventInit);
        doc.removeEventListener('focus', handler, defaultCaptureEventInit);
        win.removeEventListener('blur', handler, defaultBubbleEventInit);
    }
}
let Blur = class Blur {
    constructor(element, p) {
        this.element = element;
        this.p = p;
        /**
         * By default, the behavior should be least surprise possible, that:
         *
         * it searches for anything from root context,
         * and root context is document body
         */
        this.linkedMultiple = true;
        this.searchSubTree = true;
        this.linkingContext = null;
        this.value = unset;
        this.manager = BlurManager.createFor(p);
    }
    attached() {
        this.manager.register(this);
    }
    detaching() {
        this.manager.unregister(this);
    }
    handleEventTarget(target) {
        if (this.value === false) {
            return;
        }
        const p = this.p;
        if (target === p.window || target === p.document || !this.contains(target)) {
            this.triggerBlur();
        }
    }
    contains(target) {
        if (!this.value) {
            return false;
        }
        let els;
        let i;
        let j, jj;
        let link;
        const element = this.element;
        if (containsElementOrShadowRoot(element, target)) {
            return true;
        }
        if (!this.linkedWith) {
            return false;
        }
        const doc = this.p.document;
        const linkedWith = this.linkedWith;
        const linkingContext = this.linkingContext;
        const searchSubTree = this.searchSubTree;
        const linkedMultiple = this.linkedMultiple;
        const links = Array.isArray(linkedWith) ? linkedWith : [linkedWith];
        const contextNode = (typeof linkingContext === 'string'
            ? doc.querySelector(linkingContext)
            : linkingContext)
            || doc.body;
        const ii = links.length;
        for (i = 0; ii > i; ++i) {
            link = links[i];
            // When user specify to link with something by a string, it acts as a CSS selector
            // We need to do some querying stuff to determine if target above is contained.
            if (typeof link === 'string') {
                // Default behavior, search the whole tree, from context that user specified, which default to document body
                if (searchSubTree) {
                    // todo: are there too many knobs?? Consider remove "linkedMultiple"??
                    if (!linkedMultiple) {
                        const el = contextNode.querySelector(link);
                        els = el !== null ? [el] : _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
                    }
                    else {
                        els = contextNode.querySelectorAll(link);
                    }
                    jj = els.length;
                    for (j = 0; jj > j; ++j) {
                        if (els[j].contains(target)) {
                            return true;
                        }
                    }
                }
                else {
                    // default to document body, if user didn't define a linking context, and wanted to ignore subtree.
                    // This is specifically performant and useful for dialogs, plugins
                    // that usually generate contents to document body
                    els = contextNode.children;
                    jj = els.length;
                    for (j = 0; jj > j; ++j) {
                        if (els[j].matches(link)) {
                            return true;
                        }
                    }
                }
            }
            else {
                // When user passed in something that is not a string,
                // simply check if has method `contains` (allow duck typing)
                // and call it against target.
                // This enables flexible usages
                if (link && link.contains(target)) {
                    return true;
                }
            }
        }
        return false;
    }
    triggerBlur() {
        this.value = false;
        if (typeof this.onBlur === 'function') {
            this.onBlur.call(null);
        }
    }
};
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "value", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "onBlur", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "linkedWith", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "linkedMultiple", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "searchSubTree", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)()
], Blur.prototype, "linkingContext", void 0);
Blur = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('blur'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(1, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform)
], Blur);

const containsElementOrShadowRoot = (container, target) => {
    if (container.contains(target)) {
        return true;
    }
    let parentNode = null;
    while (target != null) {
        if (target === container) {
            return true;
        }
        parentNode = target.parentNode;
        if (parentNode === null && target.nodeType === 11 /* DocumentFragment */) {
            target = target.host;
            continue;
        }
        target = parentNode;
    }
    return false;
};
const createHandler = (manager, checkTargets) => {
    // *******************************
    // EVENTS ORDER
    // -----------------------------
    // pointerdown
    // touchstart
    // pointerup
    // touchend
    // mousedown
    // --------------
    // BLUR
    // FOCUS
    // --------------
    // mouseup
    // click
    //
    // ******************************
    //
    // There are cases focus happens without mouse interaction (keyboard)
    // So it needs to capture both mouse / focus movement
    //
    // ******************************
    let hasChecked = false;
    const revertCheckage = () => {
        hasChecked = false;
    };
    const markChecked = () => {
        hasChecked = true;
        manager.platform.domWriteQueue.queueTask(revertCheckage, { preempt: true });
    };
    const handleMousedown = (e) => {
        if (!hasChecked) {
            handleEvent(e);
            markChecked();
        }
    };
    /**
     * Handle globally captured focus event
     * This can happen via a few way:
     * User clicks on a focusable element
     * User uses keyboard to navigate to a focusable element
     * User goes back to the window from another browser tab
     * User clicks on a non-focusable element
     * User clicks on the window, outside of the document
     */
    const handleFocus = (e) => {
        if (hasChecked) {
            return;
        }
        // there are two way a focus gets captured on window
        // when the windows itself got focus
        // and when an element in the document gets focus
        // when the window itself got focus, reacting to it is quite unnecessary
        // as it doesn't really affect element inside the document
        // Do a simple check and bail immediately
        const isWindow = e.target === manager.platform.window;
        if (isWindow) {
            for (let i = 0, ii = checkTargets.length; ii > i; ++i) {
                checkTargets[i].triggerBlur();
            }
        }
        else {
            handleEvent(e);
        }
        markChecked();
    };
    const handleWindowBlur = () => {
        hasChecked = false;
        for (let i = 0, ii = checkTargets.length; i < ii; ++i) {
            checkTargets[i].triggerBlur();
        }
    };
    const handleEvent = (e) => {
        const target = e.composed ? e.composedPath()[0] : e.target;
        if (target === null) {
            return;
        }
        for (let i = 0, ii = checkTargets.length; i < ii; ++i) {
            checkTargets[i].handleEventTarget(target);
        }
    };
    return {
        onpointerdown: handleMousedown,
        ontouchstart: handleMousedown,
        onmousedown: handleMousedown,
        onfocus: handleFocus,
        onblur: handleWindowBlur,
        handleEvent(e) {
            this[`on${e.type}`](e);
        }
    };
};
//# sourceMappingURL=blur.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/focus.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Focus": () => /* binding */ Focus
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





/**
 * Focus attribute for element focus binding
 */
let Focus = class Focus {
    constructor(element, p) {
        this.element = element;
        this.p = p;
        /**
         * Indicates whether `apply` should be called when `attached` callback is invoked
         */
        this.needsApply = false;
    }
    binding() {
        this.valueChanged();
    }
    /**
     * Invoked everytime the bound value changes.
     *
     * @param newValue - The new value.
     */
    valueChanged() {
        // In theory, we could/should react immediately
        // but focus state of an element cannot be achieved
        // while it's disconnected from the document
        // thus, there neesd to be a check if it's currently connected or not
        // before applying the value to the element
        if (this.$controller.isActive) {
            this.apply();
        }
        else {
            // If the element is not currently connect
            // toggle the flag to add pending work for later
            // in attached lifecycle
            this.needsApply = true;
        }
    }
    /**
     * Invoked when the attribute is attached to the DOM.
     */
    attached() {
        if (this.needsApply) {
            this.needsApply = false;
            this.apply();
        }
        const el = this.element;
        el.addEventListener('focus', this);
        el.addEventListener('blur', this);
    }
    /**
     * Invoked when the attribute is afterDetachChildren from the DOM.
     */
    afterDetachChildren() {
        const el = this.element;
        el.removeEventListener('focus', this);
        el.removeEventListener('blur', this);
    }
    /**
     * EventTarget interface handler for better memory usage
     */
    handleEvent(e) {
        // there are only two event listened to
        // if the even is focus, it menans the element is focused
        // only need to switch the value to true
        if (e.type === 'focus') {
            this.value = true;
        }
        else if (!this.isElFocused) {
            // else, it's blur event
            // when a blur event happens, there are two situations
            // 1. the element itself lost the focus
            // 2. window lost the focus
            // To handle both (1) and (2), only need to check if
            // current active element is still the same element of this focus custom attribute
            // If it's not, it's a blur event happened on Window because the browser tab lost focus
            this.value = false;
        }
    }
    /**
     * Focus/blur based on current value
     */
    apply() {
        const el = this.element;
        const isFocused = this.isElFocused;
        const shouldFocus = this.value;
        if (shouldFocus && !isFocused) {
            el.focus();
        }
        else if (!shouldFocus && isFocused) {
            el.blur();
        }
    }
    get isElFocused() {
        return this.element === this.p.document.activeElement;
    }
};
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable)({ mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.BindingMode.twoWay })
], Focus.prototype, "value", void 0);
Focus = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('focus'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(1, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform)
], Focus);

//# sourceMappingURL=focus.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attributes/show.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Show": () => /* binding */ Show
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let Show = class Show {
    constructor(el, p, instr) {
        this.el = el;
        this.p = p;
        this.isActive = false;
        this.task = null;
        this.$val = '';
        this.$prio = '';
        this.update = () => {
            this.task = null;
            // Only compare at the synchronous moment when we're about to update, because the value might have changed since the update was queued.
            if (Boolean(this.value) !== this.isToggled) {
                if (this.isToggled === this.base) {
                    this.isToggled = !this.base;
                    // Note: in v1 we used the 'au-hide' class, but in v2 it's so trivial to conditionally apply classes (e.g. 'hide.class="someCondition"'),
                    // that it's probably better to avoid the CSS inject infra involvement and keep this CA as simple as possible.
                    // Instead, just store and restore the property values (with each mutation, to account for in-between updates), to cover the common cases, until there is convincing feedback to do otherwise.
                    this.$val = this.el.style.getPropertyValue('display');
                    this.$prio = this.el.style.getPropertyPriority('display');
                    this.el.style.setProperty('display', 'none', 'important');
                }
                else {
                    this.isToggled = this.base;
                    this.el.style.setProperty('display', this.$val, this.$prio);
                    // If the style attribute is now empty, remove it.
                    if (this.el.getAttribute('style') === '') {
                        this.el.removeAttribute('style');
                    }
                }
            }
        };
        // if this is declared as a 'hide' attribute, then this.base will be false, inverting everything.
        this.isToggled = this.base = instr.alias !== 'hide';
    }
    binding() {
        this.isActive = true;
        this.update();
    }
    detaching() {
        this.isActive = false;
        this.task?.cancel();
        this.task = null;
    }
    valueChanged() {
        if (this.isActive && this.task === null) {
            this.task = this.p.domWriteQueue.queueTask(this.update);
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable
], Show.prototype, "value", void 0);
Show = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('show'),
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.alias)('hide'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_1__.INode),
    __param(1, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform),
    __param(2, _renderer_js__WEBPACK_IMPORTED_MODULE_5__.IInstruction)
], Show);

//# sourceMappingURL=show.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customElement": () => /* binding */ customElement,
/* harmony export */   "useShadowDOM": () => /* binding */ useShadowDOM,
/* harmony export */   "containerless": () => /* binding */ containerless,
/* harmony export */   "strict": () => /* binding */ strict,
/* harmony export */   "CustomElementDefinition": () => /* binding */ CustomElementDefinition,
/* harmony export */   "CustomElement": () => /* binding */ CustomElement
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_children_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../templating/children.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js");
/* harmony import */ var _watch_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../watch.js */ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js");






function customElement(nameOrDef) {
    return function (target) {
        return CustomElement.define(nameOrDef, target);
    };
}
function useShadowDOM(targetOrOptions) {
    if (targetOrOptions === void 0) {
        return function ($target) {
            CustomElement.annotate($target, 'shadowOptions', { mode: 'open' });
        };
    }
    if (typeof targetOrOptions !== 'function') {
        return function ($target) {
            CustomElement.annotate($target, 'shadowOptions', targetOrOptions);
        };
    }
    CustomElement.annotate(targetOrOptions, 'shadowOptions', { mode: 'open' });
}
function containerless(target) {
    if (target === void 0) {
        return function ($target) {
            CustomElement.annotate($target, 'containerless', true);
        };
    }
    CustomElement.annotate(target, 'containerless', true);
}
function strict(target) {
    if (target === void 0) {
        return function ($target) {
            CustomElement.annotate($target, 'isStrictBinding', true);
        };
    }
    CustomElement.annotate(target, 'isStrictBinding', true);
}
const definitionLookup = new WeakMap();
class CustomElementDefinition {
    constructor(Type, name, aliases, key, cache, template, instructions, dependencies, injectable, needsCompile, surrogates, bindables, childrenObservers, containerless, isStrictBinding, shadowOptions, hasSlots, enhance, projectionsMap, watches) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.cache = cache;
        this.template = template;
        this.instructions = instructions;
        this.dependencies = dependencies;
        this.injectable = injectable;
        this.needsCompile = needsCompile;
        this.surrogates = surrogates;
        this.bindables = bindables;
        this.childrenObservers = childrenObservers;
        this.containerless = containerless;
        this.isStrictBinding = isStrictBinding;
        this.shadowOptions = shadowOptions;
        this.hasSlots = hasSlots;
        this.enhance = enhance;
        this.projectionsMap = projectionsMap;
        this.watches = watches;
    }
    static create(nameOrDef, Type = null) {
        if (Type === null) {
            const def = nameOrDef;
            if (typeof def === 'string') {
                throw new Error(`Cannot create a custom element definition with only a name and no type: ${nameOrDef}`);
            }
            const name = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('name', def, CustomElement.generateName);
            if (typeof def.Type === 'function') {
                // This needs to be a clone (it will usually be the compiler calling this signature)
                // TODO: we need to make sure it's documented that passing in the type via the definition (while passing in null
                // as the "Type" parameter) effectively skips type analysis, so it should only be used this way for cloning purposes.
                Type = def.Type;
            }
            else {
                Type = CustomElement.generateType((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.pascalCase)(name));
            }
            return new CustomElementDefinition(Type, name, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.aliases), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('key', def, () => CustomElement.keyFrom(name)), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('cache', def, () => 0), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('template', def, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.instructions), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.dependencies), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('injectable', def, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('needsCompile', def, () => true), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.surrogates), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(def.bindables), _templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.from(def.childrenObservers), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('containerless', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('isStrictBinding', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('shadowOptions', def, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('hasSlots', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('enhance', def, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('projectionsMap', def, () => new Map()), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('watches', def, () => _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray));
        }
        // If a type is passed in, we ignore the Type property on the definition if it exists.
        // TODO: document this behavior
        if (typeof nameOrDef === 'string') {
            return new CustomElementDefinition(Type, nameOrDef, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'aliases'), Type.aliases), CustomElement.keyFrom(nameOrDef), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('cache', Type, () => 0), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('template', Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'instructions'), Type.instructions), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'dependencies'), Type.dependencies), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('injectable', Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('needsCompile', Type, () => true), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'surrogates'), Type.surrogates), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(..._bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.getAll(Type), CustomElement.getAnnotation(Type, 'bindables'), Type.bindables), _templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.from(..._templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.getAll(Type), CustomElement.getAnnotation(Type, 'childrenObservers'), Type.childrenObservers), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('containerless', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('isStrictBinding', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('shadowOptions', Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('hasSlots', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('enhance', Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrTypeOrDefault)('projectionsMap', Type, () => new Map()), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(_watch_js__WEBPACK_IMPORTED_MODULE_5__.Watch.getAnnotation(Type), Type.watches));
        }
        // This is the typical default behavior, e.g. from regular CustomElement.define invocations or from @customElement deco
        // The ViewValueConverter also uses this signature and passes in a definition where everything except for the 'hooks'
        // property needs to be copied. So we have that exception for 'hooks', but we may need to revisit that default behavior
        // if this turns out to be too opinionated.
        const name = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromDefinitionOrDefault)('name', nameOrDef, CustomElement.generateName);
        return new CustomElementDefinition(Type, name, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'aliases'), nameOrDef.aliases, Type.aliases), CustomElement.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('cache', nameOrDef, Type, () => 0), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('template', nameOrDef, Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'instructions'), nameOrDef.instructions, Type.instructions), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'dependencies'), nameOrDef.dependencies, Type.dependencies), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('injectable', nameOrDef, Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('needsCompile', nameOrDef, Type, () => true), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(CustomElement.getAnnotation(Type, 'surrogates'), nameOrDef.surrogates, Type.surrogates), _bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.from(..._bindable_js__WEBPACK_IMPORTED_MODULE_2__.Bindable.getAll(Type), CustomElement.getAnnotation(Type, 'bindables'), Type.bindables, nameOrDef.bindables), _templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.from(..._templating_children_js__WEBPACK_IMPORTED_MODULE_4__.Children.getAll(Type), CustomElement.getAnnotation(Type, 'childrenObservers'), Type.childrenObservers, nameOrDef.childrenObservers), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('containerless', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('isStrictBinding', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('shadowOptions', nameOrDef, Type, () => null), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('hasSlots', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('enhance', nameOrDef, Type, () => false), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('projectionsMap', nameOrDef, Type, () => new Map()), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(nameOrDef.watches, _watch_js__WEBPACK_IMPORTED_MODULE_5__.Watch.getAnnotation(Type), Type.watches));
    }
    static getOrCreate(partialDefinition) {
        if (partialDefinition instanceof CustomElementDefinition) {
            return partialDefinition;
        }
        if (definitionLookup.has(partialDefinition)) {
            return definitionLookup.get(partialDefinition);
        }
        const definition = CustomElementDefinition.create(partialDefinition);
        definitionLookup.set(partialDefinition, definition);
        // Make sure the full definition can be retrieved from dynamically created classes as well
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomElement.name, definition, definition.Type);
        return definition;
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.transient(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, CustomElement, key, container);
    }
}
const defaultForOpts = {
    name: undefined,
    searchParents: false,
    optional: false,
};
const CustomElement = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('custom-element'),
    keyFrom(name) {
        return `${CustomElement.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(CustomElement.name, value);
    },
    for(node, opts = defaultForOpts) {
        if (opts.name === void 0 && opts.searchParents !== true) {
            const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, node);
            if (controller === void 0) {
                if (opts.optional === true) {
                    return null;
                }
                throw new Error(`The provided node is not a custom element or containerless host.`);
            }
            return controller;
        }
        if (opts.name !== void 0) {
            if (opts.searchParents !== true) {
                const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, node);
                if (controller === void 0) {
                    throw new Error(`The provided node is not a custom element or containerless host.`);
                }
                if (controller.is(opts.name)) {
                    return controller;
                }
                return (void 0);
            }
            let cur = node;
            let foundAController = false;
            while (cur !== null) {
                const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, cur);
                if (controller !== void 0) {
                    foundAController = true;
                    if (controller.is(opts.name)) {
                        return controller;
                    }
                }
                cur = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.getEffectiveParentNode)(cur);
            }
            if (foundAController) {
                return (void 0);
            }
            throw new Error(`The provided node does does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`);
        }
        let cur = node;
        while (cur !== null) {
            const controller = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, cur);
            if (controller !== void 0) {
                return controller;
            }
            cur = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.getEffectiveParentNode)(cur);
        }
        throw new Error(`The provided node does does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`);
    },
    define(nameOrDef, Type) {
        const definition = CustomElementDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomElement.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(CustomElement.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(definition.Type, CustomElement.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(CustomElement.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
    generateName: (function () {
        let id = 0;
        return function () {
            return `unnamed-${++id}`;
        };
    })(),
    createInjectable() {
        const $injectable = function (target, property, index) {
            const annotationParamtypes = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.getOrCreateAnnotationParamTypes(target);
            annotationParamtypes[index] = $injectable;
            return target;
        };
        $injectable.register = function (container) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {
                resolve(container, requestor) {
                    if (requestor.has($injectable, true)) {
                        return requestor.get($injectable);
                    }
                    else {
                        return null;
                    }
                },
            };
        };
        return $injectable;
    },
    generateType: (function () {
        const nameDescriptor = {
            value: '',
            writable: false,
            enumerable: false,
            configurable: true,
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const defaultProto = {};
        return function (name, proto = defaultProto) {
            // Anonymous class ensures that minification cannot cause unintended side-effects, and keeps the class
            // looking similarly from the outside (when inspected via debugger, etc).
            const Type = class {
            };
            // Define the name property so that Type.name can be used by end users / plugin authors if they really need to,
            // even when minified.
            nameDescriptor.value = name;
            Reflect.defineProperty(Type, 'name', nameDescriptor);
            // Assign anything from the prototype that was passed in
            if (proto !== defaultProto) {
                Object.assign(Type.prototype, proto);
            }
            return Type;
        };
    })(),
};
//# sourceMappingURL=custom-element.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IProjections": () => /* binding */ IProjections,
/* harmony export */   "AuSlotContentType": () => /* binding */ AuSlotContentType,
/* harmony export */   "SlotInfo": () => /* binding */ SlotInfo,
/* harmony export */   "ProjectionContext": () => /* binding */ ProjectionContext,
/* harmony export */   "RegisteredProjections": () => /* binding */ RegisteredProjections,
/* harmony export */   "IProjectionProvider": () => /* binding */ IProjectionProvider,
/* harmony export */   "ProjectionProvider": () => /* binding */ ProjectionProvider,
/* harmony export */   "AuSlot": () => /* binding */ AuSlot
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _custom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");




const IProjections = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface("IProjections");
var AuSlotContentType;
(function (AuSlotContentType) {
    AuSlotContentType[AuSlotContentType["Projection"] = 0] = "Projection";
    AuSlotContentType[AuSlotContentType["Fallback"] = 1] = "Fallback";
})(AuSlotContentType || (AuSlotContentType = {}));
class SlotInfo {
    constructor(name, type, projectionContext) {
        this.name = name;
        this.type = type;
        this.projectionContext = projectionContext;
    }
}
class ProjectionContext {
    constructor(content, scope = null) {
        this.content = content;
        this.scope = scope;
    }
}
class RegisteredProjections {
    constructor(scope, projections) {
        this.scope = scope;
        this.projections = projections;
    }
}
const IProjectionProvider = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IProjectionProvider', x => x.singleton(ProjectionProvider));
const projectionMap = new WeakMap();
class ProjectionProvider {
    registerProjections(projections, scope) {
        for (const [instruction, $projections] of projections) {
            projectionMap.set(instruction, new RegisteredProjections(scope, $projections));
        }
    }
    getProjectionFor(instruction) {
        return projectionMap.get(instruction) ?? null;
    }
}
class AuSlot {
    constructor(factory, location) {
        this.factory = factory;
        this.hostScope = null;
        this.view = factory.create().setLocation(location);
        this.isProjection = factory.contentType === AuSlotContentType.Projection;
        this.outerScope = factory.projectionScope;
    }
    /**
     * @internal
     */
    static get inject() { return [_templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation]; }
    binding(initiator, parent, flags) {
        this.hostScope = this.$controller.scope.parentScope;
    }
    attaching(initiator, parent, flags) {
        const { $controller } = this;
        return this.view.activate(initiator, $controller, flags, this.outerScope ?? this.hostScope, this.hostScope);
    }
    detaching(initiator, parent, flags) {
        return this.view.deactivate(initiator, this.$controller, flags);
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
}
(0,_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.customElement)({ name: 'au-slot', template: null, containerless: true })(AuSlot);
//# sourceMappingURL=au-slot.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/compose.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Compose": () => /* binding */ Compose
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _create_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../create-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/create-element.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _templating_render_context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../templating/render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _custom_element_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};








function toLookup(acc, item) {
    const to = item.to;
    if (to !== void 0 && to !== 'subject' && to !== 'composing') {
        acc[to] = item;
    }
    return acc;
}
let Compose = class Compose {
    constructor(p, instruction) {
        this.p = p;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.subject = void 0;
        this.composing = false;
        this.view = void 0;
        this.lastSubject = void 0;
        this.properties = instruction.instructions.reduce(toLookup, {});
    }
    attaching(initiator, parent, flags) {
        const { subject, view } = this;
        if (view === void 0 || this.lastSubject !== subject) {
            this.lastSubject = subject;
            this.composing = true;
            return this.compose(void 0, subject, initiator, flags);
        }
        return this.compose(view, subject, initiator, flags);
    }
    detaching(initiator, parent, flags) {
        return this.deactivate(this.view, initiator, flags);
    }
    subjectChanged(newValue, previousValue, flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        if (this.lastSubject === newValue) {
            return;
        }
        this.lastSubject = newValue;
        this.composing = true;
        flags |= $controller.flags;
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivate(this.view, null, flags), () => {
            // TODO(fkleuver): handle & test race condition
            return this.compose(void 0, newValue, null, flags);
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    compose(view, subject, initiator, flags) {
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view === void 0
            ? (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(subject, resolvedSubject => {
                return this.resolveView(resolvedSubject, flags);
            })
            : view, resolvedView => {
            return this.activate(resolvedView, initiator, flags);
        });
    }
    deactivate(view, initiator, flags) {
        return view?.deactivate(initiator ?? view, this.$controller, flags);
    }
    activate(view, initiator, flags) {
        const { $controller } = this;
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view?.activate(initiator ?? view, $controller, flags, $controller.scope, $controller.hostScope), () => {
            this.composing = false;
        });
    }
    resolveView(subject, flags) {
        const view = this.provideViewFor(subject, flags);
        if (view) {
            view.setLocation(this.$controller.location);
            view.lockScope(this.$controller.scope);
            return view;
        }
        return void 0;
    }
    provideViewFor(subject, flags) {
        if (!subject) {
            return void 0;
        }
        if (isController(subject)) { // IController
            return subject;
        }
        if ('createView' in subject) { // RenderPlan
            return subject.createView(this.$controller.context);
        }
        if ('create' in subject) { // IViewFactory
            return subject.create(flags);
        }
        if ('template' in subject) { // Raw Template Definition
            const definition = _custom_element_js__WEBPACK_IMPORTED_MODULE_6__.CustomElementDefinition.getOrCreate(subject);
            return (0,_templating_render_context_js__WEBPACK_IMPORTED_MODULE_5__.getRenderContext)(definition, this.$controller.context).getViewFactory().create(flags);
        }
        // Constructable (Custom Element Constructor)
        return (0,_create_element_js__WEBPACK_IMPORTED_MODULE_2__.createElement)(this.p, subject, this.properties, this.$controller.host.childNodes).createView(this.$controller.context);
    }
    dispose() {
        this.view?.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_7__.bindable
], Compose.prototype, "subject", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_7__.bindable)({ mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView })
], Compose.prototype, "composing", void 0);
Compose = __decorate([
    (0,_custom_element_js__WEBPACK_IMPORTED_MODULE_6__.customElement)({ name: 'au-compose', template: null, containerless: true }),
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform),
    __param(1, _renderer_js__WEBPACK_IMPORTED_MODULE_3__.IInstruction)
], Compose);

function isController(subject) {
    return 'lockScope' in subject;
}
//# sourceMappingURL=compose.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/flags.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FrequentMutations": () => /* binding */ FrequentMutations,
/* harmony export */   "ObserveShallow": () => /* binding */ ObserveShallow
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");




class FlagsTemplateController {
    constructor(factory, location, flags) {
        this.factory = factory;
        this.flags = flags;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.view = this.factory.create().setLocation(location);
    }
    attaching(initiator, parent, flags) {
        const { $controller } = this;
        return this.view.activate(initiator, $controller, flags | this.flags, $controller.scope, $controller.hostScope);
    }
    detaching(initiator, parent, flags) {
        return this.view.deactivate(initiator, this.$controller, flags);
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
}
class FrequentMutations extends FlagsTemplateController {
    constructor(factory, location) {
        super(factory, location, 8192 /* persistentTargetObserverQueue */);
    }
}
/**
 * @internal
 */
FrequentMutations.inject = [_templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation];
class ObserveShallow extends FlagsTemplateController {
    constructor(factory, location) {
        super(factory, location, 2048 /* observeLeafPropertiesOnly */);
    }
}
/**
 * @internal
 */
ObserveShallow.inject = [_templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation];
(0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('frequent-mutations')(FrequentMutations);
(0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('observe-shallow')(ObserveShallow);
//# sourceMappingURL=flags.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/if.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "If": () => /* binding */ If,
/* harmony export */   "Else": () => /* binding */ Else
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





let If = class If {
    constructor(ifFactory, location) {
        this.ifFactory = ifFactory;
        this.location = location;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.elseFactory = void 0;
        this.elseView = void 0;
        this.ifView = void 0;
        this.view = void 0;
        this.value = false;
    }
    attaching(initiator, parent, flags) {
        const view = this.view = this.updateView(this.value, flags);
        if (view !== void 0) {
            const { $controller } = this;
            return view.activate(initiator, $controller, flags, $controller.scope, $controller.hostScope);
        }
    }
    detaching(initiator, parent, flags) {
        if (this.view !== void 0) {
            return this.view.deactivate(initiator, this.$controller, flags);
        }
    }
    valueChanged(newValue, oldValue, flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.view?.deactivate(this.view, $controller, flags), () => {
            const view = this.view = this.updateView(this.value, flags);
            if (view !== void 0) {
                // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
                return view.activate(view, $controller, flags, $controller.scope, $controller.hostScope);
            }
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    /** @internal */
    updateView(value, flags) {
        if (value) {
            return this.ifView = this.ensureView(this.ifView, this.ifFactory, flags);
        }
        if (this.elseFactory != void 0) {
            return this.elseView = this.ensureView(this.elseView, this.elseFactory, flags);
        }
        return void 0;
    }
    /** @internal */
    ensureView(view, factory, flags) {
        if (view === void 0) {
            view = factory.create(flags);
        }
        view.setLocation(this.location);
        return view;
    }
    dispose() {
        if (this.ifView !== void 0) {
            this.ifView.dispose();
            this.ifView = void 0;
        }
        if (this.elseView !== void 0) {
            this.elseView.dispose();
            this.elseView = void 0;
        }
        this.view = void 0;
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_4__.bindable
], If.prototype, "value", void 0);
If = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('if'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation)
], If);

let Else = class Else {
    constructor(factory) {
        this.factory = factory;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
    }
    link(flags, parentContext, controller, _childController, _target, _instruction) {
        const children = controller.children;
        const ifBehavior = children[children.length - 1];
        if (ifBehavior instanceof If) {
            ifBehavior.elseFactory = this.factory;
        }
        else if (ifBehavior.viewModel instanceof If) {
            ifBehavior.viewModel.elseFactory = this.factory;
        }
        else {
            throw new Error(`Unsupported IfBehavior`); // TODO: create error code
        }
    }
};
Else = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)({ name: 'else' }),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_2__.IViewFactory)
], Else);

//# sourceMappingURL=if.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/portal.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Portal": () => /* binding */ Portal
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let Portal = class Portal {
    constructor(factory, originalLoc, p) {
        this.factory = factory;
        this.originalLoc = originalLoc;
        this.p = p;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.strict = false;
        // to make the shape of this object consistent.
        // todo: is this necessary
        this.currentTarget = p.document.createElement('div');
        this.view = this.factory.create();
        (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.setEffectiveParentNode)(this.view.nodes, originalLoc);
    }
    attaching(initiator, parent, flags) {
        if (this.callbackContext == null) {
            this.callbackContext = this.$controller.scope.bindingContext;
        }
        const newTarget = this.currentTarget = this.resolveTarget();
        this.view.setHost(newTarget);
        return this.$activating(initiator, newTarget, flags);
    }
    detaching(initiator, parent, flags) {
        return this.$deactivating(initiator, this.currentTarget, flags);
    }
    targetChanged() {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        const oldTarget = this.currentTarget;
        const newTarget = this.currentTarget = this.resolveTarget();
        if (oldTarget === newTarget) {
            return;
        }
        this.view.setHost(newTarget);
        // TODO(fkleuver): fix and test possible race condition
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.$deactivating(null, newTarget, $controller.flags), () => {
            return this.$activating(null, newTarget, $controller.flags);
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    $activating(initiator, target, flags) {
        const { activating, callbackContext, view } = this;
        view.setHost(target);
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(activating?.call(callbackContext, target, view), () => {
            return this.activate(initiator, target, flags);
        });
    }
    activate(initiator, target, flags) {
        const { $controller, view } = this;
        if (initiator === null) {
            view.nodes.appendTo(target);
        }
        else {
            // TODO(fkleuver): fix and test possible race condition
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view.activate(initiator ?? view, $controller, flags, $controller.scope), () => {
                return this.$activated(target);
            });
        }
        return this.$activated(target);
    }
    $activated(target) {
        const { activated, callbackContext, view } = this;
        return activated?.call(callbackContext, target, view);
    }
    $deactivating(initiator, target, flags) {
        const { deactivating, callbackContext, view } = this;
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(deactivating?.call(callbackContext, target, view), () => {
            return this.deactivate(initiator, target, flags);
        });
    }
    deactivate(initiator, target, flags) {
        const { $controller, view } = this;
        if (initiator === null) {
            view.nodes.remove();
        }
        else {
            return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(view.deactivate(initiator, $controller, flags), () => {
                return this.$deactivated(target);
            });
        }
        return this.$deactivated(target);
    }
    $deactivated(target) {
        const { deactivated, callbackContext, view } = this;
        return deactivated?.call(callbackContext, target, view);
    }
    resolveTarget() {
        const p = this.p;
        // with a $ in front to make it less confusing/error prone
        const $document = p.document;
        let target = this.target;
        let context = this.renderContext;
        if (target === '') {
            if (this.strict) {
                throw new Error('Empty querySelector');
            }
            return $document.body;
        }
        if (typeof target === 'string') {
            let queryContext = $document;
            if (typeof context === 'string') {
                context = $document.querySelector(context);
            }
            if (context instanceof p.Node) {
                queryContext = context;
            }
            target = queryContext.querySelector(target);
        }
        if (target instanceof p.Node) {
            return target;
        }
        if (target == null) {
            if (this.strict) {
                throw new Error('Portal target not found');
            }
            return $document.body;
        }
        return target;
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
        this.callbackContext = null;
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)({ primary: true })
], Portal.prototype, "target", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)({ callback: 'targetChanged' })
], Portal.prototype, "renderContext", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "strict", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "deactivating", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "activating", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "deactivated", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "activated", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)()
], Portal.prototype, "callbackContext", void 0);
Portal = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__.templateController)('portal'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation),
    __param(2, _platform_js__WEBPACK_IMPORTED_MODULE_2__.IPlatform)
], Portal);

//# sourceMappingURL=portal.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/repeat.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Repeat": () => /* binding */ Repeat,
/* harmony export */   "longestIncreasingSubsequence": () => /* binding */ longestIncreasingSubsequence
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _templating_controller_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../templating/controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};







function dispose(disposable) {
    disposable.dispose();
}
let Repeat = class Repeat {
    constructor(location, parent, factory) {
        this.location = location;
        this.parent = parent;
        this.factory = factory;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.hasPendingInstanceMutation = false;
        this.observer = void 0;
        this.views = [];
        this.key = void 0;
        this.normalizedItems = void 0;
    }
    binding(initiator, parent, flags) {
        this.checkCollectionObserver(flags);
        const bindings = this.parent.bindings;
        let binding = (void 0);
        for (let i = 0, ii = bindings.length; i < ii; ++i) {
            binding = bindings[i];
            if (binding.target === this && binding.targetProperty === 'items') {
                this.forOf = binding.sourceExpression;
                break;
            }
        }
        this.local = this.forOf.declaration.evaluate(flags, this.$controller.scope, null, binding.locator, null);
    }
    attaching(initiator, parent, flags) {
        this.normalizeToArray(flags);
        return this.activateAllViews(initiator, flags);
    }
    detaching(initiator, parent, flags) {
        this.checkCollectionObserver(flags);
        return this.deactivateAllViews(initiator, flags);
    }
    // called by SetterObserver
    itemsChanged(flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        flags |= $controller.flags;
        this.checkCollectionObserver(flags);
        flags |= 8 /* updateTarget */;
        this.normalizeToArray(flags);
        const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivateAllViews(null, flags), () => {
            // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
            return this.activateAllViews(null, flags);
        });
        if (ret instanceof Promise) {
            ret.catch(err => { throw err; });
        }
    }
    // called by a CollectionObserver
    handleCollectionChange(indexMap, flags) {
        const { $controller } = this;
        if (!$controller.isActive) {
            return;
        }
        flags |= $controller.flags;
        flags |= 8 /* updateTarget */;
        this.normalizeToArray(flags);
        if (indexMap === void 0) {
            const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivateAllViews(null, flags), () => {
                // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
                return this.activateAllViews(null, flags);
            });
            if (ret instanceof Promise) {
                ret.catch(err => { throw err; });
            }
        }
        else {
            const oldLength = this.views.length;
            (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.applyMutationsToIndices)(indexMap);
            // first detach+unbind+(remove from array) the deleted view indices
            if (indexMap.deletedItems.length > 0) {
                indexMap.deletedItems.sort(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.compareNumber);
                const ret = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.deactivateAndRemoveViewsByKey(indexMap, flags), () => {
                    // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests
                    return this.createAndActivateAndSortViewsByKey(oldLength, indexMap, flags);
                });
                if (ret instanceof Promise) {
                    ret.catch(err => { throw err; });
                }
            }
            else {
                // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.createAndActivateAndSortViewsByKey(oldLength, indexMap, flags);
            }
        }
    }
    // todo: subscribe to collection from inner expression
    checkCollectionObserver(flags) {
        const oldObserver = this.observer;
        if ((flags & 64 /* fromUnbind */)) {
            if (oldObserver !== void 0) {
                oldObserver.unsubscribe(this);
            }
        }
        else if (this.$controller.isActive) {
            const newObserver = this.observer = (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.getCollectionObserver)(this.items);
            if (oldObserver !== newObserver && oldObserver) {
                oldObserver.unsubscribe(this);
            }
            if (newObserver) {
                newObserver.subscribe(this);
            }
        }
    }
    normalizeToArray(flags) {
        const items = this.items;
        if (items instanceof Array) {
            this.normalizedItems = items;
            return;
        }
        const forOf = this.forOf;
        if (forOf === void 0) {
            return;
        }
        const normalizedItems = [];
        this.forOf.iterate(flags, items, (arr, index, item) => {
            normalizedItems[index] = item;
        });
        this.normalizedItems = normalizedItems;
    }
    activateAllViews(initiator, flags) {
        let promises = void 0;
        let ret;
        let view;
        let viewScope;
        const { $controller, factory, local, location, items } = this;
        const parentScope = $controller.scope;
        const hostScope = $controller.hostScope;
        const newLen = this.forOf.count(flags, items);
        const views = this.views = Array(newLen);
        this.forOf.iterate(flags, items, (arr, i, item) => {
            view = views[i] = factory.create(flags).setLocation(location);
            view.nodes.unlink();
            viewScope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent(parentScope, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingContext.create(local, item));
            setContextualProperties(viewScope.overrideContext, i, newLen);
            ret = view.activate(initiator ?? view, $controller, flags, viewScope, hostScope);
            if (ret instanceof Promise) {
                (promises ?? (promises = [])).push(ret);
            }
        });
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    deactivateAllViews(initiator, flags) {
        let promises = void 0;
        let ret;
        let view;
        const { views, $controller } = this;
        for (let i = 0, ii = views.length; i < ii; ++i) {
            view = views[i];
            view.release();
            ret = view.deactivate(initiator ?? view, $controller, flags);
            if (ret instanceof Promise) {
                (promises ?? (promises = [])).push(ret);
            }
        }
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    deactivateAndRemoveViewsByKey(indexMap, flags) {
        let promises = void 0;
        let ret;
        let view;
        const { $controller, views } = this;
        const deleted = indexMap.deletedItems;
        const deletedLen = deleted.length;
        let i = 0;
        for (; i < deletedLen; ++i) {
            view = views[deleted[i]];
            view.release();
            ret = view.deactivate(view, $controller, flags);
            if (ret instanceof Promise) {
                (promises ?? (promises = [])).push(ret);
            }
        }
        i = 0;
        let j = 0;
        for (; i < deletedLen; ++i) {
            j = deleted[i] - i;
            views.splice(j, 1);
        }
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    createAndActivateAndSortViewsByKey(oldLength, indexMap, flags) {
        let promises = void 0;
        let ret;
        let view;
        let viewScope;
        const { $controller, factory, local, normalizedItems, location, views } = this;
        const mapLen = indexMap.length;
        for (let i = 0; i < mapLen; ++i) {
            if (indexMap[i] === -2) {
                view = factory.create(flags);
                views.splice(i, 0, view);
            }
        }
        if (views.length !== mapLen) {
            // TODO: create error code and use reporter with more informative message
            throw new Error(`viewsLen=${views.length}, mapLen=${mapLen}`);
        }
        const parentScope = $controller.scope;
        const hostScope = $controller.hostScope;
        const newLen = indexMap.length;
        (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.synchronizeIndices)(views, indexMap);
        // this algorithm retrieves the indices of the longest increasing subsequence of items in the repeater
        // the items on those indices are not moved; this minimizes the number of DOM operations that need to be performed
        const seq = longestIncreasingSubsequence(indexMap);
        const seqLen = seq.length;
        let next;
        let j = seqLen - 1;
        let i = newLen - 1;
        for (; i >= 0; --i) {
            view = views[i];
            next = views[i + 1];
            view.nodes.link(next?.nodes ?? location);
            if (indexMap[i] === -2) {
                viewScope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent(parentScope, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingContext.create(local, normalizedItems[i]));
                setContextualProperties(viewScope.overrideContext, i, newLen);
                view.setLocation(location);
                ret = view.activate(view, $controller, flags, viewScope, hostScope);
                if (ret instanceof Promise) {
                    (promises ?? (promises = [])).push(ret);
                }
            }
            else if (j < 0 || seqLen === 1 || i !== seq[j]) {
                setContextualProperties(view.scope.overrideContext, i, newLen);
                view.nodes.insertBefore(view.location);
            }
            else {
                if (oldLength !== newLen) {
                    setContextualProperties(view.scope.overrideContext, i, newLen);
                }
                --j;
            }
        }
        if (promises !== void 0) {
            return promises.length === 1
                ? promises[0]
                : Promise.all(promises);
        }
    }
    dispose() {
        this.views.forEach(dispose);
        this.views = (void 0);
    }
    accept(visitor) {
        const { views } = this;
        if (views !== void 0) {
            for (let i = 0, ii = views.length; i < ii; ++i) {
                if (views[i].accept(visitor) === true) {
                    return true;
                }
            }
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_6__.bindable
], Repeat.prototype, "items", void 0);
Repeat = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__.templateController)('repeat'),
    __param(0, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation),
    __param(1, _templating_controller_js__WEBPACK_IMPORTED_MODULE_5__.IController),
    __param(2, _templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory)
], Repeat);

let maxLen = 16;
let prevIndices = new Int32Array(maxLen);
let tailIndices = new Int32Array(maxLen);
// Based on inferno's lis_algorithm @ https://github.com/infernojs/inferno/blob/master/packages/inferno/src/DOM/patching.ts#L732
// with some tweaks to make it just a bit faster + account for IndexMap (and some names changes for readability)
/** @internal */
function longestIncreasingSubsequence(indexMap) {
    const len = indexMap.length;
    if (len > maxLen) {
        maxLen = len;
        prevIndices = new Int32Array(len);
        tailIndices = new Int32Array(len);
    }
    let cursor = 0;
    let cur = 0;
    let prev = 0;
    let i = 0;
    let j = 0;
    let low = 0;
    let high = 0;
    let mid = 0;
    for (; i < len; i++) {
        cur = indexMap[i];
        if (cur !== -2) {
            j = prevIndices[cursor];
            prev = indexMap[j];
            if (prev !== -2 && prev < cur) {
                tailIndices[i] = j;
                prevIndices[++cursor] = i;
                continue;
            }
            low = 0;
            high = cursor;
            while (low < high) {
                mid = (low + high) >> 1;
                prev = indexMap[prevIndices[mid]];
                if (prev !== -2 && prev < cur) {
                    low = mid + 1;
                }
                else {
                    high = mid;
                }
            }
            prev = indexMap[prevIndices[low]];
            if (cur < prev || prev === -2) {
                if (low > 0) {
                    tailIndices[i] = prevIndices[low - 1];
                }
                prevIndices[low] = i;
            }
        }
    }
    i = ++cursor;
    const result = new Int32Array(i);
    cur = prevIndices[cursor - 1];
    while (cursor-- > 0) {
        result[cursor] = cur;
        cur = tailIndices[cur];
    }
    while (i-- > 0)
        prevIndices[i] = 0;
    return result;
}
function setContextualProperties(oc, index, length) {
    const isFirst = index === 0;
    const isLast = index === length - 1;
    const isEven = index % 2 === 0;
    oc.$index = index;
    oc.$first = isFirst;
    oc.$last = isLast;
    oc.$middle = !isFirst && !isLast;
    oc.$even = isEven;
    oc.$odd = !isEven;
    oc.$length = length;
}
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/switch.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Switch": () => /* binding */ Switch,
/* harmony export */   "Case": () => /* binding */ Case,
/* harmony export */   "DefaultCase": () => /* binding */ DefaultCase
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let Switch = class Switch {
    constructor(factory, location) {
        this.factory = factory;
        this.location = location;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        /** @internal */
        this.cases = [];
        this.activeCases = [];
        /**
         * This is kept around here so that changes can be awaited from the tests.
         * This needs to be removed after the scheduler is ready to handle/queue the floating promises.
         */
        this.promise = void 0;
    }
    link(flags, _parentContext, _controller, _childController, _target, _instruction) {
        this.view = this.factory.create(flags, this.$controller).setLocation(this.location);
    }
    attaching(initiator, parent, flags) {
        const view = this.view;
        const $controller = this.$controller;
        this.queue(() => view.activate(initiator, $controller, flags, $controller.scope, $controller.hostScope));
        this.queue(() => this.swap(initiator, flags, this.value));
        return this.promise;
    }
    detaching(initiator, parent, flags) {
        this.queue(() => {
            const view = this.view;
            return view.deactivate(initiator, this.$controller, flags);
        });
        return this.promise;
    }
    dispose() {
        this.view?.dispose();
        this.view = (void 0);
    }
    valueChanged(_newValue, _oldValue, flags) {
        if (!this.$controller.isActive) {
            return;
        }
        this.queue(() => this.swap(null, flags, this.value));
    }
    caseChanged($case, flags) {
        this.queue(() => this.handleCaseChange($case, flags));
    }
    handleCaseChange($case, flags) {
        const isMatch = $case.isMatch(this.value, flags);
        const activeCases = this.activeCases;
        const numActiveCases = activeCases.length;
        // Early termination #1
        if (!isMatch) {
            /** The previous match started with this; thus clear. */
            if (numActiveCases > 0 && activeCases[0].id === $case.id) {
                return this.clearActiveCases(null, flags);
            }
            /**
             * There are 2 different scenarios here:
             * 1. $case in activeCases: Indicates by-product of fallthrough. The starting case still satisfies. Return.
             * 2. $case not in activeCases: It was previously not active, and currently also not a match. Return.
             */
            return;
        }
        // Early termination #2
        if (numActiveCases > 0 && activeCases[0].id < $case.id) {
            // Even if this case now a match, the previous case still wins by as that has lower ordinal.
            return;
        }
        // compute the new active cases
        const newActiveCases = [];
        let fallThrough = $case.fallThrough;
        if (!fallThrough) {
            newActiveCases.push($case);
        }
        else {
            const cases = this.cases;
            const idx = cases.indexOf($case);
            for (let i = idx, ii = cases.length; i < ii && fallThrough; i++) {
                const c = cases[i];
                newActiveCases.push(c);
                fallThrough = c.fallThrough;
            }
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.clearActiveCases(null, flags, newActiveCases), () => {
            this.activeCases = newActiveCases;
            return this.activateCases(null, flags);
        });
    }
    swap(initiator, flags, value) {
        const newActiveCases = [];
        let fallThrough = false;
        for (const $case of this.cases) {
            if (fallThrough || $case.isMatch(value, flags)) {
                newActiveCases.push($case);
                fallThrough = $case.fallThrough;
            }
            if (newActiveCases.length > 0 && !fallThrough) {
                break;
            }
        }
        const defaultCase = this.defaultCase;
        if (newActiveCases.length === 0 && defaultCase !== void 0) {
            newActiveCases.push(defaultCase);
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(this.activeCases.length > 0
            ? this.clearActiveCases(initiator, flags, newActiveCases)
            : void 0, () => {
            this.activeCases = newActiveCases;
            if (newActiveCases.length === 0) {
                return;
            }
            return this.activateCases(initiator, flags);
        });
    }
    activateCases(initiator, flags) {
        const controller = this.$controller;
        if (!controller.isActive) {
            return;
        }
        const cases = this.activeCases;
        const length = cases.length;
        if (length === 0) {
            return;
        }
        const scope = controller.scope;
        const hostScope = controller.hostScope;
        // most common case
        if (length === 1) {
            return cases[0].activate(initiator, flags, scope, hostScope);
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.resolveAll)(...cases.map(($case) => $case.activate(initiator, flags, scope, hostScope)));
    }
    clearActiveCases(initiator, flags, newActiveCases = []) {
        const cases = this.activeCases;
        const numCases = cases.length;
        if (numCases === 0) {
            return;
        }
        if (numCases === 1) {
            const firstCase = cases[0];
            if (!newActiveCases.includes(firstCase)) {
                cases.length = 0;
                return firstCase.deactivate(initiator, flags);
            }
            return;
        }
        return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.resolveAll)(...cases.reduce((acc, $case) => {
            if (!newActiveCases.includes($case)) {
                acc.push($case.deactivate(initiator, flags));
            }
            return acc;
        }, [])), () => {
            cases.length = 0;
        });
    }
    queue(action) {
        const previousPromise = this.promise;
        let promise = void 0;
        promise = this.promise = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.onResolve)(previousPromise, action), () => {
            if (this.promise === promise) {
                this.promise = void 0;
            }
        });
    }
    accept(visitor) {
        if (this.$controller.accept(visitor) === true) {
            return true;
        }
        if (this.activeCases.some(x => x.accept(visitor))) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable
], Switch.prototype, "value", void 0);
Switch = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('switch'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_4__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation)
], Switch);

let Case = class Case {
    constructor(factory, locator, location, logger) {
        this.factory = factory;
        this.locator = locator;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.fallThrough = false;
        this.debug = logger.config.level <= 1 /* debug */;
        this.logger = logger.scopeTo(`${this.constructor.name}-#${this.id}`);
        this.view = this.factory.create().setLocation(location);
    }
    link(flags, parentContext, controller, _childController, _target, _instruction) {
        const switchController = controller.parent;
        const $switch = switchController?.viewModel;
        if ($switch instanceof Switch) {
            this.$switch = $switch;
            this.linkToSwitch($switch);
        }
        else {
            throw new Error('The parent switch not found; only `*[switch] > *[case|default-case]` relation is supported.');
        }
    }
    detaching(initiator, parent, flags) {
        return this.deactivate(initiator, flags);
    }
    isMatch(value, flags) {
        if (this.debug) {
            this.logger.debug('isMatch()');
        }
        const $value = this.value;
        if (Array.isArray($value)) {
            if (this.observer === void 0) {
                this.observer = this.observeCollection(flags, $value);
            }
            return $value.includes(value);
        }
        return $value === value;
    }
    valueChanged(newValue, _oldValue, flags) {
        if (Array.isArray(newValue)) {
            this.observer?.unsubscribe(this);
            this.observer = this.observeCollection(flags, newValue);
        }
        else if (this.observer !== void 0) {
            this.observer.unsubscribe(this);
        }
        this.$switch.caseChanged(this, flags);
    }
    handleCollectionChange(_indexMap, flags) {
        this.$switch.caseChanged(this, flags);
    }
    activate(initiator, flags, scope, hostScope) {
        const view = this.view;
        if (view.isActive) {
            return;
        }
        return view.activate(initiator ?? view, this.$controller, flags, scope, hostScope);
    }
    deactivate(initiator, flags) {
        const view = this.view;
        if (!view.isActive) {
            return;
        }
        return view.deactivate(initiator ?? view, this.$controller, flags);
    }
    dispose() {
        this.observer?.unsubscribe(this);
        this.view?.dispose();
        this.view = (void 0);
    }
    linkToSwitch(auSwitch) {
        auSwitch.cases.push(this);
    }
    observeCollection(flags, $value) {
        const observer = this.locator.getArrayObserver($value);
        observer.subscribe(this);
        return observer;
    }
    accept(visitor) {
        if (this.$controller.accept(visitor) === true) {
            return true;
        }
        return this.view?.accept(visitor);
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable
], Case.prototype, "value", void 0);
__decorate([
    (0,_bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable)({
        set: v => {
            switch (v) {
                case 'true': return true;
                case 'false': return false;
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                default: return !!v;
            }
        },
        mode: _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime
    })
], Case.prototype, "fallThrough", void 0);
Case = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('case'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_4__.IViewFactory),
    __param(1, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator),
    __param(2, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation),
    __param(3, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger)
], Case);

let DefaultCase = class DefaultCase extends Case {
    linkToSwitch($switch) {
        if ($switch.defaultCase !== void 0) {
            throw new Error('Multiple \'default-case\'s are not allowed.');
        }
        $switch.defaultCase = this;
    }
};
DefaultCase = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.templateController)('default-case')
], DefaultCase);

//# sourceMappingURL=switch.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/template-controllers/with.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "With": () => /* binding */ With
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






let With = class With {
    constructor(factory, location) {
        this.factory = factory;
        this.location = location;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.view = this.factory.create().setLocation(location);
    }
    valueChanged(newValue, oldValue, flags) {
        if (this.$controller.isActive) {
            // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.activateView(this.view, 32 /* fromBind */);
        }
    }
    attaching(initiator, parent, flags) {
        return this.activateView(initiator, flags);
    }
    detaching(initiator, parent, flags) {
        return this.view.deactivate(initiator, this.$controller, flags);
    }
    activateView(initiator, flags) {
        const { $controller, value } = this;
        const scope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent($controller.scope, value === void 0 ? {} : value);
        return this.view.activate(initiator, $controller, flags, scope, $controller.hostScope);
    }
    dispose() {
        this.view.dispose();
        this.view = (void 0);
    }
    accept(visitor) {
        if (this.view?.accept(visitor) === true) {
            return true;
        }
    }
};
__decorate([
    _bindable_js__WEBPACK_IMPORTED_MODULE_5__.bindable
], With.prototype, "value", void 0);
With = __decorate([
    (0,_custom_attribute_js__WEBPACK_IMPORTED_MODULE_4__.templateController)('with'),
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_3__.IViewFactory),
    __param(1, _dom_js__WEBPACK_IMPORTED_MODULE_2__.IRenderLocation)
], With);

//# sourceMappingURL=with.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/sanitize.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISanitizer": () => /* binding */ ISanitizer,
/* harmony export */   "SanitizeValueConverter": () => /* binding */ SanitizeValueConverter
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


const SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
const ISanitizer = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISanitizer', x => x.singleton(class {
    sanitize(input) {
        return input.replace(SCRIPT_REGEX, '');
    }
}));
/**
 * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.
 */
let SanitizeValueConverter = class SanitizeValueConverter {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * Process the provided markup that flows to the view.
     *
     * @param untrustedMarkup - The untrusted markup to be sanitized.
     */
    toView(untrustedMarkup) {
        if (untrustedMarkup == null) {
            return null;
        }
        return this.sanitizer.sanitize(untrustedMarkup);
    }
};
SanitizeValueConverter = __decorate([
    __param(0, ISanitizer)
], SanitizeValueConverter);

(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.valueConverter)('sanitize')(SanitizeValueConverter);
//# sourceMappingURL=sanitize.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/resources/value-converters/view.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewValueConverter": () => /* binding */ ViewValueConverter
/* harmony export */ });
/* harmony import */ var _templating_view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../templating/view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


let ViewValueConverter = class ViewValueConverter {
    constructor(viewLocator) {
        this.viewLocator = viewLocator;
    }
    toView(object, viewNameOrSelector) {
        return this.viewLocator.getViewComponentForObject(object, viewNameOrSelector);
    }
};
ViewValueConverter = __decorate([
    __param(0, _templating_view_js__WEBPACK_IMPORTED_MODULE_0__.IViewLocator)
], ViewValueConverter);

(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.valueConverter)('view')(ViewValueConverter);
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SymbolFlags": () => /* binding */ SymbolFlags,
/* harmony export */   "TemplateControllerSymbol": () => /* binding */ TemplateControllerSymbol,
/* harmony export */   "ProjectionSymbol": () => /* binding */ ProjectionSymbol,
/* harmony export */   "CustomAttributeSymbol": () => /* binding */ CustomAttributeSymbol,
/* harmony export */   "PlainAttributeSymbol": () => /* binding */ PlainAttributeSymbol,
/* harmony export */   "BindingSymbol": () => /* binding */ BindingSymbol,
/* harmony export */   "CustomElementSymbol": () => /* binding */ CustomElementSymbol,
/* harmony export */   "LetElementSymbol": () => /* binding */ LetElementSymbol,
/* harmony export */   "PlainElementSymbol": () => /* binding */ PlainElementSymbol,
/* harmony export */   "TextSymbol": () => /* binding */ TextSymbol,
/* harmony export */   "BindableInfo": () => /* binding */ BindableInfo,
/* harmony export */   "ElementInfo": () => /* binding */ ElementInfo,
/* harmony export */   "AttrInfo": () => /* binding */ AttrInfo
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");


var SymbolFlags;
(function (SymbolFlags) {
    SymbolFlags[SymbolFlags["type"] = 1023] = "type";
    SymbolFlags[SymbolFlags["isTemplateController"] = 1] = "isTemplateController";
    SymbolFlags[SymbolFlags["isProjection"] = 2] = "isProjection";
    SymbolFlags[SymbolFlags["isCustomAttribute"] = 4] = "isCustomAttribute";
    SymbolFlags[SymbolFlags["isPlainAttribute"] = 8] = "isPlainAttribute";
    SymbolFlags[SymbolFlags["isCustomElement"] = 16] = "isCustomElement";
    SymbolFlags[SymbolFlags["isLetElement"] = 32] = "isLetElement";
    SymbolFlags[SymbolFlags["isPlainElement"] = 64] = "isPlainElement";
    SymbolFlags[SymbolFlags["isText"] = 128] = "isText";
    SymbolFlags[SymbolFlags["isBinding"] = 256] = "isBinding";
    SymbolFlags[SymbolFlags["isAuSlot"] = 512] = "isAuSlot";
    SymbolFlags[SymbolFlags["hasMarker"] = 1024] = "hasMarker";
    SymbolFlags[SymbolFlags["hasTemplate"] = 2048] = "hasTemplate";
    SymbolFlags[SymbolFlags["hasAttributes"] = 4096] = "hasAttributes";
    SymbolFlags[SymbolFlags["hasBindings"] = 8192] = "hasBindings";
    SymbolFlags[SymbolFlags["hasChildNodes"] = 16384] = "hasChildNodes";
    SymbolFlags[SymbolFlags["hasProjections"] = 32768] = "hasProjections";
})(SymbolFlags || (SymbolFlags = {}));
function createMarker(p) {
    const marker = p.document.createElement('au-m');
    marker.className = 'au';
    return marker;
}
/**
 * A html attribute that is associated with a registered resource, specifically a template controller.
 */
class TemplateControllerSymbol {
    constructor(p, syntax, info, res = info.name) {
        this.syntax = syntax;
        this.info = info;
        this.res = res;
        this.flags = 1 /* isTemplateController */ | 1024 /* hasMarker */;
        this.physicalNode = null;
        this.template = null;
        this.templateController = null;
        this._bindings = null;
        this.marker = createMarker(p);
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
}
class ProjectionSymbol {
    constructor(name, template) {
        this.name = name;
        this.template = template;
        this.flags = 2 /* isProjection */;
    }
}
/**
 * A html attribute that is associated with a registered resource, but not a template controller.
 */
class CustomAttributeSymbol {
    constructor(syntax, info, res = info.name) {
        this.syntax = syntax;
        this.info = info;
        this.res = res;
        this.flags = 4 /* isCustomAttribute */;
        this._bindings = null;
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
}
/**
 * An attribute, with either a binding command or an interpolation, whose target is the html
 * attribute of the element.
 *
 * This will never target a bindable property of a custom attribute or element;
 */
class PlainAttributeSymbol {
    constructor(syntax, command, expression) {
        this.syntax = syntax;
        this.command = command;
        this.expression = expression;
        this.flags = 8 /* isPlainAttribute */;
    }
}
/**
 * Either an attribute on an custom element that maps to a declared bindable property of that element,
 * a single-value bound custom attribute, or one of several bindables that were extracted from the attribute
 * value of a custom attribute with multiple bindings usage.
 *
 * This will always target a bindable property of a custom attribute or element;
 */
class BindingSymbol {
    constructor(command, bindable, expression, rawValue, target) {
        this.command = command;
        this.bindable = bindable;
        this.expression = expression;
        this.rawValue = rawValue;
        this.target = target;
        this.flags = 256 /* isBinding */;
    }
}
/**
 * A html element that is associated with a registered resource either via its (lowerCase) `nodeName`
 * or the value of its `as-element` attribute.
 */
class CustomElementSymbol {
    constructor(p, physicalNode, info, res = info.name, bindables = info.bindables) {
        this.physicalNode = physicalNode;
        this.info = info;
        this.res = res;
        this.bindables = bindables;
        this.flags = 16 /* isCustomElement */;
        this.isTarget = true;
        this.templateController = null;
        this._customAttributes = null;
        this._plainAttributes = null;
        this._bindings = null;
        this._childNodes = null;
        this._projections = null;
        if (info.containerless) {
            this.isContainerless = true;
            this.marker = createMarker(p);
            this.flags |= 1024 /* hasMarker */;
        }
        else {
            this.isContainerless = false;
            this.marker = null;
        }
    }
    get customAttributes() {
        if (this._customAttributes === null) {
            this._customAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._customAttributes;
    }
    get plainAttributes() {
        if (this._plainAttributes === null) {
            this._plainAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._plainAttributes;
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
    get childNodes() {
        if (this._childNodes === null) {
            this._childNodes = [];
            this.flags |= 16384 /* hasChildNodes */;
        }
        return this._childNodes;
    }
    get projections() {
        if (this._projections === null) {
            this._projections = [];
            this.flags |= 32768 /* hasProjections */;
        }
        return this._projections;
    }
}
class LetElementSymbol {
    constructor(p, physicalNode, marker = createMarker(p)) {
        this.physicalNode = physicalNode;
        this.marker = marker;
        this.flags = 32 /* isLetElement */ | 1024 /* hasMarker */;
        this.toBindingContext = false;
        this._bindings = null;
    }
    get bindings() {
        if (this._bindings === null) {
            this._bindings = [];
            this.flags |= 8192 /* hasBindings */;
        }
        return this._bindings;
    }
}
/**
 * A normal html element that may or may not have attribute behaviors and/or child node behaviors.
 *
 * It is possible for a PlainElementSymbol to not yield any instructions during compilation.
 */
class PlainElementSymbol {
    constructor(physicalNode) {
        this.physicalNode = physicalNode;
        this.flags = 64 /* isPlainElement */;
        this.isTarget = false;
        this.templateController = null;
        this.hasSlots = false;
        this._customAttributes = null;
        this._plainAttributes = null;
        this._childNodes = null;
    }
    get customAttributes() {
        if (this._customAttributes === null) {
            this._customAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._customAttributes;
    }
    get plainAttributes() {
        if (this._plainAttributes === null) {
            this._plainAttributes = [];
            this.flags |= 4096 /* hasAttributes */;
        }
        return this._plainAttributes;
    }
    get childNodes() {
        if (this._childNodes === null) {
            this._childNodes = [];
            this.flags |= 16384 /* hasChildNodes */;
        }
        return this._childNodes;
    }
}
/**
 * A standalone text node that has an interpolation.
 */
class TextSymbol {
    constructor(p, physicalNode, interpolation, marker = createMarker(p)) {
        this.physicalNode = physicalNode;
        this.interpolation = interpolation;
        this.marker = marker;
        this.flags = 128 /* isText */ | 1024 /* hasMarker */;
    }
}
/**
 * A pre-processed piece of information about a defined bindable property on a custom
 * element or attribute, optimized for consumption by the template compiler.
 */
class BindableInfo {
    constructor(
    /**
     * The pre-processed *property* (not attribute) name of the bindable, which is
     * (in order of priority):
     *
     * 1. The `property` from the description (if defined)
     * 2. The name of the property of the bindable itself
     */
    propName, 
    /**
     * The pre-processed (default) bindingMode of the bindable, which is (in order of priority):
     *
     * 1. The `mode` from the bindable (if defined and not bindingMode.default)
     * 2. The `defaultBindingMode` (if it's an attribute, defined, and not bindingMode.default)
     * 3. `bindingMode.toView`
     */
    mode) {
        this.propName = propName;
        this.mode = mode;
    }
}
const elementInfoLookup = new WeakMap();
/**
 * Pre-processed information about a custom element resource, optimized
 * for consumption by the template compiler.
 */
class ElementInfo {
    constructor(name, alias, containerless) {
        this.name = name;
        this.alias = alias;
        this.containerless = containerless;
        /**
         * A lookup of the bindables of this element, indexed by the (pre-processed)
         * attribute names as they would be found in parsed markup.
         */
        this.bindables = Object.create(null);
    }
    static from(def, alias) {
        if (def === null) {
            return null;
        }
        let rec = elementInfoLookup.get(def);
        if (rec === void 0) {
            elementInfoLookup.set(def, rec = Object.create(null));
        }
        let info = rec[alias];
        if (info === void 0) {
            info = rec[alias] = new ElementInfo(def.name, alias === def.name ? void 0 : alias, def.containerless);
            const bindables = def.bindables;
            const defaultBindingMode = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
            let bindable;
            let prop;
            let attr;
            let mode;
            for (prop in bindables) {
                bindable = bindables[prop];
                // explicitly provided property name has priority over the implicit property name
                if (bindable.property !== void 0) {
                    prop = bindable.property;
                }
                // explicitly provided attribute name has priority over the derived implicit attribute name
                if (bindable.attribute !== void 0) {
                    attr = bindable.attribute;
                }
                else {
                    // derive the attribute name from the resolved property name
                    attr = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase)(prop);
                }
                if (bindable.mode !== void 0 && bindable.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default) {
                    mode = bindable.mode;
                }
                else {
                    mode = defaultBindingMode;
                }
                info.bindables[attr] = new BindableInfo(prop, mode);
            }
        }
        return info;
    }
}
const attrInfoLookup = new WeakMap();
/**
 * Pre-processed information about a custom attribute resource, optimized
 * for consumption by the template compiler.
 */
class AttrInfo {
    constructor(name, alias, isTemplateController, noMultiBindings) {
        this.name = name;
        this.alias = alias;
        this.isTemplateController = isTemplateController;
        this.noMultiBindings = noMultiBindings;
        /**
         * A lookup of the bindables of this attribute, indexed by the (pre-processed)
         * bindable names as they would be found in the attribute value.
         *
         * Only applicable to multi attribute bindings (semicolon-separated).
         */
        this.bindables = Object.create(null);
        /**
         * The single or first bindable of this attribute, or a default 'value'
         * bindable if no bindables were defined on the attribute.
         *
         * Only applicable to single attribute bindings (where the attribute value
         * contains no semicolons)
         */
        this.bindable = null;
    }
    static from(def, alias) {
        if (def === null) {
            return null;
        }
        let rec = attrInfoLookup.get(def);
        if (rec === void 0) {
            attrInfoLookup.set(def, rec = Object.create(null));
        }
        let info = rec[alias];
        if (info === void 0) {
            info = rec[alias] = new AttrInfo(def.name, alias === def.name ? void 0 : alias, def.isTemplateController, def.noMultiBindings);
            const bindables = def.bindables;
            const defaultBindingMode = def.defaultBindingMode !== void 0 && def.defaultBindingMode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default
                ? def.defaultBindingMode
                : _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
            let bindable;
            let prop;
            let mode;
            let hasPrimary = false;
            let isPrimary = false;
            let bindableInfo;
            for (prop in bindables) {
                bindable = bindables[prop];
                // explicitly provided property name has priority over the implicit property name
                if (bindable.property !== void 0) {
                    prop = bindable.property;
                }
                if (bindable.mode !== void 0 && bindable.mode !== _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default) {
                    mode = bindable.mode;
                }
                else {
                    mode = defaultBindingMode;
                }
                isPrimary = bindable.primary === true;
                bindableInfo = info.bindables[prop] = new BindableInfo(prop, mode);
                if (isPrimary) {
                    if (hasPrimary) {
                        throw new Error('primary already exists');
                    }
                    hasPrimary = true;
                    info.bindable = bindableInfo;
                }
                // set to first bindable by convention
                if (info.bindable === null) {
                    info.bindable = bindableInfo;
                }
            }
            // if no bindables are present, default to "value"
            if (info.bindable === null) {
                info.bindable = new BindableInfo('value', defaultBindingMode);
            }
        }
        return info;
    }
}
//# sourceMappingURL=semantic-model.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TemplateBinder": () => /* binding */ TemplateBinder
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources/binding-command.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/binding-command.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./semantic-model.js */ "./node_modules/@aurelia/runtime-html/dist/esm/semantic-model.js");






const invalidSurrogateAttribute = Object.assign(Object.create(null), {
    'id': true,
    'au-slot': true,
});
const attributesToIgnore = Object.assign(Object.create(null), {
    'as-element': true,
});
function hasInlineBindings(rawValue) {
    const len = rawValue.length;
    let ch = 0;
    for (let i = 0; i < len; ++i) {
        ch = rawValue.charCodeAt(i);
        if (ch === 92 /* Backslash */) {
            ++i;
            // Ignore whatever comes next because it's escaped
        }
        else if (ch === 58 /* Colon */) {
            return true;
        }
        else if (ch === 36 /* Dollar */ && rawValue.charCodeAt(i + 1) === 123 /* OpenBrace */) {
            return false;
        }
    }
    return false;
}
function processInterpolationText(symbol) {
    const node = symbol.physicalNode;
    const parentNode = node.parentNode;
    while (node.nextSibling !== null && node.nextSibling.nodeType === 3 /* Text */) {
        parentNode.removeChild(node.nextSibling);
    }
    node.textContent = '';
    parentNode.insertBefore(symbol.marker, node);
}
function isTemplateControllerOf(proxy, manifest) {
    return proxy !== manifest;
}
/**
 * A (temporary) standalone function that purely does the DOM processing (lifting) related to template controllers.
 * It's a first refactoring step towards separating DOM parsing/binding from mutations.
 */
function processTemplateControllers(p, manifestProxy, manifest) {
    const manifestNode = manifest.physicalNode;
    let current = manifestProxy;
    let currentTemplate;
    while (isTemplateControllerOf(current, manifest)) {
        if (current.template === manifest) {
            // the DOM linkage is still in its original state here so we can safely assume the parentNode is non-null
            manifestNode.parentNode.replaceChild(current.marker, manifestNode);
            // if the manifest is a template element (e.g. <template repeat.for="...">) then we can skip one lift operation
            // and simply use the template directly, saving a bit of work
            if (manifestNode.nodeName === 'TEMPLATE') {
                current.physicalNode = manifestNode;
                // the template could safely stay without affecting anything visible, but let's keep the DOM tidy
                manifestNode.remove();
            }
            else {
                // the manifest is not a template element so we need to wrap it in one
                currentTemplate = current.physicalNode = p.document.createElement('template');
                currentTemplate.content.appendChild(manifestNode);
            }
        }
        else {
            currentTemplate = current.physicalNode = p.document.createElement('template');
            currentTemplate.content.appendChild(current.marker);
        }
        manifestNode.removeAttribute(current.syntax.rawName);
        current = current.template;
    }
}
/**
 * TemplateBinder. Todo: describe goal of this class
 */
class TemplateBinder {
    constructor(platform, container, attrParser, exprParser, attrSyntaxTransformer) {
        this.platform = platform;
        this.container = container;
        this.attrParser = attrParser;
        this.exprParser = exprParser;
        this.attrSyntaxTransformer = attrSyntaxTransformer;
        this.commandLookup = Object.create(null);
    }
    bind(node) {
        const surrogate = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainElementSymbol(node);
        const attrSyntaxTransformer = this.attrSyntaxTransformer;
        const attributes = node.attributes;
        let i = 0;
        while (i < attributes.length) {
            const attr = attributes[i];
            const attrSyntax = this.attrParser.parse(attr.name, attr.value);
            if (invalidSurrogateAttribute[attrSyntax.target] === true) {
                throw new Error(`Invalid surrogate attribute: ${attrSyntax.target}`);
                // TODO: use reporter
            }
            const bindingCommand = this.getBindingCommand(attrSyntax, true);
            if (bindingCommand === null || (bindingCommand.bindingType & 4096 /* IgnoreCustomAttr */) === 0) {
                const attrInfo = _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.AttrInfo.from(this.container.find(_resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.CustomAttribute, attrSyntax.target), attrSyntax.target);
                if (attrInfo === null) {
                    // map special html attributes to their corresponding properties
                    attrSyntaxTransformer.transform(node, attrSyntax);
                    // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                    this.bindPlainAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attr       */ attr, 
                    /* surrogate  */ surrogate, 
                    /* manifest   */ surrogate);
                }
                else if (attrInfo.isTemplateController) {
                    throw new Error('Cannot have template controller on surrogate element.');
                    // TODO: use reporter
                }
                else {
                    this.bindCustomAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attrInfo   */ attrInfo, 
                    /* command    */ bindingCommand, 
                    /* manifest   */ surrogate);
                }
            }
            else {
                // map special html attributes to their corresponding properties
                attrSyntaxTransformer.transform(node, attrSyntax);
                // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                this.bindPlainAttribute(
                /* attrSyntax */ attrSyntax, 
                /* attr       */ attr, 
                /* surrogate  */ surrogate, 
                /* manifest   */ surrogate);
            }
            ++i;
        }
        this.bindChildNodes(
        /* node               */ node, 
        /* surrogate          */ surrogate, 
        /* manifest           */ surrogate, 
        /* manifestRoot       */ null, 
        /* parentManifestRoot */ null);
        return surrogate;
    }
    bindManifest(parentManifest, node, surrogate, manifest, manifestRoot, parentManifestRoot) {
        let isAuSlot = false;
        switch (node.nodeName) {
            case 'LET':
                // let cannot have children and has some different processing rules, so return early
                this.bindLetElement(
                /* parentManifest */ parentManifest, 
                /* node           */ node);
                return;
            case 'SLOT':
                surrogate.hasSlots = true;
                break;
            case 'AU-SLOT':
                isAuSlot = true;
                break;
        }
        let name = node.getAttribute('as-element');
        if (name === null) {
            name = node.nodeName.toLowerCase();
        }
        const elementInfo = _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.ElementInfo.from(this.container.find(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement, name), name);
        if (elementInfo === null) {
            // there is no registered custom element with this name
            manifest = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainElementSymbol(node);
        }
        else {
            // it's a custom element so we set the manifestRoot as well (for storing replaces)
            parentManifestRoot = manifestRoot;
            const ceSymbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.CustomElementSymbol(this.platform, node, elementInfo);
            if (isAuSlot) {
                ceSymbol.flags = 512 /* isAuSlot */;
                ceSymbol.slotName = node.getAttribute("name") ?? "default";
            }
            manifestRoot = manifest = ceSymbol;
        }
        // lifting operations done by template controllers and replaces effectively unlink the nodes, so start at the bottom
        this.bindChildNodes(
        /* node               */ node, 
        /* surrogate          */ surrogate, 
        /* manifest           */ manifest, 
        /* manifestRoot       */ manifestRoot, 
        /* parentManifestRoot */ parentManifestRoot);
        // the parentManifest will receive either the direct child nodes, or the template controllers / replaces
        // wrapping them
        this.bindAttributes(
        /* node               */ node, 
        /* parentManifest     */ parentManifest, 
        /* surrogate          */ surrogate, 
        /* manifest           */ manifest, 
        /* manifestRoot       */ manifestRoot, 
        /* parentManifestRoot */ parentManifestRoot);
        if (manifestRoot === manifest && manifest.isContainerless) {
            node.parentNode.replaceChild(manifest.marker, node);
        }
        else if (manifest.isTarget) {
            node.classList.add('au');
        }
    }
    bindLetElement(parentManifest, node) {
        const symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.LetElementSymbol(this.platform, node);
        parentManifest.childNodes.push(symbol);
        const attributes = node.attributes;
        let i = 0;
        while (i < attributes.length) {
            const attr = attributes[i];
            if (attr.name === 'to-binding-context') {
                node.removeAttribute('to-binding-context');
                symbol.toBindingContext = true;
                continue;
            }
            const attrSyntax = this.attrParser.parse(attr.name, attr.value);
            const command = this.getBindingCommand(attrSyntax, false);
            const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
            const expr = this.exprParser.parse(attrSyntax.rawValue, bindingType);
            const to = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(attrSyntax.target);
            const info = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindableInfo(to, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
            symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, info, expr, attrSyntax.rawValue, to));
            ++i;
        }
        node.parentNode.replaceChild(symbol.marker, node);
    }
    bindAttributes(node, parentManifest, surrogate, manifest, manifestRoot, parentManifestRoot) {
        // This is the top-level symbol for the current depth.
        // If there are no template controllers or replaces, it is always the manifest itself.
        // If there are template controllers, then this will be the outer-most TemplateControllerSymbol.
        let manifestProxy = manifest;
        let previousController = (void 0);
        let currentController = (void 0);
        const attributes = node.attributes;
        let i = 0;
        while (i < attributes.length) {
            const attr = attributes[i];
            ++i;
            if (attributesToIgnore[attr.name] === true) {
                continue;
            }
            const attrSyntax = this.attrParser.parse(attr.name, attr.value);
            const bindingCommand = this.getBindingCommand(attrSyntax, true);
            if (bindingCommand === null || (bindingCommand.bindingType & 4096 /* IgnoreCustomAttr */) === 0) {
                const attrInfo = _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.AttrInfo.from(this.container.find(_resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_3__.CustomAttribute, attrSyntax.target), attrSyntax.target);
                if (attrInfo === null) {
                    // map special html attributes to their corresponding properties
                    this.attrSyntaxTransformer.transform(node, attrSyntax);
                    // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                    this.bindPlainAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attr       */ attr, 
                    /* surrogate  */ surrogate, 
                    /* manifest   */ manifest);
                }
                else if (attrInfo.isTemplateController) {
                    // the manifest is wrapped by the inner-most template controller (if there are multiple on the same element)
                    // so keep setting manifest.templateController to the latest template controller we find
                    currentController = manifest.templateController = this.declareTemplateController(
                    /* attrSyntax */ attrSyntax, 
                    /* attrInfo   */ attrInfo);
                    // the proxy and the manifest are only identical when we're at the first template controller (since the controller
                    // is assigned to the proxy), so this evaluates to true at most once per node
                    if (manifestProxy === manifest) {
                        currentController.template = manifest;
                        manifestProxy = currentController;
                    }
                    else {
                        currentController.templateController = previousController;
                        currentController.template = previousController.template;
                        previousController.template = currentController;
                    }
                    previousController = currentController;
                }
                else {
                    // a regular custom attribute
                    this.bindCustomAttribute(
                    /* attrSyntax */ attrSyntax, 
                    /* attrInfo   */ attrInfo, 
                    /* command    */ bindingCommand, 
                    /* manifest   */ manifest);
                }
            }
            else {
                // map special html attributes to their corresponding properties
                this.attrSyntaxTransformer.transform(node, attrSyntax);
                // it's not a custom attribute but might be a regular bound attribute or interpolation (it might also be nothing)
                this.bindPlainAttribute(
                /* attrSyntax */ attrSyntax, 
                /* attr       */ attr, 
                /* surrogate  */ surrogate, 
                /* manifest   */ manifest);
            }
        }
        if (node.tagName === 'INPUT') {
            const type = node.type;
            if (type === 'checkbox' || type === 'radio') {
                this.ensureAttributeOrder(manifest);
            }
        }
        let projection = node.getAttribute('au-slot');
        if (projection === '') {
            projection = 'default';
        }
        const hasProjection = projection !== null;
        if (hasProjection && isTemplateControllerOf(manifestProxy, manifest)) {
            // prevents <some-el au-slot TEMPLATE.CONTROLLER></some-el>.
            throw new Error(`Unsupported usage of [au-slot="${projection}"] along with a template controller (if, else, repeat.for etc.) found (example: <some-el au-slot if.bind="true"></some-el>).`);
            /**
             * TODO: prevent <template TEMPLATE.CONTROLLER><some-el au-slot></some-el></template>.
             * But there is not easy way for now, as the attribute binding is done after binding the child nodes.
             * This means by the time the template controller in the ancestor is processed, the projection is already registered.
             */
        }
        const parentName = node.parentNode?.nodeName.toLowerCase();
        if (hasProjection
            && (manifestRoot === null
                || parentName === void 0
                || this.container.find(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement, parentName) === null)) {
            /**
             * Prevents the following cases:
             * - <template><div au-slot></div></template>
             * - <my-ce><div><div au-slot></div></div></my-ce>
             * - <my-ce><div au-slot="s1"><div au-slot="s2"></div></div></my-ce>
             */
            throw new Error(`Unsupported usage of [au-slot="${projection}"]. It seems that projection is attempted, but not for a custom element.`);
        }
        processTemplateControllers(this.platform, manifestProxy, manifest);
        const projectionOwner = manifest === manifestRoot ? parentManifestRoot : manifestRoot;
        if (!hasProjection || projectionOwner === null) {
            // the proxy is either the manifest itself or the outer-most controller; add it directly to the parent
            parentManifest.childNodes.push(manifestProxy);
        }
        else if (hasProjection) {
            projectionOwner.projections.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.ProjectionSymbol(projection, manifestProxy));
            node.removeAttribute('au-slot');
            node.remove();
        }
    }
    // TODO: refactor to use render priority slots (this logic shouldn't be in the template binder)
    ensureAttributeOrder(manifest) {
        // swap the order of checked and model/value attribute, so that the required observers are prepared for checked-observer
        const attributes = manifest.plainAttributes;
        let modelOrValueIndex = void 0;
        let checkedIndex = void 0;
        let found = 0;
        for (let i = 0; i < attributes.length && found < 3; i++) {
            switch (attributes[i].syntax.target) {
                case 'model':
                case 'value':
                case 'matcher':
                    modelOrValueIndex = i;
                    found++;
                    break;
                case 'checked':
                    checkedIndex = i;
                    found++;
                    break;
            }
        }
        if (checkedIndex !== void 0 && modelOrValueIndex !== void 0 && checkedIndex < modelOrValueIndex) {
            [attributes[modelOrValueIndex], attributes[checkedIndex]] = [attributes[checkedIndex], attributes[modelOrValueIndex]];
        }
    }
    bindChildNodes(node, surrogate, manifest, manifestRoot, parentManifestRoot) {
        let childNode;
        if (node.nodeName === 'TEMPLATE') {
            childNode = node.content.firstChild;
        }
        else {
            childNode = node.firstChild;
        }
        let nextChild;
        while (childNode !== null) {
            switch (childNode.nodeType) {
                case 1 /* Element */:
                    nextChild = childNode.nextSibling;
                    this.bindManifest(
                    /* parentManifest     */ manifest, 
                    /* node               */ childNode, 
                    /* surrogate          */ surrogate, 
                    /* manifest           */ manifest, 
                    /* manifestRoot       */ manifestRoot, 
                    /* parentManifestRoot */ parentManifestRoot);
                    childNode = nextChild;
                    break;
                case 3 /* Text */:
                    childNode = this.bindText(
                    /* textNode */ childNode, 
                    /* manifest */ manifest).nextSibling;
                    break;
                case 4 /* CDATASection */:
                case 7 /* ProcessingInstruction */:
                case 8 /* Comment */:
                case 10 /* DocumentType */:
                    childNode = childNode.nextSibling;
                    break;
                case 9 /* Document */:
                case 11 /* DocumentFragment */:
                    childNode = childNode.firstChild;
            }
        }
    }
    bindText(textNode, manifest) {
        const interpolation = this.exprParser.parse(textNode.wholeText, 2048 /* Interpolation */);
        if (interpolation !== null) {
            const symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.TextSymbol(this.platform, textNode, interpolation);
            manifest.childNodes.push(symbol);
            processInterpolationText(symbol);
        }
        let next = textNode;
        while (next.nextSibling !== null && next.nextSibling.nodeType === 3 /* Text */) {
            next = next.nextSibling;
        }
        return next;
    }
    declareTemplateController(attrSyntax, attrInfo) {
        let symbol;
        const attrRawValue = attrSyntax.rawValue;
        const command = this.getBindingCommand(attrSyntax, false);
        // multi-bindings logic here is similar to (and explained in) bindCustomAttribute
        const isMultiBindings = attrInfo.noMultiBindings === false && command === null && hasInlineBindings(attrRawValue);
        if (isMultiBindings) {
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.TemplateControllerSymbol(this.platform, attrSyntax, attrInfo);
            this.bindMultiAttribute(symbol, attrInfo, attrRawValue);
        }
        else {
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.TemplateControllerSymbol(this.platform, attrSyntax, attrInfo);
            const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
            const expr = this.exprParser.parse(attrRawValue, bindingType);
            symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, attrInfo.bindable, expr, attrRawValue, attrSyntax.target));
        }
        return symbol;
    }
    bindCustomAttribute(attrSyntax, attrInfo, command, manifest) {
        let symbol;
        const attrRawValue = attrSyntax.rawValue;
        // Custom attributes are always in multiple binding mode,
        // except when they can't be
        // When they cannot be:
        //        * has explicit configuration noMultiBindings: false
        //        * has binding command, ie: <div my-attr.bind="...">.
        //          In this scenario, the value of the custom attributes is required to be a valid expression
        //        * has no colon: ie: <div my-attr="abcd">
        //          In this scenario, it's simply invalid syntax. Consider style attribute rule-value pair: <div style="rule: ruleValue">
        const isMultiBindings = attrInfo.noMultiBindings === false && command === null && hasInlineBindings(attrRawValue);
        if (isMultiBindings) {
            // a multiple-bindings attribute usage (semicolon separated binding) is only valid without a binding command;
            // the binding commands must be declared in each of the property bindings
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttributeSymbol(attrSyntax, attrInfo);
            this.bindMultiAttribute(symbol, attrInfo, attrRawValue);
        }
        else {
            symbol = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttributeSymbol(attrSyntax, attrInfo);
            const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
            const expr = this.exprParser.parse(attrRawValue, bindingType);
            symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, attrInfo.bindable, expr, attrRawValue, attrSyntax.target));
        }
        manifest.customAttributes.push(symbol);
        manifest.isTarget = true;
    }
    bindMultiAttribute(symbol, attrInfo, value) {
        const bindables = attrInfo.bindables;
        const valueLength = value.length;
        let attrName = void 0;
        let attrValue = void 0;
        let start = 0;
        let ch = 0;
        for (let i = 0; i < valueLength; ++i) {
            ch = value.charCodeAt(i);
            if (ch === 92 /* Backslash */) {
                ++i;
                // Ignore whatever comes next because it's escaped
            }
            else if (ch === 58 /* Colon */) {
                attrName = value.slice(start, i);
                // Skip whitespace after colon
                while (value.charCodeAt(++i) <= 32 /* Space */)
                    ;
                start = i;
                for (; i < valueLength; ++i) {
                    ch = value.charCodeAt(i);
                    if (ch === 92 /* Backslash */) {
                        ++i;
                        // Ignore whatever comes next because it's escaped
                    }
                    else if (ch === 59 /* Semicolon */) {
                        attrValue = value.slice(start, i);
                        break;
                    }
                }
                if (attrValue === void 0) {
                    // No semicolon found, so just grab the rest of the value
                    attrValue = value.slice(start);
                }
                const attrSyntax = this.attrParser.parse(attrName, attrValue);
                const attrTarget = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(attrSyntax.target);
                const command = this.getBindingCommand(attrSyntax, false);
                const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
                const expr = this.exprParser.parse(attrValue, bindingType);
                let bindable = bindables[attrTarget];
                if (bindable === undefined) {
                    // everything in a multi-bindings expression must be used,
                    // so if it's not a bindable then we create one on the spot
                    bindable = bindables[attrTarget] = new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindableInfo(attrTarget, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView);
                }
                symbol.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, bindable, expr, attrValue, attrTarget));
                // Skip whitespace after semicolon
                while (i < valueLength && value.charCodeAt(++i) <= 32 /* Space */)
                    ;
                start = i;
                attrName = void 0;
                attrValue = void 0;
            }
        }
    }
    bindPlainAttribute(attrSyntax, attr, surrogate, manifest) {
        const command = this.getBindingCommand(attrSyntax, false);
        const bindingType = command === null ? 2048 /* Interpolation */ : command.bindingType;
        const attrTarget = attrSyntax.target;
        const attrRawValue = attrSyntax.rawValue;
        let expr;
        if (attrRawValue.length === 0
            && (bindingType & 53 /* BindCommand */ | 49 /* OneTimeCommand */ | 50 /* ToViewCommand */ | 52 /* TwoWayCommand */) > 0) {
            if ((bindingType & 53 /* BindCommand */ | 49 /* OneTimeCommand */ | 50 /* ToViewCommand */ | 52 /* TwoWayCommand */) > 0) {
                // Default to the name of the attr for empty binding commands
                expr = this.exprParser.parse((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase)(attrTarget), bindingType);
            }
            else {
                return;
            }
        }
        else {
            expr = this.exprParser.parse(attrRawValue, bindingType);
        }
        if ((manifest.flags & 16 /* isCustomElement */) > 0) {
            const bindable = manifest.bindables[attrTarget];
            if (bindable != null) {
                // if the attribute name matches a bindable property name, add it regardless of whether it's a command, interpolation, or just a plain string;
                // the template compiler will translate it to the correct instruction
                manifest.bindings.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.BindingSymbol(command, bindable, expr, attrRawValue, attrTarget));
                manifest.isTarget = true;
            }
            else if (expr != null) {
                // if it does not map to a bindable, only add it if we were able to parse an expression (either a command or interpolation)
                manifest.plainAttributes.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainAttributeSymbol(attrSyntax, command, expr));
                manifest.isTarget = true;
            }
        }
        else if (expr != null) {
            // either a binding command, an interpolation, or a ref
            manifest.plainAttributes.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainAttributeSymbol(attrSyntax, command, expr));
            manifest.isTarget = true;
        }
        else if (manifest === surrogate) {
            // any attributes, even if they are plain (no command/interpolation etc), should be added if they
            // are on the surrogate element
            manifest.plainAttributes.push(new _semantic_model_js__WEBPACK_IMPORTED_MODULE_5__.PlainAttributeSymbol(attrSyntax, command, expr));
        }
        if (command == null && expr != null) {
            // if it's an interpolation, clear the attribute value
            attr.value = '';
        }
    }
    /**
     * Retrieve a binding command resource.
     *
     * @param name - The parsed `AttrSyntax`
     *
     * @returns An instance of the command if it exists, or `null` if it does not exist.
     */
    getBindingCommand(syntax, optional) {
        const name = syntax.command;
        if (name === null) {
            return null;
        }
        let result = this.commandLookup[name];
        if (result === void 0) {
            result = this.container.create(_resources_binding_command_js__WEBPACK_IMPORTED_MODULE_2__.BindingCommand, name);
            if (result === null) {
                if (optional) {
                    return null;
                }
                throw new Error(`Unknown binding command: ${name}`);
            }
            this.commandLookup[name] = result;
        }
        return result;
    }
}
//# sourceMappingURL=template-binder.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/template-compiler.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/template-compiler.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TemplateCompiler": () => /* binding */ TemplateCompiler
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attribute-syntax-transformer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/attribute-syntax-transformer.js");
/* harmony import */ var _template_binder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template-binder.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-binder.js");
/* harmony import */ var _template_element_factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./template-element-factory.js */ "./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _bindable_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bindable.js */ "./node_modules/@aurelia/runtime-html/dist/esm/bindable.js");
/* harmony import */ var _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./resources/attribute-pattern.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/attribute-pattern.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};











class CustomElementCompilationUnit {
    constructor(partialDefinition, surrogate, template) {
        this.partialDefinition = partialDefinition;
        this.surrogate = surrogate;
        this.template = template;
        this.instructions = [];
        this.surrogates = [];
        this.projectionsMap = new Map();
    }
    toDefinition() {
        const def = this.partialDefinition;
        return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({
            ...def,
            instructions: (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.instructions, this.instructions),
            surrogates: (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(def.surrogates, this.surrogates),
            template: this.template,
            needsCompile: false,
            hasSlots: this.surrogate.hasSlots,
            projectionsMap: this.projectionsMap,
        });
    }
}
var LocalTemplateBindableAttributes;
(function (LocalTemplateBindableAttributes) {
    LocalTemplateBindableAttributes["property"] = "property";
    LocalTemplateBindableAttributes["attribute"] = "attribute";
    LocalTemplateBindableAttributes["mode"] = "mode";
})(LocalTemplateBindableAttributes || (LocalTemplateBindableAttributes = {}));
const allowedLocalTemplateBindableAttributes = Object.freeze([
    "property" /* property */,
    "attribute" /* attribute */,
    "mode" /* mode */
]);
const localTemplateIdentifier = 'as-custom-element';
/**
 * Default (runtime-agnostic) implementation for `ITemplateCompiler`.
 *
 * @internal
 */
let TemplateCompiler = class TemplateCompiler {
    constructor(factory, attrParser, exprParser, attrSyntaxModifier, logger, p) {
        this.factory = factory;
        this.attrParser = attrParser;
        this.exprParser = exprParser;
        this.attrSyntaxModifier = attrSyntaxModifier;
        this.p = p;
        this.logger = logger.scopeTo('TemplateCompiler');
    }
    get name() {
        return 'default';
    }
    static register(container) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(_renderer_js__WEBPACK_IMPORTED_MODULE_5__.ITemplateCompiler, this).register(container);
    }
    compile(partialDefinition, context, targetedProjections) {
        const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.getOrCreate(partialDefinition);
        if (definition.template === null || definition.template === void 0) {
            return definition;
        }
        const { attrParser, exprParser, attrSyntaxModifier, factory } = this;
        const p = context.get(_platform_js__WEBPACK_IMPORTED_MODULE_6__.IPlatform);
        const binder = new _template_binder_js__WEBPACK_IMPORTED_MODULE_3__.TemplateBinder(p, context, attrParser, exprParser, attrSyntaxModifier);
        const template = definition.enhance === true
            ? definition.template
            : factory.createTemplate(definition.template);
        processLocalTemplates(template, definition, context, p, this.logger);
        const surrogate = binder.bind(template);
        const compilation = this.compilation = new CustomElementCompilationUnit(definition, surrogate, template);
        const customAttributes = surrogate.customAttributes;
        const plainAttributes = surrogate.plainAttributes;
        const customAttributeLength = customAttributes.length;
        const plainAttributeLength = plainAttributes.length;
        if (customAttributeLength + plainAttributeLength > 0) {
            let offset = 0;
            for (let i = 0; customAttributeLength > i; ++i) {
                compilation.surrogates[offset] = this.compileCustomAttribute(customAttributes[i]);
                offset++;
            }
            for (let i = 0; i < plainAttributeLength; ++i) {
                compilation.surrogates[offset] = this.compilePlainAttribute(plainAttributes[i], true);
                offset++;
            }
        }
        this.compileChildNodes(surrogate, compilation.instructions, compilation.projectionsMap, targetedProjections);
        const compiledDefinition = compilation.toDefinition();
        this.compilation = null;
        return compiledDefinition;
    }
    compileChildNodes(parent, instructionRows, projections, targetedProjections) {
        if ((parent.flags & 16384 /* hasChildNodes */) > 0) {
            const childNodes = parent.childNodes;
            const ii = childNodes.length;
            let childNode;
            for (let i = 0; i < ii; ++i) {
                childNode = childNodes[i];
                if ((childNode.flags & 128 /* isText */) > 0) {
                    instructionRows.push([new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.TextBindingInstruction(childNode.interpolation)]);
                }
                else if ((childNode.flags & 32 /* isLetElement */) > 0) {
                    const bindings = childNode.bindings;
                    const instructions = [];
                    let binding;
                    const jj = bindings.length;
                    for (let j = 0; j < jj; ++j) {
                        binding = bindings[j];
                        instructions[j] = new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.LetBindingInstruction(binding.expression, binding.target);
                    }
                    instructionRows.push([new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateLetElementInstruction(instructions, childNode.toBindingContext)]);
                }
                else {
                    this.compileParentNode(childNode, instructionRows, projections, targetedProjections);
                }
            }
        }
    }
    compileCustomElement(symbol, instructionRows, projections, targetedProjections) {
        const isAuSlot = (symbol.flags & 512 /* isAuSlot */) > 0;
        // offset 1 to leave a spot for the hydrate instruction so we don't need to create 2 arrays with a spread etc
        const instructionRow = this.compileAttributes(symbol, 1);
        const slotName = symbol.slotName;
        let slotInfo = null;
        if (isAuSlot) {
            const targetedProjection = targetedProjections?.projections?.[slotName];
            slotInfo = targetedProjection !== void 0
                ? new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.SlotInfo(slotName, _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.AuSlotContentType.Projection, new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.ProjectionContext(targetedProjection, targetedProjections?.scope))
                : new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.SlotInfo(slotName, _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.AuSlotContentType.Fallback, new _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_9__.ProjectionContext(this.compileProjectionFallback(symbol, projections, targetedProjections)));
        }
        const instruction = instructionRow[0] = new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateElementInstruction(symbol.res, symbol.info.alias, this.compileBindings(symbol), slotInfo);
        const compiledProjections = this.compileProjections(symbol, projections, targetedProjections);
        if (compiledProjections !== null) {
            projections.set(instruction, compiledProjections);
        }
        instructionRows.push(instructionRow);
        if (!isAuSlot) {
            this.compileChildNodes(symbol, instructionRows, projections, targetedProjections);
        }
    }
    compilePlainElement(symbol, instructionRows, projections, targetedProjections) {
        const attributes = this.compileAttributes(symbol, 0);
        if (attributes.length > 0) {
            instructionRows.push(attributes);
        }
        this.compileChildNodes(symbol, instructionRows, projections, targetedProjections);
    }
    compileParentNode(symbol, instructionRows, projections, targetedProjections) {
        switch (symbol.flags & 1023 /* type */) {
            case 16 /* isCustomElement */:
            case 512 /* isAuSlot */:
                this.compileCustomElement(symbol, instructionRows, projections, targetedProjections);
                break;
            case 64 /* isPlainElement */:
                this.compilePlainElement(symbol, instructionRows, projections, targetedProjections);
                break;
            case 1 /* isTemplateController */:
                this.compileTemplateController(symbol, instructionRows, projections, targetedProjections);
        }
    }
    compileTemplateController(symbol, instructionRows, projections, targetedProjections) {
        const bindings = this.compileBindings(symbol);
        const controllerInstructionRows = [];
        this.compileParentNode(symbol.template, controllerInstructionRows, projections, targetedProjections);
        const def = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({
            name: symbol.info.alias ?? symbol.info.name,
            template: symbol.physicalNode,
            instructions: controllerInstructionRows,
            needsCompile: false,
        });
        instructionRows.push([new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateTemplateController(def, symbol.res, symbol.info.alias, bindings)]);
    }
    compileBindings(symbol) {
        let bindingInstructions;
        if ((symbol.flags & 8192 /* hasBindings */) > 0) {
            // either a custom element with bindings, a custom attribute / template controller with dynamic options,
            // or a single value custom attribute binding
            const { bindings } = symbol;
            const len = bindings.length;
            bindingInstructions = Array(len);
            let i = 0;
            for (; i < len; ++i) {
                bindingInstructions[i] = this.compileBinding(bindings[i]);
            }
        }
        else {
            bindingInstructions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        return bindingInstructions;
    }
    compileBinding(symbol) {
        if (symbol.command === null) {
            // either an interpolation or a normal string value assigned to an element or attribute binding
            if (symbol.expression === null) {
                // the template binder already filtered out non-bindables, so we know we need a setProperty here
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetPropertyInstruction(symbol.rawValue, symbol.bindable.propName);
            }
            else {
                // either an element binding interpolation or a dynamic options attribute binding interpolation
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.InterpolationInstruction(symbol.expression, symbol.bindable.propName);
            }
        }
        else {
            // either an element binding command, dynamic options attribute binding command,
            // or custom attribute / template controller (single value) binding command
            return symbol.command.compile(symbol);
        }
    }
    compileAttributes(symbol, offset) {
        let attributeInstructions;
        if ((symbol.flags & 4096 /* hasAttributes */) > 0) {
            // any attributes on a custom element (which are not bindables) or a plain element
            const customAttributes = symbol.customAttributes;
            const plainAttributes = symbol.plainAttributes;
            const customAttributeLength = customAttributes.length;
            const plainAttributesLength = plainAttributes.length;
            attributeInstructions = Array(offset + customAttributeLength + plainAttributesLength);
            for (let i = 0; customAttributeLength > i; ++i) {
                attributeInstructions[offset] = this.compileCustomAttribute(customAttributes[i]);
                offset++;
            }
            for (let i = 0; plainAttributesLength > i; ++i) {
                attributeInstructions[offset] = this.compilePlainAttribute(plainAttributes[i], false);
                offset++;
            }
        }
        else if (offset > 0) {
            attributeInstructions = Array(offset);
        }
        else {
            attributeInstructions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
        }
        return attributeInstructions;
    }
    compileCustomAttribute(symbol) {
        // a normal custom attribute (not template controller)
        const bindings = this.compileBindings(symbol);
        return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.HydrateAttributeInstruction(symbol.res, symbol.info.alias, bindings);
    }
    compilePlainAttribute(symbol, isOnSurrogate) {
        if (symbol.command === null) {
            const syntax = symbol.syntax;
            if (symbol.expression === null) {
                const attrRawValue = syntax.rawValue;
                if (isOnSurrogate) {
                    switch (syntax.target) {
                        case 'class':
                            return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetClassAttributeInstruction(attrRawValue);
                        case 'style':
                            return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetStyleAttributeInstruction(attrRawValue);
                        // todo:  define how to merge other attribute peacefully
                        //        this is an existing feature request
                    }
                }
                // a plain attribute on a surrogate
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.SetAttributeInstruction(attrRawValue, syntax.target);
            }
            else {
                // a plain attribute with an interpolation
                return new _renderer_js__WEBPACK_IMPORTED_MODULE_5__.InterpolationInstruction(symbol.expression, syntax.target);
            }
        }
        else {
            // a plain attribute with a binding command
            return symbol.command.compile(symbol);
        }
    }
    // private compileAttribute(symbol: IAttributeSymbol): AttributeInstruction {
    //   // any attribute on a custom element (which is not a bindable) or a plain element
    //   if (symbol.flags & SymbolFlags.isCustomAttribute) {
    //     return this.compileCustomAttribute(symbol as CustomAttributeSymbol);
    //   } else {
    //     return this.compilePlainAttribute(symbol as PlainAttributeSymbol);
    //   }
    // }
    compileProjections(symbol, projectionMap, targetedProjections) {
        if ((symbol.flags & 32768 /* hasProjections */) === 0) {
            return null;
        }
        const p = this.p;
        const projections = Object.create(null);
        const $projections = symbol.projections;
        const len = $projections.length;
        for (let i = 0; i < len; ++i) {
            const projection = $projections[i];
            const name = projection.name;
            const instructions = [];
            this.compileParentNode(projection.template, instructions, projectionMap, targetedProjections);
            const definition = projections[name];
            if (definition === void 0) {
                let template = projection.template.physicalNode;
                if (template.tagName !== 'TEMPLATE') {
                    const _template = p.document.createElement('template');
                    _template.content.appendChild(template);
                    template = _template;
                }
                projections[name] = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({ name, template, instructions, needsCompile: false });
            }
            else {
                // consolidate the projections to same slot
                definition.template.content.appendChild(projection.template.physicalNode);
                definition.instructions.push(...instructions);
            }
        }
        return projections;
    }
    compileProjectionFallback(symbol, projections, targetedProjections) {
        const instructions = [];
        this.compileChildNodes(symbol, instructions, projections, targetedProjections);
        const template = this.p.document.createElement('template');
        template.content.append(...(0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray)(symbol.physicalNode.childNodes));
        return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElementDefinition.create({ name: _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.generateName(), template, instructions, needsCompile: false });
    }
};
TemplateCompiler = __decorate([
    __param(0, _template_element_factory_js__WEBPACK_IMPORTED_MODULE_4__.ITemplateElementFactory),
    __param(1, _resources_attribute_pattern_js__WEBPACK_IMPORTED_MODULE_8__.IAttributeParser),
    __param(2, _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser),
    __param(3, _attribute_syntax_transformer_js__WEBPACK_IMPORTED_MODULE_2__.IAttrSyntaxTransformer),
    __param(4, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger),
    __param(5, _platform_js__WEBPACK_IMPORTED_MODULE_6__.IPlatform)
], TemplateCompiler);

function processTemplateName(localTemplate, localTemplateNames) {
    const name = localTemplate.getAttribute(localTemplateIdentifier);
    if (name === null || name === '') {
        throw new Error('The value of "as-custom-element" attribute cannot be empty for local template');
    }
    if (localTemplateNames.has(name)) {
        throw new Error(`Duplicate definition of the local template named ${name}`);
    }
    else {
        localTemplateNames.add(name);
        localTemplate.removeAttribute(localTemplateIdentifier);
    }
    return name;
}
function getBindingMode(bindable) {
    switch (bindable.getAttribute("mode" /* mode */)) {
        case 'oneTime':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.oneTime;
        case 'toView':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.toView;
        case 'fromView':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.fromView;
        case 'twoWay':
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.twoWay;
        case 'default':
        default:
            return _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.BindingMode.default;
    }
}
function processLocalTemplates(template, definition, context, p, logger) {
    let root;
    if (template.nodeName === 'TEMPLATE') {
        if (template.hasAttribute(localTemplateIdentifier)) {
            throw new Error('The root cannot be a local template itself.');
        }
        root = template.content;
    }
    else {
        root = template;
    }
    const localTemplates = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray)(root.querySelectorAll('template[as-custom-element]'));
    const numLocalTemplates = localTemplates.length;
    if (numLocalTemplates === 0) {
        return;
    }
    if (numLocalTemplates === root.childElementCount) {
        throw new Error('The custom element does not have any content other than local template(s).');
    }
    const localTemplateNames = new Set();
    for (const localTemplate of localTemplates) {
        if (localTemplate.parentNode !== root) {
            throw new Error('Local templates needs to be defined directly under root.');
        }
        const name = processTemplateName(localTemplate, localTemplateNames);
        const localTemplateType = class LocalTemplate {
        };
        const content = localTemplate.content;
        const bindableEls = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray)(content.querySelectorAll('bindable'));
        const bindableInstructions = _bindable_js__WEBPACK_IMPORTED_MODULE_7__.Bindable.for(localTemplateType);
        const properties = new Set();
        const attributes = new Set();
        for (const bindableEl of bindableEls) {
            if (bindableEl.parentNode !== content) {
                throw new Error('Bindable properties of local templates needs to be defined directly under root.');
            }
            const property = bindableEl.getAttribute("property" /* property */);
            if (property === null) {
                throw new Error(`The attribute 'property' is missing in ${bindableEl.outerHTML}`);
            }
            const attribute = bindableEl.getAttribute("attribute" /* attribute */);
            if (attribute !== null
                && attributes.has(attribute)
                || properties.has(property)) {
                throw new Error(`Bindable property and attribute needs to be unique; found property: ${property}, attribute: ${attribute}`);
            }
            else {
                if (attribute !== null) {
                    attributes.add(attribute);
                }
                properties.add(property);
            }
            bindableInstructions.add({
                property,
                attribute: attribute ?? void 0,
                mode: getBindingMode(bindableEl),
            });
            const ignoredAttributes = bindableEl.getAttributeNames().filter((attrName) => !allowedLocalTemplateBindableAttributes.includes(attrName));
            if (ignoredAttributes.length > 0) {
                logger.warn(`The attribute(s) ${ignoredAttributes.join(', ')} will be ignored for ${bindableEl.outerHTML}. Only ${allowedLocalTemplateBindableAttributes.join(', ')} are processed.`);
            }
            content.removeChild(bindableEl);
        }
        const localTemplateDefinition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_10__.CustomElement.define({ name, template: localTemplate }, localTemplateType);
        // the casting is needed here as the dependencies are typed as readonly array
        definition.dependencies.push(localTemplateDefinition);
        context.register(localTemplateDefinition);
        root.removeChild(localTemplate);
    }
}
//# sourceMappingURL=template-compiler.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/template-element-factory.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ITemplateElementFactory": () => /* binding */ ITemplateElementFactory,
/* harmony export */   "TemplateElementFactory": () => /* binding */ TemplateElementFactory
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};


const ITemplateElementFactory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ITemplateElementFactory', x => x.singleton(TemplateElementFactory));
const markupCache = {};
let TemplateElementFactory = class TemplateElementFactory {
    constructor(p) {
        this.p = p;
        this.template = p.document.createElement('template');
    }
    createTemplate(input) {
        if (typeof input === 'string') {
            let result = markupCache[input];
            if (result === void 0) {
                const template = this.template;
                template.innerHTML = input;
                const node = template.content.firstElementChild;
                // if the input is either not wrapped in a template or there is more than one node,
                // return the whole template that wraps it/them (and create a new one for the next input)
                if (node == null || node.nodeName !== 'TEMPLATE' || node.nextElementSibling != null) {
                    this.template = this.p.document.createElement('template');
                    result = template;
                }
                else {
                    // the node to return is both a template and the only node, so return just the node
                    // and clean up the template for the next input
                    template.content.removeChild(node);
                    result = node;
                }
                markupCache[input] = result;
            }
            return result.cloneNode(true);
        }
        if (input.nodeName !== 'TEMPLATE') {
            // if we get one node that is not a template, wrap it in one
            const template = this.p.document.createElement('template');
            template.content.appendChild(input);
            return template;
        }
        // we got a template element, remove it from the DOM if it's present there and don't
        // do any other processing
        input.parentNode?.removeChild(input);
        return input.cloneNode(true);
    }
};
TemplateElementFactory = __decorate([
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_1__.IPlatform)
], TemplateElementFactory);

//# sourceMappingURL=template-element-factory.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "children": () => /* binding */ children,
/* harmony export */   "Children": () => /* binding */ Children,
/* harmony export */   "ChildrenDefinition": () => /* binding */ ChildrenDefinition,
/* harmony export */   "ChildrenObserver": () => /* binding */ ChildrenObserver,
/* harmony export */   "filterChildren": () => /* binding */ filterChildren
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChildrenObserver_1;



function children(configOrTarget, prop) {
    let config;
    function decorator($target, $prop) {
        if (arguments.length > 1) {
            // Non invocation:
            // - @children
            // Invocation with or w/o opts:
            // - @children()
            // - @children({...opts})
            config.property = $prop;
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Children.name, ChildrenDefinition.create($prop, config), $target.constructor, $prop);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.appendTo($target.constructor, Children.keyFrom($prop));
    }
    if (arguments.length > 1) {
        // Non invocation:
        // - @children
        config = {};
        decorator(configOrTarget, prop);
        return;
    }
    else if (typeof configOrTarget === 'string') {
        // ClassDecorator
        // - @children('bar')
        // Direct call:
        // - @children('bar')(Foo)
        config = {};
        return decorator;
    }
    // Invocation with or w/o opts:
    // - @children()
    // - @children({...opts})
    config = configOrTarget === void 0 ? {} : configOrTarget;
    return decorator;
}
function isChildrenObserverAnnotation(key) {
    return key.startsWith(Children.name);
}
const Children = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('children-observer'),
    keyFrom(name) {
        return `${Children.name}:${name}`;
    },
    from(...childrenObserverLists) {
        const childrenObservers = {};
        const isArray = Array.isArray;
        function addName(name) {
            childrenObservers[name] = ChildrenDefinition.create(name);
        }
        function addDescription(name, def) {
            childrenObservers[name] = ChildrenDefinition.create(name, def);
        }
        function addList(maybeList) {
            if (isArray(maybeList)) {
                maybeList.forEach(addName);
            }
            else if (maybeList instanceof ChildrenDefinition) {
                childrenObservers[maybeList.property] = maybeList;
            }
            else if (maybeList !== void 0) {
                Object.keys(maybeList).forEach(name => addDescription(name, maybeList));
            }
        }
        childrenObserverLists.forEach(addList);
        return childrenObservers;
    },
    getAll(Type) {
        const propStart = Children.name.length + 1;
        const defs = [];
        const prototypeChain = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.getPrototypeChain)(Type);
        let iProto = prototypeChain.length;
        let iDefs = 0;
        let keys;
        let keysLen;
        let Class;
        while (--iProto >= 0) {
            Class = prototypeChain[iProto];
            keys = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.getKeys(Class).filter(isChildrenObserverAnnotation);
            keysLen = keys.length;
            for (let i = 0; i < keysLen; ++i) {
                defs[iDefs++] = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Children.name, Class, keys[i].slice(propStart));
            }
        }
        return defs;
    },
};
const childObserverOptions = { childList: true };
class ChildrenDefinition {
    constructor(callback, property, options, query, filter, map) {
        this.callback = callback;
        this.property = property;
        this.options = options;
        this.query = query;
        this.filter = filter;
        this.map = map;
    }
    static create(prop, def = {}) {
        return new ChildrenDefinition((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.callback, `${prop}Changed`), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(def.property, prop), def.options ?? childObserverOptions, def.query, def.filter, def.map);
    }
}
/** @internal */
let ChildrenObserver = ChildrenObserver_1 = class ChildrenObserver {
    constructor(controller, obj, propertyKey, cbName, query = defaultChildQuery, filter = defaultChildFilter, map = defaultChildMap, options) {
        this.controller = controller;
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.query = query;
        this.filter = filter;
        this.map = map;
        this.options = options;
        this.observing = false;
        this.children = (void 0);
        this.callback = obj[cbName];
        Reflect.defineProperty(this.obj, this.propertyKey, {
            enumerable: true,
            configurable: true,
            get: () => this.getValue(),
            set: () => { return; },
        });
    }
    getValue() {
        this.tryStartObserving();
        return this.children;
    }
    setValue(newValue) { }
    subscribe(subscriber) {
        this.tryStartObserving();
        this.subs.add(subscriber);
    }
    tryStartObserving() {
        if (!this.observing) {
            this.observing = true;
            this.children = filterChildren(this.controller, this.query, this.filter, this.map);
            const obs = new this.controller.host.ownerDocument.defaultView.MutationObserver(() => { this.onChildrenChanged(); });
            obs.observe(this.controller.host, this.options);
        }
    }
    onChildrenChanged() {
        this.children = filterChildren(this.controller, this.query, this.filter, this.map);
        if (this.callback !== void 0) {
            this.callback.call(this.obj);
        }
        this.subs.notify(this.children, undefined, 8 /* updateTarget */);
    }
};
ChildrenObserver = ChildrenObserver_1 = __decorate([
    (0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)()
], ChildrenObserver);

function defaultChildQuery(controller) {
    return controller.host.childNodes;
}
function defaultChildFilter(node, controller, viewModel) {
    return !!viewModel;
}
function defaultChildMap(node, controller, viewModel) {
    return viewModel;
}
const forOpts = { optional: true };
/** @internal */
function filterChildren(controller, query, filter, map) {
    const nodes = query(controller);
    const children = [];
    for (let i = 0, ii = nodes.length; i < ii; ++i) {
        const node = nodes[i];
        const $controller = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.for(node, forOpts);
        const viewModel = $controller?.viewModel ?? null;
        if (filter(node, $controller, viewModel)) {
            children.push(map(node, $controller, viewModel));
        }
    }
    return children;
}
//# sourceMappingURL=children.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MountTarget": () => /* binding */ MountTarget,
/* harmony export */   "Controller": () => /* binding */ Controller,
/* harmony export */   "isCustomElementController": () => /* binding */ isCustomElementController,
/* harmony export */   "isCustomElementViewModel": () => /* binding */ isCustomElementViewModel,
/* harmony export */   "HooksDefinition": () => /* binding */ HooksDefinition,
/* harmony export */   "ViewModelKind": () => /* binding */ ViewModelKind,
/* harmony export */   "State": () => /* binding */ State,
/* harmony export */   "stringifyState": () => /* binding */ stringifyState,
/* harmony export */   "IController": () => /* binding */ IController
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observation/bindable-observer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/bindable-observer.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
/* harmony import */ var _render_context_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./render-context.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js");
/* harmony import */ var _children_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./children.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/children.js");
/* harmony import */ var _app_root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../app-root.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-root.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _styles_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./styles.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js");
/* harmony import */ var _watchers_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./watchers.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js");
/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */












function callDispose(disposable) {
    disposable.dispose();
}
var MountTarget;
(function (MountTarget) {
    MountTarget[MountTarget["none"] = 0] = "none";
    MountTarget[MountTarget["host"] = 1] = "host";
    MountTarget[MountTarget["shadowRoot"] = 2] = "shadowRoot";
    MountTarget[MountTarget["location"] = 3] = "location";
})(MountTarget || (MountTarget = {}));
const optional = { optional: true };
const controllerLookup = new WeakMap();
class Controller {
    constructor(root, container, vmKind, flags, definition, 
    /**
     * The viewFactory. Only present for synthetic views.
     */
    viewFactory, 
    /**
     * The backing viewModel. Only present for custom attributes and elements.
     */
    viewModel, 
    /**
     * The physical host dom node.
     *
     * For containerless elements, this node will be removed from the DOM and replaced by a comment, which is assigned to the `location` property.
     *
     * For ShadowDOM elements, this will be the original declaring element, NOT the shadow root (the shadow root is stored on the `shadowRoot` property)
     */
    host) {
        this.root = root;
        this.container = container;
        this.vmKind = vmKind;
        this.flags = flags;
        this.definition = definition;
        this.viewFactory = viewFactory;
        this.viewModel = viewModel;
        this.host = host;
        this.id = (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.nextId)('au$component');
        this.head = null;
        this.tail = null;
        this.next = null;
        this.parent = null;
        this.bindings = null;
        this.children = null;
        this.hasLockedScope = false;
        this.isStrictBinding = false;
        this.scope = null;
        this.hostScope = null;
        // If a host from another custom element was passed in, then this will be the controller for that custom element (could be `au-viewport` for example).
        // In that case, this controller will create a new host node (with the definition's name) and use that as the target host for the nodes instead.
        // That host node is separately mounted to the host controller's original host node.
        this.hostController = null;
        this.mountTarget = 0 /* none */;
        this.shadowRoot = null;
        this.nodes = null;
        this.context = null;
        this.location = null;
        this.state = 0 /* none */;
        this.logger = null;
        this.debug = false;
        this.fullyNamed = false;
        this.$initiator = null;
        this.$flags = 0 /* none */;
        this.$resolve = void 0;
        this.$reject = void 0;
        this.$promise = void 0;
        this.activatingStack = 0;
        this.detachingStack = 0;
        this.unbindingStack = 0;
        if (root === null && container.has(_app_root_js__WEBPACK_IMPORTED_MODULE_8__.IAppRoot, true)) {
            this.root = container.get(_app_root_js__WEBPACK_IMPORTED_MODULE_8__.IAppRoot);
        }
        this.platform = container.get(_platform_js__WEBPACK_IMPORTED_MODULE_9__.IPlatform);
        switch (vmKind) {
            case 1 /* customAttribute */:
            case 0 /* customElement */:
                this.hooks = new HooksDefinition(viewModel);
                break;
            case 2 /* synthetic */:
                this.hooks = HooksDefinition.none;
                break;
        }
    }
    get isActive() {
        return (this.state & (1 /* activating */ | 2 /* activated */)) > 0 && (this.state & 4 /* deactivating */) === 0;
    }
    get name() {
        if (this.parent === null) {
            switch (this.vmKind) {
                case 1 /* customAttribute */:
                    return `[${this.definition.name}]`;
                case 0 /* customElement */:
                    return this.definition.name;
                case 2 /* synthetic */:
                    return this.viewFactory.name;
            }
        }
        switch (this.vmKind) {
            case 1 /* customAttribute */:
                return `${this.parent.name}>[${this.definition.name}]`;
            case 0 /* customElement */:
                return `${this.parent.name}>${this.definition.name}`;
            case 2 /* synthetic */:
                return this.viewFactory.name === this.parent.definition?.name
                    ? `${this.parent.name}[view]`
                    : `${this.parent.name}[view:${this.viewFactory.name}]`;
        }
    }
    static getCached(viewModel) {
        return controllerLookup.get(viewModel);
    }
    static getCachedOrThrow(viewModel) {
        const controller = Controller.getCached(viewModel);
        if (controller === void 0) {
            throw new Error(`There is no cached controller for the provided ViewModel: ${String(viewModel)}`);
        }
        return controller;
    }
    static forCustomElement(root, container, viewModel, host, 
    // projections *targeted* for this custom element. these are not the projections *provided* by this custom element.
    targetedProjections, flags = 0 /* none */, hydrate = true, 
    // Use this when `instance.constructor` is not a custom element type to pass on the CustomElement definition
    definition = void 0) {
        if (controllerLookup.has(viewModel)) {
            return controllerLookup.get(viewModel);
        }
        definition = definition ?? _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.getDefinition(viewModel.constructor);
        const controller = new Controller(
        /* root           */ root, 
        /* container      */ container, 0 /* customElement */, 
        /* flags          */ flags, 
        /* definition     */ definition, 
        /* viewFactory    */ null, 
        /* viewModel      */ viewModel, 
        /* host           */ host);
        controllerLookup.set(viewModel, controller);
        if (hydrate) {
            controller.hydrateCustomElement(container, targetedProjections);
        }
        return controller;
    }
    static forCustomAttribute(root, container, viewModel, host, flags = 0 /* none */) {
        if (controllerLookup.has(viewModel)) {
            return controllerLookup.get(viewModel);
        }
        const definition = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttribute.getDefinition(viewModel.constructor);
        const controller = new Controller(
        /* root           */ root, 
        /* container      */ container, 1 /* customAttribute */, 
        /* flags          */ flags, 
        /* definition     */ definition, 
        /* viewFactory    */ null, 
        /* viewModel      */ viewModel, 
        /* host           */ host);
        controllerLookup.set(viewModel, controller);
        controller.hydrateCustomAttribute();
        return controller;
    }
    static forSyntheticView(root, context, viewFactory, flags = 0 /* none */, parentController = void 0) {
        const controller = new Controller(
        /* root           */ root, 
        /* container      */ context, 2 /* synthetic */, 
        /* flags          */ flags, 
        /* definition     */ null, 
        /* viewFactory    */ viewFactory, 
        /* viewModel      */ null, 
        /* host           */ null);
        controller.parent = parentController ?? null;
        controller.hydrateSynthetic(context);
        return controller;
    }
    /** @internal */
    hydrateCustomElement(parentContainer, targetedProjections) {
        this.logger = parentContainer.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger).root;
        this.debug = this.logger.config.level <= 1 /* debug */;
        if (this.debug) {
            this.logger = this.logger.scopeTo(this.name);
        }
        let definition = this.definition;
        const flags = this.flags;
        const instance = this.viewModel;
        this.scope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.create(instance, null, true);
        if (definition.watches.length > 0) {
            createWatchers(this, this.container, definition, instance);
        }
        createObservers(this, definition, flags, instance);
        createChildrenObservers(this, definition, flags, instance);
        if (this.hooks.hasDefine) {
            if (this.debug) {
                this.logger.trace(`invoking define() hook`);
            }
            const result = instance.define(
            /* controller      */ this, 
            /* parentContainer */ parentContainer, 
            /* definition      */ definition);
            if (result !== void 0 && result !== definition) {
                definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElementDefinition.getOrCreate(result);
            }
        }
        const context = this.context = (0,_render_context_js__WEBPACK_IMPORTED_MODULE_6__.getRenderContext)(definition, parentContainer, targetedProjections?.projections);
        // Support Recursive Components by adding self to own context
        definition.register(context);
        if (definition.injectable !== null) {
            // If the element is registered as injectable, support injecting the instance into children
            context.beginChildComponentOperation(instance);
        }
        // If this is the root controller, then the AppRoot will invoke things in the following order:
        // - Controller.hydrateCustomElement
        // - runAppTasks('hydrating') // may return a promise
        // - Controller.compile
        // - runAppTasks('hydrated') // may return a promise
        // - Controller.compileChildren
        // This keeps hydration synchronous while still allowing the composition root compile hooks to do async work.
        if (this.root?.controller !== this) {
            this.hydrate(targetedProjections);
            this.hydrateChildren();
        }
    }
    /** @internal */
    hydrate(targetedProjections) {
        if (this.hooks.hasHydrating) {
            if (this.debug) {
                this.logger.trace(`invoking hasHydrating() hook`);
            }
            this.viewModel.hydrating(this);
        }
        const compiledContext = this.context.compile(targetedProjections);
        const { projectionsMap, shadowOptions, isStrictBinding, hasSlots, containerless } = compiledContext.compiledDefinition;
        compiledContext.registerProjections(projectionsMap, this.scope);
        // once the projections are registered, we can cleanup the projection map to prevent memory leaks.
        projectionsMap.clear();
        this.isStrictBinding = isStrictBinding;
        if ((this.hostController = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.for(this.host, optional)) !== null) {
            this.host = this.platform.document.createElement(this.context.definition.name);
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, this.host);
        if (shadowOptions !== null || hasSlots) {
            if (containerless) {
                throw new Error('You cannot combine the containerless custom element option with Shadow DOM.');
            }
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, this.shadowRoot = this.host.attachShadow(shadowOptions ?? defaultShadowOptions));
            this.mountTarget = 2 /* shadowRoot */;
        }
        else if (containerless) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, this.location = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.convertToRenderLocation)(this.host));
            this.mountTarget = 3 /* location */;
        }
        else {
            this.mountTarget = 1 /* host */;
        }
        this.viewModel.$controller = this;
        this.nodes = compiledContext.createNodes();
        if (this.hooks.hasHydrated) {
            if (this.debug) {
                this.logger.trace(`invoking hasHydrated() hook`);
            }
            this.viewModel.hydrated(this);
        }
    }
    /** @internal */
    hydrateChildren() {
        const targets = this.nodes.findTargets();
        this.context.render(
        /* flags      */ this.flags, 
        /* controller */ this, 
        /* targets    */ targets, 
        /* definition */ this.context.compiledDefinition, 
        /* host       */ this.host);
        if (this.hooks.hasCreated) {
            if (this.debug) {
                this.logger.trace(`invoking created() hook`);
            }
            this.viewModel.created(this);
        }
    }
    hydrateCustomAttribute() {
        const definition = this.definition;
        const instance = this.viewModel;
        if (definition.watches.length > 0) {
            createWatchers(this, this.container, definition, instance);
        }
        createObservers(this, definition, this.flags, instance);
        instance.$controller = this;
    }
    hydrateSynthetic(context) {
        this.context = context;
        const compiledContext = context.compile(null);
        const compiledDefinition = compiledContext.compiledDefinition;
        this.isStrictBinding = compiledDefinition.isStrictBinding;
        const nodes = this.nodes = compiledContext.createNodes();
        const targets = nodes.findTargets();
        compiledContext.render(
        /* flags      */ this.flags, 
        /* controller */ this, 
        /* targets    */ targets, 
        /* definition */ compiledDefinition, 
        /* host       */ void 0);
    }
    activate(initiator, parent, flags, scope, hostScope) {
        switch (this.state) {
            case 0 /* none */:
            case 8 /* deactivated */:
                if (!(parent === null || parent.isActive)) {
                    // If this is not the root, and the parent is either:
                    // 1. Not activated, or activating children OR
                    // 2. Deactivating itself
                    // abort.
                    return;
                }
                // Otherwise, proceed normally.
                // 'deactivated' and 'none' are treated the same because, from an activation perspective, they mean the same thing.
                this.state = 1 /* activating */;
                break;
            case 2 /* activated */:
                // If we're already activated, no need to do anything.
                return;
            case 32 /* disposed */:
                throw new Error(`${this.name} trying to activate a controller that is disposed.`);
            default:
                throw new Error(`${this.name} unexpected state: ${stringifyState(this.state)}.`);
        }
        this.parent = parent;
        if (this.debug && !this.fullyNamed) {
            this.fullyNamed = true;
            this.logger = this.context.get(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger).root.scopeTo(this.name);
            this.logger.trace(`activate()`);
        }
        this.hostScope = hostScope ?? null;
        flags |= 32 /* fromBind */;
        switch (this.vmKind) {
            case 0 /* customElement */:
                // Custom element scope is created and assigned during hydration
                this.scope.parentScope = scope ?? null;
                break;
            case 1 /* customAttribute */:
                this.scope = scope ?? null;
                break;
            case 2 /* synthetic */:
                if (scope === void 0 || scope === null) {
                    throw new Error(`Scope is null or undefined`);
                }
                if (!this.hasLockedScope) {
                    this.scope = scope;
                }
                break;
        }
        if (this.isStrictBinding) {
            flags |= 4 /* isStrictBindingStrategy */;
        }
        this.$initiator = initiator;
        this.$flags = flags;
        // opposing leave is called in attach() (which will trigger attached())
        this.enterActivating();
        if (this.hooks.hasBinding) {
            if (this.debug) {
                this.logger.trace(`binding()`);
            }
            const ret = this.viewModel.binding(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                ret.then(() => {
                    this.bind();
                }).catch(err => {
                    this.reject(err);
                });
                return this.$promise;
            }
        }
        this.bind();
        return this.$promise;
    }
    bind() {
        if (this.debug) {
            this.logger.trace(`bind()`);
        }
        if (this.bindings !== null) {
            for (let i = 0; i < this.bindings.length; ++i) {
                this.bindings[i].$bind(this.$flags, this.scope, this.hostScope);
            }
        }
        if (this.hooks.hasBound) {
            if (this.debug) {
                this.logger.trace(`bound()`);
            }
            const ret = this.viewModel.bound(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                ret.then(() => {
                    this.attach();
                }).catch(err => {
                    this.reject(err);
                });
                return;
            }
        }
        this.attach();
    }
    append(...nodes) {
        switch (this.mountTarget) {
            case 1 /* host */:
                this.host.append(...nodes);
                break;
            case 2 /* shadowRoot */:
                this.shadowRoot.append(...nodes);
                break;
            case 3 /* location */:
                for (let i = 0; i < nodes.length; ++i) {
                    this.location.parentNode.insertBefore(nodes[i], this.location);
                }
                break;
        }
    }
    attach() {
        if (this.debug) {
            this.logger.trace(`attach()`);
        }
        if (this.hostController !== null) {
            switch (this.mountTarget) {
                case 1 /* host */:
                case 2 /* shadowRoot */:
                    this.hostController.append(this.host);
                    break;
                case 3 /* location */:
                    this.hostController.append(this.location.$start, this.location);
                    break;
            }
        }
        switch (this.mountTarget) {
            case 1 /* host */:
                this.nodes.appendTo(this.host, this.definition?.enhance);
                break;
            case 2 /* shadowRoot */: {
                const styles = this.context.has(_styles_js__WEBPACK_IMPORTED_MODULE_10__.IShadowDOMStyles, false)
                    ? this.context.get(_styles_js__WEBPACK_IMPORTED_MODULE_10__.IShadowDOMStyles)
                    : this.context.get(_styles_js__WEBPACK_IMPORTED_MODULE_10__.IShadowDOMGlobalStyles);
                styles.applyTo(this.shadowRoot);
                this.nodes.appendTo(this.shadowRoot);
                break;
            }
            case 3 /* location */:
                this.nodes.insertBefore(this.location);
                break;
        }
        if (this.hooks.hasAttaching) {
            if (this.debug) {
                this.logger.trace(`attaching()`);
            }
            const ret = this.viewModel.attaching(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                this.enterActivating();
                ret.then(() => {
                    this.leaveActivating();
                }).catch(err => {
                    this.reject(err);
                });
            }
        }
        // attaching() and child activation run in parallel, and attached() is called when both are finished
        if (this.children !== null) {
            for (let i = 0; i < this.children.length; ++i) {
                // Any promises returned from child activation are cumulatively awaited before this.$promise resolves
                void this.children[i].activate(this.$initiator, this, this.$flags, this.scope, this.hostScope);
            }
        }
        // attached() is invoked by Controller#leaveActivating when `activatingStack` reaches 0
        this.leaveActivating();
    }
    deactivate(initiator, parent, flags) {
        switch ((this.state & ~16 /* released */)) {
            case 2 /* activated */:
                // We're fully activated, so proceed with normal deactivation.
                this.state = 4 /* deactivating */;
                break;
            case 0 /* none */:
            case 8 /* deactivated */:
            case 32 /* disposed */:
            case 8 /* deactivated */ | 32 /* disposed */:
                // If we're already deactivated (or even disposed), or never activated in the first place, no need to do anything.
                return;
            default:
                throw new Error(`${this.name} unexpected state: ${stringifyState(this.state)}.`);
        }
        if (this.debug) {
            this.logger.trace(`deactivate()`);
        }
        this.$initiator = initiator;
        this.$flags = flags;
        if (initiator === this) {
            this.enterDetaching();
        }
        if (this.children !== null) {
            for (let i = 0; i < this.children.length; ++i) {
                // Child promise results are tracked by enter/leave combo's
                void this.children[i].deactivate(initiator, this, flags);
            }
        }
        if (this.hooks.hasDetaching) {
            if (this.debug) {
                this.logger.trace(`detaching()`);
            }
            const ret = this.viewModel.detaching(this.$initiator, this.parent, this.$flags);
            if (ret instanceof Promise) {
                this.ensurePromise();
                initiator.enterDetaching();
                ret.then(() => {
                    initiator.leaveDetaching();
                }).catch(err => {
                    initiator.reject(err);
                });
            }
        }
        // Note: if a 3rd party plugin happens to do any async stuff in a template controller before calling deactivate on its view,
        // then the linking will become out of order.
        // For framework components, this shouldn't cause issues.
        // We can only prevent that by linking up after awaiting the detaching promise, which would add an extra tick + a fair bit of
        // overhead on this hot path, so it's (for now) a deliberate choice to not account for such situation.
        // Just leaving the note here so that we know to look here if a weird detaching-related timing issue is ever reported.
        if (initiator.head === null) {
            initiator.head = this;
        }
        else {
            initiator.tail.next = this;
        }
        initiator.tail = this;
        if (initiator !== this) {
            // Only detaching is called + the linked list is built when any controller that is not the initiator, is deactivated.
            // The rest is handled by the initiator.
            // This means that descendant controllers have to make sure to await the initiator's promise before doing any subsequent
            // controller api calls, or race conditions might occur.
            return;
        }
        this.leaveDetaching();
        return this.$promise;
    }
    removeNodes() {
        switch (this.vmKind) {
            case 0 /* customElement */:
            case 2 /* synthetic */:
                this.nodes.remove();
                this.nodes.unlink();
        }
        if (this.hostController !== null) {
            switch (this.mountTarget) {
                case 1 /* host */:
                case 2 /* shadowRoot */:
                    this.host.remove();
                    break;
                case 3 /* location */:
                    this.location.$start.remove();
                    this.location.remove();
                    break;
            }
        }
    }
    unbind() {
        if (this.debug) {
            this.logger.trace(`unbind()`);
        }
        const flags = this.$flags | 64 /* fromUnbind */;
        if (this.bindings !== null) {
            for (let i = 0; i < this.bindings.length; ++i) {
                this.bindings[i].$unbind(flags);
            }
        }
        this.parent = null;
        switch (this.vmKind) {
            case 1 /* customAttribute */:
                this.scope = null;
                break;
            case 2 /* synthetic */:
                if (!this.hasLockedScope) {
                    this.scope = null;
                }
                if ((this.state & 16 /* released */) === 16 /* released */ &&
                    !this.viewFactory.tryReturnToCache(this)) {
                    this.dispose();
                }
                break;
            case 0 /* customElement */:
                this.scope.parentScope = null;
                break;
        }
        if ((flags & 512 /* dispose */) === 512 /* dispose */) {
            this.dispose();
        }
        this.state = (this.state & 32 /* disposed */) | 8 /* deactivated */;
        this.$initiator = null;
        this.resolve();
    }
    ensurePromise() {
        if (this.$promise === void 0) {
            this.$promise = new Promise((resolve, reject) => {
                this.$resolve = resolve;
                this.$reject = reject;
            });
            if (this.$initiator !== this) {
                this.parent.ensurePromise();
            }
        }
    }
    resolve() {
        if (this.$promise !== void 0) {
            const resolve = this.$resolve;
            this.$resolve = this.$reject = this.$promise = void 0;
            resolve();
        }
    }
    reject(err) {
        if (this.$promise !== void 0) {
            const reject = this.$reject;
            this.$resolve = this.$reject = this.$promise = void 0;
            reject(err);
        }
        if (this.$initiator !== this) {
            this.parent.reject(err);
        }
    }
    enterActivating() {
        ++this.activatingStack;
        if (this.$initiator !== this) {
            this.parent.enterActivating();
        }
    }
    leaveActivating() {
        if (--this.activatingStack === 0) {
            if (this.hooks.hasAttached) {
                if (this.debug) {
                    this.logger.trace(`attached()`);
                }
                const ret = this.viewModel.attached(this.$initiator, this.$flags);
                if (ret instanceof Promise) {
                    this.ensurePromise();
                    ret.then(() => {
                        this.state = 2 /* activated */;
                        // Resolve this.$promise, signaling that activation is done (path 1 of 2)
                        this.resolve();
                        if (this.$initiator !== this) {
                            this.parent.leaveActivating();
                        }
                    }).catch(err => {
                        this.reject(err);
                    });
                    return;
                }
            }
            this.state = 2 /* activated */;
            // Resolve this.$promise (if present), signaling that activation is done (path 2 of 2)
            this.resolve();
        }
        if (this.$initiator !== this) {
            this.parent.leaveActivating();
        }
    }
    enterDetaching() {
        ++this.detachingStack;
    }
    leaveDetaching() {
        if (--this.detachingStack === 0) {
            // Note: this controller is the initiator (detach is only ever called on the initiator)
            if (this.debug) {
                this.logger.trace(`detach()`);
            }
            this.enterUnbinding();
            this.removeNodes();
            let cur = this.$initiator.head;
            while (cur !== null) {
                if (cur !== this) {
                    if (cur.debug) {
                        cur.logger.trace(`detach()`);
                    }
                    cur.removeNodes();
                }
                if (cur.hooks.hasUnbinding) {
                    if (cur.debug) {
                        cur.logger.trace('unbinding()');
                    }
                    const ret = cur.viewModel.unbinding(cur.$initiator, cur.parent, cur.$flags);
                    if (ret instanceof Promise) {
                        this.ensurePromise();
                        this.enterUnbinding();
                        ret.then(() => {
                            this.leaveUnbinding();
                        }).catch(err => {
                            this.reject(err);
                        });
                    }
                }
                cur = cur.next;
            }
            this.leaveUnbinding();
        }
    }
    enterUnbinding() {
        ++this.unbindingStack;
    }
    leaveUnbinding() {
        if (--this.unbindingStack === 0) {
            if (this.debug) {
                this.logger.trace(`unbind()`);
            }
            let cur = this.$initiator.head;
            let next = null;
            while (cur !== null) {
                if (cur !== this) {
                    cur.unbind();
                }
                next = cur.next;
                cur.next = null;
                cur = next;
            }
            this.head = this.tail = null;
            this.unbind();
        }
    }
    addBinding(binding) {
        if (this.bindings === null) {
            this.bindings = [binding];
        }
        else {
            this.bindings[this.bindings.length] = binding;
        }
    }
    addController(controller) {
        if (this.children === null) {
            this.children = [controller];
        }
        else {
            this.children[this.children.length] = controller;
        }
    }
    is(name) {
        switch (this.vmKind) {
            case 1 /* customAttribute */: {
                const def = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttribute.getDefinition(this.viewModel.constructor);
                return def.name === name;
            }
            case 0 /* customElement */: {
                const def = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.getDefinition(this.viewModel.constructor);
                return def.name === name;
            }
            case 2 /* synthetic */:
                return this.viewFactory.name === name;
        }
    }
    lockScope(scope) {
        this.scope = scope;
        this.hasLockedScope = true;
    }
    setHost(host) {
        if (this.vmKind === 0 /* customElement */) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, host);
        }
        this.host = host;
        this.mountTarget = 1 /* host */;
        return this;
    }
    setShadowRoot(shadowRoot) {
        if (this.vmKind === 0 /* customElement */) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, shadowRoot);
        }
        this.shadowRoot = shadowRoot;
        this.mountTarget = 2 /* shadowRoot */;
        return this;
    }
    setLocation(location) {
        if (this.vmKind === 0 /* customElement */) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.name, this, location);
        }
        this.location = location;
        this.mountTarget = 3 /* location */;
        return this;
    }
    release() {
        this.state |= 16 /* released */;
    }
    dispose() {
        if (this.debug) {
            this.logger.trace(`dispose()`);
        }
        if ((this.state & 32 /* disposed */) === 32 /* disposed */) {
            return;
        }
        this.state |= 32 /* disposed */;
        if (this.hooks.hasDispose) {
            this.viewModel.dispose();
        }
        if (this.children !== null) {
            this.children.forEach(callDispose);
            this.children = null;
        }
        this.hostController = null;
        this.scope = null;
        this.nodes = null;
        this.context = null;
        this.location = null;
        this.viewFactory = null;
        if (this.viewModel !== null) {
            controllerLookup.delete(this.viewModel);
            this.viewModel = null;
        }
        this.viewModel = null;
        this.host = null;
        this.shadowRoot = null;
        this.root = null;
    }
    accept(visitor) {
        if (visitor(this) === true) {
            return true;
        }
        if (this.hooks.hasAccept && this.viewModel.accept(visitor) === true) {
            return true;
        }
        if (this.children !== null) {
            const { children } = this;
            for (let i = 0, ii = children.length; i < ii; ++i) {
                if (children[i].accept(visitor) === true) {
                    return true;
                }
            }
        }
    }
    getTargetAccessor(propertyName) {
        const { bindings } = this;
        if (bindings !== null) {
            const binding = bindings.find(b => b.targetProperty === propertyName);
            if (binding !== void 0) {
                return binding.targetObserver;
            }
        }
        return void 0;
    }
}
function getLookup(instance) {
    let lookup = instance.$observers;
    if (lookup === void 0) {
        Reflect.defineProperty(instance, '$observers', {
            enumerable: false,
            value: lookup = {},
        });
    }
    return lookup;
}
function createObservers(controller, definition, 
// deepscan-disable-next-line
_flags, instance) {
    const bindables = definition.bindables;
    const observableNames = Object.getOwnPropertyNames(bindables);
    const length = observableNames.length;
    if (length > 0) {
        let name;
        let bindable;
        const observers = getLookup(instance);
        for (let i = 0; i < length; ++i) {
            name = observableNames[i];
            if (observers[name] === void 0) {
                bindable = bindables[name];
                observers[name] = new _observation_bindable_observer_js__WEBPACK_IMPORTED_MODULE_2__.BindableObserver(instance, name, bindable.callback, bindable.set, controller);
            }
        }
    }
}
function createChildrenObservers(controller, definition, 
// deepscan-disable-next-line
_flags, instance) {
    const childrenObservers = definition.childrenObservers;
    const childObserverNames = Object.getOwnPropertyNames(childrenObservers);
    const length = childObserverNames.length;
    if (length > 0) {
        const observers = getLookup(instance);
        let name;
        for (let i = 0; i < length; ++i) {
            name = childObserverNames[i];
            if (observers[name] == void 0) {
                const childrenDescription = childrenObservers[name];
                observers[name] = new _children_js__WEBPACK_IMPORTED_MODULE_7__.ChildrenObserver(controller, instance, name, childrenDescription.callback, childrenDescription.query, childrenDescription.filter, childrenDescription.map, childrenDescription.options);
            }
        }
    }
}
const AccessScopeAst = {
    map: new Map(),
    for(key) {
        let ast = AccessScopeAst.map.get(key);
        if (ast == null) {
            ast = new _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.AccessScopeExpression(key, 0);
            AccessScopeAst.map.set(key, ast);
        }
        return ast;
    },
};
function createWatchers(controller, context, definition, instance) {
    const observerLocator = context.get(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator);
    const expressionParser = context.get(_aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.IExpressionParser);
    const watches = definition.watches;
    let expression;
    let callback;
    for (let i = 0, ii = watches.length; ii > i; ++i) {
        ({ expression, callback } = watches[i]);
        callback = typeof callback === 'function'
            ? callback
            : Reflect.get(instance, callback);
        if (typeof callback !== 'function') {
            throw new Error(`Invalid callback for @watch decorator: ${String(callback)}`);
        }
        if (typeof expression === 'function') {
            controller.addBinding(new _watchers_js__WEBPACK_IMPORTED_MODULE_11__.ComputedWatcher(instance, observerLocator, expression, callback, 
            // there should be a flag to purposely disable proxy
            // AOT: not true for IE11
            true));
        }
        else {
            const ast = typeof expression === 'string'
                ? expressionParser.parse(expression, 53 /* BindCommand */)
                : AccessScopeAst.for(expression);
            controller.addBinding(new _watchers_js__WEBPACK_IMPORTED_MODULE_11__.ExpressionWatcher(controller.scope, context, observerLocator, ast, callback));
        }
    }
}
function isCustomElementController(value) {
    return value instanceof Controller && value.vmKind === 0 /* customElement */;
}
function isCustomElementViewModel(value) {
    return (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_4__.CustomElement.isType(value.constructor);
}
class HooksDefinition {
    constructor(target) {
        this.hasDefine = 'define' in target;
        this.hasHydrating = 'hydrating' in target;
        this.hasHydrated = 'hydrated' in target;
        this.hasCreated = 'created' in target;
        this.hasBinding = 'binding' in target;
        this.hasBound = 'bound' in target;
        this.hasAttaching = 'attaching' in target;
        this.hasAttached = 'attached' in target;
        this.hasDetaching = 'detaching' in target;
        this.hasUnbinding = 'unbinding' in target;
        this.hasDispose = 'dispose' in target;
        this.hasAccept = 'accept' in target;
    }
}
HooksDefinition.none = new HooksDefinition({});
const defaultShadowOptions = {
    mode: 'open'
};
var ViewModelKind;
(function (ViewModelKind) {
    ViewModelKind[ViewModelKind["customElement"] = 0] = "customElement";
    ViewModelKind[ViewModelKind["customAttribute"] = 1] = "customAttribute";
    ViewModelKind[ViewModelKind["synthetic"] = 2] = "synthetic";
})(ViewModelKind || (ViewModelKind = {}));
var State;
(function (State) {
    State[State["none"] = 0] = "none";
    State[State["activating"] = 1] = "activating";
    State[State["activated"] = 2] = "activated";
    State[State["deactivating"] = 4] = "deactivating";
    State[State["deactivated"] = 8] = "deactivated";
    State[State["released"] = 16] = "released";
    State[State["disposed"] = 32] = "disposed";
})(State || (State = {}));
function stringifyState(state) {
    const names = [];
    if ((state & 1 /* activating */) === 1 /* activating */) {
        names.push('activating');
    }
    if ((state & 2 /* activated */) === 2 /* activated */) {
        names.push('activated');
    }
    if ((state & 4 /* deactivating */) === 4 /* deactivating */) {
        names.push('deactivating');
    }
    if ((state & 8 /* deactivated */) === 8 /* deactivated */) {
        names.push('deactivated');
    }
    if ((state & 16 /* released */) === 16 /* released */) {
        names.push('released');
    }
    if ((state & 32 /* disposed */) === 32 /* disposed */) {
        names.push('disposed');
    }
    return names.length === 0 ? 'none' : names.join('|');
}
const IController = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IController');
//# sourceMappingURL=controller.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/render-context.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isRenderContext": () => /* binding */ isRenderContext,
/* harmony export */   "getRenderContext": () => /* binding */ getRenderContext,
/* harmony export */   "RenderContext": () => /* binding */ RenderContext,
/* harmony export */   "ViewFactoryProvider": () => /* binding */ ViewFactoryProvider
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer.js */ "./node_modules/@aurelia/runtime-html/dist/esm/renderer.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js");
/* harmony import */ var _resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../resources/custom-elements/au-slot.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-elements/au-slot.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _controller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");








const definitionContainerLookup = new WeakMap();
const definitionContainerProjectionsLookup = new WeakMap();
const fragmentCache = new WeakMap();
function isRenderContext(value) {
    return value instanceof RenderContext;
}
function getRenderContext(partialDefinition, parentContainer, projections) {
    const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_3__.CustomElementDefinition.getOrCreate(partialDefinition);
    // injectable completely prevents caching, ensuring that each instance gets a new context context
    if (definition.injectable !== null) {
        return new RenderContext(definition, parentContainer);
    }
    if (projections == null) {
        let containerLookup = definitionContainerLookup.get(definition);
        if (containerLookup === void 0) {
            definitionContainerLookup.set(definition, containerLookup = new WeakMap());
        }
        let context = containerLookup.get(parentContainer);
        if (context === void 0) {
            containerLookup.set(parentContainer, context = new RenderContext(definition, parentContainer));
        }
        return context;
    }
    let containerProjectionsLookup = definitionContainerProjectionsLookup.get(definition);
    if (containerProjectionsLookup === void 0) {
        definitionContainerProjectionsLookup.set(definition, containerProjectionsLookup = new WeakMap());
    }
    let projectionsLookup = containerProjectionsLookup.get(parentContainer);
    if (projectionsLookup === void 0) {
        containerProjectionsLookup.set(parentContainer, projectionsLookup = new WeakMap());
    }
    let context = projectionsLookup.get(projections);
    if (context === void 0) {
        projectionsLookup.set(projections, context = new RenderContext(definition, parentContainer));
    }
    return context;
}
const emptyNodeCache = new WeakMap();
class RenderContext {
    constructor(definition, parentContainer) {
        this.definition = definition;
        this.parentContainer = parentContainer;
        this.viewModelProvider = void 0;
        this.fragment = null;
        this.factory = void 0;
        this.isCompiled = false;
        this.renderers = Object.create(null);
        this.compiledDefinition = (void 0);
        const container = this.container = parentContainer.createChild();
        // TODO(fkleuver): get contextual + root renderers
        const renderers = container.getAll(_renderer_js__WEBPACK_IMPORTED_MODULE_2__.IRenderer);
        for (let i = 0; i < renderers.length; ++i) {
            const renderer = renderers[i];
            this.renderers[renderer.instructionType] = renderer;
        }
        this.projectionProvider = container.get(_resources_custom_elements_au_slot_js__WEBPACK_IMPORTED_MODULE_5__.IProjectionProvider);
        const p = this.platform = container.get(_platform_js__WEBPACK_IMPORTED_MODULE_6__.IPlatform);
        container.registerResolver(_view_js__WEBPACK_IMPORTED_MODULE_4__.IViewFactory, this.factoryProvider = new ViewFactoryProvider(), true);
        container.registerResolver(_controller_js__WEBPACK_IMPORTED_MODULE_7__.IController, this.parentControllerProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IController'), true);
        container.registerResolver(_renderer_js__WEBPACK_IMPORTED_MODULE_2__.IInstruction, this.instructionProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IInstruction'), true);
        container.registerResolver(_dom_js__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation, this.renderLocationProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('IRenderLocation'), true);
        const ep = this.elementProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('ElementResolver');
        container.registerResolver(_dom_js__WEBPACK_IMPORTED_MODULE_1__.INode, ep);
        container.registerResolver(p.Node, ep);
        container.registerResolver(p.Element, ep);
        container.registerResolver(p.HTMLElement, ep);
        container.register(...definition.dependencies);
    }
    // #region IServiceLocator api
    has(key, searchAncestors) {
        return this.container.has(key, searchAncestors);
    }
    get(key) {
        return this.container.get(key);
    }
    getAll(key) {
        return this.container.getAll(key);
    }
    // #endregion
    // #region IContainer api
    register(...params) {
        return this.container.register(...params);
    }
    registerResolver(key, resolver) {
        return this.container.registerResolver(key, resolver);
    }
    // public deregisterResolverFor<K extends Key, T = K>(key: K): void {
    //   this.container.deregisterResolverFor(key);
    // }
    registerTransformer(key, transformer) {
        return this.container.registerTransformer(key, transformer);
    }
    getResolver(key, autoRegister) {
        return this.container.getResolver(key, autoRegister);
    }
    getFactory(key) {
        return this.container.getFactory(key);
    }
    registerFactory(key, factory) {
        this.container.registerFactory(key, factory);
    }
    createChild() {
        return this.container.createChild();
    }
    find(kind, name) {
        return this.container.find(kind, name);
    }
    create(kind, name) {
        return this.container.create(kind, name);
    }
    disposeResolvers() {
        this.container.disposeResolvers();
    }
    // #endregion
    // #region IRenderContext api
    compile(targetedProjections) {
        let compiledDefinition;
        if (this.isCompiled) {
            return this;
        }
        this.isCompiled = true;
        const definition = this.definition;
        if (definition.needsCompile) {
            const container = this.container;
            const compiler = container.get(_renderer_js__WEBPACK_IMPORTED_MODULE_2__.ITemplateCompiler);
            compiledDefinition = this.compiledDefinition = compiler.compile(definition, container, targetedProjections);
        }
        else {
            compiledDefinition = this.compiledDefinition = definition;
        }
        // Support Recursive Components by adding self to own context
        compiledDefinition.register(this);
        if (fragmentCache.has(compiledDefinition)) {
            this.fragment = fragmentCache.get(compiledDefinition);
        }
        else {
            const doc = this.platform.document;
            const template = compiledDefinition.template;
            if (template === null || this.definition.enhance === true) {
                this.fragment = null;
            }
            else if (template instanceof this.platform.Node) {
                if (template.nodeName === 'TEMPLATE') {
                    this.fragment = doc.adoptNode(template.content);
                }
                else {
                    (this.fragment = doc.adoptNode(doc.createDocumentFragment())).appendChild(template);
                }
            }
            else {
                const tpl = doc.createElement('template');
                doc.adoptNode(tpl.content);
                if (typeof template === 'string') {
                    tpl.innerHTML = template;
                }
                this.fragment = tpl.content;
            }
            fragmentCache.set(compiledDefinition, this.fragment);
        }
        return this;
    }
    getViewFactory(name, contentType, projectionScope) {
        let factory = this.factory;
        if (factory === void 0) {
            if (name === void 0) {
                name = this.definition.name;
            }
            factory = this.factory = new _view_js__WEBPACK_IMPORTED_MODULE_4__.ViewFactory(name, this, contentType, projectionScope);
        }
        return factory;
    }
    beginChildComponentOperation(instance) {
        const definition = this.definition;
        if (definition.injectable !== null) {
            if (this.viewModelProvider === void 0) {
                this.container.registerResolver(definition.injectable, this.viewModelProvider = new _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider('definition.injectable'));
            }
            this.viewModelProvider.prepare(instance);
        }
        return this;
    }
    // #endregion
    // #region ICompiledRenderContext api
    createNodes() {
        if (this.compiledDefinition.enhance === true) {
            return new _dom_js__WEBPACK_IMPORTED_MODULE_1__.FragmentNodeSequence(this.platform, this.compiledDefinition.template);
        }
        if (this.fragment === null) {
            let emptyNodes = emptyNodeCache.get(this.platform);
            if (emptyNodes === void 0) {
                emptyNodeCache.set(this.platform, emptyNodes = new _dom_js__WEBPACK_IMPORTED_MODULE_1__.FragmentNodeSequence(this.platform, this.platform.document.createDocumentFragment()));
            }
            return emptyNodes;
        }
        return new _dom_js__WEBPACK_IMPORTED_MODULE_1__.FragmentNodeSequence(this.platform, this.fragment.cloneNode(true));
    }
    // TODO: split up into 2 methods? getComponentFactory + getSyntheticFactory or something
    getComponentFactory(parentController, host, instruction, viewFactory, location) {
        if (parentController !== void 0) {
            this.parentControllerProvider.prepare(parentController);
        }
        if (host !== void 0) {
            // TODO: fix provider input type, Key is probably not a good constraint
            this.elementProvider.prepare(host);
        }
        if (instruction !== void 0) {
            this.instructionProvider.prepare(instruction);
        }
        if (location !== void 0) {
            this.renderLocationProvider.prepare(location);
        }
        if (viewFactory !== void 0) {
            this.factoryProvider.prepare(viewFactory);
        }
        return this;
    }
    // #endregion
    // #region IComponentFactory api
    createComponent(resourceKey) {
        return this.container.get(resourceKey);
    }
    render(flags, controller, targets, definition, host) {
        if (targets.length !== definition.instructions.length) {
            throw new Error(`The compiled template is not aligned with the render instructions. There are ${targets.length} targets and ${definition.instructions.length} instructions.`);
        }
        for (let i = 0; i < targets.length; ++i) {
            this.renderChildren(
            /* flags        */ flags, 
            /* instructions */ definition.instructions[i], 
            /* controller   */ controller, 
            /* target       */ targets[i]);
        }
        if (host !== void 0 && host !== null) {
            this.renderChildren(
            /* flags        */ flags, 
            /* instructions */ definition.surrogates, 
            /* controller   */ controller, 
            /* target       */ host);
        }
    }
    renderChildren(flags, instructions, controller, target) {
        for (let i = 0; i < instructions.length; ++i) {
            const current = instructions[i];
            this.renderers[current.type].render(flags, this, controller, target, current);
        }
    }
    dispose() {
        this.elementProvider.dispose();
    }
    // #endregion
    // #region IProjectionProvider api
    registerProjections(projections, scope) {
        this.projectionProvider.registerProjections(projections, scope);
    }
    getProjectionFor(instruction) {
        return this.projectionProvider.getProjectionFor(instruction);
    }
}
/** @internal */
class ViewFactoryProvider {
    constructor() {
        this.factory = null;
    }
    prepare(factory) {
        this.factory = factory;
    }
    get $isResolver() { return true; }
    resolve(_handler, _requestor) {
        const factory = this.factory;
        if (factory === null) {
            throw new Error('Cannot resolve ViewFactory before the provider was prepared.');
        }
        if (typeof factory.name !== 'string' || factory.name.length === 0) {
            throw new Error('Cannot resolve ViewFactory without a (valid) name.');
        }
        return factory;
    }
    dispose() {
        this.factory = null;
    }
}
//# sourceMappingURL=render-context.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/styles.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cssModules": () => /* binding */ cssModules,
/* harmony export */   "CSSModulesProcessorRegistry": () => /* binding */ CSSModulesProcessorRegistry,
/* harmony export */   "shadowCSS": () => /* binding */ shadowCSS,
/* harmony export */   "IShadowDOMStyleFactory": () => /* binding */ IShadowDOMStyleFactory,
/* harmony export */   "ShadowDOMRegistry": () => /* binding */ ShadowDOMRegistry,
/* harmony export */   "IShadowDOMStyles": () => /* binding */ IShadowDOMStyles,
/* harmony export */   "IShadowDOMGlobalStyles": () => /* binding */ IShadowDOMGlobalStyles,
/* harmony export */   "AdoptedStyleSheetsStyles": () => /* binding */ AdoptedStyleSheetsStyles,
/* harmony export */   "StyleElementStyles": () => /* binding */ StyleElementStyles,
/* harmony export */   "StyleConfiguration": () => /* binding */ StyleConfiguration
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _app_task_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app-task.js */ "./node_modules/@aurelia/runtime-html/dist/esm/app-task.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/@aurelia/runtime-html/dist/esm/dom.js");
/* harmony import */ var _observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observation/class-attribute-accessor.js */ "./node_modules/@aurelia/runtime-html/dist/esm/observation/class-attribute-accessor.js");
/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../platform.js */ "./node_modules/@aurelia/runtime-html/dist/esm/platform.js");
/* harmony import */ var _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../resources/custom-attribute.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-attribute.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};






function cssModules(...modules) {
    return new CSSModulesProcessorRegistry(modules);
}
class CSSModulesProcessorRegistry {
    constructor(modules) {
        this.modules = modules;
    }
    register(container) {
        var _a;
        const classLookup = Object.assign({}, ...this.modules);
        const ClassCustomAttribute = _resources_custom_attribute_js__WEBPACK_IMPORTED_MODULE_5__.CustomAttribute.define({
            name: 'class',
            bindables: ['value'],
        }, (_a = class CustomAttributeClass {
                constructor(element) {
                    this.element = element;
                }
                binding() {
                    this.valueChanged();
                }
                valueChanged() {
                    if (!this.value) {
                        this.element.className = '';
                        return;
                    }
                    this.element.className = (0,_observation_class_attribute_accessor_js__WEBPACK_IMPORTED_MODULE_3__.getClassesToAdd)(this.value).map(x => classLookup[x] || x).join(' ');
                }
            },
            _a.inject = [_dom_js__WEBPACK_IMPORTED_MODULE_2__.INode],
            _a));
        container.register(ClassCustomAttribute);
    }
}
function shadowCSS(...css) {
    return new ShadowDOMRegistry(css);
}
const IShadowDOMStyleFactory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IShadowDOMStyleFactory', x => x.cachedCallback(handler => {
    if (AdoptedStyleSheetsStyles.supported(handler.get(_platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform))) {
        return handler.get(AdoptedStyleSheetsStylesFactory);
    }
    return handler.get(StyleElementStylesFactory);
}));
class ShadowDOMRegistry {
    constructor(css) {
        this.css = css;
    }
    register(container) {
        const sharedStyles = container.get(IShadowDOMGlobalStyles);
        const factory = container.get(IShadowDOMStyleFactory);
        container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IShadowDOMStyles, factory.createStyles(this.css, sharedStyles)));
    }
}
let AdoptedStyleSheetsStylesFactory = class AdoptedStyleSheetsStylesFactory {
    constructor(p) {
        this.p = p;
        this.cache = new Map();
    }
    createStyles(localStyles, sharedStyles) {
        return new AdoptedStyleSheetsStyles(this.p, localStyles, this.cache, sharedStyles);
    }
};
AdoptedStyleSheetsStylesFactory = __decorate([
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform)
], AdoptedStyleSheetsStylesFactory);
let StyleElementStylesFactory = class StyleElementStylesFactory {
    constructor(p) {
        this.p = p;
    }
    createStyles(localStyles, sharedStyles) {
        return new StyleElementStyles(this.p, localStyles, sharedStyles);
    }
};
StyleElementStylesFactory = __decorate([
    __param(0, _platform_js__WEBPACK_IMPORTED_MODULE_4__.IPlatform)
], StyleElementStylesFactory);
const IShadowDOMStyles = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IShadowDOMStyles');
const IShadowDOMGlobalStyles = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IShadowDOMGlobalStyles', x => x.instance({ applyTo: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop }));
class AdoptedStyleSheetsStyles {
    constructor(p, localStyles, styleSheetCache, sharedStyles = null) {
        this.sharedStyles = sharedStyles;
        this.styleSheets = localStyles.map(x => {
            let sheet;
            if (x instanceof p.CSSStyleSheet) {
                sheet = x;
            }
            else {
                sheet = styleSheetCache.get(x);
                if (sheet === void 0) {
                    sheet = new p.CSSStyleSheet();
                    sheet.replaceSync(x);
                    styleSheetCache.set(x, sheet);
                }
            }
            return sheet;
        });
    }
    static supported(p) {
        return 'adoptedStyleSheets' in p.ShadowRoot.prototype;
    }
    applyTo(shadowRoot) {
        if (this.sharedStyles !== null) {
            this.sharedStyles.applyTo(shadowRoot);
        }
        // https://wicg.github.io/construct-stylesheets/
        // https://developers.google.com/web/updates/2019/02/constructable-stylesheets
        shadowRoot.adoptedStyleSheets = [
            ...shadowRoot.adoptedStyleSheets,
            ...this.styleSheets
        ];
    }
}
class StyleElementStyles {
    constructor(p, localStyles, sharedStyles = null) {
        this.p = p;
        this.localStyles = localStyles;
        this.sharedStyles = sharedStyles;
    }
    applyTo(shadowRoot) {
        const styles = this.localStyles;
        const p = this.p;
        for (let i = styles.length - 1; i > -1; --i) {
            const element = p.document.createElement('style');
            element.innerHTML = styles[i];
            shadowRoot.prepend(element);
        }
        if (this.sharedStyles !== null) {
            this.sharedStyles.applyTo(shadowRoot);
        }
    }
}
const StyleConfiguration = {
    shadowDOM(config) {
        return _app_task_js__WEBPACK_IMPORTED_MODULE_1__.AppTask.with(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer).beforeCreate().call(container => {
            if (config.sharedStyles != null) {
                const factory = container.get(IShadowDOMStyleFactory);
                container.register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(IShadowDOMGlobalStyles, factory.createStyles(config.sharedStyles, null)));
            }
        });
    }
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/view.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IViewFactory": () => /* binding */ IViewFactory,
/* harmony export */   "ViewFactory": () => /* binding */ ViewFactory,
/* harmony export */   "Views": () => /* binding */ Views,
/* harmony export */   "view": () => /* binding */ view,
/* harmony export */   "IViewLocator": () => /* binding */ IViewLocator,
/* harmony export */   "ViewLocator": () => /* binding */ ViewLocator
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");
/* harmony import */ var _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/custom-element.js */ "./node_modules/@aurelia/runtime-html/dist/esm/resources/custom-element.js");
/* harmony import */ var _controller_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controller.js */ "./node_modules/@aurelia/runtime-html/dist/esm/templating/controller.js");




const IViewFactory = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IViewFactory');
class ViewFactory {
    constructor(name, context, contentType, projectionScope = null) {
        this.name = name;
        this.context = context;
        this.contentType = contentType;
        this.projectionScope = projectionScope;
        this.isCaching = false;
        this.cache = null;
        this.cacheSize = -1;
    }
    setCacheSize(size, doNotOverrideIfAlreadySet) {
        if (size) {
            if (size === '*') {
                size = ViewFactory.maxCacheSize;
            }
            else if (typeof size === 'string') {
                size = parseInt(size, 10);
            }
            if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
                this.cacheSize = size;
            }
        }
        if (this.cacheSize > 0) {
            this.cache = [];
        }
        else {
            this.cache = null;
        }
        this.isCaching = this.cacheSize > 0;
    }
    canReturnToCache(controller) {
        return this.cache != null && this.cache.length < this.cacheSize;
    }
    tryReturnToCache(controller) {
        if (this.canReturnToCache(controller)) {
            this.cache.push(controller);
            return true;
        }
        return false;
    }
    create(flags, parentController) {
        const cache = this.cache;
        let controller;
        if (cache != null && cache.length > 0) {
            controller = cache.pop();
            return controller;
        }
        controller = _controller_js__WEBPACK_IMPORTED_MODULE_3__.Controller.forSyntheticView(null, this.context, this, flags, parentController);
        return controller;
    }
}
ViewFactory.maxCacheSize = 0xFFFF;
const seenViews = new WeakSet();
function notYetSeen($view) {
    return !seenViews.has($view);
}
function toCustomElementDefinition($view) {
    seenViews.add($view);
    return _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElementDefinition.create($view);
}
const Views = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('views'),
    has(value) {
        return typeof value === 'function' && (_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(Views.name, value) || '$views' in value);
    },
    get(value) {
        if (typeof value === 'function' && '$views' in value) {
            // TODO: a `get` operation with side effects is not a good thing. Should refactor this to a proper resource kind.
            const $views = value.$views;
            const definitions = $views.filter(notYetSeen).map(toCustomElementDefinition);
            for (const def of definitions) {
                Views.add(value, def);
            }
        }
        let views = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Views.name, value);
        if (views === void 0) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Views.name, views = [], value);
        }
        return views;
    },
    add(Type, partialDefinition) {
        const definition = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElementDefinition.create(partialDefinition);
        let views = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Views.name, Type);
        if (views === void 0) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Views.name, views = [definition], Type);
        }
        else {
            views.push(definition);
        }
        return views;
    },
};
function view(v) {
    return function (target) {
        Views.add(target, v);
    };
}
const IViewLocator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IViewLocator', x => x.singleton(ViewLocator));
class ViewLocator {
    constructor() {
        this.modelInstanceToBoundComponent = new WeakMap();
        this.modelTypeToUnboundComponent = new Map();
    }
    getViewComponentForObject(object, viewNameOrSelector) {
        if (object) {
            const availableViews = Views.has(object.constructor) ? Views.get(object.constructor) : [];
            const resolvedViewName = typeof viewNameOrSelector === 'function'
                ? viewNameOrSelector(object, availableViews)
                : this.getViewName(availableViews, viewNameOrSelector);
            return this.getOrCreateBoundComponent(object, availableViews, resolvedViewName);
        }
        return null;
    }
    getOrCreateBoundComponent(object, availableViews, resolvedViewName) {
        let lookup = this.modelInstanceToBoundComponent.get(object);
        let BoundComponent;
        if (lookup === void 0) {
            lookup = {};
            this.modelInstanceToBoundComponent.set(object, lookup);
        }
        else {
            BoundComponent = lookup[resolvedViewName];
        }
        if (BoundComponent === void 0) {
            const UnboundComponent = this.getOrCreateUnboundComponent(object, availableViews, resolvedViewName);
            BoundComponent = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.define(_resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.getDefinition(UnboundComponent), class extends UnboundComponent {
                constructor() {
                    super(object);
                }
            });
            lookup[resolvedViewName] = BoundComponent;
        }
        return BoundComponent;
    }
    getOrCreateUnboundComponent(object, availableViews, resolvedViewName) {
        let lookup = this.modelTypeToUnboundComponent.get(object.constructor);
        let UnboundComponent;
        if (lookup === void 0) {
            lookup = {};
            this.modelTypeToUnboundComponent.set(object.constructor, lookup);
        }
        else {
            UnboundComponent = lookup[resolvedViewName];
        }
        if (UnboundComponent === void 0) {
            UnboundComponent = _resources_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.CustomElement.define(this.getView(availableViews, resolvedViewName), class {
                constructor(viewModel) {
                    this.viewModel = viewModel;
                }
                define(controller, parentContainer, definition) {
                    const vm = this.viewModel;
                    controller.scope = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_1__.Scope.fromParent(controller.scope, vm);
                    if (vm.define !== void 0) {
                        return vm.define(controller, parentContainer, definition);
                    }
                }
            });
            const proto = UnboundComponent.prototype;
            if ('hydrating' in object) {
                proto.hydrating = function hydrating(controller) {
                    this.viewModel.hydrating(controller);
                };
            }
            if ('hydrated' in object) {
                proto.hydrated = function hydrated(controller) {
                    this.viewModel.hydrated(controller);
                };
            }
            if ('created' in object) {
                proto.created = function created(controller) {
                    this.viewModel.created(controller);
                };
            }
            if ('binding' in object) {
                proto.binding = function binding(initiator, parent, flags) {
                    return this.viewModel.binding(initiator, parent, flags);
                };
            }
            if ('bound' in object) {
                proto.bound = function bound(initiator, parent, flags) {
                    return this.viewModel.bound(initiator, parent, flags);
                };
            }
            if ('attaching' in object) {
                proto.attaching = function attaching(initiator, parent, flags) {
                    return this.viewModel.attaching(initiator, parent, flags);
                };
            }
            if ('attached' in object) {
                proto.attached = function attached(initiator, flags) {
                    return this.viewModel.attached(initiator, flags);
                };
            }
            if ('detaching' in object) {
                proto.detaching = function detaching(initiator, parent, flags) {
                    return this.viewModel.detaching(initiator, parent, flags);
                };
            }
            if ('unbinding' in object) {
                proto.unbinding = function unbinding(initiator, parent, flags) {
                    return this.viewModel.unbinding(initiator, parent, flags);
                };
            }
            if ('dispose' in object) {
                proto.dispose = function dispose() {
                    this.viewModel.dispose();
                };
            }
            lookup[resolvedViewName] = UnboundComponent;
        }
        return UnboundComponent;
    }
    getViewName(views, requestedName) {
        if (requestedName) {
            return requestedName;
        }
        if (views.length === 1) {
            return views[0].name;
        }
        return 'default-view';
    }
    getView(views, name) {
        const v = views.find(x => x.name === name);
        if (v === void 0) {
            throw new Error(`Could not find view: ${name}`);
        }
        return v;
    }
}
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/templating/watchers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComputedWatcher": () => /* binding */ ComputedWatcher,
/* harmony export */   "ExpressionWatcher": () => /* binding */ ExpressionWatcher
/* harmony export */ });
/* harmony import */ var _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime */ "./node_modules/@aurelia/runtime/dist/esm/index.js");

const { enter, exit } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.ConnectableSwitcher;
const { wrap, unwrap } = _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.ProxyObservable;
class ComputedWatcher {
    constructor(obj, observerLocator, get, cb, useProxy) {
        this.obj = obj;
        this.observerLocator = observerLocator;
        this.get = get;
        this.cb = cb;
        this.useProxy = useProxy;
        this.interceptor = this;
        this.value = void 0;
        this.isBound = false;
        // todo: maybe use a counter allow recursive call to a certain level
        this.running = false;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    handleChange() {
        this.run();
    }
    handleCollectionChange() {
        this.run();
    }
    $bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        this.compute();
    }
    $unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.obs.clear(true);
    }
    run() {
        if (!this.isBound || this.running) {
            return;
        }
        const obj = this.obj;
        const oldValue = this.value;
        const newValue = this.compute();
        if (!Object.is(newValue, oldValue)) {
            // should optionally queue
            this.cb.call(obj, newValue, oldValue, obj);
        }
    }
    compute() {
        this.running = true;
        this.obs.version++;
        try {
            enter(this);
            return this.value = unwrap(this.get.call(void 0, this.useProxy ? wrap(this.obj) : this.obj, this));
        }
        finally {
            this.obs.clear(false);
            this.running = false;
            exit(this);
        }
    }
}
class ExpressionWatcher {
    constructor(scope, locator, observerLocator, expression, callback) {
        this.scope = scope;
        this.locator = locator;
        this.observerLocator = observerLocator;
        this.expression = expression;
        this.callback = callback;
        this.interceptor = this;
        this.isBound = false;
        this.obj = scope.bindingContext;
        _aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable.assignIdTo(this);
    }
    handleChange(value) {
        const expr = this.expression;
        const obj = this.obj;
        const oldValue = this.value;
        const canOptimize = expr.$kind === 10082 /* AccessScope */ && this.obs.count === 1;
        if (!canOptimize) {
            this.obs.version++;
            value = expr.evaluate(0, this.scope, null, this.locator, this);
            this.obs.clear(false);
        }
        if (!Object.is(value, oldValue)) {
            this.value = value;
            // should optionally queue for batch synchronous
            this.callback.call(obj, value, oldValue, obj);
        }
    }
    $bind() {
        if (this.isBound) {
            return;
        }
        this.isBound = true;
        this.obs.version++;
        this.value = this.expression.evaluate(0 /* none */, this.scope, null, this.locator, this);
        this.obs.clear(false);
    }
    $unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.obs.clear(true);
        this.value = void 0;
    }
}
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(ComputedWatcher);
(0,_aurelia_runtime__WEBPACK_IMPORTED_MODULE_0__.connectable)(ExpressionWatcher);
//# sourceMappingURL=watchers.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime-html/dist/esm/watch.js":
/*!**************************************************************!*\
  !*** ./node_modules/@aurelia/runtime-html/dist/esm/watch.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "watch": () => /* binding */ watch,
/* harmony export */   "Watch": () => /* binding */ Watch
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

function watch(expressionOrPropertyAccessFn, changeHandlerOrCallback) {
    if (!expressionOrPropertyAccessFn) {
        throw new Error('Invalid watch config. Expected an expression or a fn');
    }
    return function decorator(target, key, descriptor) {
        const isClassDecorator = key == null;
        const Type = isClassDecorator ? target : target.constructor;
        // basic validation
        if (isClassDecorator) {
            if (typeof changeHandlerOrCallback !== 'function'
                && (changeHandlerOrCallback == null || !(changeHandlerOrCallback in Type.prototype))) {
                throw new Error(`Invalid change handler config. Method "${String(changeHandlerOrCallback)}" not found in class ${Type.name}`);
            }
        }
        else if (typeof descriptor?.value !== 'function') {
            throw new Error(`decorated target ${String(key)} is not a class method.`);
        }
        Watch.add(Type, new WatchDefinition(expressionOrPropertyAccessFn, isClassDecorator ? changeHandlerOrCallback : descriptor.value));
    };
}
class WatchDefinition {
    constructor(expression, callback) {
        this.expression = expression;
        this.callback = callback;
    }
}
const noDefinitions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray;
const Watch = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('watch'),
    add(Type, definition) {
        let watchDefinitions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Watch.name, Type);
        if (watchDefinitions == null) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(Watch.name, watchDefinitions = [], Type);
        }
        watchDefinitions.push(definition);
    },
    getAnnotation(Type) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(Watch.name, Type) ?? noDefinitions;
    },
};
//# sourceMappingURL=watch.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/alias.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/alias.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alias": () => /* binding */ alias,
/* harmony export */   "registerAliases": () => /* binding */ registerAliases
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

function alias(...aliases) {
    return function (target) {
        const key = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor('aliases');
        const existing = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(key, target);
        if (existing === void 0) {
            _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(key, aliases, target);
        }
        else {
            existing.push(...aliases);
        }
    };
}
function registerAliases(aliases, resource, key, container) {
    for (let i = 0, ii = aliases.length; i < ii; ++i) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, resource.keyFrom(aliases[i])).register(container);
    }
}
//# sourceMappingURL=alias.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js":
/*!********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingBehaviorStrategy": () => /* binding */ BindingBehaviorStrategy,
/* harmony export */   "bindingBehavior": () => /* binding */ bindingBehavior,
/* harmony export */   "BindingBehaviorDefinition": () => /* binding */ BindingBehaviorDefinition,
/* harmony export */   "BindingBehaviorFactory": () => /* binding */ BindingBehaviorFactory,
/* harmony export */   "BindingInterceptor": () => /* binding */ BindingInterceptor,
/* harmony export */   "BindingBehavior": () => /* binding */ BindingBehavior
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _alias_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alias.js */ "./node_modules/@aurelia/runtime/dist/esm/alias.js");


var BindingBehaviorStrategy;
(function (BindingBehaviorStrategy) {
    BindingBehaviorStrategy[BindingBehaviorStrategy["singleton"] = 1] = "singleton";
    BindingBehaviorStrategy[BindingBehaviorStrategy["interceptor"] = 2] = "interceptor";
})(BindingBehaviorStrategy || (BindingBehaviorStrategy = {}));
function bindingBehavior(nameOrDef) {
    return function (target) {
        return BindingBehavior.define(nameOrDef, target);
    };
}
class BindingBehaviorDefinition {
    constructor(Type, name, aliases, key, strategy) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
        this.strategy = strategy;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        const inheritsFromInterceptor = Object.getPrototypeOf(Type) === BindingInterceptor;
        return new BindingBehaviorDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(BindingBehavior.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(BindingBehavior.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), BindingBehavior.keyFrom(name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.fromAnnotationOrDefinitionOrTypeOrDefault)('strategy', def, Type, () => inheritsFromInterceptor ? 2 /* interceptor */ : 1 /* singleton */));
    }
    register(container) {
        const { Type, key, aliases, strategy } = this;
        switch (strategy) {
            case 1 /* singleton */:
                _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(key, Type).register(container);
                break;
            case 2 /* interceptor */:
                _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(key, new BindingBehaviorFactory(container, Type)).register(container);
                break;
        }
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_alias_js__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, BindingBehavior, key, container);
    }
}
class BindingBehaviorFactory {
    constructor(container, Type) {
        this.container = container;
        this.Type = Type;
        this.deps = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.getDependencies(Type);
    }
    construct(binding, expr) {
        const container = this.container;
        const deps = this.deps;
        switch (deps.length) {
            case 0:
            case 1:
            case 2:
                // TODO(fkleuver): fix this cast
                return new this.Type(binding, expr);
            case 3:
                return new this.Type(container.get(deps[0]), binding, expr);
            case 4:
                return new this.Type(container.get(deps[0]), container.get(deps[1]), binding, expr);
            default:
                return new this.Type(...deps.map(d => container.get(d)), binding, expr);
        }
    }
}
class BindingInterceptor {
    constructor(binding, expr) {
        this.binding = binding;
        this.expr = expr;
        this.interceptor = this;
        let interceptor;
        while (binding.interceptor !== this) {
            interceptor = binding.interceptor;
            binding.interceptor = this;
            binding = interceptor;
        }
    }
    get id() {
        return this.binding.id;
    }
    get observerLocator() {
        return this.binding.observerLocator;
    }
    get locator() {
        return this.binding.locator;
    }
    get $scope() {
        return this.binding.$scope;
    }
    get $hostScope() {
        return this.binding.$hostScope;
    }
    get isBound() {
        return this.binding.isBound;
    }
    get obs() {
        return this.binding.obs;
    }
    updateTarget(value, flags) {
        this.binding.updateTarget(value, flags);
    }
    updateSource(value, flags) {
        this.binding.updateSource(value, flags);
    }
    callSource(args) {
        return this.binding.callSource(args);
    }
    handleChange(newValue, previousValue, flags) {
        this.binding.handleChange(newValue, previousValue, flags);
    }
    handleCollectionChange(indexMap, flags) {
        this.binding.handleCollectionChange(indexMap, flags);
    }
    observeProperty(obj, key) {
        this.binding.observeProperty(obj, key);
    }
    observeCollection(observer) {
        this.binding.observeCollection(observer);
    }
    $bind(flags, scope, hostScope) {
        this.binding.$bind(flags, scope, hostScope);
    }
    $unbind(flags) {
        this.binding.$unbind(flags);
    }
}
const BindingBehavior = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('binding-behavior'),
    keyFrom(name) {
        return `${BindingBehavior.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(BindingBehavior.name, value);
    },
    define(nameOrDef, Type) {
        const definition = BindingBehaviorDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingBehavior.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(BindingBehavior.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, BindingBehavior.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(BindingBehavior.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
//# sourceMappingURL=binding-behavior.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding/ast.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding/ast.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExpressionKind": () => /* binding */ ExpressionKind,
/* harmony export */   "Unparser": () => /* binding */ Unparser,
/* harmony export */   "CustomExpression": () => /* binding */ CustomExpression,
/* harmony export */   "BindingBehaviorExpression": () => /* binding */ BindingBehaviorExpression,
/* harmony export */   "ValueConverterExpression": () => /* binding */ ValueConverterExpression,
/* harmony export */   "AssignExpression": () => /* binding */ AssignExpression,
/* harmony export */   "ConditionalExpression": () => /* binding */ ConditionalExpression,
/* harmony export */   "AccessThisExpression": () => /* binding */ AccessThisExpression,
/* harmony export */   "AccessScopeExpression": () => /* binding */ AccessScopeExpression,
/* harmony export */   "AccessMemberExpression": () => /* binding */ AccessMemberExpression,
/* harmony export */   "AccessKeyedExpression": () => /* binding */ AccessKeyedExpression,
/* harmony export */   "CallScopeExpression": () => /* binding */ CallScopeExpression,
/* harmony export */   "CallMemberExpression": () => /* binding */ CallMemberExpression,
/* harmony export */   "CallFunctionExpression": () => /* binding */ CallFunctionExpression,
/* harmony export */   "BinaryExpression": () => /* binding */ BinaryExpression,
/* harmony export */   "UnaryExpression": () => /* binding */ UnaryExpression,
/* harmony export */   "PrimitiveLiteralExpression": () => /* binding */ PrimitiveLiteralExpression,
/* harmony export */   "HtmlLiteralExpression": () => /* binding */ HtmlLiteralExpression,
/* harmony export */   "ArrayLiteralExpression": () => /* binding */ ArrayLiteralExpression,
/* harmony export */   "ObjectLiteralExpression": () => /* binding */ ObjectLiteralExpression,
/* harmony export */   "TemplateExpression": () => /* binding */ TemplateExpression,
/* harmony export */   "TaggedTemplateExpression": () => /* binding */ TaggedTemplateExpression,
/* harmony export */   "ArrayBindingPattern": () => /* binding */ ArrayBindingPattern,
/* harmony export */   "ObjectBindingPattern": () => /* binding */ ObjectBindingPattern,
/* harmony export */   "BindingIdentifier": () => /* binding */ BindingIdentifier,
/* harmony export */   "ForOfStatement": () => /* binding */ ForOfStatement,
/* harmony export */   "Interpolation": () => /* binding */ Interpolation
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/binding-context.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js");
/* harmony import */ var _observation_signaler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observation/signaler.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js");
/* harmony import */ var _binding_behavior_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../binding-behavior.js */ "./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js");
/* harmony import */ var _value_converter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../value-converter.js */ "./node_modules/@aurelia/runtime/dist/esm/value-converter.js");
/* eslint-disable eqeqeq */
/* eslint-disable @typescript-eslint/restrict-template-expressions */





var ExpressionKind;
(function (ExpressionKind) {
    ExpressionKind[ExpressionKind["Connects"] = 32] = "Connects";
    ExpressionKind[ExpressionKind["Observes"] = 64] = "Observes";
    ExpressionKind[ExpressionKind["CallsFunction"] = 128] = "CallsFunction";
    ExpressionKind[ExpressionKind["HasAncestor"] = 256] = "HasAncestor";
    ExpressionKind[ExpressionKind["IsPrimary"] = 512] = "IsPrimary";
    ExpressionKind[ExpressionKind["IsLeftHandSide"] = 1024] = "IsLeftHandSide";
    ExpressionKind[ExpressionKind["HasBind"] = 2048] = "HasBind";
    ExpressionKind[ExpressionKind["HasUnbind"] = 4096] = "HasUnbind";
    ExpressionKind[ExpressionKind["IsAssignable"] = 8192] = "IsAssignable";
    ExpressionKind[ExpressionKind["IsLiteral"] = 16384] = "IsLiteral";
    ExpressionKind[ExpressionKind["IsResource"] = 32768] = "IsResource";
    ExpressionKind[ExpressionKind["IsForDeclaration"] = 65536] = "IsForDeclaration";
    ExpressionKind[ExpressionKind["Type"] = 31] = "Type";
    // ---------------------------------------------------------------------------------------------------------------------------
    ExpressionKind[ExpressionKind["AccessThis"] = 1793] = "AccessThis";
    ExpressionKind[ExpressionKind["AccessScope"] = 10082] = "AccessScope";
    ExpressionKind[ExpressionKind["ArrayLiteral"] = 17955] = "ArrayLiteral";
    ExpressionKind[ExpressionKind["ObjectLiteral"] = 17956] = "ObjectLiteral";
    ExpressionKind[ExpressionKind["PrimitiveLiteral"] = 17925] = "PrimitiveLiteral";
    ExpressionKind[ExpressionKind["Template"] = 17958] = "Template";
    ExpressionKind[ExpressionKind["Unary"] = 39] = "Unary";
    ExpressionKind[ExpressionKind["CallScope"] = 1448] = "CallScope";
    ExpressionKind[ExpressionKind["CallMember"] = 1161] = "CallMember";
    ExpressionKind[ExpressionKind["CallFunction"] = 1162] = "CallFunction";
    ExpressionKind[ExpressionKind["AccessMember"] = 9323] = "AccessMember";
    ExpressionKind[ExpressionKind["AccessKeyed"] = 9324] = "AccessKeyed";
    ExpressionKind[ExpressionKind["TaggedTemplate"] = 1197] = "TaggedTemplate";
    ExpressionKind[ExpressionKind["Binary"] = 46] = "Binary";
    ExpressionKind[ExpressionKind["Conditional"] = 63] = "Conditional";
    ExpressionKind[ExpressionKind["Assign"] = 8208] = "Assign";
    ExpressionKind[ExpressionKind["ValueConverter"] = 36913] = "ValueConverter";
    ExpressionKind[ExpressionKind["BindingBehavior"] = 38962] = "BindingBehavior";
    ExpressionKind[ExpressionKind["HtmlLiteral"] = 51] = "HtmlLiteral";
    ExpressionKind[ExpressionKind["ArrayBindingPattern"] = 65556] = "ArrayBindingPattern";
    ExpressionKind[ExpressionKind["ObjectBindingPattern"] = 65557] = "ObjectBindingPattern";
    ExpressionKind[ExpressionKind["BindingIdentifier"] = 65558] = "BindingIdentifier";
    ExpressionKind[ExpressionKind["ForOfStatement"] = 6199] = "ForOfStatement";
    ExpressionKind[ExpressionKind["Interpolation"] = 24] = "Interpolation"; //
})(ExpressionKind || (ExpressionKind = {}));
class Unparser {
    constructor() {
        this.text = '';
    }
    static unparse(expr) {
        const visitor = new Unparser();
        expr.accept(visitor);
        return visitor.text;
    }
    visitAccessMember(expr) {
        expr.object.accept(this);
        this.text += `.${expr.name}`;
    }
    visitAccessKeyed(expr) {
        expr.object.accept(this);
        this.text += '[';
        expr.key.accept(this);
        this.text += ']';
    }
    visitAccessThis(expr) {
        if (expr.ancestor === 0) {
            this.text += '$this';
            return;
        }
        this.text += '$parent';
        let i = expr.ancestor - 1;
        while (i--) {
            this.text += '.$parent';
        }
    }
    visitAccessScope(expr) {
        let i = expr.ancestor;
        while (i--) {
            this.text += '$parent.';
        }
        this.text += expr.name;
    }
    visitArrayLiteral(expr) {
        const elements = expr.elements;
        this.text += '[';
        for (let i = 0, length = elements.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            elements[i].accept(this);
        }
        this.text += ']';
    }
    visitObjectLiteral(expr) {
        const keys = expr.keys;
        const values = expr.values;
        this.text += '{';
        for (let i = 0, length = keys.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            this.text += `'${keys[i]}':`;
            values[i].accept(this);
        }
        this.text += '}';
    }
    visitPrimitiveLiteral(expr) {
        this.text += '(';
        if (typeof expr.value === 'string') {
            const escaped = expr.value.replace(/'/g, '\\\'');
            this.text += `'${escaped}'`;
        }
        else {
            this.text += `${expr.value}`;
        }
        this.text += ')';
    }
    visitCallFunction(expr) {
        this.text += '(';
        expr.func.accept(this);
        this.writeArgs(expr.args);
        this.text += ')';
    }
    visitCallMember(expr) {
        this.text += '(';
        expr.object.accept(this);
        this.text += `.${expr.name}`;
        this.writeArgs(expr.args);
        this.text += ')';
    }
    visitCallScope(expr) {
        this.text += '(';
        let i = expr.ancestor;
        while (i--) {
            this.text += '$parent.';
        }
        this.text += expr.name;
        this.writeArgs(expr.args);
        this.text += ')';
    }
    visitTemplate(expr) {
        const { cooked, expressions } = expr;
        const length = expressions.length;
        this.text += '`';
        this.text += cooked[0];
        for (let i = 0; i < length; i++) {
            expressions[i].accept(this);
            this.text += cooked[i + 1];
        }
        this.text += '`';
    }
    visitTaggedTemplate(expr) {
        const { cooked, expressions } = expr;
        const length = expressions.length;
        expr.func.accept(this);
        this.text += '`';
        this.text += cooked[0];
        for (let i = 0; i < length; i++) {
            expressions[i].accept(this);
            this.text += cooked[i + 1];
        }
        this.text += '`';
    }
    visitUnary(expr) {
        this.text += `(${expr.operation}`;
        if (expr.operation.charCodeAt(0) >= /* a */ 97) {
            this.text += ' ';
        }
        expr.expression.accept(this);
        this.text += ')';
    }
    visitBinary(expr) {
        this.text += '(';
        expr.left.accept(this);
        if (expr.operation.charCodeAt(0) === /* i */ 105) {
            this.text += ` ${expr.operation} `;
        }
        else {
            this.text += expr.operation;
        }
        expr.right.accept(this);
        this.text += ')';
    }
    visitConditional(expr) {
        this.text += '(';
        expr.condition.accept(this);
        this.text += '?';
        expr.yes.accept(this);
        this.text += ':';
        expr.no.accept(this);
        this.text += ')';
    }
    visitAssign(expr) {
        this.text += '(';
        expr.target.accept(this);
        this.text += '=';
        expr.value.accept(this);
        this.text += ')';
    }
    visitValueConverter(expr) {
        const args = expr.args;
        expr.expression.accept(this);
        this.text += `|${expr.name}`;
        for (let i = 0, length = args.length; i < length; ++i) {
            this.text += ':';
            args[i].accept(this);
        }
    }
    visitBindingBehavior(expr) {
        const args = expr.args;
        expr.expression.accept(this);
        this.text += `&${expr.name}`;
        for (let i = 0, length = args.length; i < length; ++i) {
            this.text += ':';
            args[i].accept(this);
        }
    }
    visitArrayBindingPattern(expr) {
        const elements = expr.elements;
        this.text += '[';
        for (let i = 0, length = elements.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            elements[i].accept(this);
        }
        this.text += ']';
    }
    visitObjectBindingPattern(expr) {
        const keys = expr.keys;
        const values = expr.values;
        this.text += '{';
        for (let i = 0, length = keys.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            this.text += `'${keys[i]}':`;
            values[i].accept(this);
        }
        this.text += '}';
    }
    visitBindingIdentifier(expr) {
        this.text += expr.name;
    }
    visitHtmlLiteral(expr) { throw new Error('visitHtmlLiteral'); }
    visitForOfStatement(expr) {
        expr.declaration.accept(this);
        this.text += ' of ';
        expr.iterable.accept(this);
    }
    visitInterpolation(expr) {
        const { parts, expressions } = expr;
        const length = expressions.length;
        this.text += '${';
        this.text += parts[0];
        for (let i = 0; i < length; i++) {
            expressions[i].accept(this);
            this.text += parts[i + 1];
        }
        this.text += '}';
    }
    writeArgs(args) {
        this.text += '(';
        for (let i = 0, length = args.length; i < length; ++i) {
            if (i !== 0) {
                this.text += ',';
            }
            args[i].accept(this);
        }
        this.text += ')';
    }
}
function chooseScope(accessHostScope, s, hs) {
    if (accessHostScope) {
        if (hs === null || hs === void 0) {
            throw new Error('Host scope is missing. Are you using `$host` outside the `au-slot`? Or missing the `au-slot` attribute?');
        }
        return hs;
    }
    return s;
}
class CustomExpression {
    constructor(value) {
        this.value = value;
    }
    evaluate(_f, _s, _hs, _l, _c) {
        return this.value;
    }
}
class BindingBehaviorExpression {
    constructor(expression, name, args) {
        this.expression = expression;
        this.name = name;
        this.args = args;
        this.behaviorKey = _binding_behavior_js__WEBPACK_IMPORTED_MODULE_3__.BindingBehavior.keyFrom(name);
    }
    get $kind() { return 38962 /* BindingBehavior */; }
    get hasBind() { return true; }
    get hasUnbind() { return true; }
    evaluate(f, s, hs, l, c) {
        return this.expression.evaluate(f, s, hs, l, c);
    }
    assign(f, s, hs, l, val) {
        return this.expression.assign(f, s, hs, l, val);
    }
    bind(f, s, hs, b) {
        if (this.expression.hasBind) {
            this.expression.bind(f, s, hs, b);
        }
        const behavior = b.locator.get(this.behaviorKey);
        if (behavior == null) {
            throw new Error(`BindingBehavior named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
        }
        if (!(behavior instanceof _binding_behavior_js__WEBPACK_IMPORTED_MODULE_3__.BindingBehaviorFactory)) {
            if (b[this.behaviorKey] === void 0) {
                b[this.behaviorKey] = behavior;
                behavior.bind.call(behavior, f, s, hs, b, ...this.args.map(a => a.evaluate(f, s, hs, b.locator, null)));
            }
            else {
                throw new Error(`BindingBehavior named '${this.name}' already applied.`);
            }
        }
    }
    unbind(f, s, hs, b) {
        const key = this.behaviorKey;
        const $b = b;
        if ($b[key] !== void 0) {
            if (typeof $b[key].unbind === 'function') {
                $b[key].unbind(f, s, hs, b);
            }
            $b[key] = void 0;
        }
        if (this.expression.hasUnbind) {
            this.expression.unbind(f, s, hs, b);
        }
    }
    accept(visitor) {
        return visitor.visitBindingBehavior(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ValueConverterExpression {
    constructor(expression, name, args) {
        this.expression = expression;
        this.name = name;
        this.args = args;
        this.converterKey = _value_converter_js__WEBPACK_IMPORTED_MODULE_4__.ValueConverter.keyFrom(name);
    }
    get $kind() { return 36913 /* ValueConverter */; }
    get hasBind() { return false; }
    get hasUnbind() { return true; }
    evaluate(f, s, hs, l, c) {
        const vc = l.get(this.converterKey);
        if (vc == null) {
            throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
        }
        // note: the cast is expected. To connect, it just needs to be a IConnectable
        // though to work with signal, it needs to have `handleChange`
        // so having `handleChange` as a guard in the connectable as a safe measure is needed
        // to make sure signaler works
        if (c !== null && ('handleChange' in c)) {
            const signals = vc.signals;
            if (signals != null) {
                const signaler = l.get(_observation_signaler_js__WEBPACK_IMPORTED_MODULE_2__.ISignaler);
                for (let i = 0, ii = signals.length; i < ii; ++i) {
                    signaler.addSignalListener(signals[i], c);
                }
            }
        }
        if ('toView' in vc) {
            return vc.toView(this.expression.evaluate(f, s, hs, l, c), ...this.args.map(a => a.evaluate(f, s, hs, l, c)));
        }
        return this.expression.evaluate(f, s, hs, l, c);
    }
    assign(f, s, hs, l, val) {
        const vc = l.get(this.converterKey);
        if (vc == null) {
            throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);
        }
        if ('fromView' in vc) {
            val = vc.fromView(val, ...this.args.map(a => a.evaluate(f, s, hs, l, null)));
        }
        return this.expression.assign(f, s, hs, l, val);
    }
    unbind(_f, _s, _hs, b) {
        const vc = b.locator.get(this.converterKey);
        if (vc.signals === void 0) {
            return;
        }
        const signaler = b.locator.get(_observation_signaler_js__WEBPACK_IMPORTED_MODULE_2__.ISignaler);
        for (let i = 0; i < vc.signals.length; ++i) {
            // the cast is correct, as the value converter expression would only add
            // a IConnectable that also implements `ISubscriber` interface to the signaler
            signaler.removeSignalListener(vc.signals[i], b);
        }
    }
    accept(visitor) {
        return visitor.visitValueConverter(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AssignExpression {
    constructor(target, value) {
        this.target = target;
        this.value = value;
    }
    get $kind() { return 8208 /* Assign */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.target.assign(f, s, hs, l, this.value.evaluate(f, s, hs, l, c));
    }
    assign(f, s, hs, l, val) {
        this.value.assign(f, s, hs, l, val);
        return this.target.assign(f, s, hs, l, val);
    }
    accept(visitor) {
        return visitor.visitAssign(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ConditionalExpression {
    constructor(condition, yes, no) {
        this.condition = condition;
        this.yes = yes;
        this.no = no;
    }
    get $kind() { return 63 /* Conditional */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.condition.evaluate(f, s, hs, l, c) ? this.yes.evaluate(f, s, hs, l, c) : this.no.evaluate(f, s, hs, l, c);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitConditional(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AccessThisExpression {
    constructor(ancestor = 0) {
        this.ancestor = ancestor;
    }
    get $kind() { return 1793 /* AccessThis */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, s, hs, _l, _c) {
        if (this === AccessThisExpression.$host) {
            s = chooseScope(true, s, hs);
        }
        let oc = s.overrideContext;
        let currentScope = s;
        let i = this.ancestor;
        while (i-- && oc) {
            currentScope = currentScope.parentScope;
            oc = currentScope?.overrideContext ?? null;
        }
        return i < 1 && oc ? oc.bindingContext : void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitAccessThis(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
AccessThisExpression.$this = new AccessThisExpression(0);
// $host and $this are loosely the same thing. $host is used in the context of `au-slot` with the primary objective of determining the s.
AccessThisExpression.$host = new AccessThisExpression(0);
AccessThisExpression.$parent = new AccessThisExpression(1);
class AccessScopeExpression {
    constructor(name, ancestor = 0, accessHostScope = false) {
        this.name = name;
        this.ancestor = ancestor;
        this.accessHostScope = accessHostScope;
    }
    get $kind() { return 10082 /* AccessScope */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, _l, c) {
        const obj = _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__.BindingContext.get(chooseScope(this.accessHostScope, s, hs), this.name, this.ancestor, f, hs);
        if (c !== null) {
            c.observeProperty(obj, this.name);
        }
        const evaluatedValue = obj[this.name];
        if (f & 4 /* isStrictBindingStrategy */) {
            return evaluatedValue;
        }
        return evaluatedValue == null ? '' : evaluatedValue;
    }
    assign(f, s, hs, _l, val) {
        const obj = _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__.BindingContext.get(chooseScope(this.accessHostScope, s, hs), this.name, this.ancestor, f, hs);
        if (obj instanceof Object) {
            if (obj.$observers?.[this.name] !== void 0) {
                obj.$observers[this.name].setValue(val, f);
                return val;
            }
            else {
                return obj[this.name] = val;
            }
        }
        return void 0;
    }
    accept(visitor) {
        return visitor.visitAccessScope(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AccessMemberExpression {
    constructor(object, name) {
        this.object = object;
        this.name = name;
    }
    get $kind() { return 9323 /* AccessMember */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = this.object.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
        if (f & 4 /* isStrictBindingStrategy */) {
            if (instance == null) {
                return instance;
            }
            if (c !== null) {
                c.observeProperty(instance, this.name);
            }
            return instance[this.name];
        }
        if (c !== null && instance instanceof Object) {
            c.observeProperty(instance, this.name);
        }
        return instance ? instance[this.name] : '';
    }
    assign(f, s, hs, l, val) {
        const obj = this.object.evaluate(f, s, hs, l, null);
        if (obj instanceof Object) {
            if (obj.$observers !== void 0 && obj.$observers[this.name] !== void 0) {
                obj.$observers[this.name].setValue(val, f);
            }
            else {
                obj[this.name] = val;
            }
        }
        else {
            this.object.assign(f, s, hs, l, { [this.name]: val });
        }
        return val;
    }
    accept(visitor) {
        return visitor.visitAccessMember(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class AccessKeyedExpression {
    constructor(object, key) {
        this.object = object;
        this.key = key;
    }
    get $kind() { return 9324 /* AccessKeyed */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = this.object.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
        if (instance instanceof Object) {
            const key = this.key.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
            if (c !== null) {
                c.observeProperty(instance, key);
            }
            return instance[key];
        }
        return void 0;
    }
    assign(f, s, hs, l, val) {
        const instance = this.object.evaluate(f, s, hs, l, null);
        const key = this.key.evaluate(f, s, hs, l, null);
        return instance[key] = val;
    }
    accept(visitor) {
        return visitor.visitAccessKeyed(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class CallScopeExpression {
    constructor(name, args, ancestor = 0, accessHostScope = false) {
        this.name = name;
        this.args = args;
        this.ancestor = ancestor;
        this.accessHostScope = accessHostScope;
    }
    get $kind() { return 1448 /* CallScope */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        s = chooseScope(this.accessHostScope, s, hs);
        const args = this.args.map(a => a.evaluate(f, s, hs, l, c));
        const context = _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_1__.BindingContext.get(s, this.name, this.ancestor, f, hs);
        // ideally, should observe property represents by this.name as well
        // because it could be changed
        // todo: did it ever surprise anyone?
        const func = getFunction(f, context, this.name);
        if (func) {
            return func.apply(context, args);
        }
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitCallScope(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class CallMemberExpression {
    constructor(object, name, args) {
        this.object = object;
        this.name = name;
        this.args = args;
    }
    get $kind() { return 1161 /* CallMember */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = this.object.evaluate(f, s, hs, l, (f & 2048 /* observeLeafPropertiesOnly */) > 0 ? null : c);
        const args = this.args.map(a => a.evaluate(f, s, hs, l, c));
        const func = getFunction(f, instance, this.name);
        if (func) {
            return func.apply(instance, args);
        }
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitCallMember(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class CallFunctionExpression {
    constructor(func, args) {
        this.func = func;
        this.args = args;
    }
    get $kind() { return 1162 /* CallFunction */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const func = this.func.evaluate(f, s, hs, l, c);
        if (typeof func === 'function') {
            return func(...this.args.map(a => a.evaluate(f, s, hs, l, c)));
        }
        if (!(f & 128 /* mustEvaluate */) && (func == null)) {
            return void 0;
        }
        throw new Error(`Expression is not a function.`);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitCallFunction(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class BinaryExpression {
    constructor(operation, left, right) {
        this.operation = operation;
        this.left = left;
        this.right = right;
    }
    get $kind() { return 46 /* Binary */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        switch (this.operation) {
            case '&&':
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                return this.left.evaluate(f, s, hs, l, c) && this.right.evaluate(f, s, hs, l, c);
            case '||':
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                return this.left.evaluate(f, s, hs, l, c) || this.right.evaluate(f, s, hs, l, c);
            case '==':
                return this.left.evaluate(f, s, hs, l, c) == this.right.evaluate(f, s, hs, l, c);
            case '===':
                return this.left.evaluate(f, s, hs, l, c) === this.right.evaluate(f, s, hs, l, c);
            case '!=':
                return this.left.evaluate(f, s, hs, l, c) != this.right.evaluate(f, s, hs, l, c);
            case '!==':
                return this.left.evaluate(f, s, hs, l, c) !== this.right.evaluate(f, s, hs, l, c);
            case 'instanceof': {
                const right = this.right.evaluate(f, s, hs, l, c);
                if (typeof right === 'function') {
                    return this.left.evaluate(f, s, hs, l, c) instanceof right;
                }
                return false;
            }
            case 'in': {
                const right = this.right.evaluate(f, s, hs, l, c);
                if (right instanceof Object) {
                    return this.left.evaluate(f, s, hs, l, c) in right;
                }
                return false;
            }
            // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar
            // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)
            // this makes bugs in user code easier to track down for end users
            // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code
            case '+': {
                const left = this.left.evaluate(f, s, hs, l, c);
                const right = this.right.evaluate(f, s, hs, l, c);
                if ((f & 4 /* isStrictBindingStrategy */) > 0) {
                    return left + right;
                }
                // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                if (!left || !right) {
                    if ((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isNumberOrBigInt)(left) || (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isNumberOrBigInt)(right)) {
                        return (left || 0) + (right || 0);
                    }
                    if ((0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isStringOrDate)(left) || (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isStringOrDate)(right)) {
                        return (left || '') + (right || '');
                    }
                }
                return left + right;
            }
            case '-':
                return this.left.evaluate(f, s, hs, l, c) - this.right.evaluate(f, s, hs, l, c);
            case '*':
                return this.left.evaluate(f, s, hs, l, c) * this.right.evaluate(f, s, hs, l, c);
            case '/':
                return this.left.evaluate(f, s, hs, l, c) / this.right.evaluate(f, s, hs, l, c);
            case '%':
                return this.left.evaluate(f, s, hs, l, c) % this.right.evaluate(f, s, hs, l, c);
            case '<':
                return this.left.evaluate(f, s, hs, l, c) < this.right.evaluate(f, s, hs, l, c);
            case '>':
                return this.left.evaluate(f, s, hs, l, c) > this.right.evaluate(f, s, hs, l, c);
            case '<=':
                return this.left.evaluate(f, s, hs, l, c) <= this.right.evaluate(f, s, hs, l, c);
            case '>=':
                return this.left.evaluate(f, s, hs, l, c) >= this.right.evaluate(f, s, hs, l, c);
            default:
                throw new Error(`Unknown binary operator: '${this.operation}'`);
        }
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitBinary(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class UnaryExpression {
    constructor(operation, expression) {
        this.operation = operation;
        this.expression = expression;
    }
    get $kind() { return 39 /* Unary */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        switch (this.operation) {
            case 'void':
                return void this.expression.evaluate(f, s, hs, l, c);
            case 'typeof':
                return typeof this.expression.evaluate(f | 4 /* isStrictBindingStrategy */, s, hs, l, c);
            case '!':
                return !this.expression.evaluate(f, s, hs, l, c);
            case '-':
                return -this.expression.evaluate(f, s, hs, l, c);
            case '+':
                return +this.expression.evaluate(f, s, hs, l, c);
            default:
                throw new Error(`Unknown unary operator: '${this.operation}'`);
        }
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitUnary(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class PrimitiveLiteralExpression {
    constructor(value) {
        this.value = value;
    }
    get $kind() { return 17925 /* PrimitiveLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        return this.value;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitPrimitiveLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
PrimitiveLiteralExpression.$undefined = new PrimitiveLiteralExpression(void 0);
PrimitiveLiteralExpression.$null = new PrimitiveLiteralExpression(null);
PrimitiveLiteralExpression.$true = new PrimitiveLiteralExpression(true);
PrimitiveLiteralExpression.$false = new PrimitiveLiteralExpression(false);
PrimitiveLiteralExpression.$empty = new PrimitiveLiteralExpression('');
class HtmlLiteralExpression {
    constructor(parts) {
        this.parts = parts;
    }
    get $kind() { return 51 /* HtmlLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        let result = '';
        for (let i = 0; i < this.parts.length; ++i) {
            const v = this.parts[i].evaluate(f, s, hs, l, c);
            if (v == null) {
                continue;
            }
            result += v;
        }
        return result;
    }
    assign(_f, _s, _hs, _l, _obj, _projection) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitHtmlLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ArrayLiteralExpression {
    constructor(elements) {
        this.elements = elements;
    }
    get $kind() { return 17955 /* ArrayLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.elements.map(e => e.evaluate(f, s, hs, l, c));
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitArrayLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
ArrayLiteralExpression.$empty = new ArrayLiteralExpression(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray);
class ObjectLiteralExpression {
    constructor(keys, values) {
        this.keys = keys;
        this.values = values;
    }
    get $kind() { return 17956 /* ObjectLiteral */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const instance = {};
        for (let i = 0; i < this.keys.length; ++i) {
            instance[this.keys[i]] = this.values[i].evaluate(f, s, hs, l, c);
        }
        return instance;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitObjectLiteral(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
ObjectLiteralExpression.$empty = new ObjectLiteralExpression(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray, _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray);
class TemplateExpression {
    constructor(cooked, expressions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        this.cooked = cooked;
        this.expressions = expressions;
    }
    get $kind() { return 17958 /* Template */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        let result = this.cooked[0];
        for (let i = 0; i < this.expressions.length; ++i) {
            result += String(this.expressions[i].evaluate(f, s, hs, l, c));
            result += this.cooked[i + 1];
        }
        return result;
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitTemplate(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
TemplateExpression.$empty = new TemplateExpression(['']);
class TaggedTemplateExpression {
    constructor(cooked, raw, func, expressions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        this.cooked = cooked;
        this.func = func;
        this.expressions = expressions;
        cooked.raw = raw;
    }
    get $kind() { return 1197 /* TaggedTemplate */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        const results = this.expressions.map(e => e.evaluate(f, s, hs, l, c));
        const func = this.func.evaluate(f, s, hs, l, c);
        if (typeof func !== 'function') {
            throw new Error(`Left-hand side of tagged template expression is not a function.`);
        }
        return func(this.cooked, ...results);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitTaggedTemplate(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ArrayBindingPattern {
    // We'll either have elements, or keys+values, but never all 3
    constructor(elements) {
        this.elements = elements;
    }
    get $kind() { return 65556 /* ArrayBindingPattern */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        // TODO: this should come after batch
        // as a destructuring expression like [x, y] = value
        //
        // should only trigger change only once:
        // batch(() => {
        //   object.x = value[0]
        //   object.y = value[1]
        // })
        //
        // instead of twice:
        // object.x = value[0]
        // object.y = value[1]
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        // TODO
        return void 0;
    }
    accept(visitor) {
        return visitor.visitArrayBindingPattern(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class ObjectBindingPattern {
    // We'll either have elements, or keys+values, but never all 3
    constructor(keys, values) {
        this.keys = keys;
        this.values = values;
    }
    get $kind() { return 65557 /* ObjectBindingPattern */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        // TODO
        // similar to array binding ast, this should only come after batch
        // for a single notification per destructing,
        // regardless number of property assignments on the scope binding context
        return void 0;
    }
    assign(_f, _s, _hs, _l, _obj) {
        // TODO
        return void 0;
    }
    accept(visitor) {
        return visitor.visitObjectBindingPattern(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
class BindingIdentifier {
    constructor(name) {
        this.name = name;
    }
    get $kind() { return 65558 /* BindingIdentifier */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(_f, _s, _hs, _l, _c) {
        return this.name;
    }
    accept(visitor) {
        return visitor.visitBindingIdentifier(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
const toStringTag = Object.prototype.toString;
// https://tc39.github.io/ecma262/#sec-iteration-statements
// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
class ForOfStatement {
    constructor(declaration, iterable) {
        this.declaration = declaration;
        this.iterable = iterable;
    }
    get $kind() { return 6199 /* ForOfStatement */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        return this.iterable.evaluate(f, s, hs, l, c);
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    count(_f, result) {
        switch (toStringTag.call(result)) {
            case '[object Array]': return result.length;
            case '[object Map]': return result.size;
            case '[object Set]': return result.size;
            case '[object Number]': return result;
            case '[object Null]': return 0;
            case '[object Undefined]': return 0;
            default: throw new Error(`Cannot count ${toStringTag.call(result)}`);
        }
    }
    // deepscan-disable-next-line
    iterate(f, result, func) {
        switch (toStringTag.call(result)) {
            case '[object Array]': return $array(result, func);
            case '[object Map]': return $map(result, func);
            case '[object Set]': return $set(result, func);
            case '[object Number]': return $number(result, func);
            case '[object Null]': return;
            case '[object Undefined]': return;
            default: throw new Error(`Cannot iterate over ${toStringTag.call(result)}`);
        }
    }
    bind(f, s, hs, b) {
        if (this.iterable.hasBind) {
            this.iterable.bind(f, s, hs, b);
        }
    }
    unbind(f, s, hs, b) {
        if (this.iterable.hasUnbind) {
            this.iterable.unbind(f, s, hs, b);
        }
    }
    accept(visitor) {
        return visitor.visitForOfStatement(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
/*
* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)
* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction
* but this class might be a candidate for removal if it turns out it does provide all we need
*/
class Interpolation {
    constructor(parts, expressions = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray) {
        this.parts = parts;
        this.expressions = expressions;
        this.isMulti = expressions.length > 1;
        this.firstExpression = expressions[0];
    }
    get $kind() { return 24 /* Interpolation */; }
    get hasBind() { return false; }
    get hasUnbind() { return false; }
    evaluate(f, s, hs, l, c) {
        if (this.isMulti) {
            let result = this.parts[0];
            for (let i = 0; i < this.expressions.length; ++i) {
                result += String(this.expressions[i].evaluate(f, s, hs, l, c));
                result += this.parts[i + 1];
            }
            return result;
        }
        else {
            return `${this.parts[0]}${this.firstExpression.evaluate(f, s, hs, l, c)}${this.parts[1]}`;
        }
    }
    assign(_f, _s, _hs, _l, _obj) {
        return void 0;
    }
    accept(visitor) {
        return visitor.visitInterpolation(this);
    }
    toString() {
        return Unparser.unparse(this);
    }
}
function getFunction(f, obj, name) {
    const func = obj == null ? null : obj[name];
    if (typeof func === 'function') {
        return func;
    }
    if (!(f & 128 /* mustEvaluate */) && func == null) {
        return null;
    }
    throw new Error(`Expected '${name}' to be a function`);
}
function $array(result, func) {
    for (let i = 0, ii = result.length; i < ii; ++i) {
        func(result, i, result[i]);
    }
}
function $map(result, func) {
    const arr = Array(result.size);
    let i = -1;
    for (const entry of result.entries()) {
        arr[++i] = entry;
    }
    $array(arr, func);
}
function $set(result, func) {
    const arr = Array(result.size);
    let i = -1;
    for (const key of result.keys()) {
        arr[++i] = key;
    }
    $array(arr, func);
}
function $number(result, func) {
    const arr = Array(result);
    for (let i = 0; i < result; ++i) {
        arr[i] = i;
    }
    $array(arr, func);
}
//# sourceMappingURL=ast.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingObserverRecord": () => /* binding */ BindingObserverRecord,
/* harmony export */   "connectable": () => /* binding */ connectable,
/* harmony export */   "BindingMediator": () => /* binding */ BindingMediator
/* harmony export */ });
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");
/* harmony import */ var _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observation/array-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js");
/* harmony import */ var _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observation/set-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js");
/* harmony import */ var _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observation/map-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js");




// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time
const slotNames = [];
const versionSlotNames = [];
let lastSlot = -1;
function ensureEnoughSlotNames(currentSlot) {
    if (currentSlot === lastSlot) {
        lastSlot += 5;
        const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;
        for (let i = currentSlot + 1; i < ii; ++i) {
            slotNames[i] = `_o${i}`;
            versionSlotNames[i] = `_v${i}`;
        }
    }
}
ensureEnoughSlotNames(-1);
function observeProperty(obj, key) {
    const observer = this.observerLocator.getObserver(obj, key);
    /* Note: we need to cast here because we can indeed get an accessor instead of an observer,
     *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:
     *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)
     *  2. Fail silently (without throwing): give all accessors a no-op subscribe method
     *
     * We'll probably want to implement some global configuration (like a "strict" toggle) so users can pick between enforced correctness vs. ease-of-use
     */
    this.obs.add(observer);
}
function getObserverRecord() {
    const record = new BindingObserverRecord(this);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.defineHiddenProp)(this, 'obs', record);
    return record;
}
function observeCollection(collection) {
    let obs;
    if (collection instanceof Array) {
        obs = (0,_observation_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(collection);
    }
    else if (collection instanceof Set) {
        obs = (0,_observation_set_observer_js__WEBPACK_IMPORTED_MODULE_2__.getSetObserver)(collection);
    }
    else if (collection instanceof Map) {
        obs = (0,_observation_map_observer_js__WEBPACK_IMPORTED_MODULE_3__.getMapObserver)(collection);
    }
    else {
        throw new Error('Unrecognised collection type.');
    }
    this.obs.add(obs);
}
function noopHandleChange() {
    throw new Error('method "handleChange" not implemented');
}
function noopHandleCollectionChange() {
    throw new Error('method "handleCollectionChange" not implemented');
}
class BindingObserverRecord {
    constructor(binding) {
        this.binding = binding;
        this.version = 0;
        this.count = 0;
        connectable.assignIdTo(this);
    }
    handleChange(value, oldValue, flags) {
        return this.binding.interceptor.handleChange(value, oldValue, flags);
    }
    handleCollectionChange(indexMap, flags) {
        this.binding.interceptor.handleCollectionChange(indexMap, flags);
    }
    /**
     * Add, and subscribe to a given observer
     */
    add(observer) {
        // find the observer.
        const observerSlots = this.count == null ? 0 : this.count;
        let i = observerSlots;
        while (i-- && this[slotNames[i]] !== observer)
            ;
        // if we are not already observing, put the observer in an open slot and subscribe.
        if (i === -1) {
            i = 0;
            while (this[slotNames[i]]) {
                i++;
            }
            this[slotNames[i]] = observer;
            observer.subscribe(this);
            observer[this.id] |= 8 /* updateTarget */;
            // increment the slot count.
            if (i === observerSlots) {
                this.count = i + 1;
            }
        }
        this[versionSlotNames[i]] = this.version;
        ensureEnoughSlotNames(i);
    }
    /**
     * Unsubscribe the observers that are not up to date with the record version
     */
    clear(all) {
        const slotCount = this.count;
        let slotName;
        let observer;
        let i = 0;
        if (all === true) {
            for (; i < slotCount; ++i) {
                slotName = slotNames[i];
                observer = this[slotName];
                if (observer != null) {
                    this[slotName] = void 0;
                    observer.unsubscribe(this);
                    observer[this.id] &= ~8 /* updateTarget */;
                }
            }
            this.count = 0;
        }
        else {
            for (; i < slotCount; ++i) {
                if (this[versionSlotNames[i]] !== this.version) {
                    slotName = slotNames[i];
                    observer = this[slotName];
                    if (observer != null) {
                        this[slotName] = void 0;
                        observer.unsubscribe(this);
                        observer[this.id] &= ~8 /* updateTarget */;
                        this.count--;
                    }
                }
            }
        }
    }
}
function connectableDecorator(target) {
    const proto = target.prototype;
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'observeProperty', observeProperty, true);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'observeCollection', observeCollection, true);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.def)(proto, 'obs', { get: getObserverRecord });
    // optionally add these two methods to normalize a connectable impl
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'handleChange', noopHandleChange);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'handleCollectionChange', noopHandleCollectionChange);
    return target;
}
function connectable(target) {
    return target == null ? connectableDecorator : connectableDecorator(target);
}
let idValue = 0;
connectable.assignIdTo = (instance) => {
    instance.id = ++idValue;
};
// @connectable
class BindingMediator {
    constructor(key, binding, observerLocator, locator) {
        this.key = key;
        this.binding = binding;
        this.observerLocator = observerLocator;
        this.locator = locator;
        this.interceptor = this;
        connectable.assignIdTo(this);
    }
    $bind(flags, scope, hostScope, projection) {
        throw new Error('Method not implemented.');
    }
    $unbind(flags) {
        throw new Error('Method not implemented.');
    }
    handleChange(newValue, previousValue, flags) {
        this.binding[this.key](newValue, previousValue, flags);
    }
}
connectableDecorator(BindingMediator);
//# sourceMappingURL=connectable.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/binding/expression-parser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/binding/expression-parser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IExpressionParser": () => /* binding */ IExpressionParser,
/* harmony export */   "ExpressionParser": () => /* binding */ ExpressionParser,
/* harmony export */   "Char": () => /* binding */ Char,
/* harmony export */   "Access": () => /* binding */ Access,
/* harmony export */   "Precedence": () => /* binding */ Precedence,
/* harmony export */   "BindingType": () => /* binding */ BindingType,
/* harmony export */   "ParserState": () => /* binding */ ParserState,
/* harmony export */   "parseExpression": () => /* binding */ parseExpression,
/* harmony export */   "parse": () => /* binding */ parse
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _ast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/ast.js");


const IExpressionParser = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IExpressionParser', x => x.singleton(ExpressionParser));
class ExpressionParser {
    constructor() {
        this.expressionLookup = Object.create(null);
        this.forOfLookup = Object.create(null);
        this.interpolationLookup = Object.create(null);
    }
    parse(expression, bindingType) {
        switch (bindingType) {
            case 2048 /* Interpolation */: {
                let found = this.interpolationLookup[expression];
                if (found === void 0) {
                    found = this.interpolationLookup[expression] = this.$parse(expression, bindingType);
                }
                return found;
            }
            case 539 /* ForCommand */: {
                let found = this.forOfLookup[expression];
                if (found === void 0) {
                    found = this.forOfLookup[expression] = this.$parse(expression, bindingType);
                }
                return found;
            }
            default: {
                // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)
                // But don't cache it, because empty strings are always invalid for any other type of binding
                if (expression.length === 0 && (bindingType & (53 /* BindCommand */ | 49 /* OneTimeCommand */ | 50 /* ToViewCommand */))) {
                    return _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$empty;
                }
                let found = this.expressionLookup[expression];
                if (found === void 0) {
                    found = this.expressionLookup[expression] = this.$parse(expression, bindingType);
                }
                return found;
            }
        }
    }
    $parse(expression, bindingType) {
        $state.input = expression;
        $state.length = expression.length;
        $state.index = 0;
        $state.currentChar = expression.charCodeAt(0);
        return parse($state, 0 /* Reset */, 61 /* Variadic */, bindingType === void 0 ? 53 /* BindCommand */ : bindingType);
    }
}
var Char;
(function (Char) {
    Char[Char["Null"] = 0] = "Null";
    Char[Char["Backspace"] = 8] = "Backspace";
    Char[Char["Tab"] = 9] = "Tab";
    Char[Char["LineFeed"] = 10] = "LineFeed";
    Char[Char["VerticalTab"] = 11] = "VerticalTab";
    Char[Char["FormFeed"] = 12] = "FormFeed";
    Char[Char["CarriageReturn"] = 13] = "CarriageReturn";
    Char[Char["Space"] = 32] = "Space";
    Char[Char["Exclamation"] = 33] = "Exclamation";
    Char[Char["DoubleQuote"] = 34] = "DoubleQuote";
    Char[Char["Dollar"] = 36] = "Dollar";
    Char[Char["Percent"] = 37] = "Percent";
    Char[Char["Ampersand"] = 38] = "Ampersand";
    Char[Char["SingleQuote"] = 39] = "SingleQuote";
    Char[Char["OpenParen"] = 40] = "OpenParen";
    Char[Char["CloseParen"] = 41] = "CloseParen";
    Char[Char["Asterisk"] = 42] = "Asterisk";
    Char[Char["Plus"] = 43] = "Plus";
    Char[Char["Comma"] = 44] = "Comma";
    Char[Char["Minus"] = 45] = "Minus";
    Char[Char["Dot"] = 46] = "Dot";
    Char[Char["Slash"] = 47] = "Slash";
    Char[Char["Semicolon"] = 59] = "Semicolon";
    Char[Char["Backtick"] = 96] = "Backtick";
    Char[Char["OpenBracket"] = 91] = "OpenBracket";
    Char[Char["Backslash"] = 92] = "Backslash";
    Char[Char["CloseBracket"] = 93] = "CloseBracket";
    Char[Char["Caret"] = 94] = "Caret";
    Char[Char["Underscore"] = 95] = "Underscore";
    Char[Char["OpenBrace"] = 123] = "OpenBrace";
    Char[Char["Bar"] = 124] = "Bar";
    Char[Char["CloseBrace"] = 125] = "CloseBrace";
    Char[Char["Colon"] = 58] = "Colon";
    Char[Char["LessThan"] = 60] = "LessThan";
    Char[Char["Equals"] = 61] = "Equals";
    Char[Char["GreaterThan"] = 62] = "GreaterThan";
    Char[Char["Question"] = 63] = "Question";
    Char[Char["Zero"] = 48] = "Zero";
    Char[Char["One"] = 49] = "One";
    Char[Char["Two"] = 50] = "Two";
    Char[Char["Three"] = 51] = "Three";
    Char[Char["Four"] = 52] = "Four";
    Char[Char["Five"] = 53] = "Five";
    Char[Char["Six"] = 54] = "Six";
    Char[Char["Seven"] = 55] = "Seven";
    Char[Char["Eight"] = 56] = "Eight";
    Char[Char["Nine"] = 57] = "Nine";
    Char[Char["UpperA"] = 65] = "UpperA";
    Char[Char["UpperB"] = 66] = "UpperB";
    Char[Char["UpperC"] = 67] = "UpperC";
    Char[Char["UpperD"] = 68] = "UpperD";
    Char[Char["UpperE"] = 69] = "UpperE";
    Char[Char["UpperF"] = 70] = "UpperF";
    Char[Char["UpperG"] = 71] = "UpperG";
    Char[Char["UpperH"] = 72] = "UpperH";
    Char[Char["UpperI"] = 73] = "UpperI";
    Char[Char["UpperJ"] = 74] = "UpperJ";
    Char[Char["UpperK"] = 75] = "UpperK";
    Char[Char["UpperL"] = 76] = "UpperL";
    Char[Char["UpperM"] = 77] = "UpperM";
    Char[Char["UpperN"] = 78] = "UpperN";
    Char[Char["UpperO"] = 79] = "UpperO";
    Char[Char["UpperP"] = 80] = "UpperP";
    Char[Char["UpperQ"] = 81] = "UpperQ";
    Char[Char["UpperR"] = 82] = "UpperR";
    Char[Char["UpperS"] = 83] = "UpperS";
    Char[Char["UpperT"] = 84] = "UpperT";
    Char[Char["UpperU"] = 85] = "UpperU";
    Char[Char["UpperV"] = 86] = "UpperV";
    Char[Char["UpperW"] = 87] = "UpperW";
    Char[Char["UpperX"] = 88] = "UpperX";
    Char[Char["UpperY"] = 89] = "UpperY";
    Char[Char["UpperZ"] = 90] = "UpperZ";
    Char[Char["LowerA"] = 97] = "LowerA";
    Char[Char["LowerB"] = 98] = "LowerB";
    Char[Char["LowerC"] = 99] = "LowerC";
    Char[Char["LowerD"] = 100] = "LowerD";
    Char[Char["LowerE"] = 101] = "LowerE";
    Char[Char["LowerF"] = 102] = "LowerF";
    Char[Char["LowerG"] = 103] = "LowerG";
    Char[Char["LowerH"] = 104] = "LowerH";
    Char[Char["LowerI"] = 105] = "LowerI";
    Char[Char["LowerJ"] = 106] = "LowerJ";
    Char[Char["LowerK"] = 107] = "LowerK";
    Char[Char["LowerL"] = 108] = "LowerL";
    Char[Char["LowerM"] = 109] = "LowerM";
    Char[Char["LowerN"] = 110] = "LowerN";
    Char[Char["LowerO"] = 111] = "LowerO";
    Char[Char["LowerP"] = 112] = "LowerP";
    Char[Char["LowerQ"] = 113] = "LowerQ";
    Char[Char["LowerR"] = 114] = "LowerR";
    Char[Char["LowerS"] = 115] = "LowerS";
    Char[Char["LowerT"] = 116] = "LowerT";
    Char[Char["LowerU"] = 117] = "LowerU";
    Char[Char["LowerV"] = 118] = "LowerV";
    Char[Char["LowerW"] = 119] = "LowerW";
    Char[Char["LowerX"] = 120] = "LowerX";
    Char[Char["LowerY"] = 121] = "LowerY";
    Char[Char["LowerZ"] = 122] = "LowerZ";
})(Char || (Char = {}));
function unescapeCode(code) {
    switch (code) {
        case 98 /* LowerB */: return 8 /* Backspace */;
        case 116 /* LowerT */: return 9 /* Tab */;
        case 110 /* LowerN */: return 10 /* LineFeed */;
        case 118 /* LowerV */: return 11 /* VerticalTab */;
        case 102 /* LowerF */: return 12 /* FormFeed */;
        case 114 /* LowerR */: return 13 /* CarriageReturn */;
        case 34 /* DoubleQuote */: return 34 /* DoubleQuote */;
        case 39 /* SingleQuote */: return 39 /* SingleQuote */;
        case 92 /* Backslash */: return 92 /* Backslash */;
        default: return code;
    }
}
var Access;
(function (Access) {
    Access[Access["Reset"] = 0] = "Reset";
    Access[Access["Ancestor"] = 511] = "Ancestor";
    Access[Access["This"] = 512] = "This";
    Access[Access["Scope"] = 1024] = "Scope";
    Access[Access["Member"] = 2048] = "Member";
    Access[Access["Keyed"] = 4096] = "Keyed";
})(Access || (Access = {}));
var Precedence;
(function (Precedence) {
    Precedence[Precedence["Variadic"] = 61] = "Variadic";
    Precedence[Precedence["Assign"] = 62] = "Assign";
    Precedence[Precedence["Conditional"] = 63] = "Conditional";
    Precedence[Precedence["LogicalOR"] = 64] = "LogicalOR";
    Precedence[Precedence["LogicalAND"] = 128] = "LogicalAND";
    Precedence[Precedence["Equality"] = 192] = "Equality";
    Precedence[Precedence["Relational"] = 256] = "Relational";
    Precedence[Precedence["Additive"] = 320] = "Additive";
    Precedence[Precedence["Multiplicative"] = 384] = "Multiplicative";
    Precedence[Precedence["Binary"] = 448] = "Binary";
    Precedence[Precedence["LeftHandSide"] = 449] = "LeftHandSide";
    Precedence[Precedence["Primary"] = 450] = "Primary";
    Precedence[Precedence["Unary"] = 451] = "Unary";
})(Precedence || (Precedence = {}));
var Token;
(function (Token) {
    Token[Token["EOF"] = 1572864] = "EOF";
    Token[Token["ExpressionTerminal"] = 1048576] = "ExpressionTerminal";
    Token[Token["AccessScopeTerminal"] = 524288] = "AccessScopeTerminal";
    Token[Token["ClosingToken"] = 262144] = "ClosingToken";
    Token[Token["OpeningToken"] = 131072] = "OpeningToken";
    Token[Token["BinaryOp"] = 65536] = "BinaryOp";
    Token[Token["UnaryOp"] = 32768] = "UnaryOp";
    Token[Token["LeftHandSide"] = 16384] = "LeftHandSide";
    Token[Token["StringOrNumericLiteral"] = 12288] = "StringOrNumericLiteral";
    Token[Token["NumericLiteral"] = 8192] = "NumericLiteral";
    Token[Token["StringLiteral"] = 4096] = "StringLiteral";
    Token[Token["IdentifierName"] = 3072] = "IdentifierName";
    Token[Token["Keyword"] = 2048] = "Keyword";
    Token[Token["Identifier"] = 1024] = "Identifier";
    Token[Token["Contextual"] = 512] = "Contextual";
    Token[Token["Precedence"] = 448] = "Precedence";
    Token[Token["Type"] = 63] = "Type";
    Token[Token["FalseKeyword"] = 2048] = "FalseKeyword";
    Token[Token["TrueKeyword"] = 2049] = "TrueKeyword";
    Token[Token["NullKeyword"] = 2050] = "NullKeyword";
    Token[Token["UndefinedKeyword"] = 2051] = "UndefinedKeyword";
    Token[Token["ThisScope"] = 3076] = "ThisScope";
    Token[Token["HostScope"] = 3077] = "HostScope";
    Token[Token["ParentScope"] = 3078] = "ParentScope";
    Token[Token["OpenParen"] = 671751] = "OpenParen";
    Token[Token["OpenBrace"] = 131080] = "OpenBrace";
    Token[Token["Dot"] = 16393] = "Dot";
    Token[Token["CloseBrace"] = 1835018] = "CloseBrace";
    Token[Token["CloseParen"] = 1835019] = "CloseParen";
    Token[Token["Comma"] = 1572876] = "Comma";
    Token[Token["OpenBracket"] = 671757] = "OpenBracket";
    Token[Token["CloseBracket"] = 1835022] = "CloseBracket";
    Token[Token["Colon"] = 1572879] = "Colon";
    Token[Token["Question"] = 1572880] = "Question";
    Token[Token["Ampersand"] = 1572883] = "Ampersand";
    Token[Token["Bar"] = 1572884] = "Bar";
    Token[Token["BarBar"] = 1638549] = "BarBar";
    Token[Token["AmpersandAmpersand"] = 1638614] = "AmpersandAmpersand";
    Token[Token["EqualsEquals"] = 1638679] = "EqualsEquals";
    Token[Token["ExclamationEquals"] = 1638680] = "ExclamationEquals";
    Token[Token["EqualsEqualsEquals"] = 1638681] = "EqualsEqualsEquals";
    Token[Token["ExclamationEqualsEquals"] = 1638682] = "ExclamationEqualsEquals";
    Token[Token["LessThan"] = 1638747] = "LessThan";
    Token[Token["GreaterThan"] = 1638748] = "GreaterThan";
    Token[Token["LessThanEquals"] = 1638749] = "LessThanEquals";
    Token[Token["GreaterThanEquals"] = 1638750] = "GreaterThanEquals";
    Token[Token["InKeyword"] = 1640799] = "InKeyword";
    Token[Token["InstanceOfKeyword"] = 1640800] = "InstanceOfKeyword";
    Token[Token["Plus"] = 623009] = "Plus";
    Token[Token["Minus"] = 623010] = "Minus";
    Token[Token["TypeofKeyword"] = 34851] = "TypeofKeyword";
    Token[Token["VoidKeyword"] = 34852] = "VoidKeyword";
    Token[Token["Asterisk"] = 1638885] = "Asterisk";
    Token[Token["Percent"] = 1638886] = "Percent";
    Token[Token["Slash"] = 1638887] = "Slash";
    Token[Token["Equals"] = 1048616] = "Equals";
    Token[Token["Exclamation"] = 32809] = "Exclamation";
    Token[Token["TemplateTail"] = 540714] = "TemplateTail";
    Token[Token["TemplateContinuation"] = 540715] = "TemplateContinuation";
    Token[Token["OfKeyword"] = 1051180] = "OfKeyword";
})(Token || (Token = {}));
const $false = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$false;
const $true = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$true;
const $null = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$null;
const $undefined = _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression.$undefined;
const $this = _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression.$this;
const $host = _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression.$host;
const $parent = _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression.$parent;
var BindingType;
(function (BindingType) {
    BindingType[BindingType["None"] = 0] = "None";
    BindingType[BindingType["IgnoreCustomAttr"] = 4096] = "IgnoreCustomAttr";
    BindingType[BindingType["Interpolation"] = 2048] = "Interpolation";
    BindingType[BindingType["IsRef"] = 5376] = "IsRef";
    BindingType[BindingType["IsIterator"] = 512] = "IsIterator";
    BindingType[BindingType["IsCustom"] = 256] = "IsCustom";
    BindingType[BindingType["IsFunction"] = 128] = "IsFunction";
    BindingType[BindingType["IsEvent"] = 64] = "IsEvent";
    BindingType[BindingType["IsProperty"] = 32] = "IsProperty";
    BindingType[BindingType["IsCommand"] = 16] = "IsCommand";
    BindingType[BindingType["IsPropertyCommand"] = 48] = "IsPropertyCommand";
    BindingType[BindingType["IsEventCommand"] = 80] = "IsEventCommand";
    BindingType[BindingType["DelegationStrategyDelta"] = 6] = "DelegationStrategyDelta";
    BindingType[BindingType["Command"] = 15] = "Command";
    BindingType[BindingType["OneTimeCommand"] = 49] = "OneTimeCommand";
    BindingType[BindingType["ToViewCommand"] = 50] = "ToViewCommand";
    BindingType[BindingType["FromViewCommand"] = 51] = "FromViewCommand";
    BindingType[BindingType["TwoWayCommand"] = 52] = "TwoWayCommand";
    BindingType[BindingType["BindCommand"] = 53] = "BindCommand";
    BindingType[BindingType["TriggerCommand"] = 4182] = "TriggerCommand";
    BindingType[BindingType["CaptureCommand"] = 4183] = "CaptureCommand";
    BindingType[BindingType["DelegateCommand"] = 4184] = "DelegateCommand";
    BindingType[BindingType["CallCommand"] = 153] = "CallCommand";
    BindingType[BindingType["OptionsCommand"] = 26] = "OptionsCommand";
    BindingType[BindingType["ForCommand"] = 539] = "ForCommand";
    BindingType[BindingType["CustomCommand"] = 284] = "CustomCommand";
})(BindingType || (BindingType = {}));
/* eslint-enable @typescript-eslint/indent */
/** @internal */
class ParserState {
    constructor(input) {
        this.input = input;
        this.index = 0;
        this.startIndex = 0;
        this.lastIndex = 0;
        this.currentToken = 1572864 /* EOF */;
        this.tokenValue = '';
        this.assignable = true;
        this.length = input.length;
        this.currentChar = input.charCodeAt(0);
    }
    get tokenRaw() {
        return this.input.slice(this.startIndex, this.index);
    }
}
const $state = new ParserState('');
/** @internal */
function parseExpression(input, bindingType) {
    $state.input = input;
    $state.length = input.length;
    $state.index = 0;
    $state.currentChar = input.charCodeAt(0);
    return parse($state, 0 /* Reset */, 61 /* Variadic */, bindingType === void 0 ? 53 /* BindCommand */ : bindingType);
}
/** @internal */
// This is performance-critical code which follows a subset of the well-known ES spec.
// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the
// single source of information for being able to figure it out.
// It generally does not need to change unless the spec changes or spec violations are found, or optimization
// opportunities are found (which would likely not fix these warnings in any case).
// It's therefore not considered to have any tangible impact on the maintainability of the code base.
// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions
// eslint-disable-next-line max-lines-per-function
function parse(state, access, minPrecedence, bindingType) {
    if (bindingType === 284 /* CustomCommand */) {
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CustomExpression(state.input);
    }
    if (state.index === 0) {
        if (bindingType & 2048 /* Interpolation */) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return parseInterpolation(state);
        }
        nextToken(state);
        if (state.currentToken & 1048576 /* ExpressionTerminal */) {
            throw new Error(`Invalid start of expression: '${state.input}'`);
        }
    }
    state.assignable = 448 /* Binary */ > minPrecedence;
    let result = void 0;
    if (state.currentToken & 32768 /* UnaryOp */) {
        /** parseUnaryExpression
         * https://tc39.github.io/ecma262/#sec-unary-operators
         *
         * UnaryExpression :
         * 1. LeftHandSideExpression
         * 2. void UnaryExpression
         * 3. typeof UnaryExpression
         * 4. + UnaryExpression
         * 5. - UnaryExpression
         * 6. ! UnaryExpression
         *
         * IsValidAssignmentTarget
         * 2,3,4,5,6 = false
         * 1 = see parseLeftHandSideExpression
         *
         * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that
         */
        const op = TokenValues[state.currentToken & 63 /* Type */];
        nextToken(state);
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.UnaryExpression(op, parse(state, access, 449 /* LeftHandSide */, bindingType));
        state.assignable = false;
    }
    else {
        /** parsePrimaryExpression
         * https://tc39.github.io/ecma262/#sec-primary-expression
         *
         * PrimaryExpression :
         * 1. this
         * 2. IdentifierName
         * 3. Literal
         * 4. ArrayLiteralExpression
         * 5. ObjectLiteralExpression
         * 6. TemplateLiteral
         * 7. ParenthesizedExpression
         *
         * Literal :
         * NullLiteral
         * BooleanLiteral
         * NumericLiteral
         * StringLiteral
         *
         * ParenthesizedExpression :
         * ( AssignmentExpression )
         *
         * IsValidAssignmentTarget
         * 1,3,4,5,6,7 = false
         * 2 = true
         */
        primary: switch (state.currentToken) {
            case 3078 /* ParentScope */: // $parent
                state.assignable = false;
                do {
                    nextToken(state);
                    access++; // ancestor
                    if (consumeOpt(state, 16393 /* Dot */)) {
                        if (state.currentToken === 16393 /* Dot */) {
                            throw new Error(`Double dot and spread operators are not supported: '${state.input}'`);
                        }
                        else if (state.currentToken === 1572864 /* EOF */) {
                            throw new Error(`Expected identifier: '${state.input}'`);
                        }
                    }
                    else if (state.currentToken & 524288 /* AccessScopeTerminal */) {
                        const ancestor = access & 511 /* Ancestor */;
                        result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessThisExpression(ancestor);
                        access = 512 /* This */;
                        break primary;
                    }
                    else {
                        throw new Error(`Invalid member expression: '${state.input}'`);
                    }
                } while (state.currentToken === 3078 /* ParentScope */);
            // falls through
            case 1024 /* Identifier */: // identifier
                if (bindingType & 512 /* IsIterator */) {
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.BindingIdentifier(state.tokenValue);
                }
                else {
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessScopeExpression(state.tokenValue, access & 511 /* Ancestor */);
                    access = 1024 /* Scope */;
                }
                state.assignable = true;
                nextToken(state);
                break;
            case 3076 /* ThisScope */: // $this
                state.assignable = false;
                nextToken(state);
                result = $this;
                access = 512 /* This */;
                break;
            case 3077 /* HostScope */: // $host
                state.assignable = false;
                nextToken(state);
                result = $host;
                access = 512 /* This */;
                break;
            case 671751 /* OpenParen */: // parenthesized expression
                nextToken(state);
                result = parse(state, 0 /* Reset */, 62 /* Assign */, bindingType);
                consume(state, 1835019 /* CloseParen */);
                access = 0 /* Reset */;
                break;
            case 671757 /* OpenBracket */:
                result = parseArrayLiteralExpression(state, access, bindingType);
                access = 0 /* Reset */;
                break;
            case 131080 /* OpenBrace */:
                result = parseObjectLiteralExpression(state, bindingType);
                access = 0 /* Reset */;
                break;
            case 540714 /* TemplateTail */:
                result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TemplateExpression([state.tokenValue]);
                state.assignable = false;
                nextToken(state);
                access = 0 /* Reset */;
                break;
            case 540715 /* TemplateContinuation */:
                result = parseTemplate(state, access, bindingType, result, false);
                access = 0 /* Reset */;
                break;
            case 4096 /* StringLiteral */:
            case 8192 /* NumericLiteral */:
                result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.PrimitiveLiteralExpression(state.tokenValue);
                state.assignable = false;
                nextToken(state);
                access = 0 /* Reset */;
                break;
            case 2050 /* NullKeyword */:
            case 2051 /* UndefinedKeyword */:
            case 2049 /* TrueKeyword */:
            case 2048 /* FalseKeyword */:
                result = TokenValues[state.currentToken & 63 /* Type */];
                state.assignable = false;
                nextToken(state);
                access = 0 /* Reset */;
                break;
            default:
                if (state.index >= state.length) {
                    throw new Error(`Unexpected end of expression: '${state.input}'`);
                }
                else {
                    throw new Error(`Unconsumed token: '${state.input}'`);
                }
        }
        if (bindingType & 512 /* IsIterator */) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return parseForOfStatement(state, result);
        }
        if (449 /* LeftHandSide */ < minPrecedence) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return result;
        }
        /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)
         * MemberExpression :
         * 1. PrimaryExpression
         * 2. MemberExpression [ AssignmentExpression ]
         * 3. MemberExpression . IdentifierName
         * 4. MemberExpression TemplateLiteral
         *
         * IsValidAssignmentTarget
         * 1,4 = false
         * 2,3 = true
         *
         *
         * parseCallExpression (Token.OpenParen)
         * CallExpression :
         * 1. MemberExpression Arguments
         * 2. CallExpression Arguments
         * 3. CallExpression [ AssignmentExpression ]
         * 4. CallExpression . IdentifierName
         * 5. CallExpression TemplateLiteral
         *
         * IsValidAssignmentTarget
         * 1,2,5 = false
         * 3,4 = true
         */
        let name = state.tokenValue;
        while ((state.currentToken & 16384 /* LeftHandSide */) > 0) {
            const args = [];
            let strings;
            switch (state.currentToken) {
                case 16393 /* Dot */:
                    state.assignable = true;
                    nextToken(state);
                    if ((state.currentToken & 3072 /* IdentifierName */) === 0) {
                        throw new Error(`Expected identifier: '${state.input}'`);
                    }
                    name = state.tokenValue;
                    nextToken(state);
                    // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags
                    access = ((access & (512 /* This */ | 1024 /* Scope */)) << 1) | (access & 2048 /* Member */) | ((access & 4096 /* Keyed */) >> 1);
                    if (state.currentToken === 671751 /* OpenParen */) {
                        if (access === 0 /* Reset */) { // if the left hand side is a literal, make sure we parse a CallMemberExpression
                            access = 2048 /* Member */;
                        }
                        continue;
                    }
                    if (access & 1024 /* Scope */) {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessScopeExpression(name, result.ancestor, result === $host);
                    }
                    else { // if it's not $Scope, it's $Member
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessMemberExpression(result, name);
                    }
                    continue;
                case 671757 /* OpenBracket */:
                    state.assignable = true;
                    nextToken(state);
                    access = 4096 /* Keyed */;
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AccessKeyedExpression(result, parse(state, 0 /* Reset */, 62 /* Assign */, bindingType));
                    consume(state, 1835022 /* CloseBracket */);
                    break;
                case 671751 /* OpenParen */:
                    state.assignable = false;
                    nextToken(state);
                    while (state.currentToken !== 1835019 /* CloseParen */) {
                        args.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType));
                        if (!consumeOpt(state, 1572876 /* Comma */)) {
                            break;
                        }
                    }
                    consume(state, 1835019 /* CloseParen */);
                    if (access & 1024 /* Scope */) {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CallScopeExpression(name, args, result.ancestor, result === $host);
                    }
                    else if (access & 2048 /* Member */) {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CallMemberExpression(result, name, args);
                    }
                    else {
                        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.CallFunctionExpression(result, args);
                    }
                    access = 0;
                    break;
                case 540714 /* TemplateTail */:
                    state.assignable = false;
                    strings = [state.tokenValue];
                    result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TaggedTemplateExpression(strings, strings, result);
                    nextToken(state);
                    break;
                case 540715 /* TemplateContinuation */:
                    result = parseTemplate(state, access, bindingType, result, true);
                default:
            }
        }
    }
    if (448 /* Binary */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /** parseBinaryExpression
     * https://tc39.github.io/ecma262/#sec-multiplicative-operators
     *
     * MultiplicativeExpression : (local precedence 6)
     * UnaryExpression
     * MultiplicativeExpression * / % UnaryExpression
     *
     * AdditiveExpression : (local precedence 5)
     * MultiplicativeExpression
     * AdditiveExpression + - MultiplicativeExpression
     *
     * RelationalExpression : (local precedence 4)
     * AdditiveExpression
     * RelationalExpression < > <= >= instanceof in AdditiveExpression
     *
     * EqualityExpression : (local precedence 3)
     * RelationalExpression
     * EqualityExpression == != === !== RelationalExpression
     *
     * LogicalANDExpression : (local precedence 2)
     * EqualityExpression
     * LogicalANDExpression && EqualityExpression
     *
     * LogicalORExpression : (local precedence 1)
     * LogicalANDExpression
     * LogicalORExpression || LogicalANDExpression
     */
    while ((state.currentToken & 65536 /* BinaryOp */) > 0) {
        const opToken = state.currentToken;
        if ((opToken & 448 /* Precedence */) <= minPrecedence) {
            break;
        }
        nextToken(state);
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.BinaryExpression(TokenValues[opToken & 63 /* Type */], result, parse(state, access, opToken & 448 /* Precedence */, bindingType));
        state.assignable = false;
    }
    if (63 /* Conditional */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /**
     * parseConditionalExpression
     * https://tc39.github.io/ecma262/#prod-ConditionalExpression
     *
     * ConditionalExpression :
     * 1. BinaryExpression
     * 2. BinaryExpression ? AssignmentExpression : AssignmentExpression
     *
     * IsValidAssignmentTarget
     * 1,2 = false
     */
    if (consumeOpt(state, 1572880 /* Question */)) {
        const yes = parse(state, access, 62 /* Assign */, bindingType);
        consume(state, 1572879 /* Colon */);
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ConditionalExpression(result, yes, parse(state, access, 62 /* Assign */, bindingType));
        state.assignable = false;
    }
    if (62 /* Assign */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /** parseAssignmentExpression
     * https://tc39.github.io/ecma262/#prod-AssignmentExpression
     * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator
     *
     * AssignmentExpression :
     * 1. ConditionalExpression
     * 2. LeftHandSideExpression = AssignmentExpression
     *
     * IsValidAssignmentTarget
     * 1,2 = false
     */
    if (consumeOpt(state, 1048616 /* Equals */)) {
        if (!state.assignable) {
            throw new Error(`Left hand side of expression is not assignable: '${state.input}'`);
        }
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.AssignExpression(result, parse(state, access, 62 /* Assign */, bindingType));
    }
    if (61 /* Variadic */ < minPrecedence) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return result;
    }
    /** parseValueConverter
     */
    while (consumeOpt(state, 1572884 /* Bar */)) {
        if (state.currentToken === 1572864 /* EOF */) {
            throw new Error(`Expected identifier to come after ValueConverter operator: '${state.input}'`);
        }
        const name = state.tokenValue;
        nextToken(state);
        const args = new Array();
        while (consumeOpt(state, 1572879 /* Colon */)) {
            args.push(parse(state, access, 62 /* Assign */, bindingType));
        }
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ValueConverterExpression(result, name, args);
    }
    /** parseBindingBehavior
     */
    while (consumeOpt(state, 1572883 /* Ampersand */)) {
        if (state.currentToken === 1572864 /* EOF */) {
            throw new Error(`Expected identifier to come after BindingBehavior operator: '${state.input}'`);
        }
        const name = state.tokenValue;
        nextToken(state);
        const args = new Array();
        while (consumeOpt(state, 1572879 /* Colon */)) {
            args.push(parse(state, access, 62 /* Assign */, bindingType));
        }
        result = new _ast_js__WEBPACK_IMPORTED_MODULE_1__.BindingBehaviorExpression(result, name, args);
    }
    if (state.currentToken !== 1572864 /* EOF */) {
        if (bindingType & 2048 /* Interpolation */) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return result;
        }
        if (state.tokenRaw === 'of') {
            throw new Error(`Unexpected keyword "of": '${state.input}'`);
        }
        throw new Error(`Unconsumed token: '${state.input}'`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return result;
}
/**
 * parseArrayLiteralExpression
 * https://tc39.github.io/ecma262/#prod-ArrayLiteralExpression
 *
 * ArrayLiteralExpression :
 * [ Elision(opt) ]
 * [ ElementList ]
 * [ ElementList, Elision(opt) ]
 *
 * ElementList :
 * Elision(opt) AssignmentExpression
 * ElementList, Elision(opt) AssignmentExpression
 *
 * Elision :
 * ,
 * Elision ,
 */
function parseArrayLiteralExpression(state, access, bindingType) {
    nextToken(state);
    const elements = new Array();
    while (state.currentToken !== 1835022 /* CloseBracket */) {
        if (consumeOpt(state, 1572876 /* Comma */)) {
            elements.push($undefined);
            if (state.currentToken === 1835022 /* CloseBracket */) {
                break;
            }
        }
        else {
            elements.push(parse(state, access, 62 /* Assign */, bindingType & ~512 /* IsIterator */));
            if (consumeOpt(state, 1572876 /* Comma */)) {
                if (state.currentToken === 1835022 /* CloseBracket */) {
                    break;
                }
            }
            else {
                break;
            }
        }
    }
    consume(state, 1835022 /* CloseBracket */);
    if (bindingType & 512 /* IsIterator */) {
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ArrayBindingPattern(elements);
    }
    else {
        state.assignable = false;
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ArrayLiteralExpression(elements);
    }
}
function parseForOfStatement(state, result) {
    if ((result.$kind & 65536 /* IsForDeclaration */) === 0) {
        throw new Error(`Invalid BindingIdentifier at left hand side of "of": '${state.input}'`);
    }
    if (state.currentToken !== 1051180 /* OfKeyword */) {
        throw new Error(`Invalid BindingIdentifier at left hand side of "of": '${state.input}'`);
    }
    nextToken(state);
    const declaration = result;
    const statement = parse(state, 0 /* Reset */, 61 /* Variadic */, 0 /* None */);
    return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ForOfStatement(declaration, statement);
}
/**
 * parseObjectLiteralExpression
 * https://tc39.github.io/ecma262/#prod-Literal
 *
 * ObjectLiteralExpression :
 * { }
 * { PropertyDefinitionList }
 *
 * PropertyDefinitionList :
 * PropertyDefinition
 * PropertyDefinitionList, PropertyDefinition
 *
 * PropertyDefinition :
 * IdentifierName
 * PropertyName : AssignmentExpression
 *
 * PropertyName :
 * IdentifierName
 * StringLiteral
 * NumericLiteral
 */
function parseObjectLiteralExpression(state, bindingType) {
    const keys = new Array();
    const values = new Array();
    nextToken(state);
    while (state.currentToken !== 1835018 /* CloseBrace */) {
        keys.push(state.tokenValue);
        // Literal = mandatory colon
        if (state.currentToken & 12288 /* StringOrNumericLiteral */) {
            nextToken(state);
            consume(state, 1572879 /* Colon */);
            values.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType & ~512 /* IsIterator */));
        }
        else if (state.currentToken & 3072 /* IdentifierName */) {
            // IdentifierName = optional colon
            const { currentChar, currentToken, index } = state;
            nextToken(state);
            if (consumeOpt(state, 1572879 /* Colon */)) {
                values.push(parse(state, 0 /* Reset */, 62 /* Assign */, bindingType & ~512 /* IsIterator */));
            }
            else {
                // Shorthand
                state.currentChar = currentChar;
                state.currentToken = currentToken;
                state.index = index;
                values.push(parse(state, 0 /* Reset */, 450 /* Primary */, bindingType & ~512 /* IsIterator */));
            }
        }
        else {
            throw new Error(`Invalid or unsupported property definition in object literal: '${state.input}'`);
        }
        if (state.currentToken !== 1835018 /* CloseBrace */) {
            consume(state, 1572876 /* Comma */);
        }
    }
    consume(state, 1835018 /* CloseBrace */);
    if (bindingType & 512 /* IsIterator */) {
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ObjectBindingPattern(keys, values);
    }
    else {
        state.assignable = false;
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.ObjectLiteralExpression(keys, values);
    }
}
function parseInterpolation(state) {
    const parts = [];
    const expressions = [];
    const length = state.length;
    let result = '';
    while (state.index < length) {
        switch (state.currentChar) {
            case 36 /* Dollar */:
                if (state.input.charCodeAt(state.index + 1) === 123 /* OpenBrace */) {
                    parts.push(result);
                    result = '';
                    state.index += 2;
                    state.currentChar = state.input.charCodeAt(state.index);
                    nextToken(state);
                    const expression = parse(state, 0 /* Reset */, 61 /* Variadic */, 2048 /* Interpolation */);
                    expressions.push(expression);
                    continue;
                }
                else {
                    result += '$';
                }
                break;
            case 92 /* Backslash */:
                result += String.fromCharCode(unescapeCode(nextChar(state)));
                break;
            default:
                result += String.fromCharCode(state.currentChar);
        }
        nextChar(state);
    }
    if (expressions.length) {
        parts.push(result);
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.Interpolation(parts, expressions);
    }
    return null;
}
/**
 * parseTemplateLiteralExpression
 * https://tc39.github.io/ecma262/#prod-Literal
 *
 * TemplateExpression :
 * NoSubstitutionTemplate
 * TemplateHead
 *
 * NoSubstitutionTemplate :
 * ` TemplateCharacters(opt) `
 *
 * TemplateHead :
 * ` TemplateCharacters(opt) ${
 *
 * TemplateSubstitutionTail :
 * TemplateMiddle
 * TemplateTail
 *
 * TemplateMiddle :
 * } TemplateCharacters(opt) ${
 *
 * TemplateTail :
 * } TemplateCharacters(opt) `
 *
 * TemplateCharacters :
 * TemplateCharacter TemplateCharacters(opt)
 *
 * TemplateCharacter :
 * $ [lookahead ≠ {]
 * \ EscapeSequence
 * SourceCharacter (but not one of ` or \ or $)
 */
function parseTemplate(state, access, bindingType, result, tagged) {
    const cooked = [state.tokenValue];
    // TODO: properly implement raw parts / decide whether we want this
    consume(state, 540715 /* TemplateContinuation */);
    const expressions = [parse(state, access, 62 /* Assign */, bindingType)];
    while ((state.currentToken = scanTemplateTail(state)) !== 540714 /* TemplateTail */) {
        cooked.push(state.tokenValue);
        consume(state, 540715 /* TemplateContinuation */);
        expressions.push(parse(state, access, 62 /* Assign */, bindingType));
    }
    cooked.push(state.tokenValue);
    state.assignable = false;
    if (tagged) {
        nextToken(state);
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TaggedTemplateExpression(cooked, cooked, result, expressions);
    }
    else {
        nextToken(state);
        return new _ast_js__WEBPACK_IMPORTED_MODULE_1__.TemplateExpression(cooked, expressions);
    }
}
function nextToken(state) {
    while (state.index < state.length) {
        state.startIndex = state.index;
        if ((state.currentToken = (CharScanners[state.currentChar](state))) != null) { // a null token means the character must be skipped
            return;
        }
    }
    state.currentToken = 1572864 /* EOF */;
}
function nextChar(state) {
    return state.currentChar = state.input.charCodeAt(++state.index);
}
function scanIdentifier(state) {
    // run to the next non-idPart
    while (IdParts[nextChar(state)])
        ;
    const token = KeywordLookup[state.tokenValue = state.tokenRaw];
    return token === undefined ? 1024 /* Identifier */ : token;
}
function scanNumber(state, isFloat) {
    let char = state.currentChar;
    if (isFloat === false) {
        do {
            char = nextChar(state);
        } while (char <= 57 /* Nine */ && char >= 48 /* Zero */);
        if (char !== 46 /* Dot */) {
            state.tokenValue = parseInt(state.tokenRaw, 10);
            return 8192 /* NumericLiteral */;
        }
        // past this point it's always a float
        char = nextChar(state);
        if (state.index >= state.length) {
            // unless the number ends with a dot - that behaves a little different in native ES expressions
            // but in our AST that behavior has no effect because numbers are always stored in variables
            state.tokenValue = parseInt(state.tokenRaw.slice(0, -1), 10);
            return 8192 /* NumericLiteral */;
        }
    }
    if (char <= 57 /* Nine */ && char >= 48 /* Zero */) {
        do {
            char = nextChar(state);
        } while (char <= 57 /* Nine */ && char >= 48 /* Zero */);
    }
    else {
        state.currentChar = state.input.charCodeAt(--state.index);
    }
    state.tokenValue = parseFloat(state.tokenRaw);
    return 8192 /* NumericLiteral */;
}
function scanString(state) {
    const quote = state.currentChar;
    nextChar(state); // Skip initial quote.
    let unescaped = 0;
    const buffer = new Array();
    let marker = state.index;
    while (state.currentChar !== quote) {
        if (state.currentChar === 92 /* Backslash */) {
            buffer.push(state.input.slice(marker, state.index));
            nextChar(state);
            unescaped = unescapeCode(state.currentChar);
            nextChar(state);
            buffer.push(String.fromCharCode(unescaped));
            marker = state.index;
        }
        else if (state.index >= state.length) {
            throw new Error(`Unterminated quote in string literal: '${state.input}'`);
        }
        else {
            nextChar(state);
        }
    }
    const last = state.input.slice(marker, state.index);
    nextChar(state); // Skip terminating quote.
    // Compute the unescaped string value.
    buffer.push(last);
    const unescapedStr = buffer.join('');
    state.tokenValue = unescapedStr;
    return 4096 /* StringLiteral */;
}
function scanTemplate(state) {
    let tail = true;
    let result = '';
    while (nextChar(state) !== 96 /* Backtick */) {
        if (state.currentChar === 36 /* Dollar */) {
            if ((state.index + 1) < state.length && state.input.charCodeAt(state.index + 1) === 123 /* OpenBrace */) {
                state.index++;
                tail = false;
                break;
            }
            else {
                result += '$';
            }
        }
        else if (state.currentChar === 92 /* Backslash */) {
            result += String.fromCharCode(unescapeCode(nextChar(state)));
        }
        else {
            if (state.index >= state.length) {
                throw new Error(`Unterminated template string: '${state.input}'`);
            }
            result += String.fromCharCode(state.currentChar);
        }
    }
    nextChar(state);
    state.tokenValue = result;
    if (tail) {
        return 540714 /* TemplateTail */;
    }
    return 540715 /* TemplateContinuation */;
}
function scanTemplateTail(state) {
    if (state.index >= state.length) {
        throw new Error(`Unterminated template string: '${state.input}'`);
    }
    state.index--;
    return scanTemplate(state);
}
function consumeOpt(state, token) {
    if (state.currentToken === token) {
        nextToken(state);
        return true;
    }
    return false;
}
function consume(state, token) {
    if (state.currentToken === token) {
        nextToken(state);
    }
    else {
        throw new Error(`Missing expected token: '${state.input}'`);
    }
}
/**
 * Array for mapping tokens to token values. The indices of the values
 * correspond to the token bits 0-38.
 * For this to work properly, the values in the array must be kept in
 * the same order as the token bits.
 * Usage: TokenValues[token & Token.Type]
 */
const TokenValues = [
    $false, $true, $null, $undefined, '$this', '$host', '$parent',
    '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\'', '"',
    '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>',
    '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',
    540714 /* TemplateTail */, 540715 /* TemplateContinuation */,
    'of'
];
const KeywordLookup = Object.create(null);
KeywordLookup.true = 2049 /* TrueKeyword */;
KeywordLookup.null = 2050 /* NullKeyword */;
KeywordLookup.false = 2048 /* FalseKeyword */;
KeywordLookup.undefined = 2051 /* UndefinedKeyword */;
KeywordLookup.$this = 3076 /* ThisScope */;
KeywordLookup.$host = 3077 /* HostScope */;
KeywordLookup.$parent = 3078 /* ParentScope */;
KeywordLookup.in = 1640799 /* InKeyword */;
KeywordLookup.instanceof = 1640800 /* InstanceOfKeyword */;
KeywordLookup.typeof = 34851 /* TypeofKeyword */;
KeywordLookup.void = 34852 /* VoidKeyword */;
KeywordLookup.of = 1051180 /* OfKeyword */;
/**
 * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)
 * Single values are denoted by the second value being a 0
 *
 * Copied from output generated with "node build/generate-unicode.js"
 *
 * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF
 */
const codes = {
    /* [$0-9A-Za_a-z] */
    AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],
    IdStart: /* IdentifierStart */ [0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],
    Digit: /* DecimalNumber */ [0x30, 0x3A],
    Skip: /* Skippable */ [0, 0x21, 0x7F, 0xA1]
};
/**
 * Decompress the ranges into an array of numbers so that the char code
 * can be used as an index to the lookup
 */
function decompress(lookup, $set, compressed, value) {
    const rangeCount = compressed.length;
    for (let i = 0; i < rangeCount; i += 2) {
        const start = compressed[i];
        let end = compressed[i + 1];
        end = end > 0 ? end : start + 1;
        if (lookup) {
            lookup.fill(value, start, end);
        }
        if ($set) {
            for (let ch = start; ch < end; ch++) {
                $set.add(ch);
            }
        }
    }
}
// CharFuncLookup functions
function returnToken(token) {
    return s => {
        nextChar(s);
        return token;
    };
}
const unexpectedCharacter = s => {
    throw new Error(`Unexpected character: '${s.input}'`);
};
unexpectedCharacter.notMapped = true;
// ASCII IdentifierPart lookup
const AsciiIdParts = new Set();
decompress(null, AsciiIdParts, codes.AsciiIdPart, true);
// IdentifierPart lookup
const IdParts = new Uint8Array(0xFFFF);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
decompress(IdParts, null, codes.IdStart, 1);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
decompress(IdParts, null, codes.Digit, 1);
// Character scanning function lookup
const CharScanners = new Array(0xFFFF);
CharScanners.fill(unexpectedCharacter, 0, 0xFFFF);
decompress(CharScanners, null, codes.Skip, s => {
    nextChar(s);
    return null;
});
decompress(CharScanners, null, codes.IdStart, scanIdentifier);
decompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));
CharScanners[34 /* DoubleQuote */] =
    CharScanners[39 /* SingleQuote */] = s => {
        return scanString(s);
    };
CharScanners[96 /* Backtick */] = s => {
    return scanTemplate(s);
};
// !, !=, !==
CharScanners[33 /* Exclamation */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 32809 /* Exclamation */;
    }
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638680 /* ExclamationEquals */;
    }
    nextChar(s);
    return 1638682 /* ExclamationEqualsEquals */;
};
// =, ==, ===
CharScanners[61 /* Equals */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 1048616 /* Equals */;
    }
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638679 /* EqualsEquals */;
    }
    nextChar(s);
    return 1638681 /* EqualsEqualsEquals */;
};
// &, &&
CharScanners[38 /* Ampersand */] = s => {
    if (nextChar(s) !== 38 /* Ampersand */) {
        return 1572883 /* Ampersand */;
    }
    nextChar(s);
    return 1638614 /* AmpersandAmpersand */;
};
// |, ||
CharScanners[124 /* Bar */] = s => {
    if (nextChar(s) !== 124 /* Bar */) {
        return 1572884 /* Bar */;
    }
    nextChar(s);
    return 1638549 /* BarBar */;
};
// .
CharScanners[46 /* Dot */] = s => {
    if (nextChar(s) <= 57 /* Nine */ && s.currentChar >= 48 /* Zero */) {
        return scanNumber(s, true);
    }
    return 16393 /* Dot */;
};
// <, <=
CharScanners[60 /* LessThan */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638747 /* LessThan */;
    }
    nextChar(s);
    return 1638749 /* LessThanEquals */;
};
// >, >=
CharScanners[62 /* GreaterThan */] = s => {
    if (nextChar(s) !== 61 /* Equals */) {
        return 1638748 /* GreaterThan */;
    }
    nextChar(s);
    return 1638750 /* GreaterThanEquals */;
};
CharScanners[37 /* Percent */] = returnToken(1638886 /* Percent */);
CharScanners[40 /* OpenParen */] = returnToken(671751 /* OpenParen */);
CharScanners[41 /* CloseParen */] = returnToken(1835019 /* CloseParen */);
CharScanners[42 /* Asterisk */] = returnToken(1638885 /* Asterisk */);
CharScanners[43 /* Plus */] = returnToken(623009 /* Plus */);
CharScanners[44 /* Comma */] = returnToken(1572876 /* Comma */);
CharScanners[45 /* Minus */] = returnToken(623010 /* Minus */);
CharScanners[47 /* Slash */] = returnToken(1638887 /* Slash */);
CharScanners[58 /* Colon */] = returnToken(1572879 /* Colon */);
CharScanners[63 /* Question */] = returnToken(1572880 /* Question */);
CharScanners[91 /* OpenBracket */] = returnToken(671757 /* OpenBracket */);
CharScanners[93 /* CloseBracket */] = returnToken(1835022 /* CloseBracket */);
CharScanners[123 /* OpenBrace */] = returnToken(131080 /* OpenBrace */);
CharScanners[125 /* CloseBrace */] = returnToken(1835018 /* CloseBrace */);
//# sourceMappingURL=expression-parser.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IPlatform": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform,
/* harmony export */   "Platform": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Platform,
/* harmony export */   "TaskQueue": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueue,
/* harmony export */   "Task": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.Task,
/* harmony export */   "TaskAbortError": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskAbortError,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskQueuePriority,
/* harmony export */   "TaskStatus": () => /* reexport safe */ _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__.TaskStatus,
/* harmony export */   "alias": () => /* reexport safe */ _alias_js__WEBPACK_IMPORTED_MODULE_2__.alias,
/* harmony export */   "registerAliases": () => /* reexport safe */ _alias_js__WEBPACK_IMPORTED_MODULE_2__.registerAliases,
/* harmony export */   "ExpressionKind": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ExpressionKind,
/* harmony export */   "CallFunctionExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CallFunctionExpression,
/* harmony export */   "CustomExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CustomExpression,
/* harmony export */   "BindingBehaviorExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.BindingBehaviorExpression,
/* harmony export */   "ValueConverterExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ValueConverterExpression,
/* harmony export */   "AssignExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AssignExpression,
/* harmony export */   "ConditionalExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ConditionalExpression,
/* harmony export */   "AccessThisExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessThisExpression,
/* harmony export */   "AccessScopeExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessScopeExpression,
/* harmony export */   "AccessMemberExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessMemberExpression,
/* harmony export */   "AccessKeyedExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.AccessKeyedExpression,
/* harmony export */   "CallScopeExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CallScopeExpression,
/* harmony export */   "CallMemberExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.CallMemberExpression,
/* harmony export */   "BinaryExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.BinaryExpression,
/* harmony export */   "UnaryExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.UnaryExpression,
/* harmony export */   "PrimitiveLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.PrimitiveLiteralExpression,
/* harmony export */   "HtmlLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.HtmlLiteralExpression,
/* harmony export */   "ArrayLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ArrayLiteralExpression,
/* harmony export */   "ObjectLiteralExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ObjectLiteralExpression,
/* harmony export */   "TemplateExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.TemplateExpression,
/* harmony export */   "TaggedTemplateExpression": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.TaggedTemplateExpression,
/* harmony export */   "ArrayBindingPattern": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ArrayBindingPattern,
/* harmony export */   "ObjectBindingPattern": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ObjectBindingPattern,
/* harmony export */   "BindingIdentifier": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.BindingIdentifier,
/* harmony export */   "ForOfStatement": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.ForOfStatement,
/* harmony export */   "Interpolation": () => /* reexport safe */ _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__.Interpolation,
/* harmony export */   "connectable": () => /* reexport safe */ _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__.connectable,
/* harmony export */   "BindingMediator": () => /* reexport safe */ _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__.BindingMediator,
/* harmony export */   "BindingObserverRecord": () => /* reexport safe */ _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__.BindingObserverRecord,
/* harmony export */   "IExpressionParser": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.IExpressionParser,
/* harmony export */   "BindingType": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.BindingType,
/* harmony export */   "parseExpression": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.parseExpression,
/* harmony export */   "Char": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.Char,
/* harmony export */   "Access": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.Access,
/* harmony export */   "Precedence": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.Precedence,
/* harmony export */   "parse": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.parse,
/* harmony export */   "ParserState": () => /* reexport safe */ _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__.ParserState,
/* harmony export */   "ArrayObserver": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.ArrayObserver,
/* harmony export */   "ArrayIndexObserver": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.ArrayIndexObserver,
/* harmony export */   "enableArrayObservation": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.enableArrayObservation,
/* harmony export */   "disableArrayObservation": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.disableArrayObservation,
/* harmony export */   "applyMutationsToIndices": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.applyMutationsToIndices,
/* harmony export */   "synchronizeIndices": () => /* reexport safe */ _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__.synchronizeIndices,
/* harmony export */   "MapObserver": () => /* reexport safe */ _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__.MapObserver,
/* harmony export */   "enableMapObservation": () => /* reexport safe */ _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__.enableMapObservation,
/* harmony export */   "disableMapObservation": () => /* reexport safe */ _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__.disableMapObservation,
/* harmony export */   "SetObserver": () => /* reexport safe */ _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__.SetObserver,
/* harmony export */   "enableSetObservation": () => /* reexport safe */ _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__.enableSetObservation,
/* harmony export */   "disableSetObservation": () => /* reexport safe */ _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__.disableSetObservation,
/* harmony export */   "BindingContext": () => /* reexport safe */ _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__.BindingContext,
/* harmony export */   "Scope": () => /* reexport safe */ _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__.Scope,
/* harmony export */   "OverrideContext": () => /* reexport safe */ _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__.OverrideContext,
/* harmony export */   "CollectionLengthObserver": () => /* reexport safe */ _observation_collection_length_observer_js__WEBPACK_IMPORTED_MODULE_10__.CollectionLengthObserver,
/* harmony export */   "CollectionSizeObserver": () => /* reexport safe */ _observation_collection_length_observer_js__WEBPACK_IMPORTED_MODULE_10__.CollectionSizeObserver,
/* harmony export */   "ComputedObserver": () => /* reexport safe */ _observation_computed_observer_js__WEBPACK_IMPORTED_MODULE_11__.ComputedObserver,
/* harmony export */   "IDirtyChecker": () => /* reexport safe */ _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__.IDirtyChecker,
/* harmony export */   "DirtyCheckProperty": () => /* reexport safe */ _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__.DirtyCheckProperty,
/* harmony export */   "DirtyCheckSettings": () => /* reexport safe */ _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__.DirtyCheckSettings,
/* harmony export */   "observable": () => /* reexport safe */ _observation_observable_js__WEBPACK_IMPORTED_MODULE_13__.observable,
/* harmony export */   "IObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.IObserverLocator,
/* harmony export */   "INodeObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.INodeObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.getCollectionObserver,
/* harmony export */   "ObserverLocator": () => /* reexport safe */ _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__.ObserverLocator,
/* harmony export */   "PrimitiveObserver": () => /* reexport safe */ _observation_primitive_observer_js__WEBPACK_IMPORTED_MODULE_15__.PrimitiveObserver,
/* harmony export */   "PropertyAccessor": () => /* reexport safe */ _observation_property_accessor_js__WEBPACK_IMPORTED_MODULE_16__.PropertyAccessor,
/* harmony export */   "ProxyObservable": () => /* reexport safe */ _observation_proxy_observation_js__WEBPACK_IMPORTED_MODULE_17__.ProxyObservable,
/* harmony export */   "SetterObserver": () => /* reexport safe */ _observation_setter_observer_js__WEBPACK_IMPORTED_MODULE_18__.SetterObserver,
/* harmony export */   "ISignaler": () => /* reexport safe */ _observation_signaler_js__WEBPACK_IMPORTED_MODULE_19__.ISignaler,
/* harmony export */   "SubscriberRecord": () => /* reexport safe */ _observation_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_20__.SubscriberRecord,
/* harmony export */   "subscriberCollection": () => /* reexport safe */ _observation_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_20__.subscriberCollection,
/* harmony export */   "ConnectableSwitcher": () => /* reexport safe */ _observation_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_21__.ConnectableSwitcher,
/* harmony export */   "bindingBehavior": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.bindingBehavior,
/* harmony export */   "BindingBehavior": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehavior,
/* harmony export */   "BindingBehaviorDefinition": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehaviorDefinition,
/* harmony export */   "BindingInterceptor": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingInterceptor,
/* harmony export */   "BindingBehaviorFactory": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehaviorFactory,
/* harmony export */   "BindingBehaviorStrategy": () => /* reexport safe */ _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__.BindingBehaviorStrategy,
/* harmony export */   "ValueConverter": () => /* reexport safe */ _value_converter_js__WEBPACK_IMPORTED_MODULE_23__.ValueConverter,
/* harmony export */   "ValueConverterDefinition": () => /* reexport safe */ _value_converter_js__WEBPACK_IMPORTED_MODULE_23__.ValueConverterDefinition,
/* harmony export */   "valueConverter": () => /* reexport safe */ _value_converter_js__WEBPACK_IMPORTED_MODULE_23__.valueConverter,
/* harmony export */   "BindingMode": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.BindingMode,
/* harmony export */   "LifecycleFlags": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.LifecycleFlags,
/* harmony export */   "AccessorType": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.AccessorType,
/* harmony export */   "CollectionKind": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.CollectionKind,
/* harmony export */   "DelegationStrategy": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.DelegationStrategy,
/* harmony export */   "isIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.isIndexMap,
/* harmony export */   "copyIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.copyIndexMap,
/* harmony export */   "cloneIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.cloneIndexMap,
/* harmony export */   "createIndexMap": () => /* reexport safe */ _observation_js__WEBPACK_IMPORTED_MODULE_24__.createIndexMap
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/platform */ "./node_modules/@aurelia/platform/dist/esm/index.js");
/* harmony import */ var _alias_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./alias.js */ "./node_modules/@aurelia/runtime/dist/esm/alias.js");
/* harmony import */ var _binding_ast_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./binding/ast.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/ast.js");
/* harmony import */ var _binding_connectable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binding/connectable.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js");
/* harmony import */ var _binding_expression_parser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./binding/expression-parser.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/expression-parser.js");
/* harmony import */ var _observation_array_observer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./observation/array-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js");
/* harmony import */ var _observation_map_observer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./observation/map-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js");
/* harmony import */ var _observation_set_observer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./observation/set-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js");
/* harmony import */ var _observation_binding_context_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./observation/binding-context.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js");
/* harmony import */ var _observation_collection_length_observer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./observation/collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _observation_computed_observer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./observation/computed-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js");
/* harmony import */ var _observation_dirty_checker_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./observation/dirty-checker.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js");
/* harmony import */ var _observation_observable_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./observation/observable.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/observable.js");
/* harmony import */ var _observation_observer_locator_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./observation/observer-locator.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/observer-locator.js");
/* harmony import */ var _observation_primitive_observer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./observation/primitive-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js");
/* harmony import */ var _observation_property_accessor_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./observation/property-accessor.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js");
/* harmony import */ var _observation_proxy_observation_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./observation/proxy-observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js");
/* harmony import */ var _observation_setter_observer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./observation/setter-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js");
/* harmony import */ var _observation_signaler_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./observation/signaler.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js");
/* harmony import */ var _observation_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./observation/subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _observation_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./observation/connectable-switcher.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js");
/* harmony import */ var _binding_behavior_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./binding-behavior.js */ "./node_modules/@aurelia/runtime/dist/esm/binding-behavior.js");
/* harmony import */ var _value_converter_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./value-converter.js */ "./node_modules/@aurelia/runtime/dist/esm/value-converter.js");
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");

























//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingMode": () => /* binding */ BindingMode,
/* harmony export */   "LifecycleFlags": () => /* binding */ LifecycleFlags,
/* harmony export */   "SubscriberFlags": () => /* binding */ SubscriberFlags,
/* harmony export */   "DelegationStrategy": () => /* binding */ DelegationStrategy,
/* harmony export */   "CollectionKind": () => /* binding */ CollectionKind,
/* harmony export */   "AccessorType": () => /* binding */ AccessorType,
/* harmony export */   "copyIndexMap": () => /* binding */ copyIndexMap,
/* harmony export */   "createIndexMap": () => /* binding */ createIndexMap,
/* harmony export */   "cloneIndexMap": () => /* binding */ cloneIndexMap,
/* harmony export */   "isIndexMap": () => /* binding */ isIndexMap
/* harmony export */ });
/*
* Note: the oneTime binding now has a non-zero value for 2 reasons:
*  - plays nicer with bitwise operations (more consistent code, more explicit settings)
*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model
*
* Furthermore, the "default" mode would be for simple ".bind" expressions to make it explicit for our logic that the default is being used.
* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it
*/
var BindingMode;
(function (BindingMode) {
    BindingMode[BindingMode["oneTime"] = 1] = "oneTime";
    BindingMode[BindingMode["toView"] = 2] = "toView";
    BindingMode[BindingMode["fromView"] = 4] = "fromView";
    BindingMode[BindingMode["twoWay"] = 6] = "twoWay";
    BindingMode[BindingMode["default"] = 8] = "default";
})(BindingMode || (BindingMode = {}));
var LifecycleFlags;
(function (LifecycleFlags) {
    LifecycleFlags[LifecycleFlags["none"] = 0] = "none";
    // Bitmask for flags that need to be stored on a binding during $bind for mutation
    // callbacks outside of $bind
    LifecycleFlags[LifecycleFlags["persistentBindingFlags"] = 15367] = "persistentBindingFlags";
    LifecycleFlags[LifecycleFlags["allowParentScopeTraversal"] = 1024] = "allowParentScopeTraversal";
    LifecycleFlags[LifecycleFlags["observeLeafPropertiesOnly"] = 2048] = "observeLeafPropertiesOnly";
    LifecycleFlags[LifecycleFlags["targetObserverFlags"] = 12295] = "targetObserverFlags";
    LifecycleFlags[LifecycleFlags["noFlush"] = 4096] = "noFlush";
    LifecycleFlags[LifecycleFlags["persistentTargetObserverQueue"] = 8192] = "persistentTargetObserverQueue";
    LifecycleFlags[LifecycleFlags["bindingStrategy"] = 7] = "bindingStrategy";
    LifecycleFlags[LifecycleFlags["getterSetterStrategy"] = 1] = "getterSetterStrategy";
    LifecycleFlags[LifecycleFlags["proxyStrategy"] = 2] = "proxyStrategy";
    LifecycleFlags[LifecycleFlags["isStrictBindingStrategy"] = 4] = "isStrictBindingStrategy";
    LifecycleFlags[LifecycleFlags["update"] = 24] = "update";
    LifecycleFlags[LifecycleFlags["updateTarget"] = 8] = "updateTarget";
    LifecycleFlags[LifecycleFlags["updateSource"] = 16] = "updateSource";
    LifecycleFlags[LifecycleFlags["from"] = 96] = "from";
    LifecycleFlags[LifecycleFlags["fromBind"] = 32] = "fromBind";
    LifecycleFlags[LifecycleFlags["fromUnbind"] = 64] = "fromUnbind";
    LifecycleFlags[LifecycleFlags["mustEvaluate"] = 128] = "mustEvaluate";
    LifecycleFlags[LifecycleFlags["isTraversingParentScope"] = 256] = "isTraversingParentScope";
    LifecycleFlags[LifecycleFlags["dispose"] = 512] = "dispose";
})(LifecycleFlags || (LifecycleFlags = {}));
/** @internal */
var SubscriberFlags;
(function (SubscriberFlags) {
    SubscriberFlags[SubscriberFlags["None"] = 0] = "None";
    SubscriberFlags[SubscriberFlags["Subscriber0"] = 1] = "Subscriber0";
    SubscriberFlags[SubscriberFlags["Subscriber1"] = 2] = "Subscriber1";
    SubscriberFlags[SubscriberFlags["Subscriber2"] = 4] = "Subscriber2";
    SubscriberFlags[SubscriberFlags["SubscribersRest"] = 8] = "SubscribersRest";
    SubscriberFlags[SubscriberFlags["Any"] = 15] = "Any";
})(SubscriberFlags || (SubscriberFlags = {}));
var DelegationStrategy;
(function (DelegationStrategy) {
    DelegationStrategy[DelegationStrategy["none"] = 0] = "none";
    DelegationStrategy[DelegationStrategy["capturing"] = 1] = "capturing";
    DelegationStrategy[DelegationStrategy["bubbling"] = 2] = "bubbling";
})(DelegationStrategy || (DelegationStrategy = {}));
var CollectionKind;
(function (CollectionKind) {
    CollectionKind[CollectionKind["indexed"] = 8] = "indexed";
    CollectionKind[CollectionKind["keyed"] = 4] = "keyed";
    CollectionKind[CollectionKind["array"] = 9] = "array";
    CollectionKind[CollectionKind["map"] = 6] = "map";
    CollectionKind[CollectionKind["set"] = 7] = "set";
})(CollectionKind || (CollectionKind = {}));
var AccessorType;
(function (AccessorType) {
    AccessorType[AccessorType["None"] = 0] = "None";
    AccessorType[AccessorType["Observer"] = 1] = "Observer";
    AccessorType[AccessorType["Node"] = 2] = "Node";
    // misc characteristic of accessors/observers when update
    //
    // by default, everything is synchronous
    // except changes that are supposed to cause reflow/heavy computation
    // an observer can use this flag to signal binding that don't carelessly tell it to update
    // queue it instead
    // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
    // todo: https://csstriggers.com/
    AccessorType[AccessorType["Layout"] = 4] = "Layout";
    // by default, everything is an object
    // eg: a property is accessed on an object
    // unless explicitly not so
    AccessorType[AccessorType["Primtive"] = 8] = "Primtive";
    AccessorType[AccessorType["Array"] = 18] = "Array";
    AccessorType[AccessorType["Set"] = 34] = "Set";
    AccessorType[AccessorType["Map"] = 66] = "Map";
})(AccessorType || (AccessorType = {}));
function copyIndexMap(existing, deletedItems) {
    const { length } = existing;
    const arr = Array(length);
    let i = 0;
    while (i < length) {
        arr[i] = existing[i];
        ++i;
    }
    if (deletedItems !== void 0) {
        arr.deletedItems = deletedItems.slice(0);
    }
    else if (existing.deletedItems !== void 0) {
        arr.deletedItems = existing.deletedItems.slice(0);
    }
    else {
        arr.deletedItems = [];
    }
    arr.isIndexMap = true;
    return arr;
}
function createIndexMap(length = 0) {
    const arr = Array(length);
    let i = 0;
    while (i < length) {
        arr[i] = i++;
    }
    arr.deletedItems = [];
    arr.isIndexMap = true;
    return arr;
}
function cloneIndexMap(indexMap) {
    const clone = indexMap.slice();
    clone.deletedItems = indexMap.deletedItems.slice();
    clone.isIndexMap = true;
    return clone;
}
function isIndexMap(value) {
    return value instanceof Array && value.isIndexMap === true;
}
//# sourceMappingURL=observation.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableArrayObservation": () => /* binding */ enableArrayObservation,
/* harmony export */   "disableArrayObservation": () => /* binding */ disableArrayObservation,
/* harmony export */   "ArrayObserver": () => /* binding */ ArrayObserver,
/* harmony export */   "ArrayIndexObserver": () => /* binding */ ArrayIndexObserver,
/* harmony export */   "getArrayObserver": () => /* binding */ getArrayObserver,
/* harmony export */   "applyMutationsToIndices": () => /* binding */ applyMutationsToIndices,
/* harmony export */   "synchronizeIndices": () => /* binding */ synchronizeIndices
/* harmony export */ });
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");
/* harmony import */ var _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");




const observerLookup = new WeakMap();
// https://tc39.github.io/ecma262/#sec-sortcompare
function sortCompare(x, y) {
    if (x === y) {
        return 0;
    }
    x = x === null ? 'null' : x.toString();
    y = y === null ? 'null' : y.toString();
    return x < y ? -1 : 1;
}
function preSortCompare(x, y) {
    if (x === void 0) {
        if (y === void 0) {
            return 0;
        }
        else {
            return 1;
        }
    }
    if (y === void 0) {
        return -1;
    }
    return 0;
}
function insertionSort(arr, indexMap, from, to, compareFn) {
    let velement, ielement, vtmp, itmp, order;
    let i, j;
    for (i = from + 1; i < to; i++) {
        velement = arr[i];
        ielement = indexMap[i];
        for (j = i - 1; j >= from; j--) {
            vtmp = arr[j];
            itmp = indexMap[j];
            order = compareFn(vtmp, velement);
            if (order > 0) {
                arr[j + 1] = vtmp;
                indexMap[j + 1] = itmp;
            }
            else {
                break;
            }
        }
        arr[j + 1] = velement;
        indexMap[j + 1] = ielement;
    }
}
function quickSort(arr, indexMap, from, to, compareFn) {
    let thirdIndex = 0, i = 0;
    let v0, v1, v2;
    let i0, i1, i2;
    let c01, c02, c12;
    let vtmp, itmp;
    let vpivot, ipivot, lowEnd, highStart;
    let velement, ielement, order, vtopElement;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (to - from <= 10) {
            insertionSort(arr, indexMap, from, to, compareFn);
            return;
        }
        thirdIndex = from + ((to - from) >> 1);
        v0 = arr[from];
        i0 = indexMap[from];
        v1 = arr[to - 1];
        i1 = indexMap[to - 1];
        v2 = arr[thirdIndex];
        i2 = indexMap[thirdIndex];
        c01 = compareFn(v0, v1);
        if (c01 > 0) {
            vtmp = v0;
            itmp = i0;
            v0 = v1;
            i0 = i1;
            v1 = vtmp;
            i1 = itmp;
        }
        c02 = compareFn(v0, v2);
        if (c02 >= 0) {
            vtmp = v0;
            itmp = i0;
            v0 = v2;
            i0 = i2;
            v2 = v1;
            i2 = i1;
            v1 = vtmp;
            i1 = itmp;
        }
        else {
            c12 = compareFn(v1, v2);
            if (c12 > 0) {
                vtmp = v1;
                itmp = i1;
                v1 = v2;
                i1 = i2;
                v2 = vtmp;
                i2 = itmp;
            }
        }
        arr[from] = v0;
        indexMap[from] = i0;
        arr[to - 1] = v2;
        indexMap[to - 1] = i2;
        vpivot = v1;
        ipivot = i1;
        lowEnd = from + 1;
        highStart = to - 1;
        arr[thirdIndex] = arr[lowEnd];
        indexMap[thirdIndex] = indexMap[lowEnd];
        arr[lowEnd] = vpivot;
        indexMap[lowEnd] = ipivot;
        partition: for (i = lowEnd + 1; i < highStart; i++) {
            velement = arr[i];
            ielement = indexMap[i];
            order = compareFn(velement, vpivot);
            if (order < 0) {
                arr[i] = arr[lowEnd];
                indexMap[i] = indexMap[lowEnd];
                arr[lowEnd] = velement;
                indexMap[lowEnd] = ielement;
                lowEnd++;
            }
            else if (order > 0) {
                do {
                    highStart--;
                    // eslint-disable-next-line eqeqeq
                    if (highStart == i) {
                        break partition;
                    }
                    vtopElement = arr[highStart];
                    order = compareFn(vtopElement, vpivot);
                } while (order > 0);
                arr[i] = arr[highStart];
                indexMap[i] = indexMap[highStart];
                arr[highStart] = velement;
                indexMap[highStart] = ielement;
                if (order < 0) {
                    velement = arr[i];
                    ielement = indexMap[i];
                    arr[i] = arr[lowEnd];
                    indexMap[i] = indexMap[lowEnd];
                    arr[lowEnd] = velement;
                    indexMap[lowEnd] = ielement;
                    lowEnd++;
                }
            }
        }
        if (to - highStart < lowEnd - from) {
            quickSort(arr, indexMap, highStart, to, compareFn);
            to = lowEnd;
        }
        else {
            quickSort(arr, indexMap, from, lowEnd, compareFn);
            from = highStart;
        }
    }
}
const proto = Array.prototype;
const $push = proto.push;
const $unshift = proto.unshift;
const $pop = proto.pop;
const $shift = proto.shift;
const $splice = proto.splice;
const $reverse = proto.reverse;
const $sort = proto.sort;
const native = { push: $push, unshift: $unshift, pop: $pop, shift: $shift, splice: $splice, reverse: $reverse, sort: $sort };
const methods = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'];
const observe = {
    // https://tc39.github.io/ecma262/#sec-array.prototype.push
    push: function (...args) {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $push.apply(this, args);
        }
        const len = this.length;
        const argCount = args.length;
        if (argCount === 0) {
            return len;
        }
        this.length = o.indexMap.length = len + argCount;
        let i = len;
        while (i < this.length) {
            this[i] = args[i - len];
            o.indexMap[i] = -2;
            i++;
        }
        o.notify();
        return this.length;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.unshift
    unshift: function (...args) {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $unshift.apply(this, args);
        }
        const argCount = args.length;
        const inserts = new Array(argCount);
        let i = 0;
        while (i < argCount) {
            inserts[i++] = -2;
        }
        $unshift.apply(o.indexMap, inserts);
        const len = $unshift.apply(this, args);
        o.notify();
        return len;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.pop
    pop: function () {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $pop.call(this);
        }
        const indexMap = o.indexMap;
        const element = $pop.call(this);
        // only mark indices as deleted if they actually existed in the original array
        const index = indexMap.length - 1;
        if (indexMap[index] > -1) {
            indexMap.deletedItems.push(indexMap[index]);
        }
        $pop.call(indexMap);
        o.notify();
        return element;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.shift
    shift: function () {
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $shift.call(this);
        }
        const indexMap = o.indexMap;
        const element = $shift.call(this);
        // only mark indices as deleted if they actually existed in the original array
        if (indexMap[0] > -1) {
            indexMap.deletedItems.push(indexMap[0]);
        }
        $shift.call(indexMap);
        o.notify();
        return element;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.splice
    splice: function (...args) {
        const start = args[0];
        const deleteCount = args[1];
        const o = observerLookup.get(this);
        if (o === void 0) {
            return $splice.apply(this, args);
        }
        const len = this.length;
        const relativeStart = start | 0;
        const actualStart = relativeStart < 0 ? Math.max((len + relativeStart), 0) : Math.min(relativeStart, len);
        const indexMap = o.indexMap;
        const argCount = args.length;
        const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;
        if (actualDeleteCount > 0) {
            let i = actualStart;
            const to = i + actualDeleteCount;
            while (i < to) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                i++;
            }
        }
        if (argCount > 2) {
            const itemCount = argCount - 2;
            const inserts = new Array(itemCount);
            let i = 0;
            while (i < itemCount) {
                inserts[i++] = -2;
            }
            $splice.call(indexMap, start, deleteCount, ...inserts);
        }
        else {
            $splice.apply(indexMap, args);
        }
        const deleted = $splice.apply(this, args);
        o.notify();
        return deleted;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
    reverse: function () {
        const o = observerLookup.get(this);
        if (o === void 0) {
            $reverse.call(this);
            return this;
        }
        const len = this.length;
        const middle = (len / 2) | 0;
        let lower = 0;
        while (lower !== middle) {
            const upper = len - lower - 1;
            const lowerValue = this[lower];
            const lowerIndex = o.indexMap[lower];
            const upperValue = this[upper];
            const upperIndex = o.indexMap[upper];
            this[lower] = upperValue;
            o.indexMap[lower] = upperIndex;
            this[upper] = lowerValue;
            o.indexMap[upper] = lowerIndex;
            lower++;
        }
        o.notify();
        return this;
    },
    // https://tc39.github.io/ecma262/#sec-array.prototype.sort
    // https://github.com/v8/v8/blob/master/src/js/array.js
    sort: function (compareFn) {
        const o = observerLookup.get(this);
        if (o === void 0) {
            $sort.call(this, compareFn);
            return this;
        }
        const len = this.length;
        if (len < 2) {
            return this;
        }
        quickSort(this, o.indexMap, 0, len, preSortCompare);
        let i = 0;
        while (i < len) {
            if (this[i] === void 0) {
                break;
            }
            i++;
        }
        if (compareFn === void 0 || typeof compareFn !== 'function' /* spec says throw a TypeError, should we do that too? */) {
            compareFn = sortCompare;
        }
        quickSort(this, o.indexMap, 0, i, compareFn);
        o.notify();
        return this;
    }
};
for (const method of methods) {
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });
}
let enableArrayObservationCalled = false;
function enableArrayObservation() {
    for (const method of methods) {
        if (proto[method].observing !== true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.defineHiddenProp)(proto, method, observe[method]);
        }
    }
}
function disableArrayObservation() {
    for (const method of methods) {
        if (proto[method].observing === true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.defineHiddenProp)(proto, method, native[method]);
        }
    }
}
class ArrayObserver {
    constructor(array) {
        this.type = 18 /* Array */;
        if (!enableArrayObservationCalled) {
            enableArrayObservationCalled = true;
            enableArrayObservation();
        }
        this.indexObservers = {};
        this.collection = array;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(array.length);
        this.lenObs = void 0;
        observerLookup.set(array, this);
    }
    notify() {
        const indexMap = this.indexMap;
        const length = this.collection.length;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(length);
        this.subs.notifyCollection(indexMap, 8 /* updateTarget */);
    }
    getLengthObserver() {
        return this.lenObs ?? (this.lenObs = new _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__.CollectionLengthObserver(this));
    }
    getIndexObserver(index) {
        var _a;
        // It's unnecessary to destroy/recreate index observer all the time,
        // so just create once, and add/remove instead
        return (_a = this.indexObservers)[index] ?? (_a[index] = new ArrayIndexObserver(this, index));
    }
}
class ArrayIndexObserver {
    constructor(owner, index) {
        this.owner = owner;
        this.index = index;
        this.value = this.getValue();
    }
    getValue() {
        return this.owner.collection[this.index];
    }
    setValue(newValue, flags) {
        if (newValue === this.getValue()) {
            return;
        }
        const arrayObserver = this.owner;
        const index = this.index;
        const indexMap = arrayObserver.indexMap;
        if (indexMap[index] > -1) {
            indexMap.deletedItems.push(indexMap[index]);
        }
        indexMap[index] = -2;
        // do not need to update current value here
        // as it will be updated inside handle collection change
        arrayObserver.collection[index] = newValue;
        arrayObserver.notify();
    }
    /**
     * From interface `ICollectionSubscriber`
     */
    handleCollectionChange(indexMap, flags) {
        const index = this.index;
        const noChange = indexMap[index] === index;
        if (noChange) {
            return;
        }
        const prevValue = this.value;
        const currValue = this.value = this.getValue();
        // hmm
        if (prevValue !== currValue) {
            this.subs.notify(currValue, prevValue, flags);
        }
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.owner.subscribe(this);
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.owner.unsubscribe(this);
        }
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(ArrayObserver);
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(ArrayIndexObserver);
function getArrayObserver(array) {
    let observer = observerLookup.get(array);
    if (observer === void 0) {
        observer = new ArrayObserver(array);
    }
    return observer;
}
/**
 * Applies offsets to the non-negative indices in the IndexMap
 * based on added and deleted items relative to those indices.
 *
 * e.g. turn `[-2, 0, 1]` into `[-2, 1, 2]`, allowing the values at the indices to be
 * used for sorting/reordering items if needed
 */
function applyMutationsToIndices(indexMap) {
    let offset = 0;
    let j = 0;
    const len = indexMap.length;
    for (let i = 0; i < len; ++i) {
        while (indexMap.deletedItems[j] <= i - offset) {
            ++j;
            --offset;
        }
        if (indexMap[i] === -2) {
            ++offset;
        }
        else {
            indexMap[i] += offset;
        }
    }
}
/**
 * After `applyMutationsToIndices`, this function can be used to reorder items in a derived
 * array (e.g.  the items in the `views` in the repeater are derived from the `items` property)
 */
function synchronizeIndices(items, indexMap) {
    const copy = items.slice();
    const len = indexMap.length;
    let to = 0;
    let from = 0;
    while (to < len) {
        from = indexMap[to];
        if (from !== -2) {
            items[to] = copy[from];
        }
        ++to;
    }
}
//# sourceMappingURL=array-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/binding-context.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BindingContext": () => /* binding */ BindingContext,
/* harmony export */   "Scope": () => /* binding */ Scope,
/* harmony export */   "OverrideContext": () => /* binding */ OverrideContext
/* harmony export */ });
const marker = Object.freeze({});
class BindingContext {
    constructor(keyOrObj, value) {
        if (keyOrObj !== void 0) {
            if (value !== void 0) {
                // if value is defined then it's just a property and a value to initialize with
                this[keyOrObj] = value;
            }
            else {
                // can either be some random object or another bindingContext to clone from
                for (const prop in keyOrObj) {
                    if (Object.prototype.hasOwnProperty.call(keyOrObj, prop)) {
                        this[prop] = keyOrObj[prop];
                    }
                }
            }
        }
    }
    static create(keyOrObj, value) {
        return new BindingContext(keyOrObj, value);
    }
    static get(scope, name, ancestor, flags, hostScope) {
        if (scope == null && hostScope == null) {
            throw new Error(`Scope is ${scope} and HostScope is ${hostScope}.`);
        }
        const hasOtherScope = hostScope !== scope && hostScope != null;
        /* eslint-disable jsdoc/check-indentation */
        /**
         * This fallback is needed to support the following case:
         * <div au-slot="s1">
         *  <let outer-host.bind="$host"></let>
         *  ${outerHost.prop}
         * </div>
         * To enable the `let` binding for 'hostScope', the property is added to `hostScope.overrideContext`. That enables us to use such let binding also inside a repeater.
         * However, as the expression `${outerHost.prop}` does not start with `$host`, it is considered that to evaluate this expression, we don't need the access to hostScope.
         * This artifact raises the need for this fallback.
         */
        /* eslint-enable jsdoc/check-indentation */
        let context = chooseContext(scope, name, ancestor);
        if (context !== null
            && ((context == null ? false : name in context)
                || !hasOtherScope)) {
            return context;
        }
        if (hasOtherScope) {
            context = chooseContext(hostScope, name, ancestor);
            if (context !== null) {
                return context;
            }
        }
        // still nothing found. return the root binding context (or null
        // if this is a parent scope traversal, to ensure we fall back to the
        // correct level)
        if (flags & 256 /* isTraversingParentScope */) {
            return marker;
        }
        return scope.bindingContext || scope.overrideContext;
    }
}
function chooseContext(scope, name, ancestor) {
    let overrideContext = scope.overrideContext;
    let currentScope = scope;
    if (ancestor > 0) {
        // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)
        while (ancestor > 0) {
            ancestor--;
            currentScope = currentScope.parentScope;
            if (currentScope?.overrideContext == null) {
                return void 0;
            }
        }
        overrideContext = currentScope.overrideContext;
        return name in overrideContext ? overrideContext : overrideContext.bindingContext;
    }
    // traverse the context and it's ancestors, searching for a context that has the name.
    while (!currentScope?.isComponentBoundary
        && overrideContext
        && !(name in overrideContext)
        && !(overrideContext.bindingContext
            && name in overrideContext.bindingContext)) {
        currentScope = currentScope.parentScope ?? null;
        overrideContext = currentScope?.overrideContext ?? null;
    }
    if (overrideContext) {
        return name in overrideContext ? overrideContext : overrideContext.bindingContext;
    }
    return null;
}
class Scope {
    constructor(parentScope, bindingContext, overrideContext, isComponentBoundary) {
        this.parentScope = parentScope;
        this.bindingContext = bindingContext;
        this.overrideContext = overrideContext;
        this.isComponentBoundary = isComponentBoundary;
    }
    static create(bc, oc, isComponentBoundary) {
        return new Scope(null, bc, oc == null ? OverrideContext.create(bc) : oc, isComponentBoundary ?? false);
    }
    static fromOverride(oc) {
        if (oc == null) {
            throw new Error(`OverrideContext is ${oc}`);
        }
        return new Scope(null, oc.bindingContext, oc, false);
    }
    static fromParent(ps, bc) {
        if (ps == null) {
            throw new Error(`ParentScope is ${ps}`);
        }
        return new Scope(ps, bc, OverrideContext.create(bc), false);
    }
}
class OverrideContext {
    constructor(bindingContext) {
        this.bindingContext = bindingContext;
    }
    static create(bc) {
        return new OverrideContext(bc);
    }
}
//# sourceMappingURL=binding-context.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionLengthObserver": () => /* binding */ CollectionLengthObserver,
/* harmony export */   "CollectionSizeObserver": () => /* binding */ CollectionSizeObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");



class CollectionLengthObserver {
    constructor(owner) {
        this.owner = owner;
        this.type = 18 /* Array */;
        this.value = (this.obj = owner.collection).length;
    }
    getValue() {
        return this.obj.length;
    }
    setValue(newValue, flags) {
        const currentValue = this.value;
        // if in the template, length is two-way bound directly
        // then there's a chance that the new value is invalid
        // add a guard so that we don't accidentally broadcast invalid values
        if (newValue !== currentValue && (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isArrayIndex)(newValue)) {
            if ((flags & 4096 /* noFlush */) === 0) {
                this.obj.length = newValue;
            }
            this.value = newValue;
            this.subs.notify(newValue, currentValue, flags | 8 /* updateTarget */);
        }
    }
    handleCollectionChange(_, flags) {
        const oldValue = this.value;
        const value = this.obj.length;
        if ((this.value = value) !== oldValue) {
            this.subs.notify(value, oldValue, flags);
        }
    }
}
class CollectionSizeObserver {
    constructor(owner) {
        this.owner = owner;
        this.value = (this.obj = owner.collection).size;
        this.type = this.obj instanceof Map ? 66 /* Map */ : 34 /* Set */;
    }
    getValue() {
        return this.obj.size;
    }
    setValue() {
        throw new Error('Map/Set "size" is a readonly property');
    }
    handleCollectionChange(_, flags) {
        const oldValue = this.value;
        const value = this.obj.size;
        this.value = value;
        if (value !== oldValue) {
            this.subs.notify(value, oldValue, flags);
        }
    }
}
function implementLengthObserver(klass) {
    const proto = klass.prototype;
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_2__.ensureProto)(proto, 'subscribe', subscribe, true);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_2__.ensureProto)(proto, 'unsubscribe', unsubscribe, true);
    (0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)(klass);
}
function subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
        this.owner.subscribe(this);
    }
}
function unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
        this.owner.subscribe(this);
    }
}
implementLengthObserver(CollectionLengthObserver);
implementLengthObserver(CollectionSizeObserver);
//# sourceMappingURL=collection-length-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComputedObserver": () => /* binding */ ComputedObserver
/* harmony export */ });
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _connectable_switcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connectable-switcher.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js");
/* harmony import */ var _binding_connectable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../binding/connectable.js */ "./node_modules/@aurelia/runtime/dist/esm/binding/connectable.js");
/* harmony import */ var _proxy_observation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy-observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");





class ComputedObserver {
    constructor(obj, get, set, useProxy, observerLocator) {
        this.obj = obj;
        this.get = get;
        this.set = set;
        this.useProxy = useProxy;
        this.observerLocator = observerLocator;
        this.interceptor = this;
        this.type = 1 /* Observer */;
        this.value = void 0;
        // todo: maybe use a counter allow recursive call to a certain level
        /**
         * @internal
         */
        this.running = false;
        this.isDirty = false;
        _binding_connectable_js__WEBPACK_IMPORTED_MODULE_2__.connectable.assignIdTo(this);
    }
    static create(obj, key, descriptor, observerLocator, useProxy) {
        const getter = descriptor.get;
        const setter = descriptor.set;
        const observer = new ComputedObserver(obj, getter, setter, useProxy, observerLocator);
        const $get = (( /* Computed Observer */) => observer.getValue());
        $get.getObserver = () => observer;
        (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_4__.def)(obj, key, {
            enumerable: descriptor.enumerable,
            configurable: true,
            get: $get,
            set: (/* Computed Observer */ v) => {
                observer.setValue(v, 0 /* none */);
            },
        });
        return observer;
    }
    getValue() {
        if (this.subs.count === 0) {
            return this.get.call(this.obj, this);
        }
        if (this.isDirty) {
            this.compute();
            this.isDirty = false;
        }
        return this.value;
    }
    // deepscan-disable-next-line
    setValue(v, _flags) {
        if (typeof this.set === 'function') {
            if (v !== this.value) {
                // setting running true as a form of batching
                this.running = true;
                this.set.call(this.obj, v);
                this.running = false;
                this.run();
            }
        }
        else {
            throw new Error('Property is readonly');
        }
    }
    handleChange() {
        this.isDirty = true;
        if (this.subs.count > 0) {
            this.run();
        }
    }
    handleCollectionChange() {
        this.isDirty = true;
        if (this.subs.count > 0) {
            this.run();
        }
    }
    subscribe(subscriber) {
        // in theory, a collection subscriber could be added before a property subscriber
        // and it should be handled similarly in subscribeToCollection
        // though not handling for now, and wait until the merge of normal + collection subscription
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.compute();
            this.isDirty = false;
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.isDirty = true;
            this.obs.clear(true);
        }
    }
    run() {
        if (this.running) {
            return;
        }
        const oldValue = this.value;
        const newValue = this.compute();
        this.isDirty = false;
        if (!Object.is(newValue, oldValue)) {
            // should optionally queue
            this.subs.notify(newValue, oldValue, 0 /* none */);
        }
    }
    compute() {
        this.running = true;
        this.obs.version++;
        try {
            (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_1__.enterConnectable)(this);
            return this.value = (0,_proxy_observation_js__WEBPACK_IMPORTED_MODULE_3__.unwrap)(this.get.call(this.useProxy ? (0,_proxy_observation_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this.obj) : this.obj, this));
        }
        finally {
            this.obs.clear(false);
            this.running = false;
            (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_1__.exitConnectable)(this);
        }
    }
}
(0,_binding_connectable_js__WEBPACK_IMPORTED_MODULE_2__.connectable)(ComputedObserver);
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(ComputedObserver);
//# sourceMappingURL=computed-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "connecting": () => /* binding */ connecting,
/* harmony export */   "pauseConnecting": () => /* binding */ pauseConnecting,
/* harmony export */   "resumeConnecting": () => /* binding */ resumeConnecting,
/* harmony export */   "currentConnectable": () => /* binding */ currentConnectable,
/* harmony export */   "enterConnectable": () => /* binding */ enterConnectable,
/* harmony export */   "exitConnectable": () => /* binding */ exitConnectable,
/* harmony export */   "ConnectableSwitcher": () => /* binding */ ConnectableSwitcher
/* harmony export */ });
/**
 * Current subscription collector
 */
let _connectable = null;
const connectables = [];
// eslint-disable-next-line
let connecting = false;
// todo: layer based collection pause/resume?
function pauseConnecting() {
    connecting = false;
}
function resumeConnecting() {
    connecting = true;
}
function currentConnectable() {
    return _connectable;
}
function enterConnectable(connectable) {
    if (connectable == null) {
        throw new Error('connectable cannot be null/undefined');
    }
    if (_connectable == null) {
        _connectable = connectable;
        connectables[0] = _connectable;
        connecting = true;
        return;
    }
    if (_connectable === connectable) {
        throw new Error(`Already in this connectable ${connectable.id}`);
    }
    connectables.push(_connectable);
    _connectable = connectable;
    connecting = true;
}
function exitConnectable(connectable) {
    if (connectable == null) {
        throw new Error('Connectable cannot be null/undefined');
    }
    if (_connectable !== connectable) {
        throw new Error(`${connectable.id} is not currently collecting`);
    }
    connectables.pop();
    _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;
    connecting = _connectable != null;
}
const ConnectableSwitcher = Object.freeze({
    get current() {
        return _connectable;
    },
    get connecting() {
        return connecting;
    },
    enter: enterConnectable,
    exit: exitConnectable,
    pause: pauseConnecting,
    resume: resumeConnecting,
});
//# sourceMappingURL=connectable-switcher.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IDirtyChecker": () => /* binding */ IDirtyChecker,
/* harmony export */   "DirtyCheckSettings": () => /* binding */ DirtyCheckSettings,
/* harmony export */   "DirtyChecker": () => /* binding */ DirtyChecker,
/* harmony export */   "DirtyCheckProperty": () => /* binding */ DirtyCheckProperty
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");


const IDirtyChecker = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IDirtyChecker', x => x.singleton(DirtyChecker));
const DirtyCheckSettings = {
    /**
     * Default: `6`
     *
     * Adjust the global dirty check frequency.
     * Measures in "timeouts per check", such that (given a default of 250 timeouts per second in modern browsers):
     * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)
     * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)
     */
    timeoutsPerCheck: 25,
    /**
     * Default: `false`
     *
     * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking
     * or an adapter, will simply not be observed.
     */
    disabled: false,
    /**
     * Default: `false`
     *
     * Throw an error if a property is being dirty-checked.
     */
    throw: false,
    /**
     * Resets all dirty checking settings to the framework's defaults.
     */
    resetToDefault() {
        this.timeoutsPerCheck = 6;
        this.disabled = false;
        this.throw = false;
    }
};
const queueTaskOpts = {
    persistent: true,
};
class DirtyChecker {
    constructor(platform) {
        this.platform = platform;
        this.tracked = [];
        this.task = null;
        this.elapsedFrames = 0;
        this.check = () => {
            if (DirtyCheckSettings.disabled) {
                return;
            }
            if (++this.elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {
                return;
            }
            this.elapsedFrames = 0;
            const tracked = this.tracked;
            const len = tracked.length;
            let current;
            let i = 0;
            for (; i < len; ++i) {
                current = tracked[i];
                if (current.isDirty()) {
                    current.flush(0 /* none */);
                }
            }
        };
    }
    createProperty(obj, propertyName) {
        if (DirtyCheckSettings.throw) {
            throw new Error(`Property '${propertyName}' is being dirty-checked.`);
        }
        return new DirtyCheckProperty(this, obj, propertyName);
    }
    addProperty(property) {
        this.tracked.push(property);
        if (this.tracked.length === 1) {
            this.task = this.platform.macroTaskQueue.queueTask(this.check, queueTaskOpts);
        }
    }
    removeProperty(property) {
        this.tracked.splice(this.tracked.indexOf(property), 1);
        if (this.tracked.length === 0) {
            this.task.cancel();
            this.task = null;
        }
    }
}
/**
 * @internal
 */
DirtyChecker.inject = [_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IPlatform];
class DirtyCheckProperty {
    constructor(dirtyChecker, obj, propertyKey) {
        this.dirtyChecker = dirtyChecker;
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.type = 0 /* None */;
    }
    getValue() {
        return this.obj[this.propertyKey];
    }
    setValue(v, f) {
        // todo: this should be allowed, probably
        // but the construction of dirty checker should throw instead
        throw new Error(`Trying to set value for property ${this.propertyKey} in dirty checker`);
    }
    isDirty() {
        return this.oldValue !== this.obj[this.propertyKey];
    }
    flush(flags) {
        const oldValue = this.oldValue;
        const newValue = this.getValue();
        this.subs.notify(newValue, oldValue, flags | 8 /* updateTarget */);
        this.oldValue = newValue;
    }
    subscribe(subscriber) {
        if (this.subs.add(subscriber) && this.subs.count === 1) {
            this.oldValue = this.obj[this.propertyKey];
            this.dirtyChecker.addProperty(this);
        }
    }
    unsubscribe(subscriber) {
        if (this.subs.remove(subscriber) && this.subs.count === 0) {
            this.dirtyChecker.removeProperty(this);
        }
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection)(DirtyCheckProperty);
//# sourceMappingURL=dirty-checker.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableMapObservation": () => /* binding */ enableMapObservation,
/* harmony export */   "disableMapObservation": () => /* binding */ disableMapObservation,
/* harmony export */   "MapObserver": () => /* binding */ MapObserver,
/* harmony export */   "getMapObserver": () => /* binding */ getMapObserver
/* harmony export */ });
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");
/* harmony import */ var _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");




const observerLookup = new WeakMap();
const proto = Map.prototype;
const $set = proto.set;
const $clear = proto.clear;
const $delete = proto.delete;
const native = { set: $set, clear: $clear, delete: $delete };
const methods = ['set', 'clear', 'delete'];
// note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls
// fortunately, map/delete/clear are easy to reconstruct for the indexMap
const observe = {
    // https://tc39.github.io/ecma262/#sec-map.prototype.map
    set: function (key, value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            $set.call(this, key, value);
            return this;
        }
        const oldValue = this.get(key);
        const oldSize = this.size;
        $set.call(this, key, value);
        const newSize = this.size;
        if (newSize === oldSize) {
            let i = 0;
            for (const entry of this.entries()) {
                if (entry[0] === key) {
                    if (entry[1] !== oldValue) {
                        o.indexMap.deletedItems.push(o.indexMap[i]);
                        o.indexMap[i] = -2;
                        o.notify();
                    }
                    return this;
                }
                i++;
            }
            return this;
        }
        o.indexMap[oldSize] = -2;
        o.notify();
        return this;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.clear
    clear: function () {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $clear.call(this);
        }
        const size = this.size;
        if (size > 0) {
            const indexMap = o.indexMap;
            let i = 0;
            // deepscan-disable-next-line
            for (const _ of this.keys()) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                i++;
            }
            $clear.call(this);
            indexMap.length = 0;
            o.notify();
        }
        return undefined;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.delete
    delete: function (value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $delete.call(this, value);
        }
        const size = this.size;
        if (size === 0) {
            return false;
        }
        let i = 0;
        const indexMap = o.indexMap;
        for (const entry of this.keys()) {
            if (entry === value) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                indexMap.splice(i, 1);
                const deleteResult = $delete.call(this, value);
                if (deleteResult === true) {
                    o.notify();
                }
                return deleteResult;
            }
            ++i;
        }
        return false;
    }
};
const descriptorProps = {
    writable: true,
    enumerable: false,
    configurable: true
};
for (const method of methods) {
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });
}
let enableMapObservationCalled = false;
function enableMapObservation() {
    for (const method of methods) {
        if (proto[method].observing !== true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: observe[method] });
        }
    }
}
function disableMapObservation() {
    for (const method of methods) {
        if (proto[method].observing === true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: native[method] });
        }
    }
}
class MapObserver {
    constructor(map) {
        this.type = 66 /* Map */;
        if (!enableMapObservationCalled) {
            enableMapObservationCalled = true;
            enableMapObservation();
        }
        this.collection = map;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(map.size);
        this.lenObs = void 0;
        observerLookup.set(map, this);
    }
    notify() {
        const indexMap = this.indexMap;
        const size = this.collection.size;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(size);
        this.subs.notifyCollection(indexMap, 8 /* updateTarget */);
    }
    getLengthObserver() {
        return this.lenObs ?? (this.lenObs = new _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__.CollectionSizeObserver(this));
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(MapObserver);
function getMapObserver(map) {
    let observer = observerLookup.get(map);
    if (observer === void 0) {
        observer = new MapObserver(map);
    }
    return observer;
}
//# sourceMappingURL=map-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/observable.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/observable.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "observable": () => /* binding */ observable
/* harmony export */ });
/* harmony import */ var _setter_observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setter-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");


function getObserversLookup(obj) {
    if (obj.$observers === void 0) {
        (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(obj, '$observers', { value: {} });
        // todo: define in a weakmap
    }
    return obj.$observers;
}
const noValue = {};
// impl, wont be seen
function observable(targetOrConfig, key, descriptor) {
    // either this check, or arguments.length === 3
    // or could be both, so can throw against user error for better DX
    if (key == null) {
        // for:
        //    @observable('prop')
        //    class {}
        //
        //    @observable({ name: 'prop', callback: ... })
        //    class {}
        //
        //    class {
        //      @observable() prop
        //      @observable({ callback: ... }) prop2
        //    }
        return ((t, k, d) => deco(t, k, d, targetOrConfig));
    }
    // for:
    //    class {
    //      @observable prop
    //    }
    return deco(targetOrConfig, key, descriptor);
    function deco(target, key, descriptor, config) {
        // class decorator?
        const isClassDecorator = key === void 0;
        config = typeof config !== 'object'
            ? { name: config }
            : (config || {});
        if (isClassDecorator) {
            key = config.name;
        }
        if (key == null || key === '') {
            throw new Error('Invalid usage, cannot determine property name for @observable');
        }
        // determine callback name based on config or convention.
        const callback = config.callback || `${String(key)}Changed`;
        let initialValue = noValue;
        if (descriptor) {
            // we're adding a getter and setter which means the property descriptor
            // cannot have a "value" or "writable" attribute
            delete descriptor.value;
            delete descriptor.writable;
            initialValue = descriptor.initializer?.();
            delete descriptor.initializer;
        }
        else {
            descriptor = { configurable: true };
        }
        // make the accessor enumerable by default, as fields are enumerable
        if (!('enumerable' in descriptor)) {
            descriptor.enumerable = true;
        }
        // todo(bigopon/fred): discuss string api for converter
        const $set = config.set;
        descriptor.get = function g( /* @observable */) {
            return getNotifier(this, key, callback, initialValue, $set).getValue();
        };
        descriptor.set = function s(newValue) {
            getNotifier(this, key, callback, initialValue, $set).setValue(newValue, 0 /* none */);
        };
        descriptor.get.getObserver = function gO(/* @observable */ obj) {
            return getNotifier(obj, key, callback, initialValue, $set);
        };
        if (isClassDecorator) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(target.prototype, key, descriptor);
        }
        else {
            return descriptor;
        }
    }
}
function getNotifier(obj, key, callbackKey, initialValue, set) {
    const lookup = getObserversLookup(obj);
    let notifier = lookup[key];
    if (notifier == null) {
        notifier = new _setter_observer_js__WEBPACK_IMPORTED_MODULE_0__.SetterNotifier(obj, callbackKey, set, initialValue === noValue ? void 0 : initialValue);
        lookup[key] = notifier;
    }
    return notifier;
}
/*
          | typescript       | babel
----------|------------------|-------------------------
property  | config           | config
w/parens  | target, key      | target, key, descriptor
----------|------------------|-------------------------
property  | target, key      | target, key, descriptor
no parens | n/a              | n/a
----------|------------------|-------------------------
class     | config           | config
          | target           | target
*/
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/observer-locator.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/observer-locator.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "propertyAccessor": () => /* binding */ propertyAccessor,
/* harmony export */   "IObserverLocator": () => /* binding */ IObserverLocator,
/* harmony export */   "INodeObserverLocator": () => /* binding */ INodeObserverLocator,
/* harmony export */   "ObserverLocator": () => /* binding */ ObserverLocator,
/* harmony export */   "getCollectionObserver": () => /* binding */ getCollectionObserver
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _array_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/array-observer.js");
/* harmony import */ var _computed_observer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computed-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/computed-observer.js");
/* harmony import */ var _dirty_checker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dirty-checker.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/dirty-checker.js");
/* harmony import */ var _map_observer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./map-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/map-observer.js");
/* harmony import */ var _primitive_observer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./primitive-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js");
/* harmony import */ var _property_accessor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./property-accessor.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js");
/* harmony import */ var _set_observer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./set-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js");
/* harmony import */ var _setter_observer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./setter-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");










const propertyAccessor = new _property_accessor_js__WEBPACK_IMPORTED_MODULE_6__.PropertyAccessor();
const IObserverLocator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('IObserverLocator', x => x.singleton(ObserverLocator));
const INodeObserverLocator = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('INodeObserverLocator', x => x.cachedCallback(handler => {
    handler.getAll(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger).forEach(logger => {
        logger.error('Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).');
    });
    return new DefaultNodeObserverLocator();
}));
class DefaultNodeObserverLocator {
    handles() {
        return false;
    }
    getObserver() {
        return propertyAccessor;
    }
    getAccessor() {
        return propertyAccessor;
    }
}
class ObserverLocator {
    constructor(dirtyChecker, nodeObserverLocator) {
        this.dirtyChecker = dirtyChecker;
        this.nodeObserverLocator = nodeObserverLocator;
        this.adapters = [];
    }
    addAdapter(adapter) {
        this.adapters.push(adapter);
    }
    getObserver(obj, key) {
        return obj.$observers?.[key]
            ?? this.cache(obj, key, this.createObserver(obj, key));
    }
    getAccessor(obj, key) {
        const cached = obj.$observers?.[key];
        if (cached !== void 0) {
            return cached;
        }
        if (this.nodeObserverLocator.handles(obj, key, this)) {
            return this.nodeObserverLocator.getAccessor(obj, key, this);
        }
        return propertyAccessor;
    }
    getArrayObserver(observedArray) {
        return (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(observedArray);
    }
    getMapObserver(observedMap) {
        return (0,_map_observer_js__WEBPACK_IMPORTED_MODULE_4__.getMapObserver)(observedMap);
    }
    getSetObserver(observedSet) {
        return (0,_set_observer_js__WEBPACK_IMPORTED_MODULE_7__.getSetObserver)(observedSet);
    }
    createObserver(obj, key) {
        if (!(obj instanceof Object)) {
            return new _primitive_observer_js__WEBPACK_IMPORTED_MODULE_5__.PrimitiveObserver(obj, key);
        }
        if (this.nodeObserverLocator.handles(obj, key, this)) {
            return this.nodeObserverLocator.getObserver(obj, key, this);
        }
        switch (key) {
            case 'length':
                if (obj instanceof Array) {
                    return (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(obj).getLengthObserver();
                }
                break;
            case 'size':
                if (obj instanceof Map) {
                    return (0,_map_observer_js__WEBPACK_IMPORTED_MODULE_4__.getMapObserver)(obj).getLengthObserver();
                }
                else if (obj instanceof Set) {
                    return (0,_set_observer_js__WEBPACK_IMPORTED_MODULE_7__.getSetObserver)(obj).getLengthObserver();
                }
                break;
            default:
                if (obj instanceof Array && (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isArrayIndex)(key)) {
                    return (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(obj).getIndexObserver(Number(key));
                }
                break;
        }
        let pd = Object.getOwnPropertyDescriptor(obj, key);
        // Only instance properties will yield a descriptor here, otherwise walk up the proto chain
        if (pd === void 0) {
            let proto = Object.getPrototypeOf(obj);
            while (proto !== null) {
                pd = Object.getOwnPropertyDescriptor(proto, key);
                if (pd === void 0) {
                    proto = Object.getPrototypeOf(proto);
                }
                else {
                    break;
                }
            }
        }
        // If the descriptor does not have a 'value' prop, it must have a getter and/or setter
        if (pd !== void 0 && !Object.prototype.hasOwnProperty.call(pd, 'value')) {
            let obs = this.getAdapterObserver(obj, key, pd);
            if (obs == null) {
                obs = (pd.get?.getObserver ?? pd.set?.getObserver)?.(obj, this);
            }
            return obs == null
                ? pd.configurable
                    ? _computed_observer_js__WEBPACK_IMPORTED_MODULE_2__.ComputedObserver.create(obj, key, pd, this, /* AOT: not true for IE11 */ true)
                    : this.dirtyChecker.createProperty(obj, key)
                : obs;
        }
        // Ordinary get/set observation (the common use case)
        // TODO: think about how to handle a data property that does not sit on the instance (should we do anything different?)
        return new _setter_observer_js__WEBPACK_IMPORTED_MODULE_8__.SetterObserver(obj, key);
    }
    getAdapterObserver(obj, propertyName, pd) {
        if (this.adapters.length > 0) {
            for (const adapter of this.adapters) {
                const observer = adapter.getObserver(obj, propertyName, pd, this);
                if (observer != null) {
                    return observer;
                }
            }
        }
        return null;
    }
    cache(obj, key, observer) {
        if (observer.doNotCache === true) {
            return observer;
        }
        if (obj.$observers === void 0) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_9__.def)(obj, '$observers', { value: { [key]: observer } });
            return observer;
        }
        return obj.$observers[key] = observer;
    }
}
ObserverLocator.inject = [_dirty_checker_js__WEBPACK_IMPORTED_MODULE_3__.IDirtyChecker, INodeObserverLocator];
function getCollectionObserver(collection) {
    let obs;
    if (collection instanceof Array) {
        obs = (0,_array_observer_js__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver)(collection);
    }
    else if (collection instanceof Map) {
        obs = (0,_map_observer_js__WEBPACK_IMPORTED_MODULE_4__.getMapObserver)(collection);
    }
    else if (collection instanceof Set) {
        obs = (0,_set_observer_js__WEBPACK_IMPORTED_MODULE_7__.getSetObserver)(collection);
    }
    return obs;
}
//# sourceMappingURL=observer-locator.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/primitive-observer.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrimitiveObserver": () => /* binding */ PrimitiveObserver
/* harmony export */ });
class PrimitiveObserver {
    constructor(obj, propertyKey) {
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.type = 0 /* None */;
    }
    get doNotCache() { return true; }
    getValue() {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-explicit-any
        return this.obj[this.propertyKey];
    }
    setValue() { }
    subscribe() { }
    unsubscribe() { }
}
//# sourceMappingURL=primitive-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/property-accessor.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyAccessor": () => /* binding */ PropertyAccessor
/* harmony export */ });
class PropertyAccessor {
    constructor() {
        // the only thing can be guaranteed is it's an object
        // even if this property accessor is used to access an element
        this.type = 0 /* None */;
    }
    getValue(obj, key) {
        return obj[key];
    }
    setValue(value, flags, obj, key) {
        obj[key] = value;
    }
}
//# sourceMappingURL=property-accessor.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/proxy-observation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rawKey": () => /* binding */ rawKey,
/* harmony export */   "wrap": () => /* binding */ wrap,
/* harmony export */   "getProxy": () => /* binding */ getProxy,
/* harmony export */   "getRaw": () => /* binding */ getRaw,
/* harmony export */   "unwrap": () => /* binding */ unwrap,
/* harmony export */   "ProxyObservable": () => /* binding */ ProxyObservable
/* harmony export */ });
/* harmony import */ var _connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./connectable-switcher.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/connectable-switcher.js");

const R$get = Reflect.get;
const toStringTag = Object.prototype.toString;
const proxyMap = new WeakMap();
function canWrap(obj) {
    switch (toStringTag.call(obj)) {
        case '[object Object]':
        case '[object Array]':
        case '[object Map]':
        case '[object Set]':
            // it's unlikely that methods on the following 2 objects need to be observed for changes
            // so while they are valid/ we don't wrap them either
            // case '[object Math]':
            // case '[object Reflect]':
            return true;
        default:
            return false;
    }
}
const rawKey = '__raw__';
function wrap(v) {
    return canWrap(v) ? getProxy(v) : v;
}
function getProxy(obj) {
    // deepscan-disable-next-line
    return proxyMap.get(obj) ?? createProxy(obj);
}
function getRaw(obj) {
    // todo: get in a weakmap if null/undef
    return obj[rawKey] ?? obj;
}
function unwrap(v) {
    // eslint-disable-next-line
    return canWrap(v) && v[rawKey] || v;
}
function doNotCollect(key) {
    return key === 'constructor'
        || key === '__proto__'
        // probably should revert to v1 naming style for consistency with builtin?
        // __o__ is shorters & less chance of conflict with other libs as well
        || key === '$observers'
        || key === Symbol.toPrimitive
        || key === Symbol.toStringTag;
}
function createProxy(obj) {
    const handler = obj instanceof Array
        ? arrayHandler
        : obj instanceof Map || obj instanceof Set
            ? collectionHandler
            : objectHandler;
    const proxiedObj = new Proxy(obj, handler);
    proxyMap.set(obj, proxiedObj);
    return proxiedObj;
}
const objectHandler = {
    get(target, key, receiver) {
        // maybe use symbol?
        if (key === rawKey) {
            return target;
        }
        const connectable = (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)();
        if (!_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.connecting || doNotCollect(key) || connectable == null) {
            return R$get(target, key, receiver);
        }
        // todo: static
        connectable.observeProperty(target, key);
        return wrap(R$get(target, key, receiver));
    },
};
const arrayHandler = {
    get(target, key, receiver) {
        // maybe use symbol?
        if (key === rawKey) {
            return target;
        }
        const connectable = (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)();
        if (!_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.connecting || doNotCollect(key) || connectable == null) {
            return R$get(target, key, receiver);
        }
        switch (key) {
            case 'length':
                connectable.observeProperty(target, 'length');
                return target.length;
            case 'map':
                return wrappedArrayMap;
            case 'includes':
                return wrappedArrayIncludes;
            case 'indexOf':
                return wrappedArrayIndexOf;
            case 'lastIndexOf':
                return wrappedArrayLastIndexOf;
            case 'every':
                return wrappedArrayEvery;
            case 'filter':
                return wrappedArrayFilter;
            case 'findIndex':
                return wrappedArrayFindIndex;
            case 'flat':
                return wrappedArrayFlat;
            case 'flatMap':
                return wrappedArrayFlatMap;
            case 'join':
                return wrappedArrayJoin;
            case 'push':
                return wrappedArrayPush;
            case 'pop':
                return wrappedArrayPop;
            case 'reduce':
                return wrappedReduce;
            case 'reduceRight':
                return wrappedReduceRight;
            case 'reverse':
                return wrappedArrayReverse;
            case 'shift':
                return wrappedArrayShift;
            case 'unshift':
                return wrappedArrayUnshift;
            case 'slice':
                return wrappedArraySlice;
            case 'splice':
                return wrappedArraySplice;
            case 'some':
                return wrappedArraySome;
            case 'sort':
                return wrappedArraySort;
            case 'keys':
                return wrappedKeys;
            case 'values':
            case Symbol.iterator:
                return wrappedValues;
            case 'entries':
                return wrappedEntries;
        }
        connectable.observeProperty(target, key);
        return wrap(R$get(target, key, receiver));
    },
    // for (let i in array) ...
    ownKeys(target) {
        (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeProperty(target, 'length');
        return Reflect.ownKeys(target);
    },
};
function wrappedArrayMap(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.map((v, i) => 
    // do we wrap `thisArg`?
    unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArrayEvery(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.every((v, i) => cb.call(thisArg, wrap(v), i, this));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayFilter(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.filter((v, i) => 
    // do we wrap `thisArg`?
    unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArrayIncludes(v) {
    const raw = getRaw(this);
    const res = raw.includes(unwrap(v));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayIndexOf(v) {
    const raw = getRaw(this);
    const res = raw.indexOf(unwrap(v));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayLastIndexOf(v) {
    const raw = getRaw(this);
    const res = raw.lastIndexOf(unwrap(v));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayFindIndex(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.findIndex((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArrayFlat() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(raw.flat());
}
function wrappedArrayFlatMap(cb, thisArg) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return getProxy(raw.flatMap((v, i) => wrap(cb.call(thisArg, wrap(v), i, this))));
}
function wrappedArrayJoin(separator) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return raw.join(separator);
}
function wrappedArrayPop() {
    return wrap(getRaw(this).pop());
}
function wrappedArrayPush(...args) {
    return getRaw(this).push(...args);
}
function wrappedArrayShift() {
    return wrap(getRaw(this).shift());
}
function wrappedArrayUnshift(...args) {
    return getRaw(this).unshift(...args);
}
function wrappedArraySplice(...args) {
    return wrap(getRaw(this).splice(...args));
}
function wrappedArrayReverse(...args) {
    const raw = getRaw(this);
    const res = raw.reverse();
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArraySome(cb, thisArg) {
    const raw = getRaw(this);
    const res = raw.some((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return res;
}
function wrappedArraySort(cb) {
    const raw = getRaw(this);
    const res = raw.sort(cb);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedArraySlice(start, end) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return getProxy(raw.slice(start, end));
}
function wrappedReduce(cb, initValue) {
    const raw = getRaw(this);
    const res = raw.reduce((curr, v, i) => cb(curr, wrap(v), i, this), initValue);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
function wrappedReduceRight(cb, initValue) {
    const raw = getRaw(this);
    const res = raw.reduceRight((curr, v, i) => cb(curr, wrap(v), i, this), initValue);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(res);
}
// the below logic takes inspiration from Vue, Mobx
// much thanks to them for working out this
const collectionHandler = {
    get(target, key, receiver) {
        // maybe use symbol?
        if (key === rawKey) {
            return target;
        }
        const connectable = (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)();
        if (!_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.connecting || doNotCollect(key) || connectable == null) {
            return R$get(target, key, receiver);
        }
        switch (key) {
            case 'size':
                connectable.observeProperty(target, 'size');
                return target.size;
            case 'clear':
                return wrappedClear;
            case 'delete':
                return wrappedDelete;
            case 'forEach':
                return wrappedForEach;
            case 'add':
                if (target instanceof Set) {
                    return wrappedAdd;
                }
                break;
            case 'get':
                if (target instanceof Map) {
                    return wrappedGet;
                }
                break;
            case 'set':
                if (target instanceof Map) {
                    return wrappedSet;
                }
                break;
            case 'has':
                return wrappedHas;
            case 'keys':
                return wrappedKeys;
            case 'values':
                return wrappedValues;
            case 'entries':
                return wrappedEntries;
            case Symbol.iterator:
                return target instanceof Map ? wrappedEntries : wrappedValues;
        }
        return wrap(R$get(target, key, receiver));
    },
};
function wrappedForEach(cb, thisArg) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return raw.forEach((v, key) => {
        cb.call(/* should wrap or not?? */ thisArg, wrap(v), wrap(key), this);
    });
}
function wrappedHas(v) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return raw.has(unwrap(v));
}
function wrappedGet(k) {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    return wrap(raw.get(unwrap(k)));
}
function wrappedSet(k, v) {
    return wrap(getRaw(this).set(unwrap(k), unwrap(v)));
}
function wrappedAdd(v) {
    return wrap(getRaw(this).add(unwrap(v)));
}
function wrappedClear() {
    return wrap(getRaw(this).clear());
}
function wrappedDelete(k) {
    return wrap(getRaw(this).delete(unwrap(k)));
}
function wrappedKeys() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    const iterator = raw.keys();
    return {
        next() {
            const next = iterator.next();
            const value = next.value;
            const done = next.done;
            return done
                ? { value: void 0, done }
                : { value: wrap(value), done };
        },
        [Symbol.iterator]() {
            return this;
        },
    };
}
function wrappedValues() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    const iterator = raw.values();
    return {
        next() {
            const next = iterator.next();
            const value = next.value;
            const done = next.done;
            return done
                ? { value: void 0, done }
                : { value: wrap(value), done };
        },
        [Symbol.iterator]() {
            return this;
        },
    };
}
function wrappedEntries() {
    const raw = getRaw(this);
    (0,_connectable_switcher_js__WEBPACK_IMPORTED_MODULE_0__.currentConnectable)()?.observeCollection(raw);
    const iterator = raw.entries();
    // return a wrapped iterator which returns observed versions of the
    // values emitted from the real iterator
    return {
        next() {
            const next = iterator.next();
            const value = next.value;
            const done = next.done;
            return done
                ? { value: void 0, done }
                : { value: [wrap(value[0]), wrap(value[1])], done };
        },
        [Symbol.iterator]() {
            return this;
        },
    };
}
const ProxyObservable = Object.freeze({
    getProxy,
    getRaw,
    wrap,
    unwrap,
    rawKey,
});
//# sourceMappingURL=proxy-observation.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/set-observer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enableSetObservation": () => /* binding */ enableSetObservation,
/* harmony export */   "disableSetObservation": () => /* binding */ disableSetObservation,
/* harmony export */   "SetObserver": () => /* binding */ SetObserver,
/* harmony export */   "getSetObserver": () => /* binding */ getSetObserver
/* harmony export */ });
/* harmony import */ var _observation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observation.js */ "./node_modules/@aurelia/runtime/dist/esm/observation.js");
/* harmony import */ var _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collection-length-observer.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/collection-length-observer.js");
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");




const observerLookup = new WeakMap();
const proto = Set.prototype;
const $add = proto.add;
const $clear = proto.clear;
const $delete = proto.delete;
const native = { add: $add, clear: $clear, delete: $delete };
const methods = ['add', 'clear', 'delete'];
// note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls
// fortunately, add/delete/clear are easy to reconstruct for the indexMap
const observe = {
    // https://tc39.github.io/ecma262/#sec-set.prototype.add
    add: function (value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            $add.call(this, value);
            return this;
        }
        const oldSize = this.size;
        $add.call(this, value);
        const newSize = this.size;
        if (newSize === oldSize) {
            return this;
        }
        o.indexMap[oldSize] = -2;
        o.notify();
        return this;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.clear
    clear: function () {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $clear.call(this);
        }
        const size = this.size;
        if (size > 0) {
            const indexMap = o.indexMap;
            let i = 0;
            // deepscan-disable-next-line
            for (const _ of this.keys()) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                i++;
            }
            $clear.call(this);
            indexMap.length = 0;
            o.notify();
        }
        return undefined;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.delete
    delete: function (value) {
        const o = observerLookup.get(this);
        if (o === undefined) {
            return $delete.call(this, value);
        }
        const size = this.size;
        if (size === 0) {
            return false;
        }
        let i = 0;
        const indexMap = o.indexMap;
        for (const entry of this.keys()) {
            if (entry === value) {
                if (indexMap[i] > -1) {
                    indexMap.deletedItems.push(indexMap[i]);
                }
                indexMap.splice(i, 1);
                const deleteResult = $delete.call(this, value);
                if (deleteResult === true) {
                    o.notify();
                }
                return deleteResult;
            }
            i++;
        }
        return false;
    }
};
const descriptorProps = {
    writable: true,
    enumerable: false,
    configurable: true
};
for (const method of methods) {
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });
}
let enableSetObservationCalled = false;
function enableSetObservation() {
    for (const method of methods) {
        if (proto[method].observing !== true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: observe[method] });
        }
    }
}
function disableSetObservation() {
    for (const method of methods) {
        if (proto[method].observing === true) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_3__.def)(proto, method, { ...descriptorProps, value: native[method] });
        }
    }
}
class SetObserver {
    constructor(observedSet) {
        this.type = 34 /* Set */;
        if (!enableSetObservationCalled) {
            enableSetObservationCalled = true;
            enableSetObservation();
        }
        this.collection = observedSet;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(observedSet.size);
        this.lenObs = void 0;
        observerLookup.set(observedSet, this);
    }
    notify() {
        const indexMap = this.indexMap;
        const size = this.collection.size;
        this.indexMap = (0,_observation_js__WEBPACK_IMPORTED_MODULE_0__.createIndexMap)(size);
        this.subs.notifyCollection(indexMap, 8 /* updateTarget */);
    }
    getLengthObserver() {
        return this.lenObs ?? (this.lenObs = new _collection_length_observer_js__WEBPACK_IMPORTED_MODULE_1__.CollectionSizeObserver(this));
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_2__.subscriberCollection)(SetObserver);
function getSetObserver(observedSet) {
    let observer = observerLookup.get(observedSet);
    if (observer === void 0) {
        observer = new SetObserver(observedSet);
    }
    return observer;
}
//# sourceMappingURL=set-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/setter-observer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SetterObserver": () => /* binding */ SetterObserver,
/* harmony export */   "SetterNotifier": () => /* binding */ SetterNotifier
/* harmony export */ });
/* harmony import */ var _subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscriber-collection.js */ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js");
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");


/**
 * Observer for the mutation of object property value employing getter-setter strategy.
 * This is used for observing object properties that has no decorator.
 */
class SetterObserver {
    constructor(obj, propertyKey) {
        this.obj = obj;
        this.propertyKey = propertyKey;
        this.currentValue = void 0;
        this.oldValue = void 0;
        this.inBatch = false;
        this.observing = false;
        // todo(bigopon): tweak the flag based on typeof obj (array/set/map/iterator/proxy etc...)
        this.type = 1 /* Observer */;
    }
    getValue() {
        return this.currentValue;
    }
    setValue(newValue, flags) {
        if (this.observing) {
            const currentValue = this.currentValue;
            this.currentValue = newValue;
            this.subs.notify(newValue, currentValue, flags);
        }
        else {
            // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,
            // so calling obj[propertyKey] will actually return this.currentValue.
            // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor
            // is unmodified and we need to explicitly set the property value.
            // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.
            // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.
            this.obj[this.propertyKey] = newValue;
        }
    }
    subscribe(subscriber) {
        if (this.observing === false) {
            this.start();
        }
        this.subs.add(subscriber);
    }
    start() {
        if (this.observing === false) {
            this.observing = true;
            this.currentValue = this.obj[this.propertyKey];
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(this.obj, this.propertyKey, {
                enumerable: true,
                configurable: true,
                get: ( /* Setter Observer */) => this.getValue(),
                set: (/* Setter Observer */ value) => {
                    this.setValue(value, 0 /* none */);
                },
            });
        }
        return this;
    }
    stop() {
        if (this.observing) {
            (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_1__.def)(this.obj, this.propertyKey, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: this.currentValue,
            });
            this.observing = false;
            // todo(bigopon/fred): add .removeAllSubscribers()
        }
        return this;
    }
}
class SetterNotifier {
    constructor(obj, callbackKey, set, initialValue) {
        this.type = 1 /* Observer */;
        /**
         * @internal
         */
        this.v = void 0;
        this.obj = obj;
        this.s = set;
        const callback = obj[callbackKey];
        this.cb = typeof callback === 'function' ? callback : void 0;
        this.v = initialValue;
    }
    getValue() {
        return this.v;
    }
    setValue(value, flags) {
        if (typeof this.s === 'function') {
            value = this.s(value);
        }
        const oldValue = this.v;
        if (!Object.is(value, oldValue)) {
            this.v = value;
            this.cb?.call(this.obj, value, oldValue, flags);
            // there's a chance that cb.call(...)
            // changes the latest value of this observer
            // and thus making `value` stale
            // so for now, call with this.v
            // todo: should oldValue be treated the same way?
            this.subs.notify(this.v, oldValue, flags);
        }
    }
}
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(SetterObserver);
(0,_subscriber_collection_js__WEBPACK_IMPORTED_MODULE_0__.subscriberCollection)(SetterNotifier);
//# sourceMappingURL=setter-observer.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js":
/*!************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/signaler.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISignaler": () => /* binding */ ISignaler,
/* harmony export */   "Signaler": () => /* binding */ Signaler
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");

const ISignaler = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createInterface('ISignaler', x => x.singleton(Signaler));
class Signaler {
    constructor() {
        this.signals = Object.create(null);
    }
    dispatchSignal(name, flags) {
        const listeners = this.signals[name];
        if (listeners === undefined) {
            return;
        }
        for (const listener of listeners.keys()) {
            listener.handleChange(undefined, undefined, flags | 8 /* updateTarget */);
        }
    }
    addSignalListener(name, listener) {
        const signals = this.signals;
        const listeners = signals[name];
        if (listeners === undefined) {
            signals[name] = new Set([listener]);
        }
        else {
            listeners.add(listener);
        }
    }
    removeSignalListener(name, listener) {
        const listeners = this.signals[name];
        if (listeners) {
            listeners.delete(listener);
        }
    }
}
//# sourceMappingURL=signaler.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/observation/subscriber-collection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscriberCollection": () => /* binding */ subscriberCollection,
/* harmony export */   "SubscriberRecord": () => /* binding */ SubscriberRecord
/* harmony export */ });
/* harmony import */ var _utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities-objects.js */ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js");

function subscriberCollection(target) {
    return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target);
}
function subscriberCollectionDeco(target) {
    const proto = target.prototype;
    // not configurable, as in devtool, the getter could be invoked on the prototype,
    // and become permanently broken
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.def)(proto, 'subs', { get: getSubscriberRecord });
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'subscribe', addSubscriber);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.ensureProto)(proto, 'unsubscribe', removeSubscriber);
}
/* eslint-enable @typescript-eslint/ban-types */
class SubscriberRecord {
    constructor(owner) {
        /**
         * subscriber flags: bits indicating the existence status of the subscribers of this record
         */
        this._sf = 0 /* None */;
        this.count = 0;
        this.owner = owner;
    }
    add(subscriber) {
        if (this.has(subscriber)) {
            return false;
        }
        const subscriberFlags = this._sf;
        if ((subscriberFlags & 1 /* Subscriber0 */) === 0) {
            this._s0 = subscriber;
            this._sf |= 1 /* Subscriber0 */;
        }
        else if ((subscriberFlags & 2 /* Subscriber1 */) === 0) {
            this._s1 = subscriber;
            this._sf |= 2 /* Subscriber1 */;
        }
        else if ((subscriberFlags & 4 /* Subscriber2 */) === 0) {
            this._s2 = subscriber;
            this._sf |= 4 /* Subscriber2 */;
        }
        else if ((subscriberFlags & 8 /* SubscribersRest */) === 0) {
            this._sr = [subscriber];
            this._sf |= 8 /* SubscribersRest */;
        }
        else {
            this._sr.push(subscriber); // Non-null is implied by else branch of (subscriberFlags & SF.SubscribersRest) === 0
        }
        ++this.count;
        return true;
    }
    has(subscriber) {
        // Flags here is just a perf tweak
        // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;
        // and minor slow-down when it does, and the former is more common than the latter.
        const subscriberFlags = this._sf;
        if ((subscriberFlags & 1 /* Subscriber0 */) > 0 && this._s0 === subscriber) {
            return true;
        }
        if ((subscriberFlags & 2 /* Subscriber1 */) > 0 && this._s1 === subscriber) {
            return true;
        }
        if ((subscriberFlags & 4 /* Subscriber2 */) > 0 && this._s2 === subscriber) {
            return true;
        }
        if ((subscriberFlags & 8 /* SubscribersRest */) > 0) {
            const subscribers = this._sr; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0
            const ii = subscribers.length;
            let i = 0;
            for (; i < ii; ++i) {
                if (subscribers[i] === subscriber) {
                    return true;
                }
            }
        }
        return false;
    }
    any() {
        return this._sf !== 0 /* None */;
    }
    remove(subscriber) {
        const subscriberFlags = this._sf;
        if ((subscriberFlags & 1 /* Subscriber0 */) > 0 && this._s0 === subscriber) {
            this._s0 = void 0;
            this._sf = (this._sf | 1 /* Subscriber0 */) ^ 1 /* Subscriber0 */;
            --this.count;
            return true;
        }
        else if ((subscriberFlags & 2 /* Subscriber1 */) > 0 && this._s1 === subscriber) {
            this._s1 = void 0;
            this._sf = (this._sf | 2 /* Subscriber1 */) ^ 2 /* Subscriber1 */;
            --this.count;
            return true;
        }
        else if ((subscriberFlags & 4 /* Subscriber2 */) > 0 && this._s2 === subscriber) {
            this._s2 = void 0;
            this._sf = (this._sf | 4 /* Subscriber2 */) ^ 4 /* Subscriber2 */;
            --this.count;
            return true;
        }
        else if ((subscriberFlags & 8 /* SubscribersRest */) > 0) {
            const subscribers = this._sr; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0
            const ii = subscribers.length;
            let i = 0;
            for (; i < ii; ++i) {
                if (subscribers[i] === subscriber) {
                    subscribers.splice(i, 1);
                    if (ii === 1) {
                        this._sf = (this._sf | 8 /* SubscribersRest */) ^ 8 /* SubscribersRest */;
                    }
                    --this.count;
                    return true;
                }
            }
        }
        return false;
    }
    notify(val, oldVal, flags) {
        /**
         * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this
         * callSubscribers invocation, so we're caching them all before invoking any.
         * Subscribers added during this invocation are not invoked (and they shouldn't be).
         * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,
         * however this is accounted for via $isBound and similar flags on the subscriber objects)
         */
        const owner = this.owner;
        const sub0 = this._s0;
        const sub1 = this._s1;
        const sub2 = this._s2;
        let subs = this._sr;
        if (subs !== void 0) {
            subs = subs.slice();
        }
        flags = (flags | 24 /* update */) ^ 24 /* update */;
        if (sub0 !== void 0) {
            sub0.handleChange(val, oldVal, flags | /* sub own flags */ (sub0.id === void 0 ? 0 : owner[sub0.id]));
        }
        if (sub1 !== void 0) {
            sub1.handleChange(val, oldVal, flags | /* sub own flags */ (sub1.id === void 0 ? 0 : owner[sub1.id]));
        }
        if (sub2 !== void 0) {
            sub2.handleChange(val, oldVal, flags | /* sub own flags */ (sub2.id === void 0 ? 0 : owner[sub2.id]));
        }
        if (subs !== void 0) {
            const ii = subs.length;
            let sub;
            let i = 0;
            for (; i < ii; ++i) {
                sub = subs[i];
                if (sub !== void 0) {
                    sub.handleChange(val, oldVal, flags | /* sub own flags */ (sub.id === void 0 ? 0 : owner[sub.id]));
                }
            }
        }
    }
    notifyCollection(indexMap, flags) {
        const sub0 = this._s0;
        const sub1 = this._s1;
        const sub2 = this._s2;
        let subs = this._sr;
        if (subs !== void 0) {
            subs = subs.slice();
        }
        if (sub0 !== void 0) {
            sub0.handleCollectionChange(indexMap, flags);
        }
        if (sub1 !== void 0) {
            sub1.handleCollectionChange(indexMap, flags);
        }
        if (sub2 !== void 0) {
            sub2.handleCollectionChange(indexMap, flags);
        }
        if (subs !== void 0) {
            const ii = subs.length;
            let sub;
            let i = 0;
            for (; i < ii; ++i) {
                sub = subs[i];
                if (sub !== void 0) {
                    sub.handleCollectionChange(indexMap, flags);
                }
            }
        }
    }
}
function getSubscriberRecord() {
    const record = new SubscriberRecord(this);
    (0,_utilities_objects_js__WEBPACK_IMPORTED_MODULE_0__.defineHiddenProp)(this, 'subs', record);
    return record;
}
function addSubscriber(subscriber) {
    return this.subs.add(subscriber);
}
function removeSubscriber(subscriber) {
    return this.subs.remove(subscriber);
}
//# sourceMappingURL=subscriber-collection.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/utilities-objects.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "def": () => /* binding */ def,
/* harmony export */   "defineHiddenProp": () => /* binding */ defineHiddenProp,
/* harmony export */   "ensureProto": () => /* binding */ ensureProto
/* harmony export */ });
const def = Reflect.defineProperty;
function defineHiddenProp(obj, key, value) {
    def(obj, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value
    });
}
function ensureProto(proto, key, defaultValue, force = false) {
    if (force || !Object.prototype.hasOwnProperty.call(proto, key)) {
        defineHiddenProp(proto, key, defaultValue);
    }
}
//# sourceMappingURL=utilities-objects.js.map

/***/ }),

/***/ "./node_modules/@aurelia/runtime/dist/esm/value-converter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@aurelia/runtime/dist/esm/value-converter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "valueConverter": () => /* binding */ valueConverter,
/* harmony export */   "ValueConverterDefinition": () => /* binding */ ValueConverterDefinition,
/* harmony export */   "ValueConverter": () => /* binding */ ValueConverter
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _alias_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alias.js */ "./node_modules/@aurelia/runtime/dist/esm/alias.js");


function valueConverter(nameOrDef) {
    return function (target) {
        return ValueConverter.define(nameOrDef, target);
    };
}
class ValueConverterDefinition {
    constructor(Type, name, aliases, key) {
        this.Type = Type;
        this.name = name;
        this.aliases = aliases;
        this.key = key;
    }
    static create(nameOrDef, Type) {
        let name;
        let def;
        if (typeof nameOrDef === 'string') {
            name = nameOrDef;
            def = { name };
        }
        else {
            name = nameOrDef.name;
            def = nameOrDef;
        }
        return new ValueConverterDefinition(Type, (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.firstDefined)(ValueConverter.getAnnotation(Type, 'name'), name), (0,_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(ValueConverter.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases), ValueConverter.keyFrom(name));
    }
    register(container) {
        const { Type, key, aliases } = this;
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.singleton(key, Type).register(container);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.aliasTo(key, Type).register(container);
        (0,_alias_js__WEBPACK_IMPORTED_MODULE_1__.registerAliases)(aliases, ValueConverter, key, container);
    }
}
const ValueConverter = {
    name: _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.keyFor('value-converter'),
    keyFrom(name) {
        return `${ValueConverter.name}:${name}`;
    },
    isType(value) {
        return typeof value === 'function' && _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.hasOwn(ValueConverter.name, value);
    },
    define(nameOrDef, Type) {
        const definition = ValueConverterDefinition.create(nameOrDef, Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(ValueConverter.name, definition, definition.Type);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(ValueConverter.name, definition, definition);
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.resource.appendTo(Type, ValueConverter.name);
        return definition.Type;
    },
    getDefinition(Type) {
        const def = _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(ValueConverter.name, Type);
        if (def === void 0) {
            throw new Error(`No definition found for type ${Type.name}`);
        }
        return def;
    },
    annotate(Type, prop, value) {
        _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.define(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), value, Type);
    },
    getAnnotation(Type, prop) {
        return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata.getOwn(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Protocol.annotation.keyFor(prop), Type);
    },
};
//# sourceMappingURL=value-converter.js.map

/***/ }),

/***/ "./src/app.html":
/*!**********************!*\
  !*** ./src/app.html ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _reset_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reset.css */ "./src/reset.css");
/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app.css */ "./src/app.css");




const name = "app";
const template = "<template>\n  \n  \n\n  <div id=\"au-dev-root\" class=\"${isDarkTheme ? 'dark' : ''}\">\n    <h1 class=\"app-header\">\n      <aurelia-logo></aurelia-logo>\n      <span class=\"logo-badge\">INSPECTOR</span>\n    </h1>\n\n    <main>\n      <p class=\"not-found\" style=\"margin-bottom: 10px\">\n        Select a node through the inspect window to scope into that node. Click\n        on the value will allow one to edit the value and bind to the view.\n      </p>\n      <!-- <debug-group heading=\"Binding Context\" show.bind=\"true\">\n        <template if.bind=\"debugInfo.bindingContext\">\n          <ul>\n            <li repeat.for=\"property of debugInfo.bindingContext.properties\">\n              <property-view property.bind=\"property\"></property-view>\n            </li>\n          </ul>\n        </template>\n        <template if.bind=\"!debugInfo.bindingContext\">\n          <span class=\"not-found\"\n            >No binding context found for the selected node.</span\n          >\n        </template>\n      </debug-group>\n\n      <debug-group heading=\"Override Context\">\n        <template\n          if.bind=\"debugInfo.overrideContext && debugInfo.overrideContext.properties.length\"\n        >\n          <ul>\n            <li repeat.for=\"property of debugInfo.overrideContext.properties\">\n              <property-view property.bind=\"property\"></property-view>\n            </li>\n          </ul>\n        </template>\n        <template\n          if.bind=\"!debugInfo.overrideContext || !debugInfo.overrideContext.properties.length\"\n        >\n          <span class=\"not-found\"\n            >No override context found for the selected node.</span\n          >\n        </template>\n      </debug-group> -->\n\n      <debug-group heading=\"Custom Element\">\n        <template au-slot>\n          <span if.bind=\"!selectedElement\" class=\"not-found\"\n            >The selected node is not a custom element.</span\n          >\n          <controller-view\n            else\n            controller.bind=\"selectedElement\"\n          ></controller-view>\n        </template>\n      </debug-group>\n\n      <debug-group heading=\"Custom Attributes\">\n        <template au-slot>\n          <span if.bind=\"!selectedElementAttributes\" class=\"not-found\"\n            >No custom attributes found on the selected node.</span\n          >\n          <ul else>\n            <li\n              repeat.for=\"customAttribute of selectedElementAttributes\"\n              class=\"custom-attribute\"\n            >\n              <h3 class=\"attribute-name\">${customAttribute.name}</h3>\n              &nbsp;<span class=\"block-token\">{</span>\n              <controller-view\n                controller.bind=\"customAttribute\"\n              ></controller-view>\n              <span class=\"block-token\">}</span>\n            </li>\n          </ul>\n        </template>\n      </debug-group>\n    </main>\n\n    <!-- <main>\n      <custom-element if.bind=\"selectedElement\">\n        ${JSON.stringify(selectedElement)}\n        <div>Name = ${selectedElement.name}</div>\n        <div>Key = ${selectedElement.key}</div>\n        <div>Aliases = ${selectedElement.aliases.join(', ')}</div>\n        <h3>Bindables</h3>\n        <div repeat.for=\"value of selectedElement.bindables\">\n          ${value.name} =\n          <input\n            value.bind=\"value.value\"\n            keyup.delegate=\"valueChanged(selectedElement)\"\n          />\n        </div>\n        <hr />\n      </custom-element>\n    </main> -->\n  </div>\n</template>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _reset_css__WEBPACK_IMPORTED_MODULE_2__.default, _app_css__WEBPACK_IMPORTED_MODULE_3__.default) ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/aurelia-logo.html":
/*!**************************************************!*\
  !*** ./src/resources/elements/aurelia-logo.html ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");

const name = "aurelia-logo";
const template = "<template>\n  <svg height=\"28px\" viewBox=\"315 19 140 41\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <defs>\n      <linearGradient x1=\"-388.147851%\" y1=\"-144.177425%\" x2=\"237.683809%\" y2=\"430.405754%\" id=\"linearGradient-1\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"72.9454854%\" y1=\"84.4240777%\" x2=\"-97.0517904%\" y2=\"-147.696591%\" id=\"linearGradient-2\">\n        <stop stop-color=\"#6E4D9B\" offset=\"0%\"></stop>\n        <stop stop-color=\"#77327A\" offset=\"14%\"></stop>\n        <stop stop-color=\"#B31777\" offset=\"29%\"></stop>\n        <stop stop-color=\"#CD0F7E\" offset=\"84%\"></stop>\n        <stop stop-color=\"#ED2C89\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-283.884079%\" y1=\"-693.599872%\" x2=\"287.537417%\" y2=\"101.70976%\" id=\"linearGradient-3\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-821.186214%\" y1=\"-469.047862%\" x2=\"101.985142%\" y2=\"288.23598%\" id=\"linearGradient-4\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-140.359373%\" y1=\"-230.925718%\" x2=\"419.012316%\" y2=\"261.976742%\" id=\"linearGradient-5\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"191.083716%\" y1=\"253.952517%\" x2=\"20.3577022%\" y2=\"20.4029283%\" id=\"linearGradient-6\">\n        <stop stop-color=\"#6E4D9B\" offset=\"0%\"></stop>\n        <stop stop-color=\"#77327A\" offset=\"14%\"></stop>\n        <stop stop-color=\"#B31777\" offset=\"29%\"></stop>\n        <stop stop-color=\"#CD0F7E\" offset=\"84%\"></stop>\n        <stop stop-color=\"#ED2C89\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"-388.094004%\" y1=\"-173.850055%\" x2=\"237.674802%\" y2=\"518.990225%\" id=\"linearGradient-7\">\n        <stop stop-color=\"#C06FBB\" offset=\"0%\"></stop>\n        <stop stop-color=\"#6E4D9B\" offset=\"100%\"></stop>\n      </linearGradient>\n      <linearGradient x1=\"11.1884561%\" y1=\"89.6525993%\" x2=\"90.145125%\" y2=\"11.5773982%\" id=\"linearGradient-8\">\n        <stop stop-color=\"#6E4D9B\" offset=\"0%\"></stop>\n        <stop stop-color=\"#77327A\" offset=\"14%\"></stop>\n        <stop stop-color=\"#B31777\" offset=\"53%\"></stop>\n        <stop stop-color=\"#CD0F7E\" offset=\"79%\"></stop>\n        <stop stop-color=\"#ED2C89\" offset=\"100%\"></stop>\n      </linearGradient>\n      <rect id=\"path-9\" x=\"0.627498256\" y=\"0\" width=\"34\" height=\"16\" rx=\"2\"></rect>\n      <filter x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\" filterUnits=\"objectBoundingBox\" id=\"filter-10\">\n        <feOffset dx=\"0\" dy=\"1\" in=\"SourceAlpha\" result=\"shadowOffsetOuter1\"></feOffset>\n        <feColorMatrix values=\"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.15 0\" type=\"matrix\" in=\"shadowOffsetOuter1\"></feColorMatrix>\n      </filter>\n    </defs>\n    <g id=\"Group-3\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" transform=\"translate(317.000000, 21.000000)\">\n      <g id=\"Icon\" transform=\"translate(18.821436, 18.821436) rotate(11.283864) translate(-18.821436, -18.821436) translate(2.821436, 2.821436)\">\n        <g id=\"Group\" transform=\"translate(16.062217, 4.314649) rotate(-11.283864) translate(-16.062217, -4.314649) translate(12.909354, 0.852682)\"\n          fill=\"url(#linearGradient-1)\">\n          <polygon id=\"Shape\" points=\"6.24514134 4.78196568 3.21344731 6.8053618 0.0902584276 2.12490594 3.12195246 0.101509821\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(24.576671, 23.606062) rotate(-11.283864) translate(-24.576671, -23.606062) translate(18.394587, 16.929411)\"\n          fill=\"url(#linearGradient-2)\">\n          <polygon id=\"Shape\" points=\"7.16404632 1.47319064 12.3440146 9.23541541 6.17342916 13.3533016 0.993460912 5.5909532 0.0897638609 4.23695315 6.26047291 0.119066939\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.064001, 27.069671) rotate(-11.283864) translate(-16.064001, -27.069671) translate(12.602034, 23.854988)\"\n          fill=\"url(#linearGradient-3)\">\n          <polygon id=\"Shape\" points=\"5.69777962 1.46663763 6.83825049 3.17561295 2.14147393 6.30992958 0.0973060035 3.24683056 1.12340832 2.56210293 4.79420621 0.11251393\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(27.417287, 15.726712) rotate(-11.283864) translate(-27.417287, -15.726712) translate(24.820812, 13.130236)\"\n          fill=\"url(#linearGradient-4)\">\n          <path d=\"M1.81703815,0.894671208 L3.13444027,0.0155788519 L5.17848455,3.07867787 L2.14641959,5.10207399 L1.00594872,3.39309867 L2.72061156,2.24879491 L1.81703815,0.894671208 L1.81703815,0.894671208 Z M1.00594872,3.39309867 L0.102375312,2.03897497 L1.81703815,0.894671208 L2.72061156,2.24879491 L1.00594872,3.39309867 L1.00594872,3.39309867 Z\"\n            id=\"Shape\"></path>\n        </g>\n        <g id=\"Group\" transform=\"translate(4.721041, 15.716385) rotate(-11.283864) translate(-4.721041, -15.716385) translate(0.764507, 11.759851)\"\n          fill=\"url(#linearGradient-5)\">\n          <polygon id=\"Shape\" points=\"4.17241219 7.1450055 3.14643351 7.82973313 0.0229973528 3.14927727 4.71977391 0.0149606435 6.90909717 3.29579267 3.23842293 5.74538166 6.90909717 3.29579267 7.84321007 4.69554014\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(8.822560, 7.837609) rotate(-11.283864) translate(-8.822560, -7.837609) translate(2.640476, 1.160958)\"\n          fill=\"url(#linearGradient-6)\">\n          <polygon id=\"Shape\" points=\"11.3428879 7.75332257 12.2768771 9.15307005 6.10616809 13.2709563 5.17217883 11.8712088 0.0406781133 4.18168531 6.21138716 0.0637991077\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.122857, 4.300703) rotate(-11.283864) translate(-16.122857, -4.300703) translate(12.969994, 0.900557)\"\n          fill=\"url(#linearGradient-7)\">\n          <polygon id=\"Shape\" points=\"4.86604202 5.6013391 3.15137918 6.74551923 2.21726628 5.34589539 0.0279430201 2.06506337 3.06000798 0.0416672467 6.18344414 4.72212311\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(15.822071, 25.857155) rotate(-11.283864) translate(-15.822071, -25.857155) translate(13.472879, 23.878888)\"\n          fill=\"#714896\">\n          <polygon id=\"Shape\" points=\"0.914330236 3.91622662 0.0106331846 2.56210293 3.68143107 0.11251393 4.58500448 1.46663763\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(26.180721, 15.532164) rotate(-11.283864) translate(-26.180721, -15.532164) translate(24.758842, 14.233926)\"\n          fill=\"#6F4795\">\n          <polygon id=\"Shape\" points=\"1.00594872 2.5276069 0.102375312 1.1734832 1.81703815 0.0291794369 2.72061156 1.38330313\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(6.539242, 16.614393) rotate(-11.283864) translate(-6.539242, -16.614393) translate(4.190050, 14.636126)\"\n          fill=\"#88519F\">\n          <polygon id=\"Shape\" points=\"0.957728466 3.93032178 0.0237392029 2.53069794 3.69441345 0.0811089432 4.62852635 1.48085642\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.885795, 6.228777) rotate(-11.283864) translate(-16.885795, -6.228777) translate(15.463916, 4.868718)\"\n          fill=\"#85509E\">\n          <polygon id=\"Shape\" points=\"1.04947059 2.66534373 0.115357689 1.26571989 1.83014417 0.121416131 2.76413343 1.52116361\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(21.280404, 20.355313) rotate(-11.283864) translate(-21.280404, -20.355313) translate(17.694795, 17.511554)\"\n          fill=\"#8D166A\">\n          <polygon id=\"Shape\" points=\"7.16404632 1.47319064 0.993460912 5.5909532 0.0897638609 4.23695315 6.26047291 0.119066939\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(12.058201, 11.100454) rotate(-11.283864) translate(-12.058201, -11.100454) translate(8.410771, 8.256696)\"\n          fill=\"#A70D6F\">\n          <polygon id=\"Shape\" points=\"6.27357893 0.0875383106 7.20756819 1.48728579 1.03685914 5.605172 0.102869879 4.20542452\"></polygon>\n        </g>\n        <g id=\"Group\" transform=\"translate(1.853411, 10.678267) rotate(45.000000) translate(-1.853411, -10.678267) translate(0.797906, 9.622762)\"\n          fill=\"#9E61AD\">\n          <rect id=\"Rectangle-path\" x=\"1.66662571e-15\" y=\"0\" width=\"2.0982715\" height=\"2.0982715\"></rect>\n        </g>\n        <g id=\"Group\" transform=\"translate(12.115669, 29.966366) rotate(45.000000) translate(-12.115669, -29.966366) translate(11.060163, 28.910860)\"\n          fill=\"#8053A3\">\n          <rect id=\"Rectangle-path\" x=\"1.66662571e-15\" y=\"0\" width=\"2.0982715\" height=\"2.0982715\"></rect>\n        </g>\n        <g id=\"Group\" transform=\"translate(16.641954, 16.427437) rotate(0.000000) translate(-16.641954, -16.427437) translate(1.422442, 1.207924)\"\n          fill=\"url(#linearGradient-8)\">\n          <polygon id=\"Shape\" points=\"6.53446157 29.8878978 0.012982374 23.3175801 23.2186668 0.0630572451 29.9596099 6.46398583\"></polygon>\n        </g>\n      </g>\n      <g id=\"Aurelia-+-Type-something\" transform=\"translate(38.131960, 3.021427)\">\n        <g id=\"Aurelia\" transform=\"translate(0.929505, 0.290297)\">\n          <g id=\"A\" transform=\"translate(0.076673, 8.413465)\" fill=\"#ED2C88\">\n            <path d=\"M8.79524752,16.5403564 C8.91089109,16.5398812 9.02811881,16.5376634 9.14376238,16.5325941 C9.38930693,16.5216634 9.63326733,16.4993267 9.87722772,16.4652673 C10.5853465,16.3659406 11.2792079,16.167604 11.9334653,15.8765941 C12.7429703,15.5166733 13.4891089,15.0162376 14.1306931,14.4050693 C14.7358416,13.8271683 15.2475248,13.1512079 15.6388119,12.4104554 C15.969901,11.7821782 16.2138614,11.1084356 16.3611881,10.4133069 C16.540198,9.56356436 16.5750495,8.68324752 16.4657426,7.82178218 C16.3643564,7.03271287 16.1425743,6.26043564 15.8051485,5.53964356 C15.4186139,4.70954455 14.8815842,3.95025743 14.230495,3.30645545 C13.5445545,2.62922772 12.7334653,2.08110891 11.8479208,1.70011881 C11.3679208,1.49354455 10.8657426,1.33607921 10.3540594,1.23136634 C9.87405941,1.13314851 9.38455446,1.0810297 8.8950495,1.07485149 C8.41821782,1.06883168 7.94138614,1.10590099 7.47247525,1.18669307 C6.94019802,1.27841584 6.41742574,1.42653465 5.91524752,1.62788119 C5.03445545,1.98130693 4.22178218,2.49916832 3.52633663,3.14582178 C2.84514851,3.78011881 2.27960396,4.53687129 1.86455446,5.37061386 C1.51287129,6.08079208 1.27049505,6.8449901 1.15009901,7.6289901 C1.0170297,8.50407921 1.03287129,9.40229703 1.20079208,10.2718416 C1.3370297,10.9859802 1.57623762,11.6801584 1.90732673,12.3274455 C2.28910891,13.0731089 2.79287129,13.7552475 3.39326733,14.3405941 C4.01425743,14.9482772 4.73821782,15.450297 5.52712871,15.8181386 C6.15920792,16.1134257 6.83247525,16.321901 7.52,16.4359604 C7.76079208,16.4758812 8.00475248,16.504396 8.24871287,16.5213465 C8.38019802,16.5305347 8.51168317,16.5359208 8.64475248,16.5389307 C8.69544554,16.5397228 8.74455446,16.540198 8.79524752,16.5403564 L8.79524752,16.5403564 Z M16.8538614,12.199604 C16.769901,12.3988911 16.6780198,12.5950099 16.579802,12.7874851 C16.1330693,13.6613069 15.5374257,14.4579802 14.8261386,15.1353663 C14.1275248,15.8018218 13.3180198,16.3518416 12.440396,16.7550099 C11.7053465,17.0924356 10.9243564,17.3265743 10.1259406,17.4487129 C9.85188119,17.4905347 9.57623762,17.5193663 9.2990099,17.5350495 C9.16910891,17.542495 9.03762376,17.5466139 8.90772277,17.5486733 C8.86970297,17.5491485 8.83168317,17.5493069 8.79524752,17.5494653 C8.66376238,17.5489901 8.53227723,17.5466139 8.40079208,17.5407525 C8.12356436,17.528396 7.84792079,17.5030495 7.57227723,17.4647129 C6.77069307,17.352396 5.9849505,17.1277624 5.24514851,16.7987327 C4.34693069,16.3988911 3.51683168,15.8460198 2.80079208,15.1714851 C2.07366337,14.4861782 1.46534653,13.6768317 1.00910891,12.7874851 C0.641584158,12.0712871 0.375445545,11.3045545 0.218613861,10.5151683 C0.0316831683,9.57037624 0.00316831683,8.59453465 0.12990099,7.63992079 C0.247128713,6.76625743 0.495841584,5.91128713 0.86970297,5.11271287 C1.31485149,4.15857426 1.93425743,3.28760396 2.68831683,2.55192079 C3.46613861,1.79073267 4.38811881,1.17671287 5.39089109,0.752316832 C5.92,0.528633663 6.47128713,0.35770297 7.03366337,0.242693069 C7.59445545,0.128 8.16633663,0.0687524752 8.73821782,0.0652673267 C9.31168317,0.0616237624 9.88514851,0.113584158 10.4491089,0.221465347 C11.0130693,0.329663366 11.5675248,0.493940594 12.099802,0.711287129 C13.1089109,1.12364356 14.0372277,1.72689109 14.8261386,2.4790495 C15.5754455,3.1930297 16.1964356,4.03960396 16.6510891,4.96918812 C16.7223762,5.11588119 16.790495,5.26447525 16.8538614,5.4149703 L16.8538614,0.0944158416 L17.8439604,0.0944158416 L17.8439604,17.5201584 L16.8538614,17.5201584 L16.8538614,12.199604 L16.8538614,12.199604 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"U\" transform=\"translate(20.353901, 8.413465)\" fill=\"#CD0F7E\">\n            <path d=\"M16.5370297,12.8188515 C16.1710891,13.5234851 15.7116832,14.1790099 15.1714851,14.761505 C14.710495,15.2605149 14.1893069,15.7056634 13.6253465,16.0845941 C13.0106931,16.4967921 12.3421782,16.8299406 11.6435644,17.0724752 C11.0637624,17.2736634 10.4617822,17.4122772 9.85188119,17.4859406 C9.64910891,17.510495 9.44792079,17.5277624 9.24356436,17.5380594 C9.13108911,17.5437624 9.02019802,17.5469307 8.90772277,17.5486733 C8.86970297,17.5491485 8.83168317,17.5493069 8.79524752,17.5494653 C8.68118812,17.5491485 8.57029703,17.5472475 8.45623762,17.5429703 C8.21544554,17.5339406 7.97465347,17.5149307 7.73544554,17.486099 C7.03366337,17.401505 6.3429703,17.2318416 5.68079208,16.981703 C4.68910891,16.6065743 3.76712871,16.0505347 2.97188119,15.3492277 C2.40792079,14.8505347 1.90574257,14.2788119 1.48752475,13.6519604 C1.03445545,12.9745743 0.678019802,12.2330297 0.435643564,11.4553663 C0.256633663,10.8830099 0.139405941,10.291802 0.0855445545,9.69473267 C0.0586138614,9.39865347 0.0491089109,9.10162376 0.0522772277,8.80443564 L0.0522772277,0.0944158416 L1.06138614,0.0944158416 L1.06138614,8.81013861 L1.06138614,8.91453465 L1.06138614,9.0140198 C1.0629703,9.1130297 1.06455446,9.21188119 1.07089109,9.31073267 C1.0819802,9.53805941 1.10415842,9.76491089 1.13584158,9.99033663 C1.22772277,10.6333465 1.40356436,11.264 1.66019802,11.8613861 C2.01980198,12.7047921 2.53623762,13.4792871 3.16990099,14.1414653 C3.79564356,14.7939802 4.53544554,15.3357624 5.3449505,15.7362376 C6.05940594,16.0890297 6.82772277,16.3310891 7.6150495,16.4511683 C8.42613861,16.5747327 9.25782178,16.5704554 10.0673267,16.4359604 C10.7057426,16.3296634 11.3314851,16.1416238 11.9239604,15.8769109 C12.7714851,15.4979802 13.5477228,14.9631683 14.2067327,14.3089109 C14.8340594,13.6853861 15.3536634,12.9552475 15.740198,12.1587327 C16.0586139,11.5003564 16.2835644,10.7976238 16.4087129,10.0771485 C16.4578218,9.80308911 16.4910891,9.52665347 16.510099,9.24926733 C16.5180198,9.11651485 16.5243564,8.98376238 16.5275248,8.85069307 L16.5275248,8.80316832 L16.5370297,0.0944158416 L17.5271287,0.0944158416 L17.5271287,17.5201584 L16.5370297,17.5201584 L16.5370297,12.8188515 L16.5370297,12.8188515 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"R\" transform=\"translate(40.314297, 8.413465)\" fill=\"#B31776\">\n            <path d=\"M1.06455446,8.41552475 L1.04237624,17.5201584 L0.0522772277,17.5201584 L0.0522772277,0.0944158416 L1.04237624,0.0944158416 L1.04237624,4.55524752 C1.16594059,4.32966337 1.30059406,4.10978218 1.44316832,3.89639604 C1.83287129,3.31691089 2.29544554,2.78637624 2.81346535,2.31889109 C3.57069307,1.63611881 4.44831683,1.08910891 5.39405941,0.706693069 C6.08950495,0.425188119 6.82138614,0.232871287 7.56594059,0.133386139 C7.82257426,0.0993267327 8.07920792,0.076039604 8.33742574,0.0635247525 C8.48633663,0.0563960396 8.63524752,0.0532277228 8.78415842,0.0527524752 L8.78732673,1.08641584 C8.75247525,1.08657426 8.71920792,1.08673267 8.68594059,1.0870495 C8.65267327,1.08752475 8.61940594,1.08815842 8.58613861,1.0889505 C8.47049505,1.0919604 8.35485149,1.09687129 8.23920792,1.10463366 C7.99524752,1.12079208 7.75287129,1.14788119 7.51207921,1.18590099 C6.87366337,1.28681188 6.24792079,1.46550495 5.65227723,1.71849505 C4.82693069,2.0700198 4.06178218,2.56506931 3.40594059,3.17813861 C2.94653465,3.60712871 2.5409901,4.09346535 2.20356436,4.62320792 C1.85663366,5.16673267 1.5809901,5.75619802 1.38930693,6.37180198 C1.25306931,6.80966337 1.15960396,7.26035644 1.10891089,7.71611881 C1.0819802,7.94851485 1.06930693,8.18186139 1.06455446,8.41552475 L1.06455446,8.41552475 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"E\" transform=\"translate(48.393505, 8.413465)\" fill=\"#9B2073\">\n            <path d=\"M9.3750495,17.5510495 L8.81584158,17.5493069 C8.77940594,17.5488317 8.74138614,17.5483564 8.70336634,17.5478812 C8.59089109,17.5453465 8.48,17.5413861 8.36752475,17.5350495 C8.12831683,17.5214257 7.88910891,17.4979802 7.65148515,17.4647129 C6.98930693,17.3720396 6.33980198,17.2033267 5.71722772,16.9623762 C4.68277228,16.5620594 3.72910891,15.9626139 2.9180198,15.2072871 C2.12118812,14.4663762 1.46534653,13.5773465 0.993267327,12.5975446 C0.643168317,11.8707327 0.394455446,11.0954455 0.258217822,10.3003564 C0.0934653465,9.35081188 0.0887128713,8.37386139 0.239207921,7.42241584 C0.400792079,6.41489109 0.73980198,5.43778218 1.23722772,4.54732673 C1.78376238,3.56879208 2.52039604,2.69845545 3.39326733,1.99524752 C3.85742574,1.62075248 4.36118812,1.29394059 4.89188119,1.02178218 C5.3829703,0.770217822 5.89782178,0.565544554 6.42851485,0.411564356 C7.18574257,0.191524752 7.97148515,0.0757227723 8.76039604,0.0657425743 C9.64118812,0.0546534653 10.5235644,0.175366337 11.369505,0.426772277 C12.3184158,0.709386139 13.2182178,1.15564356 14.019802,1.73972277 C14.8673267,2.35849505 15.6023762,3.12966337 16.1805941,4.00665347 C16.5592079,4.58233663 16.869703,5.2030099 17.1025743,5.85172277 C17.3417822,6.51675248 17.4986139,7.21093069 17.569901,7.91413861 C17.5920792,8.13607921 17.6063366,8.35881188 17.6126733,8.58186139 C17.6126733,8.63825743 17.6142574,8.69449505 17.6142574,8.75073267 C17.6158416,8.78732673 17.6158416,8.82582178 17.6126733,8.86209901 C17.609505,8.8809505 17.6063366,8.89964356 17.6031683,8.91817822 C17.590495,8.97346535 17.5683168,9.02669307 17.5382178,9.07469307 C17.4780198,9.17132673 17.3845545,9.24562376 17.2768317,9.28332673 C17.2419802,9.29584158 17.2039604,9.30439604 17.1675248,9.30867327 C17.1485149,9.31073267 17.129505,9.31073267 17.110495,9.31184158 L9.0819802,9.31184158 L9.0819802,8.30273267 L16.5893069,8.30273267 C16.5718812,8.02867327 16.540198,7.75588119 16.4926733,7.48530693 C16.4023762,6.95271287 16.2534653,6.42962376 16.0522772,5.92807921 C15.7623762,5.20538614 15.3615842,4.528 14.8689109,3.92443564 C14.3112871,3.24007921 13.6364356,2.65188119 12.8823762,2.19342574 C12.2645545,1.81845545 11.5960396,1.53077228 10.8974257,1.34194059 C10.0625743,1.11588119 9.18970297,1.03287129 8.32633663,1.09322772 C7.90653465,1.12253465 7.48831683,1.18590099 7.07960396,1.28316832 C6.63287129,1.38914851 6.19722772,1.53520792 5.77584158,1.7189703 C4.89346535,2.10487129 4.08554455,2.65790099 3.40435644,3.33908911 C3.08752475,3.65655446 2.79762376,4.00158416 2.53940594,4.3689505 C2.21623762,4.82835644 1.94376238,5.32261386 1.72831683,5.84079208 C1.50336634,6.38384158 1.34019802,6.95287129 1.24356436,7.53314851 C1.16594059,8.00332673 1.13267327,8.48063366 1.14059406,8.95730693 C1.15168317,9.49449505 1.21663366,10.0305743 1.3370297,10.5541386 C1.47643564,11.1535842 1.68712871,11.7362376 1.96435644,12.2856238 C2.26534653,12.8817426 2.6439604,13.4382574 3.08594059,13.9375842 C3.49782178,14.4007921 3.96356436,14.8145743 4.47207921,15.1673663 C4.88237624,15.4514059 5.31960396,15.6958416 5.77584158,15.895604 C6.25584158,16.1050297 6.75485149,16.2653465 7.26653465,16.3733861 C7.59920792,16.4437228 7.93821782,16.4918812 8.27722772,16.517703 C8.45940594,16.5314851 8.64,16.5384554 8.82217822,16.540198 L9.37821782,16.5419406 C9.37821782,16.8782574 9.37663366,17.2145743 9.3750495,17.5510495 L9.3750495,17.5510495 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"L\" transform=\"translate(68.512317, 0.017426)\" fill=\"#8F2475\">\n            <path d=\"M5.15009901,25.945505 C4.98851485,25.9450297 4.82693069,25.9401188 4.66534653,25.9291881 C4.32475248,25.9062178 3.98415842,25.8577426 3.65148515,25.7802772 C3.31881188,25.7026535 2.99089109,25.5957228 2.67881188,25.4566337 C2.29227723,25.2849109 1.92633663,25.0642376 1.60158416,24.7947723 C1.43049505,24.6548911 1.27207921,24.5020198 1.12633663,24.3375842 C0.942574257,24.1314851 0.780990099,23.9074851 0.641584158,23.6692277 C0.467326733,23.3699802 0.331089109,23.0491881 0.234455446,22.7168317 C0.163168317,22.4693861 0.112475248,22.2157624 0.083960396,21.9597624 C0.0601980198,21.7470099 0.0491089109,21.5329901 0.0522772277,21.3189703 L0.0522772277,0.140673267 L1.06138614,0.140673267 L1.06138614,21.3253069 L1.06138614,21.430495 C1.0629703,21.5691089 1.07089109,21.7077228 1.08673267,21.8455446 C1.11207921,22.0673267 1.15643564,22.2870495 1.2229703,22.5001188 C1.30217822,22.7510495 1.40990099,22.9927921 1.54772277,23.2172673 C1.65227723,23.3893069 1.77425743,23.5510495 1.91049505,23.699802 C2.01821782,23.8186139 2.13544554,23.9291881 2.26059406,24.0305743 C2.36514851,24.1161188 2.4760396,24.1953267 2.59009901,24.2680396 C2.68831683,24.3306139 2.78970297,24.3884356 2.89267327,24.441505 C3.38534653,24.6930693 3.92712871,24.8370693 4.47524752,24.8991683 C4.70019802,24.9246733 4.92673267,24.9357624 5.15168317,24.936396 C5.15168317,25.2727129 5.15009901,25.6090297 5.15009901,25.945505 L5.15009901,25.945505 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"I\" transform=\"translate(75.957861, 0.017426)\" fill=\"#78327A\">\n            <path d=\"M0.148910891,25.916198 L0.148910891,8.49045545 L1.1390099,8.49045545 L1.1390099,25.916198 L0.148910891,25.916198 L0.148910891,25.916198 Z M0.153663366,2.47065347 L0.153663366,0.140673267 L1.13584158,0.140673267 L1.13584158,2.47065347 L0.153663366,2.47065347 L0.153663366,2.47065347 Z\"\n              id=\"Shape\"></path>\n          </g>\n          <g id=\"A1\" transform=\"translate(79.601426, 8.413465)\" fill=\"#6E4D9B\">\n            <path d=\"M8.79524752,16.5403564 C8.91089109,16.5398812 9.02811881,16.5376634 9.14376238,16.5325941 C9.38930693,16.5216634 9.63326733,16.4993267 9.87722772,16.4652673 C10.5853465,16.3659406 11.2792079,16.167604 11.9334653,15.8765941 C12.6716832,15.5480396 13.3576238,15.1027327 13.959604,14.5626931 C14.6281188,13.9616634 15.1920792,13.2446733 15.6166337,12.451802 C15.9588119,11.811802 16.2106931,11.1236436 16.3611881,10.4133069 C16.5433663,9.54756436 16.5766337,8.65029703 16.4594059,7.77330693 C16.3548515,6.98550495 16.1267327,6.21528713 15.7861386,5.49718812 C15.3932673,4.66946535 14.8514851,3.91382178 14.1972277,3.27382178 C13.5065347,2.60055446 12.6922772,2.0570297 11.8051485,1.68174257 C11.3378218,1.48419802 10.849901,1.33291089 10.3540594,1.23136634 C9.85663366,1.12982178 9.35128713,1.07754455 8.84435644,1.07437624 C8.33742574,1.07120792 7.82891089,1.1169901 7.32990099,1.21251485 C6.83089109,1.30819802 6.34138614,1.45346535 5.87247525,1.64546535 C4.9790099,2.01029703 4.15683168,2.54415842 3.45980198,3.20950495 C2.7960396,3.84126733 2.24633663,4.59041584 1.8439604,5.41275248 C1.49544554,6.12546535 1.25782178,6.89188119 1.14376238,7.6769901 C1.01861386,8.53671287 1.0360396,9.41813861 1.20079208,10.2716832 C1.34336634,11.0167129 1.59683168,11.7395644 1.95009901,12.4104554 C2.34138614,13.1512079 2.85306931,13.8271683 3.45980198,14.4050693 C4.07762376,14.9945347 4.79366337,15.4813465 5.56990099,15.8379406 C6.21940594,16.1362376 6.91009901,16.3432871 7.61663366,16.4511683 C7.8590099,16.4882376 8.1029703,16.5135842 8.34693069,16.5275248 C8.46257426,16.5341782 8.57821782,16.5378218 8.69386139,16.5397228 C8.72871287,16.5400396 8.76039604,16.540198 8.79524752,16.5403564 L8.79524752,16.5403564 Z M16.8538614,12.199604 C16.769901,12.3988911 16.6780198,12.5950099 16.579802,12.7874851 C16.1251485,13.6768317 15.5152475,14.4861782 14.7881188,15.1714851 C14.0720792,15.8460198 13.2435644,16.3988911 12.3437624,16.7987327 C11.6039604,17.1277624 10.8182178,17.352396 10.0166337,17.4647129 C9.74257426,17.5030495 9.46534653,17.528396 9.18811881,17.5407525 C9.05663366,17.5466139 8.92514851,17.5489901 8.79524752,17.5494653 C8.66376238,17.5489901 8.53227723,17.5466139 8.40079208,17.5407525 C8.12356436,17.528396 7.84792079,17.5030495 7.57227723,17.4647129 C6.77069307,17.352396 5.9849505,17.1277624 5.24514851,16.7987327 C4.33108911,16.3917624 3.48673267,15.8262178 2.76277228,15.1353663 C2.05306931,14.4579802 1.45742574,13.6613069 1.00910891,12.7874851 C0.633663366,12.0551287 0.364356436,11.269703 0.209108911,10.4616238 C0.0316831683,9.53362376 0.00475247525,8.57631683 0.12990099,7.63976238 C0.248712871,6.74867327 0.506930693,5.87706931 0.891881188,5.06471287 C1.34336634,4.11342574 1.96752475,3.24641584 2.72475248,2.51548515 C3.50891089,1.75873267 4.43405941,1.15009901 5.44,0.731722772 C5.98811881,0.504237624 6.55841584,0.332990099 7.13980198,0.221465347 C7.68475248,0.117069307 8.23920792,0.0651089109 8.79524752,0.0651089109 C9.34970297,0.0651089109 9.90415842,0.117069307 10.4491089,0.221465347 C11.030495,0.332990099 11.6007921,0.504237624 12.1489109,0.731722772 C13.1548515,1.15009901 14.08,1.75873267 14.8641584,2.51532673 C15.6087129,3.23390099 16.2249505,4.08443564 16.6748515,5.01687129 C16.7382178,5.1480396 16.7968317,5.28079208 16.8538614,5.4149703 L16.8538614,0.0944158416 L17.8439604,0.0944158416 L17.8439604,17.5201584 C17.8423762,17.5393267 16.8538614,17.5201584 16.8538614,17.5201584 L16.8538614,12.199604 L16.8538614,12.199604 Z\"\n              id=\"Shape\"></path>\n          </g>\n        </g>\n      </g>\n    </g>\n  </svg>\n</template>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [  ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/controller-view.html":
/*!*****************************************************!*\
  !*** ./src/resources/elements/controller-view.html ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "bindables": () => /* binding */ bindables,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _controller_view_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./controller-view.css */ "./src/resources/elements/controller-view.css");



const name = "controller-view";
const template = "<template >\n  \n\n  <div class=\"category\" if.bind=\"controller.bindables.length\">\n    <h4 class=\"category-name\">Bindables</h4>\n    <ul class=\"properties\">\n      <li repeat.for=\"bindable of controller.bindables\">\n        <property-view\n          controller.bind=\"controller\"\n          property.bind=\"bindable\"\n        ></property-view>\n      </li>\n    </ul>\n  </div>\n\n  <div class=\"category\" if.bind=\"controller.properties.length\">\n    <h4 class=\"category-name\">Properties</h4>\n    <ul class=\"properties\">\n      <li repeat.for=\"property of controller.properties\">\n        <property-view\n          controller.bind=\"controller\"\n          property.bind=\"property\"\n        ></property-view>\n      </li>\n    </ul>\n  </div>\n</template>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _controller_view_css__WEBPACK_IMPORTED_MODULE_2__.default) ];
const bindables = {"controller":{}};
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies, bindables });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/debug-group.html":
/*!*************************************************!*\
  !*** ./src/resources/elements/debug-group.html ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _debug_group_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug-group.css */ "./src/resources/elements/debug-group.css");



const name = "debug-group";
const template = "\n<section>\n  <h2 class=\"header\">${heading}</h2>\n  <div class=\"content\">\n    <au-slot></au-slot>\n  </div>\n</section>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _debug_group_css__WEBPACK_IMPORTED_MODULE_2__.default) ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./src/resources/elements/property-view.html":
/*!***************************************************!*\
  !*** ./src/resources/elements/property-view.html ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => /* binding */ name,
/* harmony export */   "template": () => /* binding */ template,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "dependencies": () => /* binding */ dependencies,
/* harmony export */   "register": () => /* binding */ register
/* harmony export */ });
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _property_view_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./property-view.css */ "./src/resources/elements/property-view.css");



const name = "property-view";
const template = "\n\n<span class=\"property-line\">\n  <span\n    css=\"opacity: ${property.canExpand ? 1 : 0}\"\n    class=\"arrow\"\n    click.trigger=\"debugHost.toggleDebugValueExpansion(property)\"\n  >\n    <span if.bind=\"property.isExpanded\" class=\"down\">▼</span>\n    <span if.bind=\"!property.isExpanded\" class=\"right\">▶</span>\n  </span>\n  <span class=\"property-name\">${property.name}</span\n  ><span class=\"token-colon\">:</span>&nbsp;\n\n  <span class=\"value-container\">\n    <span\n      if.bind=\"property.type === 'string' && !property.isEditing\"\n      class=\"property-value string\"\n      >\"</span\n    ><span\n      if.bind=\"!property.isEditing\"\n      class=\"property-value ${property.type}\"\n      click.trigger=\"beginEditing()\"\n      >${property.value}</span\n    ><span\n      if.bind=\"property.type === 'string' && !property.isEditing\"\n      class=\"property-value string\"\n      >\"</span\n    >\n\n    <!-- <select\n      if.bind=\"property.isEditing &&  property.type === 'boolean'\"\n      class=\"property-editor\"\n      value.bind=\"false\"\n    >\n      <option model.bind=\"true\">True</option>\n      <option model.bind=\"false\">False</option>\n    </select> -->\n\n    <input\n      if.bind=\"property.isEditing\"\n      class=\"property-editor\"\n      ref=\"editor\"\n      type=\"text\"\n      value.bind=\"property.value\"\n      keyup.trigger=\"onKeyDown($event)\"\n      blur.trigger=\"endEditing()\"\n    />\n  </span>\n</span>\n\n<ul if.bind=\"property.isExpanded && property.expandedValue\" class=\"properties\">\n  <div\n    if.bind=\"!property.expandedValue.properties.length\"\n    class=\"no-properties\"\n  >\n    Object has no properties.\n  </div>\n  <li repeat.for=\"p of property.expandedValue.properties\">\n    <property-view property.bind=\"p\"></property-view>\n  </li>\n</ul>\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);
const dependencies = [ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_1__.Registration.defer('.css', _property_view_css__WEBPACK_IMPORTED_MODULE_2__.default) ];
let _e;
function register(container) {
  if (!_e) {
    _e = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_0__.CustomElement.define({ name, template, dependencies });
  }
  container.register(_e);
}


/***/ }),

/***/ "./node_modules/aurelia/dist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/aurelia/dist/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PLATFORM": () => /* binding */ PLATFORM,
/* harmony export */   "IPlatform": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IPlatform,
/* harmony export */   "Aurelia": () => /* binding */ Aurelia,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "json": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.json,
/* harmony export */   "HttpClientConfiguration": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.HttpClientConfiguration,
/* harmony export */   "HttpClient": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.HttpClient,
/* harmony export */   "IHttpClient": () => /* reexport safe */ _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__.IHttpClient,
/* harmony export */   "all": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.all,
/* harmony export */   "DI": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI,
/* harmony export */   "IContainer": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IContainer,
/* harmony export */   "inject": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.inject,
/* harmony export */   "IServiceLocator": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IServiceLocator,
/* harmony export */   "lazy": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.lazy,
/* harmony export */   "optional": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.optional,
/* harmony export */   "Registration": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration,
/* harmony export */   "singleton": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.singleton,
/* harmony export */   "transient": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.transient,
/* harmony export */   "InstanceProvider": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.InstanceProvider,
/* harmony export */   "Metadata": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Metadata,
/* harmony export */   "ColorOptions": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ColorOptions,
/* harmony export */   "ILogger": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.ILogger,
/* harmony export */   "LoggerConfiguration": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.LoggerConfiguration,
/* harmony export */   "emptyArray": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyArray,
/* harmony export */   "emptyObject": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.emptyObject,
/* harmony export */   "noop": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.noop,
/* harmony export */   "LogLevel": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.LogLevel,
/* harmony export */   "EventAggregator": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.EventAggregator,
/* harmony export */   "IEventAggregator": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.IEventAggregator,
/* harmony export */   "isArrayIndex": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.isArrayIndex,
/* harmony export */   "camelCase": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.camelCase,
/* harmony export */   "kebabCase": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.kebabCase,
/* harmony export */   "pascalCase": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.pascalCase,
/* harmony export */   "toArray": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.toArray,
/* harmony export */   "bound": () => /* reexport safe */ _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.bound,
/* harmony export */   "NavRoute": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.NavRoute,
/* harmony export */   "RouterOptions": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.RouterOptions,
/* harmony export */   "IRouter": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.IRouter,
/* harmony export */   "Router": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.Router,
/* harmony export */   "ViewportInstruction": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.ViewportInstruction,
/* harmony export */   "RouterConfiguration": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.RouterConfiguration,
/* harmony export */   "RouterRegistration": () => /* reexport safe */ _aurelia_router__WEBPACK_IMPORTED_MODULE_4__.RouterRegistration,
/* harmony export */   "ComputedObserver": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ComputedObserver,
/* harmony export */   "ComputedWatcher": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ComputedWatcher,
/* harmony export */   "ExpressionWatcher": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ExpressionWatcher,
/* harmony export */   "Watch": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Watch,
/* harmony export */   "watch": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.watch,
/* harmony export */   "IObserverLocator": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IObserverLocator,
/* harmony export */   "ISignaler": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ISignaler,
/* harmony export */   "subscriberCollection": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection,
/* harmony export */   "bindingBehavior": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindingBehavior,
/* harmony export */   "BindingBehavior": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.BindingBehavior,
/* harmony export */   "customAttribute": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customAttribute,
/* harmony export */   "CustomAttribute": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomAttribute,
/* harmony export */   "templateController": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.templateController,
/* harmony export */   "containerless": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.containerless,
/* harmony export */   "customElement": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement,
/* harmony export */   "CustomElement": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement,
/* harmony export */   "useShadowDOM": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.useShadowDOM,
/* harmony export */   "ValueConverter": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ValueConverter,
/* harmony export */   "valueConverter": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.valueConverter,
/* harmony export */   "AppTask": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.AppTask,
/* harmony export */   "TaskQueuePriority": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.TaskQueuePriority,
/* harmony export */   "bindable": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindable,
/* harmony export */   "Bindable": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Bindable,
/* harmony export */   "children": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.children,
/* harmony export */   "Controller": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Controller,
/* harmony export */   "ViewFactory": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ViewFactory,
/* harmony export */   "IAppRoot": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAppRoot,
/* harmony export */   "alias": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.alias,
/* harmony export */   "registerAliases": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.registerAliases,
/* harmony export */   "INode": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.INode,
/* harmony export */   "IEventTarget": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IEventTarget,
/* harmony export */   "IRenderLocation": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IRenderLocation,
/* harmony export */   "BindingMode": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.BindingMode,
/* harmony export */   "LifecycleFlags": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.LifecycleFlags,
/* harmony export */   "renderer": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.renderer,
/* harmony export */   "IAurelia": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAurelia,
/* harmony export */   "NodeObserverLocator": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.NodeObserverLocator,
/* harmony export */   "attributePattern": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.attributePattern,
/* harmony export */   "IAttributePattern": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAttributePattern,
/* harmony export */   "IAttrSyntaxTransformer": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IAttrSyntaxTransformer,
/* harmony export */   "bindingCommand": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.bindingCommand,
/* harmony export */   "getTarget": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.getTarget,
/* harmony export */   "ShortHandBindingSyntax": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.ShortHandBindingSyntax,
/* harmony export */   "createElement": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.createElement,
/* harmony export */   "StyleConfiguration": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.StyleConfiguration,
/* harmony export */   "cssModules": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.cssModules,
/* harmony export */   "shadowCSS": () => /* reexport safe */ _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.shadowCSS
/* harmony export */ });
/* harmony import */ var _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aurelia/kernel */ "./node_modules/@aurelia/kernel/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @aurelia/platform-browser */ "./node_modules/@aurelia/platform-browser/dist/esm/index.js");
/* harmony import */ var _aurelia_fetch_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aurelia/fetch-client */ "./node_modules/@aurelia/fetch-client/dist/esm/index.js");
/* harmony import */ var _aurelia_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @aurelia/router */ "./node_modules/@aurelia/router/dist/esm/index.js");



const PLATFORM = _aurelia_platform_browser__WEBPACK_IMPORTED_MODULE_2__.BrowserPlatform.getOrCreate(globalThis);

function createContainer() {
    return _aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer()
        .register(_aurelia_kernel__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.IPlatform, PLATFORM), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.StandardConfiguration);
}
class Aurelia extends _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.Aurelia {
    constructor(container = createContainer()) {
        super(container);
    }
    static start(root) {
        return new Aurelia().start(root);
    }
    static app(config) {
        return new Aurelia().app(config);
    }
    static enhance(config) {
        return new Aurelia().enhance(config);
    }
    static register(...params) {
        return new Aurelia().register(...params);
    }
    app(config) {
        if (_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.isType(config)) {
            // Default to custom element element name
            const definition = _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.CustomElement.getDefinition(config);
            let host = document.querySelector(definition.name);
            if (host === null) {
                // When no target is found, default to body.
                // For example, when user forgot to write <my-app></my-app> in html.
                host = document.body;
            }
            return super.app({
                host: host,
                component: config
            });
        }
        return super.app(config);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Aurelia);




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/app.css":
/*!***********************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/app.css ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".app-header {\n  background: #f4f4f4;\n  padding: 0;\n  padding: 5px 0 0 0;\n  text-align: center;\n}\n\n.dark .app-header {\n  background: #2a2a2a;\n}\n\n.logo-badge {\n  position: relative;\n  top: -7px;\n  font-weight: 100;\n  font-size: 16px;\n  color: #BB79A8;\n}\n\n.not-found {\n  font-style: italic;\n  font-size: 10px;\n}\n\n.dark .not-found {\n  color: #989898;\n}\n\n.custom-attribute {\n  margin-bottom: 4px;\n}\n\n.custom-attribute .attribute-name {\n  color: saddlebrown;\n}\n.dark .custom-attribute .attribute-name {\n  color: #ef9565;\n}\n\n.custom-attribute .block-token {\n  color: gray;\n}\n\n.custom-attribute .attribute-name, .custom-attribute .block-token {\n  font-size: 12px;\n  display: inline;\n  font-family: monospace;\n}\n\n.custom-attribute controller-view {\n  margin-left: 8px;\n  display: block;\n}\n\ncustom-element {\n  margin-top: 2px;\n  display: block;\n}\n\ncustom-element .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\ncustom-element .arrow .right {\n  margin-right: 1px;\n}\n\ncustom-element .property-line {\n  white-space: nowrap;\n}\n\ncustom-element .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark custom-element .property-name {\n  color: #34c7bb;\n}\ncustom-element .value-container {\n  position: relative;\n}\n\ncustom-element .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0,0,0,.5);\n  position: absolute;\n  top: 4px;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\ncustom-element .property-value, custom-element .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\ncustom-element .property-value.null, custom-element .property-value.undefined {\n  color: dimgray;\n}\n\ncustom-element .property-value.boolean {\n  color: deeppink;\n}\n\ncustom-element .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark custom-element .property-value.string {\n  color:#cbcbcb;\n}\n\ncustom-element .property-value.number {\n  color: blue;\n}\n\n.dark custom-element .property-value.number {\n  color: #59a6ca;\n}\n\ncustom-element .property-value.array {\n  color: black;\n}\n\n.dark custom-element .property-value.array {\n  color: #cbcbcb;\n}\n\ncustom-element .property-value.object, custom-element .property-value.node {\n  color: black;\n}\n\n.dark custom-element .property-value.object, custom-element .property-value.node {\n  color: #cbcbcb;\n}\n\ncustom-element ul.properties {\n  margin-left: 16px;\n}\n\ncustom-element .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark custom-element .no-properties {\n  color: #989898;\n}\n", "",{"version":3,"sources":["webpack://./src/app.css"],"names":[],"mappings":"AAAA;EACE,mBAAmB;EACnB,UAAU;EACV,kBAAkB;EAClB,kBAAkB;AACpB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,gBAAgB;EAChB,eAAe;EACf,cAAc;AAChB;;AAEA;EACE,kBAAkB;EAClB,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;AACpB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,eAAe;EACf,eAAe;EACf,sBAAsB;AACxB;;AAEA;EACE,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,eAAe;EACf,aAAa;EACb,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,sBAAsB;EACtB,eAAe;EACf,SAAS;EACT,YAAY;EACZ,aAAa;EACb,0BAA0B;EAC1B,kCAAkC;EAClC,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,sBAAsB;AACxB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,UAAU;EACV,mBAAmB;AACrB;AACA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,eAAe;EACf,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB","sourcesContent":[".app-header {\n  background: #f4f4f4;\n  padding: 0;\n  padding: 5px 0 0 0;\n  text-align: center;\n}\n\n.dark .app-header {\n  background: #2a2a2a;\n}\n\n.logo-badge {\n  position: relative;\n  top: -7px;\n  font-weight: 100;\n  font-size: 16px;\n  color: #BB79A8;\n}\n\n.not-found {\n  font-style: italic;\n  font-size: 10px;\n}\n\n.dark .not-found {\n  color: #989898;\n}\n\n.custom-attribute {\n  margin-bottom: 4px;\n}\n\n.custom-attribute .attribute-name {\n  color: saddlebrown;\n}\n.dark .custom-attribute .attribute-name {\n  color: #ef9565;\n}\n\n.custom-attribute .block-token {\n  color: gray;\n}\n\n.custom-attribute .attribute-name, .custom-attribute .block-token {\n  font-size: 12px;\n  display: inline;\n  font-family: monospace;\n}\n\n.custom-attribute controller-view {\n  margin-left: 8px;\n  display: block;\n}\n\ncustom-element {\n  margin-top: 2px;\n  display: block;\n}\n\ncustom-element .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\ncustom-element .arrow .right {\n  margin-right: 1px;\n}\n\ncustom-element .property-line {\n  white-space: nowrap;\n}\n\ncustom-element .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark custom-element .property-name {\n  color: #34c7bb;\n}\ncustom-element .value-container {\n  position: relative;\n}\n\ncustom-element .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0,0,0,.5);\n  position: absolute;\n  top: 4px;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\ncustom-element .property-value, custom-element .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\ncustom-element .property-value.null, custom-element .property-value.undefined {\n  color: dimgray;\n}\n\ncustom-element .property-value.boolean {\n  color: deeppink;\n}\n\ncustom-element .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark custom-element .property-value.string {\n  color:#cbcbcb;\n}\n\ncustom-element .property-value.number {\n  color: blue;\n}\n\n.dark custom-element .property-value.number {\n  color: #59a6ca;\n}\n\ncustom-element .property-value.array {\n  color: black;\n}\n\n.dark custom-element .property-value.array {\n  color: #cbcbcb;\n}\n\ncustom-element .property-value.object, custom-element .property-value.node {\n  color: black;\n}\n\n.dark custom-element .property-value.object, custom-element .property-value.node {\n  color: #cbcbcb;\n}\n\ncustom-element ul.properties {\n  margin-left: 16px;\n}\n\ncustom-element .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark custom-element .no-properties {\n  color: #989898;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/reset.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/reset.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* http://meyerweb.com/eric/tools/css/reset/\n   v2.0 | 20110126\n   License: none (public domain)\n*/\n\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tfont-size: 100%;\n\tfont: inherit;\n\tvertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n\tdisplay: block;\n}\nbody {\n\tline-height: 1;\n}\nol, ul {\n\tlist-style: none;\n}\nblockquote, q {\n\tquotes: none;\n}\nblockquote:before, blockquote:after,\nq:before, q:after {\n\tcontent: '';\n\tcontent: none;\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n\n/*! normalize.css v5.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Change the default font family in all browsers (opinionated).\n * 2. Correct the line height in all browsers.\n * 3. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  font-family: sans-serif; /* 1 */\n  line-height: 1.15; /* 2 */\n  -ms-text-size-adjust: 100%; /* 3 */\n  -webkit-text-size-adjust: 100%; /* 3 */\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Change the border, margin, and padding in all browsers (opinionated).\n */\n\nfieldset {\n  border: 1px solid #c0c0c0;\n  margin: 0 2px;\n  padding: 0.35em 0.625em 0.75em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n", "",{"version":3,"sources":["webpack://./src/reset.css"],"names":[],"mappings":"AAAA;;;CAGC;;AAED;;;;;;;;;;;;;CAaC,SAAS;CACT,UAAU;CACV,SAAS;CACT,eAAe;CACf,aAAa;CACb,wBAAwB;AACzB;AACA,gDAAgD;AAChD;;CAEC,cAAc;AACf;AACA;CACC,cAAc;AACf;AACA;CACC,gBAAgB;AACjB;AACA;CACC,YAAY;AACb;AACA;;CAEC,WAAW;CACX,aAAa;AACd;AACA;CACC,yBAAyB;CACzB,iBAAiB;AAClB;;AAEA,2EAA2E;;AAE3E;+EAC+E;;AAE/E;;;;;EAKE;;AAEF;EACE,uBAAuB,EAAE,MAAM;EAC/B,iBAAiB,EAAE,MAAM;EACzB,0BAA0B,EAAE,MAAM;EAClC,8BAA8B,EAAE,MAAM;AACxC;;AAEA;+EAC+E;;AAE/E;;;EAGE;;AAEF;;;;;EAKE,uBAAuB,EAAE,MAAM;EAC/B,eAAe,EAAE,MAAM;EACvB,iBAAiB,EAAE,MAAM;EACzB,SAAS,EAAE,MAAM;AACnB;;AAEA;;;EAGE;;AAEF;QACQ,MAAM;EACZ,iBAAiB;AACnB;;AAEA;;;EAGE;;AAEF;SACS,MAAM;EACb,oBAAoB;AACtB;;AAEA;;;;EAIE;;AAEF;;;;EAIE,0BAA0B,EAAE,MAAM;AACpC;;AAEA;;EAEE;;AAEF;;;;EAIE,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE;;AAEF;;;;EAIE,8BAA8B;AAChC;;AAEA;;EAEE;;AAEF;EACE,yBAAyB;EACzB,aAAa;EACb,8BAA8B;AAChC;;AAEA;;;;;EAKE;;AAEF;EACE,sBAAsB,EAAE,MAAM;EAC9B,cAAc,EAAE,MAAM;EACtB,cAAc,EAAE,MAAM;EACtB,eAAe,EAAE,MAAM;EACvB,UAAU,EAAE,MAAM;EAClB,mBAAmB,EAAE,MAAM;AAC7B;;AAEA;;;EAGE;;AAEF;EACE,qBAAqB,EAAE,MAAM;EAC7B,wBAAwB,EAAE,MAAM;AAClC;;AAEA;;EAEE;;AAEF;EACE,cAAc;AAChB;;AAEA;;;EAGE;;AAEF;;EAEE,sBAAsB,EAAE,MAAM;EAC9B,UAAU,EAAE,MAAM;AACpB;;AAEA;;EAEE;;AAEF;;EAEE,YAAY;AACd;;AAEA;;;EAGE;;AAEF;EACE,6BAA6B,EAAE,MAAM;EACrC,oBAAoB,EAAE,MAAM;AAC9B;;AAEA;;EAEE;;AAEF;;EAEE,wBAAwB;AAC1B;;AAEA;;;EAGE;;AAEF;EACE,0BAA0B,EAAE,MAAM;EAClC,aAAa,EAAE,MAAM;AACvB","sourcesContent":["/* http://meyerweb.com/eric/tools/css/reset/\n   v2.0 | 20110126\n   License: none (public domain)\n*/\n\nhtml, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tfont-size: 100%;\n\tfont: inherit;\n\tvertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section {\n\tdisplay: block;\n}\nbody {\n\tline-height: 1;\n}\nol, ul {\n\tlist-style: none;\n}\nblockquote, q {\n\tquotes: none;\n}\nblockquote:before, blockquote:after,\nq:before, q:after {\n\tcontent: '';\n\tcontent: none;\n}\ntable {\n\tborder-collapse: collapse;\n\tborder-spacing: 0;\n}\n\n/*! normalize.css v5.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Change the default font family in all browsers (opinionated).\n * 2. Correct the line height in all browsers.\n * 3. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  font-family: sans-serif; /* 1 */\n  line-height: 1.15; /* 2 */\n  -ms-text-size-adjust: 100%; /* 3 */\n  -webkit-text-size-adjust: 100%; /* 3 */\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Change the border, margin, and padding in all browsers (opinionated).\n */\n\nfieldset {\n  border: 1px solid #c0c0c0;\n  margin: 0 2px;\n  padding: 0.35em 0.625em 0.75em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/controller-view.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/elements/controller-view.css ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: black;\n}\n\n.dark controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: white;\n}\n", "",{"version":3,"sources":["webpack://./src/resources/elements/controller-view.css"],"names":[],"mappings":"AAAA;EACE,eAAe;EACf,kBAAkB;EAClB,eAAe;EACf,YAAY;AACd;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,eAAe;EACf,YAAY;AACd","sourcesContent":["controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: black;\n}\n\n.dark controller-view .category-name {\n  font-size: 10px;\n  margin-bottom: 2px;\n  margin-top: 2px;\n  color: white;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/debug-group.css":
/*!**************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/elements/debug-group.css ***!
  \**************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "debug-group .header {\n  font-weight: normal;\n  font-size: 12px;\n  margin: 0;\n  padding: 4px;\n  background: #f4f4f4;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.25);\n  border-top: 1px solid rgba(0, 0, 0, 0.25);\n}\n\n.dark debug-group .header {\n  color: #989898;\n  background: #2a2a2a;\n  border-bottom: 1px solid #5c5c5c;\n  border-top: 1px solid #3d3d3d;\n}\n\ndebug-group .content {\n  margin: 4px;\n}\n", "",{"version":3,"sources":["webpack://./src/resources/elements/debug-group.css"],"names":[],"mappings":"AAAA;EACE,mBAAmB;EACnB,eAAe;EACf,SAAS;EACT,YAAY;EACZ,mBAAmB;EACnB,4CAA4C;EAC5C,yCAAyC;AAC3C;;AAEA;EACE,cAAc;EACd,mBAAmB;EACnB,gCAAgC;EAChC,6BAA6B;AAC/B;;AAEA;EACE,WAAW;AACb","sourcesContent":["debug-group .header {\n  font-weight: normal;\n  font-size: 12px;\n  margin: 0;\n  padding: 4px;\n  background: #f4f4f4;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.25);\n  border-top: 1px solid rgba(0, 0, 0, 0.25);\n}\n\n.dark debug-group .header {\n  color: #989898;\n  background: #2a2a2a;\n  border-bottom: 1px solid #5c5c5c;\n  border-top: 1px solid #3d3d3d;\n}\n\ndebug-group .content {\n  margin: 4px;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/property-view.css":
/*!****************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/resources/elements/property-view.css ***!
  \****************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "property-view {\n  padding-top: 2px;\n  padding-bottom: 2px;\n  display: block;\n}\n\nproperty-view .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\nproperty-view .arrow .right {\n  margin-right: 1px;\n}\n\nproperty-view .property-line {\n  white-space: nowrap;\n}\n\nproperty-view .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark property-view .property-name {\n  color: #34c7bb;\n}\nproperty-view .value-container {\n  position: relative;\n}\n\nproperty-view .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n  position: absolute;\n  top: 0;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\nproperty-view .property-value,\nproperty-view .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\nproperty-view .property-value.null,\nproperty-view .property-value.undefined {\n  color: dimgray;\n}\n\nproperty-view .property-value.boolean {\n  color: deeppink;\n}\n\nproperty-view .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark property-view .property-value.string {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.number {\n  color: blue;\n}\n\n.dark property-view .property-value.number {\n  color: #59a6ca;\n}\n\nproperty-view .property-value.array {\n  color: black;\n}\n\n.dark property-view .property-value.array {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.object,\nproperty-view .property-value.node {\n  color: black;\n}\n\n.dark property-view .property-value.object,\nproperty-view .property-value.node {\n  color: #cbcbcb;\n}\n\nproperty-view ul.properties {\n  margin-left: 16px;\n}\n\nproperty-view .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark property-view .no-properties {\n  color: #989898;\n}\n", "",{"version":3,"sources":["webpack://./src/resources/elements/property-view.css"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,cAAc;EACd,eAAe;AACjB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,eAAe;EACf,aAAa;EACb,sBAAsB;EACtB,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;AACA;EACE,kBAAkB;AACpB;;AAEA;EACE,sBAAsB;EACtB,eAAe;EACf,SAAS;EACT,YAAY;EACZ,aAAa;EACb,0BAA0B;EAC1B,sCAAsC;EACtC,kBAAkB;EAClB,MAAM;EACN,SAAS;EACT,kBAAkB;AACpB;;AAEA;;EAEE,eAAe;EACf,cAAc;EACd,sBAAsB;AACxB;;AAEA;;EAEE,cAAc;AAChB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,UAAU;EACV,mBAAmB;AACrB;AACA;EACE,cAAc;AAChB;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,cAAc;AAChB;;AAEA;;EAEE,YAAY;AACd;;AAEA;;EAEE,cAAc;AAChB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,eAAe;EACf,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB","sourcesContent":["property-view {\n  padding-top: 2px;\n  padding-bottom: 2px;\n  display: block;\n}\n\nproperty-view .arrow {\n  font-size: 10px;\n  color: dimgray;\n  cursor: default;\n}\n\nproperty-view .arrow .right {\n  margin-right: 1px;\n}\n\nproperty-view .property-line {\n  white-space: nowrap;\n}\n\nproperty-view .property-name {\n  font-size: 12px;\n  color: purple;\n  font-family: monospace;\n  margin-left: 1px;\n}\n\n.dark property-view .property-name {\n  color: #34c7bb;\n}\nproperty-view .value-container {\n  position: relative;\n}\n\nproperty-view .property-editor {\n  font-family: monospace;\n  font-size: 12px;\n  margin: 0;\n  height: 12px;\n  outline: none;\n  border: 1px solid darkgray;\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n  position: absolute;\n  top: 0;\n  left: 2px;\n  padding: 0 0 0 2px;\n}\n\nproperty-view .property-value,\nproperty-view .token-colon {\n  font-size: 12px;\n  color: dimgray;\n  font-family: monospace;\n}\n\nproperty-view .property-value.null,\nproperty-view .property-value.undefined {\n  color: dimgray;\n}\n\nproperty-view .property-value.boolean {\n  color: deeppink;\n}\n\nproperty-view .property-value.string {\n  color: red;\n  white-space: nowrap;\n}\n.dark property-view .property-value.string {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.number {\n  color: blue;\n}\n\n.dark property-view .property-value.number {\n  color: #59a6ca;\n}\n\nproperty-view .property-value.array {\n  color: black;\n}\n\n.dark property-view .property-value.array {\n  color: #cbcbcb;\n}\n\nproperty-view .property-value.object,\nproperty-view .property-value.node {\n  color: black;\n}\n\n.dark property-view .property-value.object,\nproperty-view .property-value.node {\n  color: #cbcbcb;\n}\n\nproperty-view ul.properties {\n  margin-left: 16px;\n}\n\nproperty-view .no-properties {\n  margin-top: 4px;\n  font-size: 10px;\n}\n\n.dark property-view .no-properties {\n  color: #989898;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (typeof btoa === 'function') {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
};

/***/ }),

/***/ "./src/app.css":
/*!*********************!*\
  !*** ./src/app.css ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./app.css */ "./node_modules/css-loader/dist/cjs.js!./src/app.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_app_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/reset.css":
/*!***********************!*\
  !*** ./src/reset.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./reset.css */ "./node_modules/css-loader/dist/cjs.js!./src/reset.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/resources/elements/controller-view.css":
/*!****************************************************!*\
  !*** ./src/resources/elements/controller-view.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_controller_view_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./controller-view.css */ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/controller-view.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_controller_view_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_controller_view_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/resources/elements/debug-group.css":
/*!************************************************!*\
  !*** ./src/resources/elements/debug-group.css ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_debug_group_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./debug-group.css */ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/debug-group.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_debug_group_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_debug_group_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/resources/elements/property-view.css":
/*!**************************************************!*\
  !*** ./src/resources/elements/property-view.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_property_view_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./property-view.css */ "./node_modules/css-loader/dist/cjs.js!./src/resources/elements/property-view.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_property_view_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_property_view_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringifyValueConverter": () => /* binding */ StringifyValueConverter,
/* harmony export */   "App": () => /* binding */ App
/* harmony export */ });
/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.html */ "./src/app.html");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _backend_debug_host__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./backend/debug-host */ "./src/backend/debug-host.ts");
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




let StringifyValueConverter = class StringifyValueConverter {
    toView(value) {
        return JSON.stringify(value);
    }
};
StringifyValueConverter = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.valueConverter)('stringify')
], StringifyValueConverter);

let App = class App {
    constructor(debugHost, plat) {
        this.debugHost = debugHost;
        this.plat = plat;
        this.isDarkTheme = false;
        this.JSON = JSON;
        this.selectedElement = undefined;
        this.selectedElementAttributes = undefined;
        this.allAureliaObjects = undefined;
    }
    attaching() {
        this.debugHost.attach(this);
        this.isDarkTheme = chrome?.devtools?.panels?.themeName === "dark";
        [].join();
    }
    get currentController() {
        return this.selectedElement;
    }
    valueChanged(element) {
        this.plat.queueMicrotask(() => this.debugHost.updateValues(element));
    }
};
App = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)({ ..._app_html__WEBPACK_IMPORTED_MODULE_0__, dependencies: [..._app_html__WEBPACK_IMPORTED_MODULE_0__.dependencies, StringifyValueConverter] }),
    (0,aurelia__WEBPACK_IMPORTED_MODULE_3__.inject)(),
    __param(1, aurelia__WEBPACK_IMPORTED_MODULE_3__.IPlatform),
    __metadata("design:paramtypes", [_backend_debug_host__WEBPACK_IMPORTED_MODULE_2__.DebugHost, Object])
], App);



/***/ }),

/***/ "./src/backend/debug-host.ts":
/*!***********************************!*\
  !*** ./src/backend/debug-host.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectionChanged": () => /* binding */ SelectionChanged,
/* harmony export */   "DebugHost": () => /* binding */ DebugHost
/* harmony export */ });
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class SelectionChanged {
    constructor(debugInfo) {
        this.debugInfo = debugInfo;
    }
}
let DebugHost = class DebugHost {
    attach(consumer) {
        this.consumer = consumer;
        if (chrome && chrome.devtools) {
            chrome.devtools.network.onNavigated.addListener(() => {
                chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.getAllInfo()`, (debugObject) => {
                    this.consumer.allAureliaObjects = debugObject;
                });
            });
            chrome.devtools.panels.elements.onSelectionChanged.addListener(() => {
                chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.getCustomElementInfo($0, false)`, (debugObject) => {
                    this.consumer.selectedElement = debugObject?.customElementInfo;
                    this.consumer.selectedElementAttributes = debugObject?.customAttributesInfo;
                });
            });
            chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.getAllInfo()`, (debugObject) => {
                this.consumer.allAureliaObjects = debugObject;
            });
        }
    }
    updateValues(value) {
        chrome.devtools.inspectedWindow.eval(`window.__AURELIA_DEVTOOLS_GLOBAL_HOOK__.updateValues(${JSON.stringify(value)})`, (debugObject) => {
            // this.consumer.selectedElement = debugObject;
        });
    }
    updateDebugValue(debugInfo) {
        let value = debugInfo.value;
        if (debugInfo.type === "string") {
            value = "'" + value + "'";
        }
        let code = `aureliaDebugger.updateValueForId(${debugInfo.debugId}, ${value})`;
        chrome.devtools.inspectedWindow.eval(code);
    }
    toggleDebugValueExpansion(debugInfo) {
        if (debugInfo.canExpand) {
            debugInfo.isExpanded = !debugInfo.isExpanded;
            if (debugInfo.isExpanded && !debugInfo.expandedValue) {
                let code = `aureliaDebugger.getExpandedDebugValueForId(${debugInfo.debugId});`;
                chrome.devtools.inspectedWindow.eval(code, (expandedValue) => {
                    debugInfo.expandedValue = expandedValue;
                    debugInfo.isExpanded = true;
                });
            }
        }
    }
};
DebugHost = __decorate([
    (0,aurelia__WEBPACK_IMPORTED_MODULE_0__.inject)()
], DebugHost);



/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app */ "./src/app.ts");
/* harmony import */ var _resources_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/index */ "./src/resources/index.ts");




const aurelia = new aurelia__WEBPACK_IMPORTED_MODULE_0__.default(aurelia__WEBPACK_IMPORTED_MODULE_0__.DI.createContainer()
    .register(aurelia__WEBPACK_IMPORTED_MODULE_0__.Registration.instance(aurelia__WEBPACK_IMPORTED_MODULE_0__.IPlatform, aurelia__WEBPACK_IMPORTED_MODULE_0__.PLATFORM), _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.StandardConfiguration, _resources_index__WEBPACK_IMPORTED_MODULE_3__)).app(_app__WEBPACK_IMPORTED_MODULE_2__.App);
aurelia.start();


/***/ }),

/***/ "./src/resources/elements/debug-group.ts":
/*!***********************************************!*\
  !*** ./src/resources/elements/debug-group.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugGroup": () => /* binding */ DebugGroup
/* harmony export */ });
/* harmony import */ var _debug_group_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug-group.html */ "./src/resources/elements/debug-group.html");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let DebugGroup = class DebugGroup {
};
__decorate([
    aurelia__WEBPACK_IMPORTED_MODULE_2__.bindable,
    __metadata("design:type", String)
], DebugGroup.prototype, "heading", void 0);
DebugGroup = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)(_debug_group_html__WEBPACK_IMPORTED_MODULE_0__)
], DebugGroup);



/***/ }),

/***/ "./src/resources/elements/property-view.ts":
/*!*************************************************!*\
  !*** ./src/resources/elements/property-view.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyView": () => /* binding */ PropertyView
/* harmony export */ });
/* harmony import */ var _property_view_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property-view.html */ "./src/resources/elements/property-view.html");
/* harmony import */ var _aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aurelia/runtime-html */ "./node_modules/@aurelia/runtime-html/dist/esm/index.js");
/* harmony import */ var aurelia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia */ "./node_modules/aurelia/dist/esm/index.js");
/* harmony import */ var _backend_debug_host__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../backend/debug-host */ "./src/backend/debug-host.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




const editableTypes = ['string', 'number', 'boolean', 'bigint'];
let PropertyView = class PropertyView {
    constructor(debugHost, platform) {
        this.debugHost = debugHost;
        this.platform = platform;
    }
    beginEditing() {
        if (editableTypes.some(x => x === this.property?.type || this.property.value == null)) {
            this.property.isEditing = true;
            this.platform.queueMicrotask(() => {
                this.editor.focus();
                this.editor.select();
            });
        }
    }
    keyup(e) {
        if (e.code === 'Enter') {
            this.endEditing();
        }
        if (this.property.type === 'undefined') {
            this.property.type = 'string';
        }
        this.platform.queueMicrotask(() => this.debugHost.updateValues(this.controller));
        return true;
    }
    endEditing() {
        this.property.isEditing = false;
    }
};
__decorate([
    aurelia__WEBPACK_IMPORTED_MODULE_2__.bindable,
    __metadata("design:type", Object)
], PropertyView.prototype, "property", void 0);
__decorate([
    aurelia__WEBPACK_IMPORTED_MODULE_2__.bindable,
    __metadata("design:type", Object)
], PropertyView.prototype, "controller", void 0);
PropertyView = __decorate([
    (0,_aurelia_runtime_html__WEBPACK_IMPORTED_MODULE_1__.customElement)(_property_view_html__WEBPACK_IMPORTED_MODULE_0__),
    (0,aurelia__WEBPACK_IMPORTED_MODULE_2__.inject)(),
    __param(1, aurelia__WEBPACK_IMPORTED_MODULE_2__.IPlatform),
    __metadata("design:paramtypes", [_backend_debug_host__WEBPACK_IMPORTED_MODULE_3__.DebugHost, Object])
], PropertyView);



/***/ }),

/***/ "./src/resources/index.ts":
/*!********************************!*\
  !*** ./src/resources/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugGroup": () => /* reexport safe */ _elements_debug_group__WEBPACK_IMPORTED_MODULE_0__.DebugGroup,
/* harmony export */   "PropertyView": () => /* reexport safe */ _elements_property_view__WEBPACK_IMPORTED_MODULE_1__.PropertyView,
/* harmony export */   "t": () => /* reexport module object */ _elements_aurelia_logo_html__WEBPACK_IMPORTED_MODULE_2__,
/* harmony export */   "t2": () => /* reexport module object */ _elements_controller_view_html__WEBPACK_IMPORTED_MODULE_3__
/* harmony export */ });
/* harmony import */ var _elements_debug_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elements/debug-group */ "./src/resources/elements/debug-group.ts");
/* harmony import */ var _elements_property_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elements/property-view */ "./src/resources/elements/property-view.ts");
/* harmony import */ var _elements_aurelia_logo_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elements/aurelia-logo.html */ "./src/resources/elements/aurelia-logo.html");
/* harmony import */ var _elements_controller_view_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./elements/controller-view.html */ "./src/resources/elements/controller-view.html");






/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/main.ts");
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvZmV0Y2gtY2xpZW50L2Rpc3QvZXNtL2h0dHAtY2xpZW50LWNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2ZldGNoLWNsaWVudC9kaXN0L2VzbS9odHRwLWNsaWVudC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvZmV0Y2gtY2xpZW50L2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9mZXRjaC1jbGllbnQvZGlzdC9lc20vcmV0cnktaW50ZXJjZXB0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2ZldGNoLWNsaWVudC9kaXN0L2VzbS91dGlsLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9rZXJuZWwvZGlzdC9lc20vZGkuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9ldmVudGFnZ3JlZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEva2VybmVsL2Rpc3QvZXNtL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEva2VybmVsL2Rpc3QvZXNtL21vZHVsZS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL2tlcm5lbC9kaXN0L2VzbS9wbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEva2VybmVsL2Rpc3QvZXNtL3Jlc291cmNlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9tZXRhZGF0YS9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcGxhdGZvcm0tYnJvd3Nlci9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcGxhdGZvcm0vZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlLXJlY29nbml6ZXIvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9hd2FpdGFibGUtbWFwLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vYnJvd3Nlci12aWV3ZXItc3RvcmUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9jb2xsZWN0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vY29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL2ZvdW5kLXJvdXRlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vaG9vay1tYW5hZ2VyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vaG9vay5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vaW5zdHJ1Y3Rpb24tcmVzb2x2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9pbnRlcmZhY2VzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vbGlmZWN5Y2xlLWxvZ2dlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL2xpbmstaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL25hdi1yb3V0ZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL25hdi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL25hdmlnYXRpb24tY29vcmRpbmF0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9uYXZpZ2F0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vbmF2aWdhdG9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vb3Blbi1wcm9taXNlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcGFyc2VyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcXVldWUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9yZXNvdXJjZXMvZ290by5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3Jlc291cmNlcy9ocmVmLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcmVzb3VyY2VzL2xvYWQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9yZXNvdXJjZXMvbmF2LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcmVzb3VyY2VzL3ZpZXdwb3J0LXNjb3BlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcmVzb3VyY2VzL3ZpZXdwb3J0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcm91dGUtcmVjb2duaXplci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3JvdXRlci1vcHRpb25zLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcm91dGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vcnVubmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vc2NvcGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS9zdGF0ZS1jb29yZGluYXRvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3Rhc2stcXVldWUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS90eXBlLXJlc29sdmVycy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3V0aWxzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vdmlld3BvcnQtY29udGVudC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcm91dGVyL2Rpc3QvZXNtL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9yb3V0ZXIvZGlzdC9lc20vdmlld3BvcnQtc2NvcGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3JvdXRlci9kaXN0L2VzbS92aWV3cG9ydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2FwcC1yb290LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYXBwLXRhc2suanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9hdHRyaWJ1dGUtc3ludGF4LXRyYW5zZm9ybWVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYXVyZWxpYS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRhYmxlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy1iZWhhdmlvcnMvYmluZGluZy1tb2RlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy1iZWhhdmlvcnMvZGVib3VuY2UuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9iaW5kaW5nLWJlaGF2aW9ycy9zaWduYWxzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy1iZWhhdmlvcnMvdGhyb3R0bGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9iaW5kaW5nL2F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRpbmcvY2FsbC1iaW5kaW5nLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy9pbnRlcnBvbGF0aW9uLWJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9iaW5kaW5nL2xldC1iaW5kaW5nLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vYmluZGluZy9saXN0ZW5lci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRpbmcvcHJvcGVydHktYmluZGluZy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL2JpbmRpbmcvcmVmLWJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9jb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vY3JlYXRlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9kb20uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2F0dHJpYnV0ZS1ucy1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2JpbmRhYmxlLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vY2hlY2tlZC1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2NsYXNzLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL29ic2VydmF0aW9uL2RhdGEtYXR0cmlidXRlLWFjY2Vzc29yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vZWxlbWVudC1hdHRyaWJ1dGUtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9vYnNlcnZhdGlvbi9ldmVudC1kZWxlZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9vYnNlcnZhdGlvbi9vYnNlcnZlci1sb2NhdG9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vc2VsZWN0LXZhbHVlLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vc3R5bGUtYXR0cmlidXRlLWFjY2Vzc29yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vc3ZnLWFuYWx5emVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vb2JzZXJ2YXRpb24vdmFsdWUtYXR0cmlidXRlLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9hdHRyaWJ1dGUtcGF0dGVybi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9iaW5kaW5nLWJlaGF2aW9ycy9hdHRyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2JpbmRpbmctYmVoYXZpb3JzL3NlbGYuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvYmluZGluZy1iZWhhdmlvcnMvdXBkYXRlLXRyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvYmluZGluZy1jb21tYW5kLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZXMvYmx1ci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlcy9mb2N1cy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlcy9zaG93LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9hdS1zbG90LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9jb21wb3NlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL2ZsYWdzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL2lmLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3BvcnRhbC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvc3dpdGNoLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3dpdGguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9yZXNvdXJjZXMvdmFsdWUtY29udmVydGVycy9zYW5pdGl6ZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3Jlc291cmNlcy92YWx1ZS1jb252ZXJ0ZXJzL3ZpZXcuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS9zZW1hbnRpYy1tb2RlbC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRlLWJpbmRlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRlLWNvbXBpbGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vdGVtcGxhdGUtZWxlbWVudC1mYWN0b3J5LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lLWh0bWwvZGlzdC9lc20vdGVtcGxhdGluZy9jaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvcmVuZGVyLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS90ZW1wbGF0aW5nL3N0eWxlcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvdmlldy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS1odG1sL2Rpc3QvZXNtL3RlbXBsYXRpbmcvd2F0Y2hlcnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUtaHRtbC9kaXN0L2VzbS93YXRjaC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9hbGlhcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9iaW5kaW5nLWJlaGF2aW9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL2JpbmRpbmcvYXN0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL2JpbmRpbmcvY29ubmVjdGFibGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vYmluZGluZy9leHByZXNzaW9uLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9hcnJheS1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9iaW5kaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vY29sbGVjdGlvbi1sZW5ndGgtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vY29tcHV0ZWQtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vY29ubmVjdGFibGUtc3dpdGNoZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vZGlydHktY2hlY2tlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9tYXAtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vb2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9vYnNlcnZlci1sb2NhdG9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL29ic2VydmF0aW9uL3ByaW1pdGl2ZS1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9wcm9wZXJ0eS1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9wcm94eS1vYnNlcnZhdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS9vYnNlcnZhdGlvbi9zZXQtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0BhdXJlbGlhL3J1bnRpbWUvZGlzdC9lc20vb2JzZXJ2YXRpb24vc2V0dGVyLW9ic2VydmVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL29ic2VydmF0aW9uL3NpZ25hbGVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AYXVyZWxpYS9ydW50aW1lL2Rpc3QvZXNtL29ic2VydmF0aW9uL3N1YnNjcmliZXItY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS91dGlsaXRpZXMtb2JqZWN0cy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQGF1cmVsaWEvcnVudGltZS9kaXN0L2VzbS92YWx1ZS1jb252ZXJ0ZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL2FwcC5odG1sIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvYXVyZWxpYS1sb2dvLmh0bWwiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9jb250cm9sbGVyLXZpZXcuaHRtbCIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2RlYnVnLWdyb3VwLmh0bWwiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9wcm9wZXJ0eS12aWV3Lmh0bWwiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL2F1cmVsaWEvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL2FwcC5jc3MiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc2V0LmNzcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2NvbnRyb2xsZXItdmlldy5jc3MiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9kZWJ1Zy1ncm91cC5jc3MiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9wcm9wZXJ0eS12aWV3LmNzcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9hcHAuY3NzP2E2NzIiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc2V0LmNzcz9lZGUwIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvY29udHJvbGxlci12aWV3LmNzcz9jM2E2Iiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvZGVidWctZ3JvdXAuY3NzPzIzZDIiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9wcm9wZXJ0eS12aWV3LmNzcz9iZDU4Iiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvYXBwLnRzIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9iYWNrZW5kL2RlYnVnLWhvc3QudHMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL21haW4udHMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9lbGVtZW50cy9kZWJ1Zy1ncm91cC50cyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL3Byb3BlcnR5LXZpZXcudHMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3Jlc291cmNlcy9pbmRleC50cyIsIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL1tuYW1lXS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0QkFBNEI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNGQUFzRixJQUFJO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0NBQW9DO0FBQ3BFLDBCQUEwQixFQUFFLEtBQUssS0FBSztBQUN0QyxhQUFhO0FBQ2Isb1hBQW9YLHNCQUFzQjtBQUMxWTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7Ozs7O0FDeGhCd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLEtBQUssS0FBSztBQUM1RztBQUNBO0FBQ08sOEJBQThCLHVEQUFRO0FBQzdDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFTO0FBQ3pDLGlDQUFpQyx3REFBUztBQUMxQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxLQUFLLEtBQUs7QUFDNUc7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnREFBZ0QsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdDQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWEsR0FBRyxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxVXNEO0FBQ2E7QUFDZjtBQUNwRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQVc7QUFDWCw0Qzs7Ozs7Ozs7Ozs7Ozs7QUM1Sk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsMkJBQTJCLDJFQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzRUFBb0I7QUFDcEIsNkM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRnlEO0FBQ0s7QUFDOUQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBb0I7QUFDcEIsaUQ7Ozs7Ozs7Ozs7Ozs7OztBQzdOd0Q7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBEQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0Q7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdJbUQ7QUFDUjtBQUNwQyxxQkFBcUIsK0RBQWtCO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1FQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQVM7QUFDL0Isd0M7Ozs7Ozs7Ozs7Ozs7OztBQzVQd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFvQjtB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QUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0VBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTO0FBQ3BDO0FBQ0Esa0VBQWtFLGlFQUFtQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLGlFQUFtQjtBQUMxSDtBQUNBLGtCQUFrQixnRUFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlFQUFtQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuWjZDO0FBQ0c7QUFDZ0I7QUFDRTtBQUNKO0FBQzRMO0FBQzFQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrRUFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZEQUFhLHFCQUFxQiwyRUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFnQixxQkFBcUIsdUVBQWE7QUFDOUU7QUFDQTtBQUNBLDJCQUEyQixrRUFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUVBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnRUFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBUztBQUNoQyw2QkFBNkIsNERBQVksS0FBSyxnRUFBa0I7QUFDaEUscUNBQXFDLDZEQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZEQUFhLHFCQUFxQiwyRUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUVBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdFQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9DQUFvQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdFQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0VBQXdCO0FBQ2pEO0FBQ0E7QUFDQSxxQ0FBcUMsNkRBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFFQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUVBQXFCO0FBQzlDO0FBQ0E7QUFDQSxxQ0FBcUMsNkRBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBEQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDREQUFZLGFBQWEsZ0VBQWtCO0FBQ3RHO0FBQ0EseUNBQXlDLDZEQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDZEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9FQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9FQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9FQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlFQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5a0JBLGtCQUFrQixTQUFJLElBQUksU0FBSTtBQUM5QjtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUk7QUFDM0IsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUMyRjtBQUN4QjtBQUNRO0FBQ3JCO0FBQ2tCO0FBQ2tSO0FBQ2hUO0FBQ0Q7QUFDMkI7QUFDb0M7QUFDakI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUZBQThCO0FBQzdDO0FBQ0EsMEJBQTBCLDREQUFXO0FBQ3JDLHdCQUF3Qiw0REFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEVBQTBFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQXNCLENBQUMsMkRBQWlCO0FBQ3ZEO0FBQ0E7QUFDQSwyQkFBMkIsOEZBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQXNEO0FBQ3JFLDhCQUE4QixtREFBUztBQUN2QywyQkFBMkIsK0RBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0EsOENBQThDLGdFQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLDhDQUE4QywrREFBcUI7QUFDbkU7QUFDQSw4Q0FBOEMsc0VBQTRCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJFQUFRLFdBQVcsK0ZBQTRCLE1BQU0sb0ZBQWlCO0FBQzVGLHNCQUFzQiwyRUFBUSxXQUFXLDZGQUEwQixNQUFNLG9GQUFpQjtBQUMxRjtBQUNBLG9EQUFvRCxtRUFBeUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlGQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0MsbUVBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVEQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0VBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVEQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxRUFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNFQUE0QjtBQUNuRTtBQUNBLHVDQUF1QyxzRUFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtFQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUZBQThCLEVBQUUsb0RBQW9EO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdEQUFPO0FBQzFDLGVBQWUseUZBQThCLEVBQUUsT0FBTyxxRkFBMEIsaURBQWlEO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUZBQXVCO0FBQ3RDLGVBQWUsNkVBQWdCO0FBQy9CLGVBQWUsK0RBQWlCO0FBQ2hDLGVBQWUsb0ZBQXNCO0FBQ3JDLGVBQWUsb0RBQU87QUFDdEIsZUFBZSxtREFBUztBQUN4QjtBQUM0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBbUI7QUFDdEM7QUFDQSxtQkFBbUIsZ0VBQWtCO0FBQ3JDO0FBQ0EsbUJBQW1CLGtFQUFvQjtBQUN2QztBQUNBLG1CQUFtQixnRUFBa0I7QUFDckM7QUFDQTtBQUNBLG1CQUFtQixpRUFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQU87QUFDbkMscUNBQXFDLHNEQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUscUJBQXFCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsbUJBQW1CLFNBQVMsZUFBZSxVQUFVO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCw2QkFBNkIsdUJBQXVCLHFCQUFxQixTQUFTLGtEQUFrRDtBQUNwTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0VBQW9CLEVBQUUsZ0NBQWdDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZiQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJO0FBQzNCLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDcUM7QUFDSztBQUNuQyxnQ0FBZ0MsK0RBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQVM7QUFDeEI7QUFDa0M7QUFDbEMsb0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pEQSxrQkFBa0IsU0FBSSxJQUFJLFNBQUk7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNzRjtBQUM5QjtBQUNPO0FBQ3hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0EsUUFBUSw0REFBZTtBQUN2QixRQUFRLHlFQUE0QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsVUFBVSx1RUFBMEI7QUFDcEM7QUFDQSxrQkFBa0IsY0FBYyxHQUFHLEtBQUs7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrRUFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0VBQTJCO0FBQzlDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEMsZ0NBQWdDLDREQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUN2QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsc0NBQXNDLDZEQUFZLGtCQUFrQixLQUFLLFdBQVcsNkRBQVk7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxFQUFFO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsMEJBQTBCLEVBQUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBb0I7QUFDeEI7QUFDNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQSw0QkFBNEIsMkVBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2TEE7QUFDMkU7QUFDMkI7QUFDL0I7QUFDbkI7QUFDb0M7QUFDckI7QUFDWjtBQUNOO0FBQ1A7QUFDQztBQUM0QjtBQUNKO0FBQ25FO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DLGtCQUFrQjtBQUNsQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdURBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQVE7QUFDbkQsc0NBQXNDLGtEQUFRO0FBQzlDO0FBQ0Esc0NBQXNDLG1EQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCLElBQUkscUJBQXFCO0FBQ3BFO0FBQ0EsMEJBQTBCLGlCQUFpQixHQUFHLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQyx5QkFBeUIsaUJBQWlCLFFBQVEsc0JBQXNCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsa0JBQWtCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUZBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5RkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9EQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkZBQW1DO0FBQ2hFO0FBQ0E7QUFDQSx1Q0FBdUMsb0VBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEVBQTBFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJFQUFpQjtBQUNwRDtBQUNBO0FBQ0EsUUFBUSw0REFBZSxDQUFDLDRFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQWUsQ0FBQyw0RUFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBZSxDQUFDLDRFQUFrQix3QkFBd0IsZ0VBQXVCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0EsbUNBQW1DLFVBQVUscUJBQXFCLDJCQUEyQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvREFBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseURBQWdCO0FBQ2hFLHVDQUF1Qyx5REFBZ0I7QUFDdkQsdUNBQXVDLCtEQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxxQkFBcUIsMkJBQTJCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxT3NGO0FBQ3RGLE9BQU8sY0FBYyxHQUFHLGlFQUFtQjtBQUMzQyxPQUFPLGVBQWUsR0FBRyw2REFBZTtBQUNqQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTBCLCtEQUFrQjtBQUM1QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNFQUFpQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5c0M2QztBQUNpRTtBQUN6RDtBQUMraEI7QUFDcGY7QUFDZ0Q7QUFDbUM7QUFDekU7QUFDRDtBQUNkO0FBQ3FCO0FBQ3pDO0FBQ2lDO0FBQzlDO0FBQzBFO0FBQzNEO0FBQ0Y7QUFDRDtBQUNIO0FBQ1o7QUFDMEM7QUFDcEI7QUFDNkY7QUFDekU7QUFDMEU7QUFDM0ssaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQzVCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQ3BDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ2xDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQzlCO0FBQ1AsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsdUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlIb0Q7QUFDd0I7QUFDVDtBQUNIO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0RUFBa0I7QUFDOUMsYUFBYSxnRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSw0RUFBa0I7QUFDMUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0RUFBa0I7QUFDOUMsYUFBYSxnRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtB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QUFDOUIsSUFBSSwrQ0FBTTtBQUNWLGVBQWUsOENBQVM7QUFDeEIscUNBQXFDLDBEQUFTO0FBQzlDO0FBQ3dCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0RlO0FBQ0U7QUFDUztBQUNJOzs7Ozs7O1VDSHREO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3JCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQSxzRjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7OztVQ05BO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6ImJ1aWxkL2VudHJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmV0cnlJbnRlcmNlcHRvciB9IGZyb20gJy4vcmV0cnktaW50ZXJjZXB0b3IuanMnO1xuLyoqXG4gKiBBIGNsYXNzIGZvciBjb25maWd1cmluZyBIdHRwQ2xpZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEh0dHBDbGllbnRDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYXNlIFVSTCB0byBiZSBwcmVwZW5kZWQgdG8gZWFjaCBSZXF1ZXN0J3MgdXJsIGJlZm9yZSBzZW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlVXJsID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHZhbHVlcyB0byBhcHBseSB0byBpbml0IG9iamVjdHMgd2hlbiBjcmVhdGluZyBSZXF1ZXN0cy4gTm90ZSB0aGF0XG4gICAgICAgICAqIGRlZmF1bHRzIGNhbm5vdCBiZSBhcHBsaWVkIHdoZW4gUmVxdWVzdCBvYmplY3RzIGFyZSBtYW51YWxseSBjcmVhdGVkIGJlY2F1c2VcbiAgICAgICAgICogUmVxdWVzdCBwcm92aWRlcyBpdHMgb3duIGRlZmF1bHRzIGFuZCBkaXNjYXJkcyB0aGUgb3JpZ2luYWwgaW5pdCBvYmplY3QuXG4gICAgICAgICAqIFNlZSBhbHNvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXF1ZXN0L1JlcXVlc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVyY2VwdG9ycyB0byBiZSBhZGRlZCB0byB0aGUgSHR0cENsaWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gW107XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZVVybCAtIFRoZSBiYXNlIFVSTC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2hhaW5hYmxlIGluc3RhbmNlIG9mIHRoaXMgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHdpdGhCYXNlVXJsKGJhc2VVcmwpIHtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlZmF1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlZmF1bHRzIC0gVGhlIGRlZmF1bHRzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjaGFpbmFibGUgaW5zdGFuY2Ugb2YgdGhpcyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgd2l0aERlZmF1bHRzKGRlZmF1bHRzKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaW50ZXJjZXB0b3IgdG8gYmUgcnVuIG9uIGFsbCByZXF1ZXN0cyBvciByZXNwb25zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJjZXB0b3IgLSBBbiBvYmplY3Qgd2l0aCByZXF1ZXN0LCByZXF1ZXN0RXJyb3IsXG4gICAgICogcmVzcG9uc2UsIG9yIHJlc3BvbnNlRXJyb3IgbWV0aG9kcy4gcmVxdWVzdCBhbmQgcmVxdWVzdEVycm9yIGFjdCBhc1xuICAgICAqIHJlc29sdmUgYW5kIHJlamVjdCBoYW5kbGVycyBmb3IgdGhlIFJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnQuXG4gICAgICogcmVzcG9uc2UgYW5kIHJlc3BvbnNlRXJyb3IgYWN0IGFzIHJlc29sdmUgYW5kIHJlamVjdCBoYW5kbGVycyBmb3JcbiAgICAgKiB0aGUgUmVzcG9uc2UgYWZ0ZXIgaXQgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGNoYWluYWJsZSBpbnN0YW5jZSBvZiB0aGlzIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB3aXRoSW50ZXJjZXB0b3IoaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMucHVzaChpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgY29uZmlndXJhdGlvbiB0aGF0IGFkZHJlc3NlcyBjb21tb24gYXBwbGljYXRpb24gbmVlZHMsIGluY2x1ZGluZ1xuICAgICAqIGNvbmZpZ3VyaW5nIHNhbWUtb3JpZ2luIGNyZWRlbnRpYWxzLCBhbmQgdXNpbmcgcmVqZWN0RXJyb3JSZXNwb25zZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY2hhaW5hYmxlIGluc3RhbmNlIG9mIHRoaXMgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHVzZVN0YW5kYXJkQ29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRDb25maWcgPSB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5kZWZhdWx0cywgc3RhbmRhcmRDb25maWcsIHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWplY3RFcnJvclJlc3BvbnNlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXVzZXMgUmVzcG9uc2VzIHdob3NlIHN0YXR1cyBjb2RlcyBmYWxsIG91dHNpZGUgdGhlIHJhbmdlIDIwMC0yOTkgdG8gcmVqZWN0LlxuICAgICAqIFRoZSBmZXRjaCBBUEkgb25seSByZWplY3RzIG9uIG5ldHdvcmsgZXJyb3JzIG9yIG90aGVyIGNvbmRpdGlvbnMgdGhhdCBwcmV2ZW50XG4gICAgICogdGhlIHJlcXVlc3QgZnJvbSBjb21wbGV0aW5nLCBtZWFuaW5nIGNvbnN1bWVycyBtdXN0IGluc3BlY3QgUmVzcG9uc2Uub2sgaW4gdGhlXG4gICAgICogUHJvbWlzZSBjb250aW51YXRpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSBzdWNjZXNzIGNvZGUuXG4gICAgICogVGhpcyBtZXRob2QgYWRkcyBhIHJlc3BvbnNlIGludGVyY2VwdG9yIHRoYXQgY2F1c2VzIFJlc3BvbnNlcyB3aXRoIGVycm9yIGNvZGVzXG4gICAgICogdG8gYmUgcmVqZWN0ZWQsIHdoaWNoIGlzIGNvbW1vbiBiZWhhdmlvciBpbiBIVFRQIGNsaWVudCBsaWJyYXJpZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY2hhaW5hYmxlIGluc3RhbmNlIG9mIHRoaXMgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlamVjdEVycm9yUmVzcG9uc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoSW50ZXJjZXB0b3IoeyByZXNwb25zZTogcmVqZWN0T25FcnJvciB9KTtcbiAgICB9XG4gICAgd2l0aFJldHJ5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IG5ldyBSZXRyeUludGVyY2VwdG9yKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhJbnRlcmNlcHRvcihpbnRlcmNlcHRvcik7XG4gICAgfVxuICAgIHdpdGhEaXNwYXRjaGVyKGRpc3BhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVqZWN0T25FcnJvcihyZXNwb25zZSkge1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHAtY2xpZW50LWNvbmZpZ3VyYXRpb24uanMubWFwIiwiaW1wb3J0IHsgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSHR0cENsaWVudENvbmZpZ3VyYXRpb24gfSBmcm9tICcuL2h0dHAtY2xpZW50LWNvbmZpZ3VyYXRpb24uanMnO1xuaW1wb3J0IHsgUmV0cnlJbnRlcmNlcHRvciB9IGZyb20gJy4vcmV0cnktaW50ZXJjZXB0b3IuanMnO1xuY29uc3QgYWJzb2x1dGVVcmxSZWdleHAgPSAvXihbYS16XVthLXowLTkrXFwtLl0qOik/XFwvXFwvL2k7XG5leHBvcnQgY29uc3QgSUh0dHBDbGllbnQgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lIdHRwQ2xpZW50JywgeCA9PiB4LnNpbmdsZXRvbihIdHRwQ2xpZW50KSk7XG4vKipcbiAqIEFuIEhUVFAgY2xpZW50IGJhc2VkIG9uIHRoZSBGZXRjaCBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEh0dHBDbGllbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pc1JlcXVlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0NvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gJyc7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhpcyBjbGllbnQgd2l0aCBkZWZhdWx0IHNldHRpbmdzIHRvIGJlIHVzZWQgYnkgYWxsIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEEgY29uZmlndXJhdGlvbiBvYmplY3QsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvbmZpZ1xuICAgICAqIG9iamVjdCBhbmQgY29uZmlndXJlcyBpdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2hhaW5hYmxlIGluc3RhbmNlIG9mIHRoaXMgSHR0cENsaWVudC5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICBsZXQgbm9ybWFsaXplZENvbmZpZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5pdENvbmZpZ3VyYXRpb24gPSB7IGRlZmF1bHRzOiBjb25maWcgfTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRDb25maWcgPSByZXF1ZXN0SW5pdENvbmZpZ3VyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbm9ybWFsaXplZENvbmZpZyA9IG5ldyBIdHRwQ2xpZW50Q29uZmlndXJhdGlvbigpO1xuICAgICAgICAgICAgbm9ybWFsaXplZENvbmZpZy5iYXNlVXJsID0gdGhpcy5iYXNlVXJsO1xuICAgICAgICAgICAgbm9ybWFsaXplZENvbmZpZy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cyB9O1xuICAgICAgICAgICAgbm9ybWFsaXplZENvbmZpZy5pbnRlcmNlcHRvcnMgPSB0aGlzLmludGVyY2VwdG9ycztcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRDb25maWcuZGlzcGF0Y2hlciA9IHRoaXMuZGlzcGF0Y2hlcjtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb25maWcobm9ybWFsaXplZENvbmZpZyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoSHR0cENsaWVudENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBjKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRDb25maWcgPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvbmZpZycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0gbm9ybWFsaXplZENvbmZpZy5kZWZhdWx0cztcbiAgICAgICAgaWYgKGRlZmF1bHRzICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoSGVhZGVycy5wcm90b3R5cGUsIGRlZmF1bHRzLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBIZWFkZXJzIGluc3RhbmNlcyBhcmUgbm90IGl0ZXJhYmxlIGluIGFsbCBicm93c2Vycy4gUmVxdWlyZSBhIHBsYWluXG4gICAgICAgICAgICAvLyBvYmplY3QgaGVyZSB0byBhbGxvdyBkZWZhdWx0IGhlYWRlcnMgdG8gYmUgbWVyZ2VkIGludG8gcmVxdWVzdCBoZWFkZXJzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IGhlYWRlcnMgbXVzdCBiZSBhIHBsYWluIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBub3JtYWxpemVkQ29uZmlnLmludGVyY2VwdG9ycztcbiAgICAgICAgaWYgKGludGVyY2VwdG9ycyAhPT0gdW5kZWZpbmVkICYmIGludGVyY2VwdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgaWYgdGhlcmUgaXMgYSBSZXRyeUludGVyY2VwdG9yXG4gICAgICAgICAgICBpZiAoaW50ZXJjZXB0b3JzLmZpbHRlcih4ID0+IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKFJldHJ5SW50ZXJjZXB0b3IucHJvdG90eXBlLCB4KSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgUmV0cnlJbnRlcmNlcHRvciBpcyBhbGxvd2VkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0cnlJbnRlcmNlcHRvckluZGV4ID0gaW50ZXJjZXB0b3JzLmZpbmRJbmRleCh4ID0+IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKFJldHJ5SW50ZXJjZXB0b3IucHJvdG90eXBlLCB4KSk7XG4gICAgICAgICAgICBpZiAocmV0cnlJbnRlcmNlcHRvckluZGV4ID49IDAgJiYgcmV0cnlJbnRlcmNlcHRvckluZGV4ICE9PSBpbnRlcmNlcHRvcnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJldHJ5IGludGVyY2VwdG9yIG11c3QgYmUgdGhlIGxhc3QgaW50ZXJjZXB0b3IgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhc2VVcmwgPSBub3JtYWxpemVkQ29uZmlnLmJhc2VVcmw7XG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSBub3JtYWxpemVkQ29uZmlnLmludGVyY2VwdG9ycyAhPT0gdW5kZWZpbmVkID8gbm9ybWFsaXplZENvbmZpZy5pbnRlcmNlcHRvcnMgOiBbXTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gbm9ybWFsaXplZENvbmZpZy5kaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLmlzQ29uZmlndXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHByb2Nlc3Mgb2YgZmV0Y2hpbmcgYSByZXNvdXJjZS4gRGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIFJlcXVlc3QuIFRoZSBjb25zdHJ1Y3RlZCBSZXF1ZXN0IHdpbGwgYmUgcGFzc2VkIHRvXG4gICAgICogcmVnaXN0ZXJlZCByZXF1ZXN0IGludGVyY2VwdG9ycyBiZWZvcmUgYmVpbmcgc2VudC4gVGhlIFJlc3BvbnNlIHdpbGwgYmUgcGFzc2VkXG4gICAgICogdG8gcmVnaXN0ZXJlZCBSZXNwb25zZSBpbnRlcmNlcHRvcnMgYmVmb3JlIGl0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogU2VlIGFsc28gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSVxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IC0gVGhlIHJlc291cmNlIHRoYXQgeW91IHdpc2ggdG8gZmV0Y2guIEVpdGhlciBhXG4gICAgICogUmVxdWVzdCBvYmplY3QsIG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIFVSTCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIGluaXQgLSBBbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHNldHRpbmdzIHRvIGJlIGFwcGxpZWQgdG9cbiAgICAgKiB0aGUgUmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIHRoZSBSZXNwb25zZSBmcm9tIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGZldGNoKGlucHV0LCBpbml0KSB7XG4gICAgICAgIHRoaXMudHJhY2tSZXF1ZXN0U3RhcnQoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXF1ZXN0KHJlcXVlc3QsIHRoaXMuaW50ZXJjZXB0b3JzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoUmVzcG9uc2UucHJvdG90eXBlLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKFJlcXVlc3QucHJvdG90eXBlLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZldGNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBpbnZhbGlkIHJlc3VsdCB3YXMgcmV0dXJuZWQgYnkgdGhlIGludGVyY2VwdG9yIGNoYWluLiBFeHBlY3RlZCBhIFJlcXVlc3Qgb3IgUmVzcG9uc2UgaW5zdGFuY2UsIGJ1dCBnb3QgWyR7cmVzdWx0fV1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgdGhpcy5pbnRlcmNlcHRvcnMsIHJlcXVlc3QpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tSZXF1ZXN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrUmVxdWVzdEVuZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZFJlcXVlc3QoaW5wdXQsIGluaXQpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzICE9PSBudWxsID8gdGhpcy5kZWZhdWx0cyA6IHt9O1xuICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGxldCByZXF1ZXN0Q29udGVudFR5cGU7XG4gICAgICAgIGNvbnN0IHBhcnNlZERlZmF1bHRIZWFkZXJzID0gcGFyc2VIZWFkZXJWYWx1ZXMoZGVmYXVsdHMuaGVhZGVycyk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSwgaW5wdXQpKSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gaW5wdXQ7XG4gICAgICAgICAgICByZXF1ZXN0Q29udGVudFR5cGUgPSBuZXcgSGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWluaXQpIHtcbiAgICAgICAgICAgICAgICBpbml0ID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5ID0gaW5pdC5ib2R5O1xuICAgICAgICAgICAgY29uc3QgYm9keU9iaiA9IGJvZHkgIT09IHVuZGVmaW5lZCA/IHsgYm9keTogYm9keSB9IDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbml0ID0geyAuLi5kZWZhdWx0cywgaGVhZGVyczoge30sIC4uLmluaXQsIC4uLmJvZHlPYmogfTtcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZW50VHlwZSA9IG5ldyBIZWFkZXJzKHJlcXVlc3RJbml0LmhlYWRlcnMpLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoZ2V0UmVxdWVzdFVybCh0aGlzLmJhc2VVcmwsIGlucHV0KSwgcmVxdWVzdEluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVxdWVzdENvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAobmV3IEhlYWRlcnMocGFyc2VkRGVmYXVsdEhlYWRlcnMpLmhhcygnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCBuZXcgSGVhZGVycyhwYXJzZWREZWZhdWx0SGVhZGVycykuZ2V0KCdjb250ZW50LXR5cGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChib2R5ICE9PSB1bmRlZmluZWQgJiYgaXNKU09OKGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXREZWZhdWx0SGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMsIHBhcnNlZERlZmF1bHRIZWFkZXJzKTtcbiAgICAgICAgaWYgKGJvZHkgIT09IHVuZGVmaW5lZCAmJiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChCbG9iLnByb3RvdHlwZSwgYm9keSkgJiYgYm9keS50eXBlKSB7XG4gICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBidWcgaW4gSUUgJiBFZGdlIHdoZXJlIHRoZSBCbG9iIHR5cGUgaXMgaWdub3JlZCBpbiB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8yMTM2MTYzXG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCBib2R5LnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBmZXRjaCBhcyBhIEdFVCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IC0gVGhlIHJlc291cmNlIHRoYXQgeW91IHdpc2ggdG8gZmV0Y2guIEVpdGhlciBhXG4gICAgICogUmVxdWVzdCBvYmplY3QsIG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIFVSTCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIGluaXQgLSBBbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHNldHRpbmdzIHRvIGJlIGFwcGxpZWQgdG9cbiAgICAgKiB0aGUgUmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIHRoZSBSZXNwb25zZSBmcm9tIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGdldChpbnB1dCwgaW5pdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChpbnB1dCwgaW5pdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIGZldGNoIHdpdGggcmVxdWVzdCBtZXRob2Qgc2V0IHRvIFBPU1QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgcmVzb3VyY2UgdGhhdCB5b3Ugd2lzaCB0byBmZXRjaC4gRWl0aGVyIGFcbiAgICAgKiBSZXF1ZXN0IG9iamVjdCwgb3IgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgVVJMIG9mIHRoZSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBpbml0IC0gQW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyB0byBiZSBhcHBsaWVkIHRvXG4gICAgICogdGhlIFJlcXVlc3QuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIGZvciB0aGUgUmVzcG9uc2UgZnJvbSB0aGUgZmV0Y2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBwb3N0KGlucHV0LCBib2R5LCBpbml0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxGZXRjaChpbnB1dCwgYm9keSwgaW5pdCwgJ1BPU1QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgZmV0Y2ggd2l0aCByZXF1ZXN0IG1ldGhvZCBzZXQgdG8gUFVULlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IC0gVGhlIHJlc291cmNlIHRoYXQgeW91IHdpc2ggdG8gZmV0Y2guIEVpdGhlciBhXG4gICAgICogUmVxdWVzdCBvYmplY3QsIG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIFVSTCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gaW5pdCAtIEFuIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgc2V0dGluZ3MgdG8gYmUgYXBwbGllZCB0b1xuICAgICAqIHRoZSBSZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgdGhlIFJlc3BvbnNlIGZyb20gdGhlIGZldGNoIHJlcXVlc3QuXG4gICAgICovXG4gICAgcHV0KGlucHV0LCBib2R5LCBpbml0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxGZXRjaChpbnB1dCwgYm9keSwgaW5pdCwgJ1BVVCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBmZXRjaCB3aXRoIHJlcXVlc3QgbWV0aG9kIHNldCB0byBQQVRDSC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0aGF0IHlvdSB3aXNoIHRvIGZldGNoLiBFaXRoZXIgYVxuICAgICAqIFJlcXVlc3Qgb2JqZWN0LCBvciBhIHN0cmluZyBjb250YWluaW5nIHRoZSBVUkwgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGluaXQgLSBBbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHNldHRpbmdzIHRvIGJlIGFwcGxpZWQgdG9cbiAgICAgKiB0aGUgUmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIHRoZSBSZXNwb25zZSBmcm9tIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIHBhdGNoKGlucHV0LCBib2R5LCBpbml0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxGZXRjaChpbnB1dCwgYm9keSwgaW5pdCwgJ1BBVENIJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIGZldGNoIHdpdGggcmVxdWVzdCBtZXRob2Qgc2V0IHRvIERFTEVURS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0aGF0IHlvdSB3aXNoIHRvIGZldGNoLiBFaXRoZXIgYVxuICAgICAqIFJlcXVlc3Qgb2JqZWN0LCBvciBhIHN0cmluZyBjb250YWluaW5nIHRoZSBVUkwgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGluaXQgLSBBbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHNldHRpbmdzIHRvIGJlIGFwcGxpZWQgdG9cbiAgICAgKiB0aGUgUmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIHRoZSBSZXNwb25zZSBmcm9tIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGRlbGV0ZShpbnB1dCwgYm9keSwgaW5pdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRmV0Y2goaW5wdXQsIGJvZHksIGluaXQsICdERUxFVEUnKTtcbiAgICB9XG4gICAgdHJhY2tSZXF1ZXN0U3RhcnQoKSB7XG4gICAgICAgIHRoaXMuaXNSZXF1ZXN0aW5nID0gISEoKyt0aGlzLmFjdGl2ZVJlcXVlc3RDb3VudCk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVxdWVzdGluZyAmJiB0aGlzLmRpc3BhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IG5ldyB0aGlzLmRpc3BhdGNoZXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5DdXN0b21FdmVudCgnYXVyZWxpYS1mZXRjaC1jbGllbnQtcmVxdWVzdC1zdGFydGVkJywgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KGV2dCk7IH0sIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYWNrUmVxdWVzdEVuZCgpIHtcbiAgICAgICAgdGhpcy5pc1JlcXVlc3RpbmcgPSAhISgtLXRoaXMuYWN0aXZlUmVxdWVzdENvdW50KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVxdWVzdGluZyAmJiB0aGlzLmRpc3BhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IG5ldyB0aGlzLmRpc3BhdGNoZXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5DdXN0b21FdmVudCgnYXVyZWxpYS1mZXRjaC1jbGllbnQtcmVxdWVzdHMtZHJhaW5lZCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmRpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChldnQpOyB9LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUmVxdWVzdChyZXF1ZXN0LCBpbnRlcmNlcHRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlJbnRlcmNlcHRvcnMocmVxdWVzdCwgaW50ZXJjZXB0b3JzLCAncmVxdWVzdCcsICdyZXF1ZXN0RXJyb3InLCB0aGlzKTtcbiAgICB9XG4gICAgcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCBpbnRlcmNlcHRvcnMsIHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlJbnRlcmNlcHRvcnMocmVzcG9uc2UsIGludGVyY2VwdG9ycywgJ3Jlc3BvbnNlJywgJ3Jlc3BvbnNlRXJyb3InLCByZXF1ZXN0LCB0aGlzKTtcbiAgICB9XG4gICAgYXBwbHlJbnRlcmNlcHRvcnMoaW5wdXQsIGludGVyY2VwdG9ycywgc3VjY2Vzc05hbWUsIGVycm9yTmFtZSwgLi4uaW50ZXJjZXB0b3JBcmdzKSB7XG4gICAgICAgIHJldHVybiAoaW50ZXJjZXB0b3JzICE9PSB1bmRlZmluZWQgPyBpbnRlcmNlcHRvcnMgOiBbXSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGNoYWluLCBpbnRlcmNlcHRvcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc0hhbmRsZXIgPSBpbnRlcmNlcHRvcltzdWNjZXNzTmFtZV07XG4gICAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBpbnRlcmNlcHRvcltlcnJvck5hbWVdO1xuICAgICAgICAgICAgLy8gVE9ETzogRml4IHRoaXMsIGFzIGl0IHZpb2xhdGVzIGBzdHJpY3RCaW5kQ2FsbEFwcGx5YC5cbiAgICAgICAgICAgIHJldHVybiBjaGFpbi50aGVuKHN1Y2Nlc3NIYW5kbGVyID8gKHZhbHVlID0+IHN1Y2Nlc3NIYW5kbGVyLmNhbGwoaW50ZXJjZXB0b3IsIHZhbHVlLCAuLi5pbnRlcmNlcHRvckFyZ3MpKSA6IGlkZW50aXR5LCBlcnJvckhhbmRsZXIgPyAocmVhc29uID0+IGVycm9ySGFuZGxlci5jYWxsKGludGVyY2VwdG9yLCByZWFzb24sIC4uLmludGVyY2VwdG9yQXJncykpIDogdGhyb3dlcik7XG4gICAgICAgIH0sIFByb21pc2UucmVzb2x2ZShpbnB1dCkpO1xuICAgIH1cbiAgICBjYWxsRmV0Y2goaW5wdXQsIGJvZHksIGluaXQsIG1ldGhvZCkge1xuICAgICAgICBpZiAoIWluaXQpIHtcbiAgICAgICAgICAgIGluaXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpbml0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIGluaXQuYm9keSA9IGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goaW5wdXQsIGluaXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyVmFsdWVzKGhlYWRlcnMpIHtcbiAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0ge307XG4gICAgY29uc3QgJGhlYWRlcnMgPSBoZWFkZXJzICE9PSB1bmRlZmluZWQgPyBoZWFkZXJzIDoge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluICRoZWFkZXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJGhlYWRlcnMsIG5hbWUpKSB7XG4gICAgICAgICAgICBwYXJzZWRIZWFkZXJzW25hbWVdID0gKHR5cGVvZiAkaGVhZGVyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICA/ICRoZWFkZXJzW25hbWVdKClcbiAgICAgICAgICAgICAgICA6ICRoZWFkZXJzW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRIZWFkZXJzO1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdFVybChiYXNlVXJsLCB1cmwpIHtcbiAgICBpZiAoYWJzb2x1dGVVcmxSZWdleHAudGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHJldHVybiAoYmFzZVVybCAhPT0gdW5kZWZpbmVkID8gYmFzZVVybCA6ICcnKSArIHVybDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRIZWFkZXJzKGhlYWRlcnMsIGRlZmF1bHRIZWFkZXJzKSB7XG4gICAgY29uc3QgJGRlZmF1bHRIZWFkZXJzID0gZGVmYXVsdEhlYWRlcnMgIT09IHVuZGVmaW5lZCA/IGRlZmF1bHRIZWFkZXJzIDoge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluICRkZWZhdWx0SGVhZGVycykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCRkZWZhdWx0SGVhZGVycywgbmFtZSkgJiYgIWhlYWRlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldChuYW1lLCAkZGVmYXVsdEhlYWRlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNKU09OKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xufVxuZnVuY3Rpb24gdGhyb3dlcih4KSB7XG4gICAgdGhyb3cgeDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHAtY2xpZW50LmpzLm1hcCIsImV4cG9ydCB7IGpzb24gfSBmcm9tICcuL3V0aWwuanMnO1xuZXhwb3J0IHsgcmV0cnlTdHJhdGVneSwgUmV0cnlJbnRlcmNlcHRvciB9IGZyb20gJy4vcmV0cnktaW50ZXJjZXB0b3IuanMnO1xuZXhwb3J0IHsgSHR0cENsaWVudENvbmZpZ3VyYXRpb24gfSBmcm9tICcuL2h0dHAtY2xpZW50LWNvbmZpZ3VyYXRpb24uanMnO1xuZXhwb3J0IHsgSHR0cENsaWVudCwgSUh0dHBDbGllbnQgfSBmcm9tICcuL2h0dHAtY2xpZW50LmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCByZXRyeVN0cmF0ZWd5ID0ge1xuICAgIGZpeGVkOiAwLFxuICAgIGluY3JlbWVudGFsOiAxLFxuICAgIGV4cG9uZW50aWFsOiAyLFxuICAgIHJhbmRvbTogM1xufTtcbmNvbnN0IGRlZmF1bHRSZXRyeUNvbmZpZyA9IHtcbiAgICBtYXhSZXRyaWVzOiAzLFxuICAgIGludGVydmFsOiAxMDAwLFxuICAgIHN0cmF0ZWd5OiByZXRyeVN0cmF0ZWd5LmZpeGVkXG59O1xuLyoqXG4gKiBJbnRlcmNlcHRvciB0aGF0IHJldHJpZXMgcmVxdWVzdHMgb24gZXJyb3IsIGJhc2VkIG9uIGEgZ2l2ZW4gUmV0cnlDb25maWd1cmF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgUmV0cnlJbnRlcmNlcHRvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXRyeUludGVyY2VwdG9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJldHJ5Q29uZmlnKSB7XG4gICAgICAgIHRoaXMucmV0cnlDb25maWcgPSB7IC4uLmRlZmF1bHRSZXRyeUNvbmZpZywgLi4uKHJldHJ5Q29uZmlnICE9PSB1bmRlZmluZWQgPyByZXRyeUNvbmZpZyA6IHt9KSB9O1xuICAgICAgICBpZiAodGhpcy5yZXRyeUNvbmZpZy5zdHJhdGVneSA9PT0gcmV0cnlTdHJhdGVneS5leHBvbmVudGlhbCAmJlxuICAgICAgICAgICAgdGhpcy5yZXRyeUNvbmZpZy5pbnRlcnZhbCA8PSAxMDAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGludGVydmFsIGxlc3MgdGhhbiBvciBlcXVhbCB0byAxIHNlY29uZCBpcyBub3QgYWxsb3dlZCB3aGVuIHVzaW5nIHRoZSBleHBvbmVudGlhbCByZXRyeSBzdHJhdGVneScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHRoZSByZXF1ZXN0IGJlZm9yZSBpdCBpcyBzZW50LiBJdCByZW1lbWJlcnMgdGhlIHJlcXVlc3Qgc28gaXQgY2FuIGJlIHJldHJpZWQgb24gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IHRvIGJlIHNlbnQuXG4gICAgICogQHJldHVybnMgVGhlIGV4aXN0aW5nIHJlcXVlc3QsIGEgbmV3IHJlcXVlc3Qgb3IgYSByZXNwb25zZTsgb3IgYSBQcm9taXNlIGZvciBhbnkgb2YgdGhlc2UuXG4gICAgICovXG4gICAgcmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGlmICghcmVxdWVzdC5yZXRyeUNvbmZpZykge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUNvbmZpZyA9IHsgLi4udGhpcy5yZXRyeUNvbmZpZyB9O1xuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUNvbmZpZy5jb3VudGVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkbyB0aGlzIG9uIGV2ZXJ5IHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdC5yZXRyeUNvbmZpZy5yZXF1ZXN0Q2xvbmUgPSByZXF1ZXN0LmNsb25lKCk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCB0aGUgcmVzcG9uc2UgYWZ0ZXIgaXQgaXMgcmVjZWl2ZWQuIENsZWFycyB0aGUgcmVtZW1iZXJlZCByZXF1ZXN0LCBhcyBpdCB3YXMgc3VjY2VzZnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSByZXNwb25zZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2U7IG9yIGEgUHJvbWlzZSBmb3Igb25lLlxuICAgICAqL1xuICAgIHJlc3BvbnNlKHJlc3BvbnNlLCByZXF1ZXN0KSB7XG4gICAgICAgIC8vIHJldHJ5IHdhcyBzdWNjZXNzZnVsLCBzbyBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXNcbiAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShyZXF1ZXN0LCAncmV0cnlDb25maWcnKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGZldGNoIGVycm9ycyBhbmQgZXJyb3JzIGdlbmVyYXRlZCBieSBwcmV2aW91cyBpbnRlcmNlcHRvcnMuIFRoaXNcbiAgICAgKiBmdW5jdGlvbiBhY3RzIGFzIGEgUHJvbWlzZSByZWplY3Rpb24gaGFuZGxlci4gSXQgd2lsIHJldHJ5IHRoZSByZW1lbWJlcmVkIHJlcXVlc3QgYmFzZWQgb24gdGhlXG4gICAgICogY29uZmlndXJlZCBSZXRyeUNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgcmVqZWN0aW9uIHZhbHVlIGZyb20gdGhlIGZldGNoIHJlcXVlc3Qgb3IgZnJvbSBhXG4gICAgICogcHJldmlvdXMgaW50ZXJjZXB0b3IuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIG9mIHRoZSByZXRyeTsgb3IgYSBQcm9taXNlIGZvciBvbmUuXG4gICAgICovXG4gICAgcmVzcG9uc2VFcnJvcihlcnJvciwgcmVxdWVzdCwgaHR0cENsaWVudCkge1xuICAgICAgICBjb25zdCB7IHJldHJ5Q29uZmlnIH0gPSByZXF1ZXN0O1xuICAgICAgICBjb25zdCB7IHJlcXVlc3RDbG9uZSB9ID0gcmV0cnlDb25maWc7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXRyeUNvbmZpZy5jb3VudGVyIDwgcmV0cnlDb25maWcubWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJldHJ5Q29uZmlnLmRvUmV0cnkgIT09IHVuZGVmaW5lZCA/IHJldHJ5Q29uZmlnLmRvUmV0cnkoZXJyb3IsIHJlcXVlc3QpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihkb1JldHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvUmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q29uZmlnLmNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gY2FsY3VsYXRlRGVsYXkocmV0cnlDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAhaXNOYU4oZGVsYXkpID8gZGVsYXkgOiAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UmVxdWVzdCA9IHJlcXVlc3RDbG9uZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5Q29uZmlnLmJlZm9yZVJldHJ5KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0cnlDb25maWcuYmVmb3JlUmV0cnkobmV3UmVxdWVzdCwgaHR0cENsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihuZXdSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeWFibGVSZXF1ZXN0ID0geyAuLi5uZXdSZXF1ZXN0LCByZXRyeUNvbmZpZyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodHRwQ2xpZW50LmZldGNoKHJldHJ5YWJsZVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbW9yZSByZXRyaWVzLCBzbyBjbGVhbiB1cFxuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHJlcXVlc3QsICdyZXRyeUNvbmZpZycpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vIG1vcmUgcmV0cmllcywgc28gY2xlYW4gdXBcbiAgICAgICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkocmVxdWVzdCwgJ3JldHJ5Q29uZmlnJyk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsYXkocmV0cnlDb25maWcpIHtcbiAgICBjb25zdCB7IGludGVydmFsLCBzdHJhdGVneSwgbWluUmFuZG9tSW50ZXJ2YWwsIG1heFJhbmRvbUludGVydmFsLCBjb3VudGVyIH0gPSByZXRyeUNvbmZpZztcbiAgICBpZiAodHlwZW9mIChzdHJhdGVneSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJldHJ5Q29uZmlnLnN0cmF0ZWd5KGNvdW50ZXIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgIGNhc2UgKHJldHJ5U3RyYXRlZ3kuZml4ZWQpOlxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5U3RyYXRlZ2llc1tyZXRyeVN0cmF0ZWd5LmZpeGVkXShpbnRlcnZhbCk7XG4gICAgICAgIGNhc2UgKHJldHJ5U3RyYXRlZ3kuaW5jcmVtZW50YWwpOlxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5U3RyYXRlZ2llc1tyZXRyeVN0cmF0ZWd5LmluY3JlbWVudGFsXShjb3VudGVyLCBpbnRlcnZhbCk7XG4gICAgICAgIGNhc2UgKHJldHJ5U3RyYXRlZ3kuZXhwb25lbnRpYWwpOlxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5U3RyYXRlZ2llc1tyZXRyeVN0cmF0ZWd5LmV4cG9uZW50aWFsXShjb3VudGVyLCBpbnRlcnZhbCk7XG4gICAgICAgIGNhc2UgKHJldHJ5U3RyYXRlZ3kucmFuZG9tKTpcbiAgICAgICAgICAgIHJldHVybiByZXRyeVN0cmF0ZWdpZXNbcmV0cnlTdHJhdGVneS5yYW5kb21dKGNvdW50ZXIsIGludGVydmFsLCBtaW5SYW5kb21JbnRlcnZhbCwgbWF4UmFuZG9tSW50ZXJ2YWwpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgcmV0cnkgc3RyYXRlZ3knKTtcbiAgICB9XG59XG5jb25zdCByZXRyeVN0cmF0ZWdpZXMgPSBbXG4gICAgLy8gZml4ZWRcbiAgICBpbnRlcnZhbCA9PiBpbnRlcnZhbCxcbiAgICAvLyBpbmNyZW1lbnRhbFxuICAgIChyZXRyeUNvdW50LCBpbnRlcnZhbCkgPT4gaW50ZXJ2YWwgKiByZXRyeUNvdW50LFxuICAgIC8vIGV4cG9uZW50aWFsXG4gICAgKHJldHJ5Q291bnQsIGludGVydmFsKSA9PiByZXRyeUNvdW50ID09PSAxID8gaW50ZXJ2YWwgOiBpbnRlcnZhbCAqKiByZXRyeUNvdW50IC8gMTAwMCxcbiAgICAvLyByYW5kb21cbiAgICAocmV0cnlDb3VudCwgaW50ZXJ2YWwsIG1pblJhbmRvbUludGVydmFsID0gMCwgbWF4UmFuZG9tSW50ZXJ2YWwgPSA2MDAwMCkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXhSYW5kb21JbnRlcnZhbCAtIG1pblJhbmRvbUludGVydmFsKSArIG1pblJhbmRvbUludGVydmFsO1xuICAgIH1cbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeS1pbnRlcmNlcHRvci5qcy5tYXAiLCIvKipcbiAqIFNlcmlhbGl6ZSBhbiBvYmplY3QgdG8gSlNPTi4gVXNlZnVsIGZvciBlYXNpbHkgY3JlYXRpbmcgSlNPTiBmZXRjaCByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBAcGFyYW0gYm9keSAtIFRoZSBvYmplY3QgdG8gYmUgc2VyaWFsaXplZCB0byBKU09OLlxuICogQHBhcmFtIHJlcGxhY2VyIC0gVGhlIEpTT04uc3RyaW5naWZ5IHJlcGxhY2VyIHVzZWQgd2hlbiBzZXJpYWxpemluZy5cbiAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uKGJvZHksIHJlcGxhY2VyKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KChib2R5ICE9PSB1bmRlZmluZWQgPyBib2R5IDoge30pLCByZXBsYWNlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsImltcG9ydCB7IE1ldGFkYXRhLCBpc09iamVjdCwgYXBwbHlNZXRhZGF0YVBvbHlmaWxsIH0gZnJvbSAnQGF1cmVsaWEvbWV0YWRhdGEnO1xuYXBwbHlNZXRhZGF0YVBvbHlmaWxsKFJlZmxlY3QpO1xuaW1wb3J0IHsgaXNBcnJheUluZGV4LCBpc05hdGl2ZUZ1bmN0aW9uIH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHsgZW1wdHlBcnJheSB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgUHJvdG9jb2wgfSBmcm9tICcuL3Jlc291cmNlLmpzJztcbmV4cG9ydCBjbGFzcyBSZXNvbHZlckJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwga2V5KSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgaW5zdGFuY2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJSZXNvbHZlcigwIC8qIGluc3RhbmNlICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIHNpbmdsZXRvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclJlc29sdmVyKDEgLyogc2luZ2xldG9uICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIHRyYW5zaWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclJlc29sdmVyKDIgLyogdHJhbnNpZW50ICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyUmVzb2x2ZXIoMyAvKiBjYWxsYmFjayAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBjYWNoZWRDYWxsYmFjayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclJlc29sdmVyKDMgLyogY2FsbGJhY2sgKi8sIGNhY2hlQ2FsbGJhY2tSZXN1bHQodmFsdWUpKTtcbiAgICB9XG4gICAgYWxpYXNUbyhkZXN0aW5hdGlvbktleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclJlc29sdmVyKDUgLyogYWxpYXMgKi8sIGRlc3RpbmF0aW9uS2V5KTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZXNvbHZlcihzdHJhdGVneSwgc3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXIsIGtleSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmtleSA9ICh2b2lkIDApO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoa2V5LCBuZXcgUmVzb2x2ZXIoa2V5LCBzdHJhdGVneSwgc3RhdGUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9uZUFycmF5V2l0aFBvc3NpYmxlUHJvcHMoc291cmNlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzb3VyY2Uuc2xpY2UoKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFpc0FycmF5SW5kZXgoa2V5KSkge1xuICAgICAgICAgICAgY2xvbmVba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cbmV4cG9ydCBjb25zdCBEZWZhdWx0UmVzb2x2ZXIgPSB7XG4gICAgbm9uZShrZXkpIHsgdGhyb3cgRXJyb3IoYCR7a2V5LnRvU3RyaW5nKCl9IG5vdCByZWdpc3RlcmVkLCBkaWQgeW91IGZvcmdldCB0byBhZGQgQHNpbmdsZXRvbigpP2ApOyB9LFxuICAgIHNpbmdsZXRvbihrZXkpIHsgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDEgLyogc2luZ2xldG9uICovLCBrZXkpOyB9LFxuICAgIHRyYW5zaWVudChrZXkpIHsgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDIgLyogdHJhbnNpZW50ICovLCBrZXkpOyB9LFxufTtcbmV4cG9ydCBjbGFzcyBDb250YWluZXJDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbmhlcml0UGFyZW50UmVzb3VyY2VzLCBkZWZhdWx0UmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5pbmhlcml0UGFyZW50UmVzb3VyY2VzID0gaW5oZXJpdFBhcmVudFJlc291cmNlcztcbiAgICAgICAgdGhpcy5kZWZhdWx0UmVzb2x2ZXIgPSBkZWZhdWx0UmVzb2x2ZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDAgfHxcbiAgICAgICAgICAgIGNvbmZpZyA9PT0gQ29udGFpbmVyQ29uZmlndXJhdGlvbi5ERUZBVUxUKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29udGFpbmVyQ29uZmlndXJhdGlvbi5ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyQ29uZmlndXJhdGlvbihjb25maWcuaW5oZXJpdFBhcmVudFJlc291cmNlcyA/PyBmYWxzZSwgY29uZmlnLmRlZmF1bHRSZXNvbHZlciA/PyBEZWZhdWx0UmVzb2x2ZXIuc2luZ2xldG9uKTtcbiAgICB9XG59XG5Db250YWluZXJDb25maWd1cmF0aW9uLkRFRkFVTFQgPSBDb250YWluZXJDb25maWd1cmF0aW9uLmZyb20oe30pO1xuZXhwb3J0IGNvbnN0IERJID0ge1xuICAgIGNyZWF0ZUNvbnRhaW5lcihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIobnVsbCwgQ29udGFpbmVyQ29uZmlndXJhdGlvbi5mcm9tKGNvbmZpZykpO1xuICAgIH0sXG4gICAgZ2V0RGVzaWduUGFyYW10eXBlcyhUeXBlKSB7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5nZXRPd24oJ2Rlc2lnbjpwYXJhbXR5cGVzJywgVHlwZSk7XG4gICAgfSxcbiAgICBnZXRBbm5vdGF0aW9uUGFyYW10eXBlcyhUeXBlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKCdkaTpwYXJhbXR5cGVzJyk7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5nZXRPd24oa2V5LCBUeXBlKTtcbiAgICB9LFxuICAgIGdldE9yQ3JlYXRlQW5ub3RhdGlvblBhcmFtVHlwZXMoVHlwZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcignZGk6cGFyYW10eXBlcycpO1xuICAgICAgICBsZXQgYW5ub3RhdGlvblBhcmFtdHlwZXMgPSBNZXRhZGF0YS5nZXRPd24oa2V5LCBUeXBlKTtcbiAgICAgICAgaWYgKGFubm90YXRpb25QYXJhbXR5cGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShrZXksIGFubm90YXRpb25QYXJhbXR5cGVzID0gW10sIFR5cGUpO1xuICAgICAgICAgICAgUHJvdG9jb2wuYW5ub3RhdGlvbi5hcHBlbmRUbyhUeXBlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uUGFyYW10eXBlcztcbiAgICB9LFxuICAgIGdldERlcGVuZGVuY2llcyhUeXBlKSB7XG4gICAgICAgIC8vIE5vdGU6IEV2ZXJ5IGRldGFpbCBvZiB0aGlzIGdldERlcGVuZGVuY2llcyBtZXRob2QgaXMgcHJldHR5IGRlbGliZXJhdGUgYXQgdGhlIG1vbWVudCwgYW5kIHByb2JhYmx5IG5vdCB5ZXQgMTAwJSB0ZXN0ZWQgZnJvbSBldmVyeSBwb3NzaWJsZSBhbmdsZSxcbiAgICAgICAgLy8gc28gYmUgY2FyZWZ1bCB3aXRoIG1ha2luZyBjaGFuZ2VzIGhlcmUgYXMgaXQgY2FuIGhhdmUgYSBodWdlIGltcGFjdCBvbiBjb21wbGV4IGVuZCB1c2VyIGFwcHMuXG4gICAgICAgIC8vIFByZWZlcmFibHksIG9ubHkgbWFrZSBjaGFuZ2VzIHRvIHRoZSBkZXBlbmRlbmN5IHJlc29sdXRpb24gcHJvY2VzcyB2aWEgYSBSRkMuXG4gICAgICAgIGNvbnN0IGtleSA9IFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKCdkaTpkZXBlbmRlbmNpZXMnKTtcbiAgICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IE1ldGFkYXRhLmdldE93bihrZXksIFR5cGUpO1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIC8vIFR5cGUubGVuZ3RoIGlzIHRoZSBudW1iZXIgb2YgY29uc3RydWN0b3IgcGFyYW1ldGVycy4gSWYgdGhpcyBpcyAwLCBpdCBjb3VsZCBtZWFuIHRoZSBjbGFzcyBoYXMgYW4gZW1wdHkgY29uc3RydWN0b3JcbiAgICAgICAgICAgIC8vIGJ1dCBpdCBjb3VsZCBhbHNvIG1lYW4gdGhlIGNsYXNzIGhhcyBubyBjb25zdHJ1Y3RvciBhdCBhbGwgKGluIHdoaWNoIGNhc2UgaXQgaW5oZXJpdHMgdGhlIGNvbnN0cnVjdG9yIGZyb20gdGhlIHByb3RvdHlwZSkuXG4gICAgICAgICAgICAvLyBOb24temVybyBjb25zdHJ1Y3RvciBsZW5ndGggKyBubyBwYXJhbXR5cGVzIG1lYW5zIGVtaXREZWNvcmF0b3JNZXRhZGF0YSBpcyBvZmYsIG9yIHRoZSBjbGFzcyBoYXMgbm8gZGVjb3JhdG9yLlxuICAgICAgICAgICAgLy8gV2UncmUgbm90IGRvaW5nIGFueXRoaW5nIHdpdGggdGhlIGFib3ZlIHJpZ2h0IG5vdywgYnV0IGl0J3MgZ29vZCB0byBrZWVwIGluIG1pbmQgZm9yIGFueSBmdXR1cmUgaXNzdWVzLlxuICAgICAgICAgICAgY29uc3QgaW5qZWN0ID0gVHlwZS5pbmplY3Q7XG4gICAgICAgICAgICBpZiAoaW5qZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAvLyBkZXNpZ246cGFyYW10eXBlcyBpcyBzZXQgYnkgdHNjIHdoZW4gZW1pdERlY29yYXRvck1ldGFkYXRhIGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzaWduUGFyYW10eXBlcyA9IERJLmdldERlc2lnblBhcmFtdHlwZXMoVHlwZSk7XG4gICAgICAgICAgICAgICAgLy8gYXU6YW5ub3RhdGlvbjpkaTpwYXJhbXR5cGVzIGlzIHNldCBieSB0aGUgcGFyYW1ldGVyIGRlY29yYXRvciBmcm9tIERJLmNyZWF0ZUludGVyZmFjZSBvciBieSBAaW5qZWN0XG4gICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblBhcmFtdHlwZXMgPSBESS5nZXRBbm5vdGF0aW9uUGFyYW10eXBlcyhUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzaWduUGFyYW10eXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uUGFyYW10eXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGdvIHVwIHRoZSBwcm90b3R5cGUgaWYgbmVpdGhlciBzdGF0aWMgaW5qZWN0IG5vciBhbnkgb2YgdGhlIHBhcmFtdHlwZXMgaXMgZGVmaW5lZCwgYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHNvdW5kIHdheSB0byBtZXJnZSBhIHR5cGUncyBkZXBzIHdpdGggaXRzIHByb3RvdHlwZSdzIGRlcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm90byA9PT0gJ2Z1bmN0aW9uJyAmJiBQcm90byAhPT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gY2xvbmVBcnJheVdpdGhQb3NzaWJsZVByb3BzKERJLmdldERlcGVuZGVuY2llcyhQcm90bykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBkZXNpZ246cGFyYW10eXBlcyBzbyBqdXN0IHVzZSB0aGUgYXU6YW5ub3RhdGlvbjpkaTpwYXJhbXR5cGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBjbG9uZUFycmF5V2l0aFBvc3NpYmxlUHJvcHMoYW5ub3RhdGlvblBhcmFtdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFubm90YXRpb25QYXJhbXR5cGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gYXU6YW5ub3RhdGlvbjpkaTpwYXJhbXR5cGVzIHNvIGp1c3QgdXNlIHRoZSBkZXNpZ246cGFyYW10eXBlc1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBjbG9uZUFycmF5V2l0aFBvc3NpYmxlUHJvcHMoZGVzaWduUGFyYW10eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBnb3QgYm90aCwgc28gbWVyZ2UgdGhlbSAoaW4gY2FzZSBvZiBjb25mbGljdCBvbiBzYW1lIGluZGV4LCBhdTphbm5vdGF0aW9uOmRpOnBhcmFtdHlwZXMgdGFrZSBwcmVjZWRlbmNlKVxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBjbG9uZUFycmF5V2l0aFBvc3NpYmxlUHJvcHMoZGVzaWduUGFyYW10eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW4gPSBhbm5vdGF0aW9uUGFyYW10eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhdUFubm90YXRpb25QYXJhbXR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1QW5ub3RhdGlvblBhcmFtdHlwZSA9IGFubm90YXRpb25QYXJhbXR5cGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1QW5ub3RhdGlvblBhcmFtdHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzW2ldID0gYXVBbm5vdGF0aW9uUGFyYW10eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhbm5vdGF0aW9uUGFyYW10eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5SW5kZXgoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llc1trZXldID0gYW5ub3RhdGlvblBhcmFtdHlwZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwYXJhbXR5cGVzIGlmIHdlIGhhdmUgc3RhdGljIGluamVjdFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IGNsb25lQXJyYXlXaXRoUG9zc2libGVQcm9wcyhpbmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKGtleSwgZGVwZW5kZW5jaWVzLCBUeXBlKTtcbiAgICAgICAgICAgIFByb3RvY29sLmFubm90YXRpb24uYXBwZW5kVG8oVHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBhIGRlY29yYXRvciB0aGF0IGFsc28gbWF0Y2hlcyBhbiBpbnRlcmZhY2UgYW5kIGNhbiBiZSB1c2VkIGFzIGEge0BsaW5rY29kZSBLZXl9LlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgSUxvZ2dlciA9IERJLmNyZWF0ZUludGVyZmFjZTxMb2dnZXI+KCdMb2dnZXInKTtcbiAgICAgKiBjb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihJTG9nZ2VyLCBnZXRTb21lTG9nZ2VyKCkpKTtcbiAgICAgKiBjb25zdCBsb2cgPSBjb250YWluZXIuZ2V0KElMb2dnZXIpO1xuICAgICAqIGxvZy5pbmZvKCdoZWxsbyB3b3JsZCcpO1xuICAgICAqIGNsYXNzIEZvbyB7XG4gICAgICogICBjb25zdHJ1Y3RvciggQElMb2dnZXIgbG9nOiBJTG9nZ2VyICkge1xuICAgICAqICAgICBsb2cuaW5mbygnaGVsbG8gd29ybGQnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogeW91IGNhbiBhbHNvIGJ1aWxkIGRlZmF1bHQgcmVnaXN0cmF0aW9ucyBpbnRvIHlvdXIgaW50ZXJmYWNlLlxuICAgICAqIGBgYHRzXG4gICAgICogZXhwb3J0IGNvbnN0IElMb2dnZXIgPSBESS5jcmVhdGVJbnRlcmZhY2U8TG9nZ2VyPignTG9nZ2VyJywgYnVpbGRlciA9PiBidWlsZGVyLmNhY2hlZENhbGxiYWNrKExvZ2dlckRlZmF1bHQpKTtcbiAgICAgKiBjb25zdCBsb2cgPSBjb250YWluZXIuZ2V0KElMb2dnZXIpO1xuICAgICAqIGxvZy5pbmZvKCdoZWxsbyB3b3JsZCcpO1xuICAgICAqIGNsYXNzIEZvbyB7XG4gICAgICogICBjb25zdHJ1Y3RvciggQElMb2dnZXIgbG9nOiBJTG9nZ2VyICkge1xuICAgICAqICAgICBsb2cuaW5mbygnaGVsbG8gd29ybGQnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYnV0IHRoZXNlIGRlZmF1bHQgcmVnaXN0cmF0aW9ucyB3b24ndCB3b3JrIHRoZSBzYW1lIHdpdGggb3RoZXIgZGVjb3JhdG9ycyB0aGF0IHRha2Uga2V5cywgZm9yIGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGV4cG9ydCBjb25zdCBNeVN0ciA9IERJLmNyZWF0ZUludGVyZmFjZTxzdHJpbmc+KCdNeVN0cicsIGJ1aWxkZXIgPT4gYnVpbGRlci5pbnN0YW5jZSgnc29tZXN0cmluZycpKTtcbiAgICAgKiBjbGFzcyBGb28ge1xuICAgICAqICAgY29uc3RydWN0b3IoIEBvcHRpb25hbChNeVN0cikgcHVibGljIHJlYWRvbmx5IHN0cjogc3RyaW5nICkge1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBjb250YWluZXIuZ2V0KEZvbykuc3RyOyAvLyByZXR1cm5zIHVuZGVmaW5lZFxuICAgICAqIGBgYFxuICAgICAqIHRvIGZpeCB0aGlzIGFkZCB0aGlzIGxpbmUgc29tZXdoZXJlIGJlZm9yZSB5b3UgZG8gYSBgZ2V0YFxuICAgICAqIGBgYHRzXG4gICAgICogY29udGFpbmVyLnJlZ2lzdGVyKE15U3RyKTtcbiAgICAgKiBjb250YWluZXIuZ2V0KEZvbykuc3RyOyAvLyByZXR1cm5zICdzb21lc3RyaW5nJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogLSBAcGFyYW0gZnJpZW5kbHlOYW1lIHVzZWQgdG8gaW1wcm92ZSBlcnJvciBtZXNzYWdpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJbnRlcmZhY2UoY29uZmlndXJlT3JOYW1lLCBjb25maWd1cm9yKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyZSA9IHR5cGVvZiBjb25maWd1cmVPck5hbWUgPT09ICdmdW5jdGlvbicgPyBjb25maWd1cmVPck5hbWUgOiBjb25maWd1cm9yO1xuICAgICAgICBjb25zdCBmcmllbmRseU5hbWUgPSB0eXBlb2YgY29uZmlndXJlT3JOYW1lID09PSAnc3RyaW5nJyA/IGNvbmZpZ3VyZU9yTmFtZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgSW50ZXJmYWNlID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwgfHwgbmV3LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZWdpc3RyYXRpb24gZm9yIGludGVyZmFjZTogJyR7SW50ZXJmYWNlLmZyaWVuZGx5TmFtZX0nYCk7IC8vIFRPRE86IGFkZCBlcnJvciAodHJ5aW5nIHRvIHJlc29sdmUgYW4gSW50ZXJmYWNlU3ltYm9sIHRoYXQgaGFzIG5vIHJlZ2lzdHJhdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uUGFyYW10eXBlcyA9IERJLmdldE9yQ3JlYXRlQW5ub3RhdGlvblBhcmFtVHlwZXModGFyZ2V0KTtcbiAgICAgICAgICAgIGFubm90YXRpb25QYXJhbXR5cGVzW2luZGV4XSA9IEludGVyZmFjZTtcbiAgICAgICAgfTtcbiAgICAgICAgSW50ZXJmYWNlLiRpc0ludGVyZmFjZSA9IHRydWU7XG4gICAgICAgIEludGVyZmFjZS5mcmllbmRseU5hbWUgPSBmcmllbmRseU5hbWUgPT0gbnVsbCA/ICcoYW5vbnltb3VzKScgOiBmcmllbmRseU5hbWU7XG4gICAgICAgIGlmIChjb25maWd1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgSW50ZXJmYWNlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ3VyZShuZXcgUmVzb2x2ZXJCdWlsZGVyKGNvbnRhaW5lciwga2V5ID8/IEludGVyZmFjZSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBJbnRlcmZhY2UudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgSW50ZXJmYWNlU3ltYm9sPCR7SW50ZXJmYWNlLmZyaWVuZGx5TmFtZX0+YDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEludGVyZmFjZTtcbiAgICB9LFxuICAgIGluamVjdCguLi5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnbnVtYmVyJykgeyAvLyBJdCdzIGEgcGFyYW1ldGVyIGRlY29yYXRvci5cbiAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uUGFyYW10eXBlcyA9IERJLmdldE9yQ3JlYXRlQW5ub3RhdGlvblBhcmFtVHlwZXModGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXAgPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGRlcCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25QYXJhbXR5cGVzW2Rlc2NyaXB0b3JdID0gZGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSkgeyAvLyBJdCdzIGEgcHJvcGVydHkgZGVjb3JhdG9yLiBOb3Qgc3VwcG9ydGVkIGJ5IHRoZSBjb250YWluZXIgd2l0aG91dCBwbHVnaW5zLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25QYXJhbXR5cGVzID0gREkuZ2V0T3JDcmVhdGVBbm5vdGF0aW9uUGFyYW1UeXBlcyh0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcCA9IGRlcGVuZGVuY2llc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvblBhcmFtdHlwZXNba2V5XSA9IGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yKSB7IC8vIEl0J3MgYSBmdW5jdGlvbiBkZWNvcmF0b3IgKG5vdCBhIENsYXNzIGNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uUGFyYW10eXBlcyA9IERJLmdldE9yQ3JlYXRlQW5ub3RhdGlvblBhcmFtVHlwZXMoZm4pO1xuICAgICAgICAgICAgICAgIGxldCBkZXA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25QYXJhbXR5cGVzW2ldID0gZGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIEl0J3MgYSBjbGFzcyBkZWNvcmF0b3IuXG4gICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvblBhcmFtdHlwZXMgPSBESS5nZXRPckNyZWF0ZUFubm90YXRpb25QYXJhbVR5cGVzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlcDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBkZXAgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXAgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvblBhcmFtdHlwZXNbaV0gPSBkZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGB0YXJnZXRgIGNsYXNzIGFzIGEgdHJhbnNpZW50IGRlcGVuZGVuY3k7IGVhY2ggdGltZSB0aGUgZGVwZW5kZW5jeSBpcyByZXNvbHZlZFxuICAgICAqIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgY2xhc3MgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byByZWdpc3RlciBhcyB0cmFuc2llbnQuXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgY2xhc3MsIHdpdGggYSBzdGF0aWMgYHJlZ2lzdGVyYCBtZXRob2QgdGhhdCB0YWtlcyBhIGNvbnRhaW5lciBhbmQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgcmVzb2x2ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBgYGB0c1xuICAgICAqIC8vIE9uIGFuIGV4aXN0aW5nIGNsYXNzXG4gICAgICogY2xhc3MgRm9vIHsgfVxuICAgICAqIERJLnRyYW5zaWVudChGb28pO1xuICAgICAqXG4gICAgICogLy8gSW5saW5lIGRlY2xhcmF0aW9uXG4gICAgICogY29uc3QgRm9vID0gREkudHJhbnNpZW50KGNsYXNzIHsgfSk7XG4gICAgICogLy8gRm9vIGlzIG5vdyBzdHJvbmdseSB0eXBlZCB3aXRoIHJlZ2lzdGVyXG4gICAgICogRm9vLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdHJhbnNpZW50KHRhcmdldCkge1xuICAgICAgICB0YXJnZXQucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IFJlZ2lzdHJhdGlvbi50cmFuc2llbnQodGFyZ2V0LCB0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbi5yZWdpc3Rlcihjb250YWluZXIsIHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5yZWdpc3RlckluUmVxdWVzdG9yID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGB0YXJnZXRgIGNsYXNzIGFzIGEgc2luZ2xldG9uIGRlcGVuZGVuY3k7IHRoZSBjbGFzcyB3aWxsIG9ubHkgYmUgY3JlYXRlZCBvbmNlLiBFYWNoXG4gICAgICogY29uc2VjdXRpdmUgdGltZSB0aGUgZGVwZW5kZW5jeSBpcyByZXNvbHZlZCwgdGhlIHNhbWUgaW5zdGFuY2Ugd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgY2xhc3MgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byByZWdpc3RlciBhcyBhIHNpbmdsZXRvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2FtZSBjbGFzcywgd2l0aCBhIHN0YXRpYyBgcmVnaXN0ZXJgIG1ldGhvZCB0aGF0IHRha2VzIGEgY29udGFpbmVyIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSByZXNvbHZlci5cbiAgICAgKiBAZXhhbXBsZSBgYGB0c1xuICAgICAqIC8vIE9uIGFuIGV4aXN0aW5nIGNsYXNzXG4gICAgICogY2xhc3MgRm9vIHsgfVxuICAgICAqIERJLnNpbmdsZXRvbihGb28pO1xuICAgICAqXG4gICAgICogLy8gSW5saW5lIGRlY2xhcmF0aW9uXG4gICAgICogY29uc3QgRm9vID0gREkuc2luZ2xldG9uKGNsYXNzIHsgfSk7XG4gICAgICogLy8gRm9vIGlzIG5vdyBzdHJvbmdseSB0eXBlZCB3aXRoIHJlZ2lzdGVyXG4gICAgICogRm9vLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2luZ2xldG9uKHRhcmdldCwgb3B0aW9ucyA9IGRlZmF1bHRTaW5nbGV0b25PcHRpb25zKSB7XG4gICAgICAgIHRhcmdldC5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cmF0aW9uID0gUmVnaXN0cmF0aW9uLnNpbmdsZXRvbih0YXJnZXQsIHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0cmF0aW9uLnJlZ2lzdGVyKGNvbnRhaW5lciwgdGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0LnJlZ2lzdGVySW5SZXF1ZXN0b3IgPSBvcHRpb25zLnNjb3BlZDtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBJQ29udGFpbmVyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJQ29udGFpbmVyJyk7XG5leHBvcnQgY29uc3QgSVNlcnZpY2VMb2NhdG9yID0gSUNvbnRhaW5lcjtcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKGdldHRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIERJLmluamVjdChyZXNvbHZlcikodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlc29sdmVyLiRpc1Jlc29sdmVyID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZXIucmVzb2x2ZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoa2V5LCBoYW5kbGVyLCByZXF1ZXN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBpbmplY3QgPSBESS5pbmplY3Q7XG5mdW5jdGlvbiB0cmFuc2llbnREZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgcmV0dXJuIERJLnRyYW5zaWVudCh0YXJnZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaWVudCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ID09IG51bGwgPyB0cmFuc2llbnREZWNvcmF0b3IgOiB0cmFuc2llbnREZWNvcmF0b3IodGFyZ2V0KTtcbn1cbmNvbnN0IGRlZmF1bHRTaW5nbGV0b25PcHRpb25zID0geyBzY29wZWQ6IGZhbHNlIH07XG5mdW5jdGlvbiBzaW5nbGV0b25EZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgcmV0dXJuIERJLnNpbmdsZXRvbih0YXJnZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZXRvbih0YXJnZXRPck9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldE9yT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gREkuc2luZ2xldG9uKHRhcmdldE9yT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoJHRhcmdldCkge1xuICAgICAgICByZXR1cm4gREkuc2luZ2xldG9uKCR0YXJnZXQsIHRhcmdldE9yT3B0aW9ucyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFsbFJlc29sdmVyKGdldHRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBzZWFyY2hBbmNlc3RvcnMpIHtcbiAgICAgICAgc2VhcmNoQW5jZXN0b3JzID0gISFzZWFyY2hBbmNlc3RvcnM7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIERJLmluamVjdChyZXNvbHZlcikodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJlc29sdmVyLiRpc1Jlc29sdmVyID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZXIucmVzb2x2ZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoa2V5LCBoYW5kbGVyLCByZXF1ZXN0b3IsIHNlYXJjaEFuY2VzdG9ycyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IGFsbCA9IGNyZWF0ZUFsbFJlc29sdmVyKChrZXksIGhhbmRsZXIsIHJlcXVlc3Rvciwgc2VhcmNoQW5jZXN0b3JzKSA9PiByZXF1ZXN0b3IuZ2V0QWxsKGtleSwgc2VhcmNoQW5jZXN0b3JzKSk7XG4vKipcbiAqIExhemlseSBpbmplY3QgYSBkZXBlbmRlbmN5IGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBbW2BLZXlgXV0gaXMgcHJlc2VudCBhdCB0aGUgdGltZSBvZiBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIFlvdSBuZWVkIHRvIG1ha2UgeW91ciBhcmd1bWVudCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdHlwZSwgZm9yIGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjbGFzcyBGb28ge1xuICogICBjb25zdHJ1Y3RvciggQGxhenkoJ3JhbmRvbScpIHB1YmxpYyByYW5kb206ICgpID0+IG51bWJlciApXG4gKiB9XG4gKiBjb25zdCBmb28gPSBjb250YWluZXIuZ2V0KEZvbyk7IC8vIGluc3RhbmNlb2YgRm9vXG4gKiBmb28ucmFuZG9tKCk7IC8vIHRocm93c1xuICogYGBgXG4gKiB3b3VsZCB0aHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSB5b3UgaGF2ZW4ndCByZWdpc3RlcmVkIGAncmFuZG9tJ2AgYmVmb3JlIGNhbGxpbmcgdGhlIG1ldGhvZC4gVGhpcywgd291bGQgZ2l2ZSB5b3UgYVxuICogbmV3IFtbJ01hdGgucmFuZG9tKCknXV0gbnVtYmVyIGVhY2ggdGltZS5cbiAqIGBgYHRzXG4gKiBjbGFzcyBGb28ge1xuICogICBjb25zdHJ1Y3RvciggQGxhenkoJ3JhbmRvbScpIHB1YmxpYyByYW5kb206ICgpID0+IHJhbmRvbSApXG4gKiB9XG4gKiBjb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmNhbGxiYWNrKCdyYW5kb20nLCBNYXRoLnJhbmRvbSApKTtcbiAqIGNvbnRhaW5lci5nZXQoRm9vKS5yYW5kb20oKTsgLy8gc29tZSByYW5kb20gbnVtYmVyXG4gKiBjb250YWluZXIuZ2V0KEZvbykucmFuZG9tKCk7IC8vIGFub3RoZXIgcmFuZG9tIG51bWJlclxuICogYGBgXG4gKiBgQGxhenlgIGRvZXMgbm90IG1hbmFnZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSB1bmRlcmx5aW5nIGtleS4gSWYgeW91IHdhbnQgYSBzaW5nbGV0b24sIHlvdSBoYXZlIHRvIHJlZ2lzdGVyIGFzIGFcbiAqIGBzaW5nbGV0b25gLCBgdHJhbnNpZW50YCB3b3VsZCBhbHNvIGJlaGF2ZSBhcyB5b3Ugd291bGQgZXhwZWN0LCBwcm92aWRpbmcgeW91IGEgbmV3IGluc3RhbmNlIGVhY2ggdGltZS5cbiAqXG4gKiAtIEBwYXJhbSBrZXkgW1tgS2V5YF1dXG4gKiBzZWUgeyBAbGluayBESS5jcmVhdGVJbnRlcmZhY2UgfSBvbiBpbnRlcmFjdGlvbnMgd2l0aCBpbnRlcmZhY2VzXG4gKi9cbmV4cG9ydCBjb25zdCBsYXp5ID0gY3JlYXRlUmVzb2x2ZXIoKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHJlcXVlc3Rvci5nZXQoa2V5KTtcbn0pO1xuLyoqXG4gKiBBbGxvd3MgeW91IHRvIG9wdGlvbmFsbHkgaW5qZWN0IGEgZGVwZW5kZW5jeSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgW1tgS2V5YF1dIGlzIHByZXNlbnQsIGZvciBleGFtcGxlXG4gKiBgYGB0c1xuICogY2xhc3MgRm9vIHtcbiAqICAgY29uc3RydWN0b3IoIEBpbmplY3QoJ215c3RyaW5nJykgcHVibGljIHN0cjogc3RyaW5nID0gJ3NvbWVzdHJpbmcnIClcbiAqIH1cbiAqIGNvbnRhaW5lci5nZXQoRm9vKTsgLy8gdGhyb3dzXG4gKiBgYGBcbiAqIHdvdWxkIGZhaWxcbiAqIGBgYHRzXG4gKiBjbGFzcyBGb28ge1xuICogICBjb25zdHJ1Y3RvciggQG9wdGlvbmFsKCdteXN0cmluZycpIHB1YmxpYyBzdHI6IHN0cmluZyA9ICdzb21lc3RyaW5nJyApXG4gKiB9XG4gKiBjb250YWluZXIuZ2V0KEZvbykuc3RyIC8vIHNvbWVzdHJpbmdcbiAqIGBgYFxuICogaWYgeW91IHVzZSBpdCB3aXRob3V0IGEgZGVmYXVsdCBpdCB3aWxsIGluamVjdCBgdW5kZWZpbmVkYCwgc28gcmVtYmVyIHRvIG1hcmsgeW91ciBpbnB1dCB0eXBlIGFzXG4gKiBwb3NzaWJseSBgdW5kZWZpbmVkYCFcbiAqXG4gKiAtIEBwYXJhbSBrZXk6IFtbYEtleWBdXVxuICpcbiAqIHNlZSB7IEBsaW5rIERJLmNyZWF0ZUludGVyZmFjZSB9IG9uIGludGVyYWN0aW9ucyB3aXRoIGludGVyZmFjZXNcbiAqL1xuZXhwb3J0IGNvbnN0IG9wdGlvbmFsID0gY3JlYXRlUmVzb2x2ZXIoKGtleSwgaGFuZGxlciwgcmVxdWVzdG9yKSA9PiB7XG4gICAgaWYgKHJlcXVlc3Rvci5oYXMoa2V5LCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gcmVxdWVzdG9yLmdldChrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59KTtcbi8qKlxuICogaWdub3JlIHRlbGxzIHRoZSBjb250YWluZXIgbm90IHRvIHRyeSB0byBpbmplY3QgYSBkZXBlbmRlbmN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZ25vcmUodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICAgIERJLmluamVjdChpZ25vcmUpKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xufVxuaWdub3JlLiRpc1Jlc29sdmVyID0gdHJ1ZTtcbmlnbm9yZS5yZXNvbHZlID0gKCkgPT4gdW5kZWZpbmVkO1xuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlRm9yU2NvcGUgPSBjcmVhdGVSZXNvbHZlcigoa2V5LCBoYW5kbGVyLCByZXF1ZXN0b3IpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGNyZWF0ZU5ld0luc3RhbmNlKGtleSwgaGFuZGxlcik7XG4gICAgY29uc3QgaW5zdGFuY2VQcm92aWRlciA9IG5ldyBJbnN0YW5jZVByb3ZpZGVyKFN0cmluZyhrZXkpKTtcbiAgICBpbnN0YW5jZVByb3ZpZGVyLnByZXBhcmUoaW5zdGFuY2UpO1xuICAgIHJlcXVlc3Rvci5yZWdpc3RlclJlc29sdmVyKGtleSwgaW5zdGFuY2VQcm92aWRlciwgdHJ1ZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufSk7XG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2VPZiA9IGNyZWF0ZVJlc29sdmVyKChrZXksIGhhbmRsZXIsIF9yZXF1ZXN0b3IpID0+IGNyZWF0ZU5ld0luc3RhbmNlKGtleSwgaGFuZGxlcikpO1xuZnVuY3Rpb24gY3JlYXRlTmV3SW5zdGFuY2Uoa2V5LCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIuZ2V0RmFjdG9yeShrZXkpLmNvbnN0cnVjdChoYW5kbGVyKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB2YXIgUmVzb2x2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoUmVzb2x2ZXJTdHJhdGVneSkge1xuICAgIFJlc29sdmVyU3RyYXRlZ3lbUmVzb2x2ZXJTdHJhdGVneVtcImluc3RhbmNlXCJdID0gMF0gPSBcImluc3RhbmNlXCI7XG4gICAgUmVzb2x2ZXJTdHJhdGVneVtSZXNvbHZlclN0cmF0ZWd5W1wic2luZ2xldG9uXCJdID0gMV0gPSBcInNpbmdsZXRvblwiO1xuICAgIFJlc29sdmVyU3RyYXRlZ3lbUmVzb2x2ZXJTdHJhdGVneVtcInRyYW5zaWVudFwiXSA9IDJdID0gXCJ0cmFuc2llbnRcIjtcbiAgICBSZXNvbHZlclN0cmF0ZWd5W1Jlc29sdmVyU3RyYXRlZ3lbXCJjYWxsYmFja1wiXSA9IDNdID0gXCJjYWxsYmFja1wiO1xuICAgIFJlc29sdmVyU3RyYXRlZ3lbUmVzb2x2ZXJTdHJhdGVneVtcImFycmF5XCJdID0gNF0gPSBcImFycmF5XCI7XG4gICAgUmVzb2x2ZXJTdHJhdGVneVtSZXNvbHZlclN0cmF0ZWd5W1wiYWxpYXNcIl0gPSA1XSA9IFwiYWxpYXNcIjtcbn0pKFJlc29sdmVyU3RyYXRlZ3kgfHwgKFJlc29sdmVyU3RyYXRlZ3kgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHN0cmF0ZWd5LCBzdGF0ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVzb2x2aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCAkaXNSZXNvbHZlcigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZWdpc3Rlcihjb250YWluZXIsIGtleSkge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoa2V5IHx8IHRoaXMua2V5LCB0aGlzKTtcbiAgICB9XG4gICAgcmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogaW5zdGFuY2UgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjYXNlIDEgLyogc2luZ2xldG9uICovOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3ljbGljIGRlcGVuZGVuY3kgZm91bmQ6ICR7dGhpcy5zdGF0ZS5uYW1lfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGhhbmRsZXIuZ2V0RmFjdG9yeSh0aGlzLnN0YXRlKS5jb25zdHJ1Y3QocmVxdWVzdG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gMCAvKiBpbnN0YW5jZSAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyIC8qIHRyYW5zaWVudCAqLzoge1xuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBjcmVhdGUgdHJhbnNpZW50cyBmcm9tIHRoZSByZXF1ZXN0aW5nIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSBoYW5kbGVyLmdldEZhY3RvcnkodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZhY3RvcnkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvbHZlciBmb3IgJHtTdHJpbmcodGhpcy5rZXkpfSByZXR1cm5lZCBhIG51bGwgZmFjdG9yeWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5jb25zdHJ1Y3QocmVxdWVzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMyAvKiBjYWxsYmFjayAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZShoYW5kbGVyLCByZXF1ZXN0b3IsIHRoaXMpO1xuICAgICAgICAgICAgY2FzZSA0IC8qIGFycmF5ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlWzBdLnJlc29sdmUoaGFuZGxlciwgcmVxdWVzdG9yKTtcbiAgICAgICAgICAgIGNhc2UgNSAvKiBhbGlhcyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdG9yLmdldCh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc29sdmVyIHN0cmF0ZWd5IHNwZWNpZmllZDogJHt0aGlzLnN0cmF0ZWd5fS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRGYWN0b3J5KGNvbnRhaW5lcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBzaW5nbGV0b24gKi86XG4gICAgICAgICAgICBjYXNlIDIgLyogdHJhbnNpZW50ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXIuZ2V0RmFjdG9yeSh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIGNhc2UgNSAvKiBhbGlhcyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmdldFJlc29sdmVyKHRoaXMuc3RhdGUpPy5nZXRGYWN0b3J5Py4oY29udGFpbmVyKSA/PyBudWxsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnRhaW5lckdldEtleShkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGQpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtSW5zdGFuY2UoaW5zdCwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybShpbnN0KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihUeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgdGhpcy5UeXBlID0gVHlwZTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXJzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0KGNvbnRhaW5lciwgZHluYW1pY0RlcGVuZGVuY2llcykge1xuICAgICAgICBsZXQgaW5zdGFuY2U7XG4gICAgICAgIGlmIChkeW5hbWljRGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IHRoaXMuVHlwZSguLi50aGlzLmRlcGVuZGVuY2llcy5tYXAoY29udGFpbmVyR2V0S2V5LCBjb250YWluZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IHRoaXMuVHlwZSguLi50aGlzLmRlcGVuZGVuY2llcy5tYXAoY29udGFpbmVyR2V0S2V5LCBjb250YWluZXIpLCAuLi5keW5hbWljRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1lcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWVycy5yZWR1Y2UodHJhbnNmb3JtSW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcikge1xuICAgICAgICAodGhpcy50cmFuc2Zvcm1lcnMgPz8gKHRoaXMudHJhbnNmb3JtZXJzID0gW10pKS5wdXNoKHRyYW5zZm9ybWVyKTtcbiAgICB9XG59XG5jb25zdCBjb250YWluZXJSZXNvbHZlciA9IHtcbiAgICAkaXNSZXNvbHZlcjogdHJ1ZSxcbiAgICByZXNvbHZlKGhhbmRsZXIsIHJlcXVlc3Rvcikge1xuICAgICAgICByZXR1cm4gcmVxdWVzdG9yO1xuICAgIH1cbn07XG5mdW5jdGlvbiBpc1JlZ2lzdHJ5KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqLnJlZ2lzdGVyID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNTZWxmUmVnaXN0cnkob2JqKSB7XG4gICAgcmV0dXJuIGlzUmVnaXN0cnkob2JqKSAmJiB0eXBlb2Ygb2JqLnJlZ2lzdGVySW5SZXF1ZXN0b3IgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIGlzUmVnaXN0ZXJJblJlcXVlc3RlcihvYmopIHtcbiAgICByZXR1cm4gaXNTZWxmUmVnaXN0cnkob2JqKSAmJiBvYmoucmVnaXN0ZXJJblJlcXVlc3Rvcjtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3Mob2JqKSB7XG4gICAgcmV0dXJuIG9iai5wcm90b3R5cGUgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzUmVzb3VyY2VLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5pbmRleE9mKCc6JykgPiAwO1xufVxuY29uc3QgSW5zdHJpbnNpY1R5cGVOYW1lcyA9IG5ldyBTZXQoW1xuICAgICdBcnJheScsXG4gICAgJ0FycmF5QnVmZmVyJyxcbiAgICAnQm9vbGVhbicsXG4gICAgJ0RhdGFWaWV3JyxcbiAgICAnRGF0ZScsXG4gICAgJ0Vycm9yJyxcbiAgICAnRXZhbEVycm9yJyxcbiAgICAnRmxvYXQzMkFycmF5JyxcbiAgICAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLFxuICAgICdJbnQ4QXJyYXknLFxuICAgICdJbnQxNkFycmF5JyxcbiAgICAnSW50MzJBcnJheScsXG4gICAgJ01hcCcsXG4gICAgJ051bWJlcicsXG4gICAgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLFxuICAgICdSYW5nZUVycm9yJyxcbiAgICAnUmVmZXJlbmNlRXJyb3InLFxuICAgICdSZWdFeHAnLFxuICAgICdTZXQnLFxuICAgICdTaGFyZWRBcnJheUJ1ZmZlcicsXG4gICAgJ1N0cmluZycsXG4gICAgJ1N5bnRheEVycm9yJyxcbiAgICAnVHlwZUVycm9yJyxcbiAgICAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JyxcbiAgICAnVWludDE2QXJyYXknLFxuICAgICdVaW50MzJBcnJheScsXG4gICAgJ1VSSUVycm9yJyxcbiAgICAnV2Vha01hcCcsXG4gICAgJ1dlYWtTZXQnLFxuXSk7XG5jb25zdCBmYWN0b3J5S2V5ID0gJ2RpOmZhY3RvcnknO1xuY29uc3QgZmFjdG9yeUFubm90YXRpb25LZXkgPSBQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcihmYWN0b3J5S2V5KTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5yZWdpc3RlckRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlUmVzb2x2ZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VSZXNvbHZlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcGFyZW50LnJvb3Q7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yaWVzID0gcGFyZW50LmZhY3RvcmllcztcbiAgICAgICAgICAgIGlmIChjb25maWcuaW5oZXJpdFBhcmVudFJlc291cmNlcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VSZXNvbHZlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHBhcmVudC5yZXNvdXJjZVJlc29sdmVycywgdGhpcy5yb290LnJlc291cmNlUmVzb2x2ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VSZXNvbHZlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMucm9vdC5yZXNvdXJjZVJlc29sdmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlcnMuc2V0KElDb250YWluZXIsIGNvbnRhaW5lclJlc29sdmVyKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPT09IG51bGwgPyAwIDogdGhpcy5wYXJlbnQuZGVwdGggKyAxO1xuICAgIH1cbiAgICByZWdpc3RlciguLi5wYXJhbXMpIHtcbiAgICAgICAgaWYgKCsrdGhpcy5yZWdpc3RlckRlcHRoID09PSAxMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGF1dG9yZWdpc3RlciBkZXBlbmRlbmN5OiBbJHtwYXJhbXMubWFwKFN0cmluZyl9XWApO1xuICAgICAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRvIHJlcG9ydGVyLmVycm9yIGFuZCBhZGQgdmFyaW91cyBwb3NzaWJsZSBjYXVzZXMgaW4gZGVzY3JpcHRpb24uXG4gICAgICAgICAgICAvLyBNb3N0IGxpa2VseSBjYXVzZSBpcyB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBwbGFpbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBoYXZlIGFcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIG1ldGhvZCBhbmQgaXMgbm90IGEgY2xhc3MgY29uc3RydWN0b3JcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgbGV0IGtleXM7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgbGV0IGo7XG4gICAgICAgIGxldCBqajtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFyYW1zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNSZWdpc3RyeShjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChQcm90b2NvbC5yZXNvdXJjZS5oYXMoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZzID0gUHJvdG9jb2wucmVzb3VyY2UuZ2V0QWxsKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgIGRlZnNbMF0ucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBkZWZzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBsZW47ICsrZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmc1tkXS5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ2xhc3MoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBSZWdpc3RyYXRpb24uc2luZ2xldG9uKGN1cnJlbnQsIGN1cnJlbnQpLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIGpqID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3VycmVudFtrZXlzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGNvdWxkIHJlbW92ZSB0aGlzIGlmLWJyYW5jaCBhbmQgY2FsbCB0aGlzLnJlZ2lzdGVyIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlIGV4dHJhIGNoZWNrIGlzIGp1c3QgYSBwZXJmIHR3ZWFrIHRvIGNyZWF0ZSBmZXdlciB1bm5lY2Vzc2FyeSBhcnJheXMgYnkgdGhlIHNwcmVhZCBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWdpc3RyeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLS10aGlzLnJlZ2lzdGVyRGVwdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWdpc3RlclJlc29sdmVyKGtleSwgcmVzb2x2ZXIsIGlzRGlzcG9zYWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhbGlkYXRlS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVycyA9IHRoaXMucmVzb2x2ZXJzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzb2x2ZXJzLnNldChrZXksIHJlc29sdmVyKTtcbiAgICAgICAgICAgIGlmIChpc1Jlc291cmNlS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlUmVzb2x2ZXJzW2tleV0gPSByZXNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZXNvbHZlciAmJiByZXN1bHQuc3RyYXRlZ3kgPT09IDQgLyogYXJyYXkgKi8pIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0ZS5wdXNoKHJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVycy5zZXQoa2V5LCBuZXcgUmVzb2x2ZXIoa2V5LCA0IC8qIGFycmF5ICovLCBbcmVzdWx0LCByZXNvbHZlcl0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVSZXNvbHZlcnMuYWRkKHJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBkZXJlZ2lzdGVyUmVzb2x2ZXJGb3I8SyBleHRlbmRzIEtleSwgVCA9IEs+KGtleTogSyk6IHZvaWQge1xuICAgIC8vICAgLy8gY29uc3QgY29uc29sZSA9ICAoZ2xvYmFsVGhpcyBhcyBhbnkpLmNvbnNvbGU7XG4gICAgLy8gICAvLyBjb25zb2xlLmdyb3VwKFwiZGVyZWdpc3RlclJlc29sdmVyRm9yXCIpO1xuICAgIC8vICAgdmFsaWRhdGVLZXkoa2V5KTtcbiAgICAvLyAgIGxldCBjdXJyZW50OiBDb250YWluZXIgPSB0aGlzO1xuICAgIC8vICAgbGV0IHJlc29sdmVyOiBJUmVzb2x2ZXIgfCB1bmRlZmluZWQ7XG4gICAgLy8gICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgLy8gICAgIHJlc29sdmVyID0gY3VycmVudC5yZXNvbHZlcnMuZ2V0KGtleSk7XG4gICAgLy8gICAgIGlmIChyZXNvbHZlciAhPSBudWxsKSB7IGJyZWFrOyB9XG4gICAgLy8gICAgIGlmIChjdXJyZW50LnBhcmVudCA9PSBudWxsKSB7IHJldHVybjsgfVxuICAgIC8vICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgLy8gICB9XG4gICAgLy8gICBpZiAocmVzb2x2ZXIgPT09IHZvaWQgMCkgeyByZXR1cm47IH1cbiAgICAvLyAgIGlmIChyZXNvbHZlciBpbnN0YW5jZW9mIFJlc29sdmVyICYmIHJlc29sdmVyLnN0cmF0ZWd5ID09PSBSZXNvbHZlclN0cmF0ZWd5LmFycmF5KSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlcmVnaXN0ZXIgYSByZXNvbHZlciB3aXRoIGFycmF5IHN0cmF0ZWd5Jyk7XG4gICAgLy8gICB9XG4gICAgLy8gICBpZiAodGhpcy5kaXNwb3NhYmxlUmVzb2x2ZXJzLmhhcyhyZXNvbHZlciBhcyBJRGlzcG9zYWJsZVJlc29sdmVyPFQ+KSkge1xuICAgIC8vICAgICAocmVzb2x2ZXIgYXMgSURpc3Bvc2FibGVSZXNvbHZlcjxUPikuZGlzcG9zZSgpO1xuICAgIC8vICAgfVxuICAgIC8vICAgaWYgKGlzUmVzb3VyY2VLZXkoa2V5KSkge1xuICAgIC8vICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgLy8gICAgIGRlbGV0ZSB0aGlzLnJlc291cmNlUmVzb2x2ZXJzW2tleV07XG4gICAgLy8gICB9XG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyhgQkVGT1JFIGRlbGV0ZSAke0FycmF5LmZyb20oY3VycmVudC5yZXNvbHZlcnMua2V5cygpKS5tYXAoKGspID0+IGsudG9TdHJpbmcoKSl9YCk7XG4gICAgLy8gICBjdXJyZW50LnJlc29sdmVycy5kZWxldGUoa2V5KTtcbiAgICAvLyAgIC8vIGNvbnNvbGUubG9nKGBBRlRFUiBkZWxldGUgJHtBcnJheS5mcm9tKGN1cnJlbnQucmVzb2x2ZXJzLmtleXMoKSkubWFwKChrKSA9PiBrLnRvU3RyaW5nKCkpfWApO1xuICAgIC8vICAgLy8gY29uc29sZS5ncm91cEVuZCgpO1xuICAgIC8vIH1cbiAgICByZWdpc3RlclRyYW5zZm9ybWVyKGtleSwgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB0aGlzLmdldFJlc29sdmVyKGtleSk7XG4gICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmVyLmdldEZhY3RvcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSByZXNvbHZlci5nZXRGYWN0b3J5KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGZhY3RvcnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgdHlwZSBjYXN0IGlzIGEgYml0IG9mIGEgaGFja3kgb25lLCBuZWNlc3NhcnkgZHVlIHRvIHRoZSBkdXBsaWNpdHkgb2YgSVJlc29sdmVyTGlrZS5cbiAgICAgICAgICAgIC8vIFByb2JsZW0gaXMgdGhhdCB0aGF0IGludGVyZmFjZSdzIHR5cGUgYXJnIGNhbiBiZSBvZiB0eXBlIEtleSwgYnV0IHRoZSBnZXRGYWN0b3J5IG1ldGhvZCBvbmx5IHdvcmtzIG9uXG4gICAgICAgICAgICAvLyB0eXBlIENvbnN0cnVjdGFibGUuIFNvIHRoZSByZXR1cm4gdHlwZSBvZiB0aGF0IG9wdGlvbmFsIG1ldGhvZCBoYXMgdGhpcyBhZGRpdGlvbmFsIGNvbnN0cmFpbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyBzZWVtcyB0byBjb25mdXNlIHRoZSB0eXBlIGNoZWNrZXIuXG4gICAgICAgICAgICBmYWN0b3J5LnJlZ2lzdGVyVHJhbnNmb3JtZXIodHJhbnNmb3JtZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlcihrZXksIGF1dG9SZWdpc3RlciA9IHRydWUpIHtcbiAgICAgICAgdmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgICAgaWYgKGtleS5yZXNvbHZlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgcmVzb2x2ZXI7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVyID0gY3VycmVudC5yZXNvbHZlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoaXNSZWdpc3RlckluUmVxdWVzdGVyKGtleSkpID8gdGhpcyA6IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvUmVnaXN0ZXIgPyB0aGlzLmppdFJlZ2lzdGVyKGtleSwgaGFuZGxlcikgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGhhcyhrZXksIHNlYXJjaEFuY2VzdG9ycyA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVycy5oYXMoa2V5KVxuICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICA6IHNlYXJjaEFuY2VzdG9ycyAmJiB0aGlzLnBhcmVudCAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyB0aGlzLnBhcmVudC5oYXMoa2V5LCB0cnVlKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgdmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgICAgaWYgKGtleS4kaXNSZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGtleS5yZXNvbHZlKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgbGV0IHJlc29sdmVyO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlciA9IGN1cnJlbnQucmVzb2x2ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKGlzUmVnaXN0ZXJJblJlcXVlc3RlcihrZXkpKSA/IHRoaXMgOiBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IHRoaXMuaml0UmVnaXN0ZXIoa2V5LCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUoY3VycmVudCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGN1cnJlbnQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUga2V5OiAke2tleX1gKTtcbiAgICB9XG4gICAgZ2V0QWxsKGtleSwgc2VhcmNoQW5jZXN0b3JzID0gZmFsc2UpIHtcbiAgICAgICAgdmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdG9yID0gdGhpcztcbiAgICAgICAgbGV0IGN1cnJlbnQgPSByZXF1ZXN0b3I7XG4gICAgICAgIGxldCByZXNvbHZlcjtcbiAgICAgICAgaWYgKHNlYXJjaEFuY2VzdG9ycykge1xuICAgICAgICAgICAgbGV0IHJlc29sdXRpb25zID0gZW1wdHlBcnJheTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlciA9IGN1cnJlbnQucmVzb2x2ZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdXRpb25zID0gcmVzb2x1dGlvbnMuY29uY2F0KGJ1aWxkQWxsUmVzcG9uc2UocmVzb2x2ZXIsIGN1cnJlbnQsIHJlcXVlc3RvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSBjdXJyZW50LnJlc29sdmVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRBbGxSZXNwb25zZShyZXNvbHZlciwgY3VycmVudCwgcmVxdWVzdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgfVxuICAgIGdldEZhY3RvcnkoVHlwZSkge1xuICAgICAgICBsZXQgZmFjdG9yeSA9IHRoaXMuZmFjdG9yaWVzLmdldChUeXBlKTtcbiAgICAgICAgaWYgKGZhY3RvcnkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKGlzTmF0aXZlRnVuY3Rpb24oVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7VHlwZS5uYW1lfSBpcyBhIG5hdGl2ZSBmdW5jdGlvbiBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSBzYWZlbHkgY29uc3RydWN0ZWQgYnkgREkuIElmIHRoaXMgaXMgaW50ZW50aW9uYWwsIHBsZWFzZSB1c2UgYSBjYWxsYmFjayBvciBjYWNoZWRDYWxsYmFjayByZXNvbHZlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmFjdG9yaWVzLnNldChUeXBlLCBmYWN0b3J5ID0gbmV3IEZhY3RvcnkoVHlwZSwgREkuZ2V0RGVwZW5kZW5jaWVzKFR5cGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgfVxuICAgIHJlZ2lzdGVyRmFjdG9yeShrZXksIGZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMuc2V0KGtleSwgZmFjdG9yeSk7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDAgJiYgdGhpcy5jb25maWcuaW5oZXJpdFBhcmVudFJlc291cmNlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnID09PSBDb250YWluZXJDb25maWd1cmF0aW9uLkRFRkFVTFQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcih0aGlzLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcih0aGlzLCBDb250YWluZXJDb25maWd1cmF0aW9uLmZyb20oe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgIGluaGVyaXRQYXJlbnRSZXNvdXJjZXM6IGZhbHNlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKHRoaXMsIENvbnRhaW5lckNvbmZpZ3VyYXRpb24uZnJvbShjb25maWcgPz8gdGhpcy5jb25maWcpKTtcbiAgICB9XG4gICAgZGlzcG9zZVJlc29sdmVycygpIHtcbiAgICAgICAgY29uc3QgZGlzcG9zYWJsZXMgPSBBcnJheS5mcm9tKHRoaXMuZGlzcG9zYWJsZVJlc29sdmVycyk7XG4gICAgICAgIHdoaWxlIChkaXNwb3NhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkaXNwb3NhYmxlcy5wb3AoKT8uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmQoa2luZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBraW5kLmtleUZyb20obmFtZSk7XG4gICAgICAgIGxldCByZXNvbHZlciA9IHRoaXMucmVzb3VyY2VSZXNvbHZlcnNba2V5XTtcbiAgICAgICAgaWYgKHJlc29sdmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJlc29sdmVyID0gdGhpcy5yb290LnJlc291cmNlUmVzb2x2ZXJzW2tleV07XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlci5nZXRGYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gcmVzb2x2ZXIuZ2V0RmFjdG9yeSh0aGlzKTtcbiAgICAgICAgICAgIGlmIChmYWN0b3J5ID09PSBudWxsIHx8IGZhY3RvcnkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IE1ldGFkYXRhLmdldE93bihraW5kLm5hbWUsIGZhY3RvcnkuVHlwZSk7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2UgbWF5IHdhbnQgdG8gbG9nIGEgd2FybmluZyBoZXJlLCBvciBldmVuIHRocm93LiBUaGlzIHdvdWxkIGhhcHBlbiBpZiBhIGRlcGVuZGVuY3kgaXMgcmVnaXN0ZXJlZCB3aXRoIGEgcmVzb3VyY2UtbGlrZSBrZXlcbiAgICAgICAgICAgICAgICAvLyBidXQgZG9lcyBub3QgYWN0dWFsbHkgaGF2ZSBhIGRlZmluaXRpb24gYXNzb2NpYXRlZCB2aWEgdGhlIHR5cGUncyBtZXRhZGF0YS4gVGhhdCAqc2hvdWxkKiBnZW5lcmFsbHkgbm90IGhhcHBlbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjcmVhdGUoa2luZCwgbmFtZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBraW5kLmtleUZyb20obmFtZSk7XG4gICAgICAgIGxldCByZXNvbHZlciA9IHRoaXMucmVzb3VyY2VSZXNvbHZlcnNba2V5XTtcbiAgICAgICAgaWYgKHJlc29sdmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJlc29sdmVyID0gdGhpcy5yb290LnJlc291cmNlUmVzb2x2ZXJzW2tleV07XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUodGhpcy5yb290LCB0aGlzKSA/PyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKHRoaXMsIHRoaXMpID8/IG51bGw7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZVJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnJlc29sdmVycy5jbGVhcigpO1xuICAgIH1cbiAgICBqaXRSZWdpc3RlcihrZXlBc1ZhbHVlLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5QXNWYWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gaml0UmVnaXN0ZXIgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgY29uc3RydWN0b3I6ICcke2tleUFzVmFsdWV9Jy4gRGlkIHlvdSBmb3JnZXQgdG8gcmVnaXN0ZXIgdGhpcyByZXNvdXJjZT9gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSW5zdHJpbnNpY1R5cGVOYW1lcy5oYXMoa2V5QXNWYWx1ZS5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gaml0UmVnaXN0ZXIgYW4gaW50cmluc2ljIHR5cGU6ICR7a2V5QXNWYWx1ZS5uYW1lfS4gRGlkIHlvdSBmb3JnZXQgdG8gYWRkIEBpbmplY3QoS2V5KWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlZ2lzdHJ5KGtleUFzVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb25SZXNvbHZlciA9IGtleUFzVmFsdWUucmVnaXN0ZXIoaGFuZGxlciwga2V5QXNWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIShyZWdpc3RyYXRpb25SZXNvbHZlciBpbnN0YW5jZW9mIE9iamVjdCkgfHwgcmVnaXN0cmF0aW9uUmVzb2x2ZXIucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UmVzb2x2ZXIgPSBoYW5kbGVyLnJlc29sdmVycy5nZXQoa2V5QXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Jlc29sdmVyICE9IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNvbHZlciByZXR1cm5lZCBmcm9tIHRoZSBzdGF0aWMgcmVnaXN0ZXIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0cmF0aW9uUmVzb2x2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUHJvdG9jb2wucmVzb3VyY2UuaGFzKGtleUFzVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZzID0gUHJvdG9jb2wucmVzb3VyY2UuZ2V0QWxsKGtleUFzVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRlZnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciB0aGUgdmVyeSBjb21tb24gY2FzZVxuICAgICAgICAgICAgICAgIGRlZnNbMF0ucmVnaXN0ZXIoaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBkZWZzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGxlbjsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZnNbZF0ucmVnaXN0ZXIoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3UmVzb2x2ZXIgPSBoYW5kbGVyLnJlc29sdmVycy5nZXQoa2V5QXNWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobmV3UmVzb2x2ZXIgIT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Jlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc29sdmVyIHJldHVybmVkIGZyb20gdGhlIHN0YXRpYyByZWdpc3RlciBtZXRob2RgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlBc1ZhbHVlLiRpc0ludGVyZmFjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gaml0UmVnaXN0ZXIgYW4gaW50ZXJmYWNlOiAke2tleUFzVmFsdWUuZnJpZW5kbHlOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB0aGlzLmNvbmZpZy5kZWZhdWx0UmVzb2x2ZXIoa2V5QXNWYWx1ZSwgaGFuZGxlcik7XG4gICAgICAgICAgICBoYW5kbGVyLnJlc29sdmVycy5zZXQoa2V5QXNWYWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBJUmVnaXN0cnkgdGhhdCBkZWxlZ2F0ZXMgcmVnaXN0cmF0aW9uIHRvIGFcbiAqIHNlcGFyYXRlbHkgcmVnaXN0ZXJlZCBjbGFzcy4gVGhlIFBhcmFtZXRlcml6ZWRSZWdpc3RyeSBmYWNpbGl0YXRlcyB0aGVcbiAqIHBhc3Npbmcgb2YgcGFyYW1ldGVycyB0byB0aGUgZmluYWwgcmVnaXN0cnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXJpemVkUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChjb250YWluZXIuaGFzKHRoaXMua2V5LCB0cnVlKSkge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBjb250YWluZXIuZ2V0KHRoaXMua2V5KTtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKGNvbnRhaW5lciwgLi4udGhpcy5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKC4uLnRoaXMucGFyYW1zLmZpbHRlcih4ID0+IHR5cGVvZiB4ID09PSAnb2JqZWN0JykpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gY2FjaGVDYWxsYmFja1Jlc3VsdChmdW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhbmRsZXIsIHJlcXVlc3RvciwgcmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKGNhY2hlLmhhcyhyZXNvbHZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQocmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQgPSBmdW4oaGFuZGxlciwgcmVxdWVzdG9yLCByZXNvbHZlcik7XG4gICAgICAgIGNhY2hlLnNldChyZXNvbHZlciwgdCk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG59XG4vKipcbiAqIHlvdSBjYW4gdXNlIHRoZSByZXN1bHRpbmcge0BsaW5rY29kZSBJUmVnaXN0cmF0aW9ufSBvZiBhbnkgb2YgdGhlIGZhY3RvcnkgbWV0aG9kc1xuICogdG8gcmVnaXN0ZXIgd2l0aCB0aGUgY29udGFpbmVyLCBlLmcuXG4gKiBgYGBcbiAqIGNsYXNzIEZvbyB7fVxuICogY29uc3QgY29udGFpbmVyID0gREkuY3JlYXRlQ29udGFpbmVyKCk7XG4gKiBjb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKEZvbywgbmV3IEZvbygpKSk7XG4gKiBjb250YWluZXIuZ2V0KEZvbyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IFJlZ2lzdHJhdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiBhbGxvd3MgeW91IHRvIHBhc3MgYW4gaW5zdGFuY2UuXG4gICAgICogRXZlcnkgdGltZSB5b3UgcmVxdWVzdCB0aGlzIHtAbGlua2NvZGUgS2V5fSB5b3Ugd2lsbCBnZXQgdGhpcyBpbnN0YW5jZSBiYWNrLlxuICAgICAqIGBgYFxuICAgICAqIFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShGb28sIG5ldyBGb28oKSkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIGluc3RhbmNlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDAgLyogaW5zdGFuY2UgKi8sIHZhbHVlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2UgZnJvbSB0aGUgY2xhc3MuXG4gICAgICogRXZlcnkgdGltZSB5b3UgcmVxdWVzdCB0aGlzIHtAbGlua2NvZGUgS2V5fSB5b3Ugd2lsbCBnZXQgdGhlIHNhbWUgb25lIGJhY2suXG4gICAgICogYGBgXG4gICAgICogUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihGb28sIEZvbyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2luZ2xldG9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDEgLyogc2luZ2xldG9uICovLCB2YWx1ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIGZyb20gYSBjbGFzcy5cbiAgICAgKiBFdmVyeSB0aW1lIHlvdSByZXF1ZXN0IHRoaXMge0BsaW5rY29kZSBLZXl9IHlvdSB3aWxsIGdldCBhIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBgYGBcbiAgICAgKiBSZWdpc3RyYXRpb24uaW5zdGFuY2UoRm9vLCBGb28pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHRyYW5zaWVudChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXIoa2V5LCAyIC8qIHRyYW5zaWVudCAqLywgdmFsdWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBmcm9tIHRoZSBtZXRob2QgcGFzc2VkLlxuICAgICAqIEV2ZXJ5IHRpbWUgeW91IHJlcXVlc3QgdGhpcyB7QGxpbmtjb2RlIEtleX0geW91IHdpbGwgZ2V0IGEgbmV3IGluc3RhbmNlLlxuICAgICAqIGBgYFxuICAgICAqIFJlZ2lzdHJhdGlvbi5jYWxsYmFjayhGb28sICgpID0+IG5ldyBGb28oKSk7XG4gICAgICogUmVnaXN0cmF0aW9uLmNhbGxiYWNrKEJhciwgKGM6IElDb250YWluZXIpID0+IG5ldyBCYXIoYy5nZXQoRm9vKSkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNhbGxiYWNrKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDMgLyogY2FsbGJhY2sgKi8sIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2UgZnJvbSB0aGUgbWV0aG9kIHBhc3NlZC5cbiAgICAgKiBPbiB0aGUgZmlyc3QgcmVxdWVzdCBmb3IgdGhlIHtAbGlua2NvZGUgS2V5fSB5b3VyIGNhbGxiYWNrIGlzIGNhbGxlZCBhbmQgcmV0dXJucyBhbiBpbnN0YW5jZS5cbiAgICAgKiBzdWJzZXF1ZW50IHJlcXVlc3RzIGZvciB0aGUge0BsaW5rY29kZSBLZXl9LCB0aGUgaW5pdGlhbCBpbnN0YW5jZSByZXR1cm5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHlvdSBwYXNzIHRoZSBzYW1lIHtAbGlua2NvZGUgUmVnaXN0cmF0aW9ufSB0byBhbm90aGVyIGNvbnRhaW5lciB0aGUgc2FtZSBjYWNoZWQgdmFsdWUgd2lsbCBiZSB1c2VkLlxuICAgICAqIFNob3VsZCBhbGwgcmVmZXJlbmNlcyB0byB0aGUgcmVzb2x2ZXIgcmV0dXJuZWQgYmUgcmVtb3ZlZCwgdGhlIGNhY2hlIHdpbGwgZXhwaXJlLlxuICAgICAqIGBgYFxuICAgICAqIFJlZ2lzdHJhdGlvbi5jYWNoZWRDYWxsYmFjayhGb28sICgpID0+IG5ldyBGb28oKSk7XG4gICAgICogUmVnaXN0cmF0aW9uLmNhY2hlZENhbGxiYWNrKEJhciwgKGM6IElDb250YWluZXIpID0+IG5ldyBCYXIoYy5nZXQoRm9vKSkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNhY2hlZENhbGxiYWNrKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlcihrZXksIDMgLyogY2FsbGJhY2sgKi8sIGNhY2hlQ2FsbGJhY2tSZXN1bHQoY2FsbGJhY2spKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgYW4gYWx0ZXJuYXRlIHtAbGlua2NvZGUgS2V5fSB0byByZXRyaWV2ZSBhbiBpbnN0YW5jZSBieS5cbiAgICAgKiBSZXR1cm5zIHRoZSBzYW1lIHNjb3BlIGFzIHRoZSBvcmlnaW5hbCB7QGxpbmtjb2RlIEtleX0uXG4gICAgICogYGBgXG4gICAgICogUmVnaXN0ZXIuc2luZ2xldG9uKEZvbywgRm9vKVxuICAgICAqIFJlZ2lzdGVyLmFsaWFzVG8oRm9vLCBNeUZvb3MpO1xuICAgICAqXG4gICAgICogY29udGFpbmVyLmdldEFsbChNeUZvb3MpIC8vIGNvbnRhaW5zIGFuIGluc3RhbmNlIG9mIEZvb1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbmFsS2V5XG4gICAgICogQHBhcmFtIGFsaWFzS2V5XG4gICAgICovXG4gICAgYWxpYXNUbyhvcmlnaW5hbEtleSwgYWxpYXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlcihhbGlhc0tleSwgNSAvKiBhbGlhcyAqLywgb3JpZ2luYWxLZXkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBkZWZlcihrZXksIC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtZXRlcml6ZWRSZWdpc3RyeShrZXksIHBhcmFtcyk7XG4gICAgfVxufTtcbmV4cG9ydCBjbGFzcyBJbnN0YW5jZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmcmllbmRseU5hbWUpIHtcbiAgICAgICAgdGhpcy5mcmllbmRseU5hbWUgPSBmcmllbmRseU5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICBwcmVwYXJlKGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgZ2V0ICRpc1Jlc29sdmVyKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlc29sdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNhbGwgcmVzb2x2ZSAke3RoaXMuZnJpZW5kbHlOYW1lfSBiZWZvcmUgY2FsbGluZyBwcmVwYXJlIG9yIGFmdGVyIGNhbGxpbmcgZGlzcG9zZS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG51bGw7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlS2V5KGtleSkge1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkvdmFsdWUgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLiBBcmUgeW91IHRyeWluZyB0byBpbmplY3QvcmVnaXN0ZXIgc29tZXRoaW5nIHRoYXQgZG9lc25cXCd0IGV4aXN0IHdpdGggREk/Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRBbGxSZXNwb25zZShyZXNvbHZlciwgaGFuZGxlciwgcmVxdWVzdG9yKSB7XG4gICAgaWYgKHJlc29sdmVyIGluc3RhbmNlb2YgUmVzb2x2ZXIgJiYgcmVzb2x2ZXIuc3RyYXRlZ3kgPT09IDQgLyogYXJyYXkgKi8pIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSByZXNvbHZlci5zdGF0ZTtcbiAgICAgICAgbGV0IGkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBzdGF0ZVtpXS5yZXNvbHZlKGhhbmRsZXIsIHJlcXVlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiBbcmVzb2x2ZXIucmVzb2x2ZShoYW5kbGVyLCByZXF1ZXN0b3IpXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucyAqL1xuaW1wb3J0IHsgREkgfSBmcm9tICcuL2RpLmpzJztcbi8qKlxuICogUmVwcmVzZW50cyBhIGhhbmRsZXIgZm9yIGFuIEV2ZW50QWdncmVnYXRvciBldmVudC5cbiAqL1xuY2xhc3MgSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZVR5cGUgPSBtZXNzYWdlVHlwZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBoYW5kbGUobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIHRoaXMubWVzc2FnZVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2suY2FsbChudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJRXZlbnRBZ2dyZWdhdG9yID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJRXZlbnRBZ2dyZWdhdG9yJywgeCA9PiB4LnNpbmdsZXRvbihFdmVudEFnZ3JlZ2F0b3IpKTtcbi8qKlxuICogRW5hYmxlcyBsb29zZWx5IGNvdXBsZWQgcHVibGlzaC9zdWJzY3JpYmUgbWVzc2FnaW5nLlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRBZ2dyZWdhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmV2ZW50TG9va3VwID0ge307XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gICAgcHVibGlzaChjaGFubmVsT3JJbnN0YW5jZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNoYW5uZWxPckluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhbm5lbCBuYW1lIG9yIGluc3RhbmNlOiAke2NoYW5uZWxPckluc3RhbmNlfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoYW5uZWxPckluc3RhbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGV0IHN1YnNjcmliZXJzID0gdGhpcy5ldmVudExvb2t1cFtjaGFubmVsT3JJbnN0YW5jZV07XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHN1YnNjcmliZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tpXShtZXNzYWdlLCBjaGFubmVsT3JJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLm1lc3NhZ2VIYW5kbGVycy5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IGkgPSBzdWJzY3JpYmVycy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzW2ldLmhhbmRsZShjaGFubmVsT3JJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGNoYW5uZWxPclR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2hhbm5lbE9yVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYW5uZWwgbmFtZSBvciB0eXBlOiAke2NoYW5uZWxPclR5cGV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYW5kbGVyO1xuICAgICAgICBsZXQgc3Vic2NyaWJlcnM7XG4gICAgICAgIGlmICh0eXBlb2YgY2hhbm5lbE9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50TG9va3VwW2NoYW5uZWxPclR5cGVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TG9va3VwW2NoYW5uZWxPclR5cGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBzdWJzY3JpYmVycyA9IHRoaXMuZXZlbnRMb29rdXBbY2hhbm5lbE9yVHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gbmV3IEhhbmRsZXIoY2hhbm5lbE9yVHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMgPSB0aGlzLm1lc3NhZ2VIYW5kbGVycztcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBzdWJzY3JpYmVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25jZShjaGFubmVsT3JUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmliZShjaGFubmVsT3JUeXBlLCBmdW5jdGlvbiAobWVzc2FnZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHN1Yi5kaXNwb3NlKCk7XG4gICAgICAgICAgICBjYWxsYmFjayhtZXNzYWdlLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50YWdncmVnYXRvci5qcy5tYXAiLCJpbXBvcnQgeyBlbXB0eUFycmF5IH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5jb25zdCBpc051bWVyaWNMb29rdXAgPSB7fTtcbi8qKlxuICogRWZmaWNpZW50bHkgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHByb3BlcnR5IGtleSBpcyBudW1lcmljXG4gKiAoYW5kIHRodXMgY291bGQgYmUgYW4gYXJyYXkgaW5kZXhlcikgb3Igbm90LlxuICpcbiAqIEFsd2F5cyByZXR1cm5zIHRydWUgZm9yIHZhbHVlcyBvZiB0eXBlIGAnbnVtYmVyJ2AuXG4gKlxuICogT3RoZXJ3aXNlLCBvbmx5IHJldHVybnMgdHJ1ZSBmb3Igc3RyaW5ncyB0aGF0IGNvbnNpc3Qgb25seSBvZiBwb3NpdGl2ZSBpbnRlZ2Vycy5cbiAqXG4gKiBSZXN1bHRzIGFyZSBjYWNoZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5SW5kZXgodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID49IDAgJiYgKHZhbHVlIHwgMCkgPT09IHZhbHVlO1xuICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpc051bWVyaWNMb29rdXBbdmFsdWVdO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOdW1lcmljTG9va3VwW3ZhbHVlXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgY2ggPT09IDB4MzAgJiYgbGVuZ3RoID4gMSAvKiBtdXN0IG5vdCBzdGFydCB3aXRoIDAgKi8gfHwgY2ggPCAweDMwIC8qIDAgKi8gfHwgY2ggPiAweDM5IC8qIDkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTnVtZXJpY0xvb2t1cFt2YWx1ZV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNOdW1lcmljTG9va3VwW3ZhbHVlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBhIG51bWJlciBvciBiaWdpbnQgZm9yIHBhcnNpbmcgcHVycG9zZXNcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBldmFsdWF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJPckJpZ0ludCh2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBhIG51bWJlciBvciBiaWdpbnQgZm9yIHBhcnNpbmcgcHVycG9zZXNcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBldmFsdWF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdPckRhdGUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBjYW1lbCBhbmQga2ViYWIgY2FzZXNcbiAqL1xuY29uc3QgYmFzZUNhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGxldCBDaGFyS2luZDtcbiAgICAoZnVuY3Rpb24gKENoYXJLaW5kKSB7XG4gICAgICAgIENoYXJLaW5kW0NoYXJLaW5kW1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgICAgIENoYXJLaW5kW0NoYXJLaW5kW1wiZGlnaXRcIl0gPSAxXSA9IFwiZGlnaXRcIjtcbiAgICAgICAgQ2hhcktpbmRbQ2hhcktpbmRbXCJ1cHBlclwiXSA9IDJdID0gXCJ1cHBlclwiO1xuICAgICAgICBDaGFyS2luZFtDaGFyS2luZFtcImxvd2VyXCJdID0gM10gPSBcImxvd2VyXCI7XG4gICAgfSkoQ2hhcktpbmQgfHwgKENoYXJLaW5kID0ge30pKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgY29uc3QgaXNEaWdpdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAnMCc6IHRydWUsXG4gICAgICAgICcxJzogdHJ1ZSxcbiAgICAgICAgJzInOiB0cnVlLFxuICAgICAgICAnMyc6IHRydWUsXG4gICAgICAgICc0JzogdHJ1ZSxcbiAgICAgICAgJzUnOiB0cnVlLFxuICAgICAgICAnNic6IHRydWUsXG4gICAgICAgICc3JzogdHJ1ZSxcbiAgICAgICAgJzgnOiB0cnVlLFxuICAgICAgICAnOSc6IHRydWUsXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hhclRvS2luZChjaGFyKSB7XG4gICAgICAgIGlmIChjaGFyID09PSAnJykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IHRoaXMgaWYgd2UgZG8gY2hhckF0KCkgd2l0aCBhbiBpbmRleCBvdXQgb2YgcmFuZ2VcbiAgICAgICAgICAgIHJldHVybiAwIC8qIG5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgIT09IGNoYXIudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDMgLyogbG93ZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgIT09IGNoYXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogdXBwZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlnaXRbY2hhcl0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIGRpZ2l0ICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIG5vbmUgKi87XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQsIGNiKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IG91dHB1dCA9ICcnO1xuICAgICAgICBsZXQgcHJldktpbmQ7XG4gICAgICAgIGxldCBjdXJDaGFyID0gJyc7XG4gICAgICAgIGxldCBjdXJLaW5kID0gMCAvKiBub25lICovO1xuICAgICAgICBsZXQgbmV4dENoYXIgPSBpbnB1dC5jaGFyQXQoMCk7XG4gICAgICAgIGxldCBuZXh0S2luZCA9IGNoYXJUb0tpbmQobmV4dENoYXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcmV2S2luZCA9IGN1cktpbmQ7XG4gICAgICAgICAgICBjdXJDaGFyID0gbmV4dENoYXI7XG4gICAgICAgICAgICBjdXJLaW5kID0gbmV4dEtpbmQ7XG4gICAgICAgICAgICBuZXh0Q2hhciA9IGlucHV0LmNoYXJBdChpICsgMSk7XG4gICAgICAgICAgICBuZXh0S2luZCA9IGNoYXJUb0tpbmQobmV4dENoYXIpO1xuICAgICAgICAgICAgaWYgKGN1cktpbmQgPT09IDAgLyogbm9uZSAqLykge1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNldCBzZXAgdG8gdHJ1ZSBpZiBpdCdzIG5vdCBhdCB0aGUgYmVnaW5uaW5nIG9mIG91dHB1dC5cbiAgICAgICAgICAgICAgICAgICAgc2VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlcCAmJiBvdXRwdXQubGVuZ3RoID4gMCAmJiBjdXJLaW5kID09PSAyIC8qIHVwcGVyICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRlIFVBRm9vIGludG8gVUEgRm9vLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZXBhcmF0ZSB1YUZPTyBpbnRvIHVhIEZPTy5cbiAgICAgICAgICAgICAgICAgICAgc2VwID0gcHJldktpbmQgPT09IDMgLyogbG93ZXIgKi8gfHwgbmV4dEtpbmQgPT09IDMgLyogbG93ZXIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBjYihjdXJDaGFyLCBzZXApO1xuICAgICAgICAgICAgICAgIHNlcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIEVmZmljaWVudGx5IGNvbnZlcnQgYSBzdHJpbmcgdG8gY2FtZWxDYXNlLlxuICpcbiAqIE5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhcmUgdHJlYXRlZCBhcyBzZXBhcmF0b3JzLlxuICpcbiAqIFByaW1hcmlseSB1c2VkIGJ5IEF1cmVsaWEgdG8gY29udmVydCBET00gYXR0cmlidXRlIG5hbWVzIHRvIFZpZXdNb2RlbCBwcm9wZXJ0eSBuYW1lcy5cbiAqXG4gKiBSZXN1bHRzIGFyZSBjYWNoZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBjYW1lbENhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiBjYWxsYmFjayhjaGFyLCBzZXApIHtcbiAgICAgICAgcmV0dXJuIHNlcCA/IGNoYXIudG9VcHBlckNhc2UoKSA6IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gY2FjaGVbaW5wdXRdO1xuICAgICAgICBpZiAob3V0cHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGNhY2hlW2lucHV0XSA9IGJhc2VDYXNlKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSkoKTtcbi8qKlxuICogRWZmaWNpZW50bHkgY29udmVydCBhIHN0cmluZyB0byBQYXNjYWxDYXNlLlxuICpcbiAqIE5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhcmUgdHJlYXRlZCBhcyBzZXBhcmF0b3JzLlxuICpcbiAqIFByaW1hcmlseSB1c2VkIGJ5IEF1cmVsaWEgdG8gY29udmVydCBlbGVtZW50IG5hbWVzIHRvIGNsYXNzIG5hbWVzIGZvciBzeW50aGV0aWMgdHlwZXMuXG4gKlxuICogUmVzdWx0cyBhcmUgY2FjaGVkLlxuICovXG5leHBvcnQgY29uc3QgcGFzY2FsQ2FzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IGNhY2hlW2lucHV0XTtcbiAgICAgICAgaWYgKG91dHB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBjYW1lbENhc2UoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0WzBdLnRvVXBwZXJDYXNlKCkgKyBvdXRwdXQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZVtpbnB1dF0gPSBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSkoKTtcbi8qKlxuICogRWZmaWNpZW50bHkgY29udmVydCBhIHN0cmluZyB0byBrZWJhYi1jYXNlLlxuICpcbiAqIE5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhcmUgdHJlYXRlZCBhcyBzZXBhcmF0b3JzLlxuICpcbiAqIFByaW1hcmlseSB1c2VkIGJ5IEF1cmVsaWEgdG8gY29udmVydCBWaWV3TW9kZWwgcHJvcGVydHkgbmFtZXMgdG8gRE9NIGF0dHJpYnV0ZSBuYW1lcy5cbiAqXG4gKiBSZXN1bHRzIGFyZSBjYWNoZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBrZWJhYkNhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiBjYWxsYmFjayhjaGFyLCBzZXApIHtcbiAgICAgICAgcmV0dXJuIHNlcCA/IGAtJHtjaGFyLnRvTG93ZXJDYXNlKCl9YCA6IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gY2FjaGVbaW5wdXRdO1xuICAgICAgICBpZiAob3V0cHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGNhY2hlW2lucHV0XSA9IGJhc2VDYXNlKGlucHV0LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufSkoKTtcbi8qKlxuICogRWZmaWNpZW50bHkgKHVwIHRvIDEweCBmYXN0ZXIgdGhhbiBgQXJyYXkuZnJvbWApIGNvbnZlcnQgYW4gYEFycmF5TGlrZWAgdG8gYSByZWFsIGFycmF5LlxuICpcbiAqIFByaW1hcmlseSB1c2VkIGJ5IEF1cmVsaWEgdG8gY29udmVydCBET00gbm9kZSBsaXN0cyB0byBhcnJheXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGlucHV0KSB7XG4gICAgLy8gYmVuY2htYXJrOiBodHRwOi8vanNiZW4uY2gveGpzeUZcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgYXJyID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFycltpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuY29uc3QgaWRzID0ge307XG4vKipcbiAqIFJldHJpZXZlIHRoZSBuZXh0IElEIGluIGEgc2VxdWVuY2UgZm9yIGEgZ2l2ZW4gc3RyaW5nLCBzdGFydGluZyB3aXRoIGAxYC5cbiAqXG4gKiBVc2VkIGJ5IEF1cmVsaWEgdG8gYXNzaWduIHVuaXF1ZSBJRCdzIHRvIGNvbnRyb2xsZXJzIGFuZCByZXNvdXJjZXMuXG4gKlxuICogQXVyZWxpYSB3aWxsIGFsd2F5cyBwcmVwZW5kIHRoZSBjb250ZXh0IG5hbWUgd2l0aCBgYXUkYCwgc28gYXMgbG9uZyBhcyB5b3UgYXZvaWRcbiAqIHVzaW5nIHRoYXQgY29udmVudGlvbiB5b3Ugc2hvdWxkIGJlIHNhZmUgZnJvbSBjb2xsaXNpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmV4dElkKGNvbnRleHQpIHtcbiAgICBpZiAoaWRzW2NvbnRleHRdID09PSB2b2lkIDApIHtcbiAgICAgICAgaWRzW2NvbnRleHRdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuICsraWRzW2NvbnRleHRdO1xufVxuLyoqXG4gKiBSZXNldCB0aGUgSUQgZm9yIHRoZSBnaXZlbiBzdHJpbmcsIHNvIHRoYXQgYG5leHRJZGAgd2lsbCByZXR1cm4gYDFgIGFnYWluIGZvciB0aGUgbmV4dCBjYWxsLlxuICpcbiAqIFVzZWQgYnkgQXVyZWxpYSB0byByZXNldCBJRCdzIGluIGJldHdlZW4gdW5pdCB0ZXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0SWQoY29udGV4dCkge1xuICAgIGlkc1tjb250ZXh0XSA9IDA7XG59XG4vKipcbiAqIEEgY29tcGFyZSBmdW5jdGlvbiB0byBwYXNzIHRvIGBBcnJheS5wcm90b3R5cGUuc29ydGAgZm9yIHNvcnRpbmcgbnVtYmVycy5cbiAqIFRoaXMgaXMgbmVlZGVkIGZvciBudW1lcmljIHNvcnQsIHNpbmNlIHRoZSBkZWZhdWx0IHNvcnRzIHRoZW0gYXMgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVOdW1iZXIoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgbWVyZ2UgYW5kIGRlZHVwbGljYXRlIHRoZSAocHJpbWl0aXZlKSB2YWx1ZXMgaW4gdHdvIGFycmF5cy5cbiAqXG4gKiBEb2VzIG5vdCBkZWR1cGxpY2F0ZSBleGlzdGluZyB2YWx1ZXMgaW4gdGhlIGZpcnN0IGFycmF5LlxuICpcbiAqIEd1YXJkcyBhZ2FpbnN0IG51bGwgb3IgdW5kZWZpbmVkIGFycmF5cy5cbiAqXG4gKiBSZXR1cm5zIGBlbXB0eUFycmF5YCBpZiBib3RoIGFycmF5cyBhcmUgZWl0aGVyIGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYGVtcHR5QXJyYXlgXG4gKlxuICogQHBhcmFtIHNsaWNlIC0gSWYgYHRydWVgLCBhbHdheXMgcmV0dXJucyBhIG5ldyBhcnJheSBjb3B5ICh1bmxlc3MgbmVpdGhlciBhcnJheSBpcy9oYXMgYSB2YWx1ZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGlzdGluY3QoYXJyMSwgYXJyMiwgc2xpY2UpIHtcbiAgICBpZiAoYXJyMSA9PT0gdm9pZCAwIHx8IGFycjEgPT09IG51bGwgfHwgYXJyMSA9PT0gZW1wdHlBcnJheSkge1xuICAgICAgICBpZiAoYXJyMiA9PT0gdm9pZCAwIHx8IGFycjIgPT09IG51bGwgfHwgYXJyMiA9PT0gZW1wdHlBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2UgPyBhcnIyLnNsaWNlKDApIDogYXJyMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcnIyID09PSB2b2lkIDAgfHwgYXJyMiA9PT0gbnVsbCB8fCBhcnIyID09PSBlbXB0eUFycmF5KSB7XG4gICAgICAgIHJldHVybiBzbGljZSA/IGFycjEuc2xpY2UoMCkgOiBhcnIxO1xuICAgIH1cbiAgICBjb25zdCBsb29rdXAgPSB7fTtcbiAgICBjb25zdCBhcnIzID0gc2xpY2UgPyBhcnIxLnNsaWNlKDApIDogYXJyMTtcbiAgICBsZXQgbGVuMSA9IGFycjEubGVuZ3RoO1xuICAgIGxldCBsZW4yID0gYXJyMi5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbjEtLSA+IDApIHtcbiAgICAgICAgbG9va3VwW2FycjFbbGVuMV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGl0ZW07XG4gICAgd2hpbGUgKGxlbjItLSA+IDApIHtcbiAgICAgICAgaXRlbSA9IGFycjJbbGVuMl07XG4gICAgICAgIGlmIChsb29rdXBbaXRlbV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYXJyMy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgbG9va3VwW2l0ZW1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyMztcbn1cbi8qKlxuICogRGVjb3JhdG9yLiAobGF6aWx5KSBiaW5kIHRoZSBtZXRob2QgdG8gdGhlIGNsYXNzIGluc3RhbmNlIG9uIGZpcnN0IGNhbGwuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5leHBvcnQgZnVuY3Rpb24gYm91bmQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgYm91bmRGbiA9IGRlc2NyaXB0b3IudmFsdWUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGJvdW5kRm4sXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kRm47XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFycmF5cyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgayA9IDA7XG4gICAgY29uc3QgYXJyYXlzTGVuID0gYXJyYXlzLmxlbmd0aDtcbiAgICBsZXQgYXJyYXlMZW4gPSAwO1xuICAgIGxldCBhcnJheTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5c0xlbjsgKytpKSB7XG4gICAgICAgIGFycmF5ID0gYXJyYXlzW2ldO1xuICAgICAgICBpZiAoYXJyYXkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYXJyYXlMZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5TGVuOyArK2opIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaysrXSA9IGFycmF5W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKC4uLm9iamVjdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBvYmplY3RzTGVuID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgbGV0IG9iamVjdDtcbiAgICBsZXQga2V5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0c0xlbjsgKytpKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdHNbaV07XG4gICAgICAgIGlmIChvYmplY3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZCguLi52YWx1ZXMpIHtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGxldCB2YWx1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVmYXVsdCB2YWx1ZSBmb3VuZGApO1xufVxuZXhwb3J0IGNvbnN0IGdldFByb3RvdHlwZUNoYWluID0gKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICBjb25zdCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICBjb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgbGV0IHByb3RvID0gZnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjaGFpbiA9IHZvaWQgMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKFR5cGUpIHtcbiAgICAgICAgY2hhaW4gPSBjYWNoZS5nZXQoVHlwZSk7XG4gICAgICAgIGlmIChjaGFpbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoVHlwZSwgY2hhaW4gPSBbcHJvdG8gPSBUeXBlXSk7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgocHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90bykpICE9PSBmdW5jdGlvblByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGNoYWluWysraV0gPSBwcm90bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgZnVuY3Rpb24gdG9Mb29rdXAoLi4ub2Jqcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIC4uLm9ianMpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdmFsdWUgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlzIHRoZSBmdW5jdGlvbiBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTmF0aXZlRnVuY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgY29uc3QgbG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBsZXQgaXNOYXRpdmUgPSBmYWxzZTtcbiAgICBsZXQgc291cmNlVGV4dCA9ICcnO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaXNOYXRpdmUgPSBsb29rdXAuZ2V0KGZuKTtcbiAgICAgICAgaWYgKGlzTmF0aXZlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNvdXJjZVRleHQgPSBmbi50b1N0cmluZygpO1xuICAgICAgICAgICAgaSA9IHNvdXJjZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLyNwcm9kLU5hdGl2ZUZ1bmN0aW9uXG4gICAgICAgICAgICBpc05hdGl2ZSA9IChcbiAgICAgICAgICAgIC8vIDI5IGlzIHRoZSBsZW5ndGggb2YgJ2Z1bmN0aW9uICgpIHsgW25hdGl2ZSBjb2RlXSB9JyB3aGljaCBpcyB0aGUgc21hbGxlc3QgbGVuZ3RoIG9mIGEgbmF0aXZlIGZ1bmN0aW9uIHN0cmluZ1xuICAgICAgICAgICAgaSA+PSAyOSAmJlxuICAgICAgICAgICAgICAgIC8vIDEwMCBzZWVtcyB0byBiZSBhIHNhZmUgdXBwZXIgYm91bmQgb2YgdGhlIG1heCBsZW5ndGggb2YgYSBuYXRpdmUgZnVuY3Rpb24uIEluIENocm9tZSBhbmQgRkYgaXQncyA1NiwgaW4gRWRnZSBpdCdzIDYxLlxuICAgICAgICAgICAgICAgIGkgPD0gMTAwICYmXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aG9sZSBoZXVyaXN0aWMgKmNvdWxkKiBiZSB0cmlja2VkIGJ5IGEgY29tbWVudC4gRG8gd2UgbmVlZCB0byBjYXJlIGFib3V0IHRoYXQ/XG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHg3RCAmJiAvLyB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhlIHNwZWMgaXMgYSBsaXR0bGUgdmFndWUgYWJvdXQgdGhlIHByZWNpc2UgY29uc3RyYWludHMsIHNvIHdlIGRvIG5lZWQgdG8gdGVzdCB0aGlzIGFjcm9zcyB2YXJpb3VzIGJyb3dzZXJzIHRvIG1ha2Ugc3VyZSBqdXN0IG9uZSB3aGl0ZXNwYWNlIGlzIGEgc2FmZSBhc3N1bXB0aW9uLlxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gMikgPD0gMHgyMCAmJiAvLyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSAzKSA9PT0gMHg1RCAmJiAvLyBdXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSA0KSA9PT0gMHg2NSAmJiAvLyBlXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSA1KSA9PT0gMHg2NCAmJiAvLyBkXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSA2KSA9PT0gMHg2RiAmJiAvLyBvXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSA3KSA9PT0gMHg2MyAmJiAvLyBjXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSA4KSA9PT0gMHgyMCAmJiAvL1xuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gOSkgPT09IDB4NjUgJiYgLy8gZVxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gMTApID09PSAweDc2ICYmIC8vIHZcbiAgICAgICAgICAgICAgICBzb3VyY2VUZXh0LmNoYXJDb2RlQXQoaSAtIDExKSA9PT0gMHg2OSAmJiAvLyBpXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSAxMikgPT09IDB4NzQgJiYgLy8gdFxuICAgICAgICAgICAgICAgIHNvdXJjZVRleHQuY2hhckNvZGVBdChpIC0gMTMpID09PSAweDYxICYmIC8vIGFcbiAgICAgICAgICAgICAgICBzb3VyY2VUZXh0LmNoYXJDb2RlQXQoaSAtIDE0KSA9PT0gMHg2RSAmJiAvLyBuXG4gICAgICAgICAgICAgICAgc291cmNlVGV4dC5jaGFyQ29kZUF0KGkgLSAxNSkgPT09IDB4NTggLy8gW1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvb2t1cC5zZXQoZm4sIGlzTmF0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYXRpdmU7XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHBvdGVudGlhbCBwcm9taXNlIHZpYSBhIGNhbGxiYWNrLCB0byBlbnN1cmUgdGhpbmdzIHN0YXkgc3luY2hyb25vdXMgd2hlbiB0aGV5IGNhbi5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBwcm9taXNlLCBpdCBpcyBgdGhlbmBlZCBiZWZvcmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWQuIE90aGVyd2lzZSB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCBzeW5jaHJvbm91c2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25SZXNvbHZlKG1heWJlUHJvbWlzZSwgcmVzb2x2ZUNhbGxiYWNrKSB7XG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS50aGVuKHJlc29sdmVDYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlQ2FsbGJhY2sobWF5YmVQcm9taXNlKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGFuIGFycmF5IG9mIHBvdGVudGlhbCBwcm9taXNlcywgdG8gZW5zdXJlIHRoaW5ncyBzdGF5IHN5bmNocm9ub3VzIHdoZW4gdGhleSBjYW4uXG4gKlxuICogSWYgZXhhY3RseSBvbmUgdmFsdWUgaXMgYSBwcm9taXNlLCB0aGVuIHRoYXQgcHJvbWlzZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBtb3JlIHRoYW4gb25lIHZhbHVlIGlzIGEgcHJvbWlzZSwgYSBuZXcgYFByb21pc2UuYWxsYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBub25lIG9mIHRoZSB2YWx1ZXMgaXMgYSBwcm9taXNlLCBub3RoaW5nIGlzIHJldHVybmVkLCB0byBpbmRpY2F0ZSB0aGF0IHRoaW5ncyBjYW4gc3RheSBzeW5jaHJvbm91cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBbGwoLi4ubWF5YmVQcm9taXNlcykge1xuICAgIGxldCBtYXliZVByb21pc2UgPSB2b2lkIDA7XG4gICAgbGV0IGZpcnN0UHJvbWlzZSA9IHZvaWQgMDtcbiAgICBsZXQgcHJvbWlzZXMgPSB2b2lkIDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbWF5YmVQcm9taXNlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZXNbaV07XG4gICAgICAgIGlmICgobWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlc1tpXSkgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdFByb21pc2UgPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9taXNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbZmlyc3RQcm9taXNlLCBtYXliZVByb21pc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtYXliZVByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9taXNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbnMuanMubWFwIiwiaW1wb3J0IHsgREkgfSBmcm9tICcuL2RpLmpzJztcbmV4cG9ydCBjb25zdCBJUGxhdGZvcm0gPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lQbGF0Zm9ybScpO1xuZXhwb3J0IHsgUGxhdGZvcm0sIFRhc2tRdWV1ZSwgVGFzaywgVGFza0Fib3J0RXJyb3IsIFRhc2tRdWV1ZVByaW9yaXR5LCBUYXNrU3RhdHVzLCB9IGZyb20gJ0BhdXJlbGlhL3BsYXRmb3JtJztcbmV4cG9ydCB7IGFsbCwgREksIElDb250YWluZXIsIGluamVjdCwgSVNlcnZpY2VMb2NhdG9yLCBsYXp5LCBvcHRpb25hbCwgaWdub3JlLCBSZWdpc3RyYXRpb24sIHNpbmdsZXRvbiwgdHJhbnNpZW50LCBJbnN0YW5jZVByb3ZpZGVyLCBuZXdJbnN0YW5jZUZvclNjb3BlLCBuZXdJbnN0YW5jZU9mLCBDb250YWluZXJDb25maWd1cmF0aW9uLCBEZWZhdWx0UmVzb2x2ZXIsIH0gZnJvbSAnLi9kaS5qcyc7XG5leHBvcnQgeyBtZXRhZGF0YSwgTWV0YWRhdGEsIGlzTnVsbE9yVW5kZWZpbmVkLCBpc09iamVjdCwgYXBwbHlNZXRhZGF0YVBvbHlmaWxsLCB9IGZyb20gJ0BhdXJlbGlhL21ldGFkYXRhJztcbmV4cG9ydCB7IExvZ0xldmVsLCBDb2xvck9wdGlvbnMsIElMb2dDb25maWcsIElMb2dFdmVudEZhY3RvcnksIElTaW5rLCBJTG9nZ2VyLCBMb2dDb25maWcsIERlZmF1bHRMb2dFdmVudCwgRGVmYXVsdExvZ0V2ZW50RmFjdG9yeSwgRGVmYXVsdExvZ2dlciwgQ29uc29sZVNpbmssIExvZ2dlckNvbmZpZ3VyYXRpb24sIGZvcm1hdCwgc2luaywgfSBmcm9tICcuL2xvZ2dlci5qcyc7XG5leHBvcnQgeyBJTW9kdWxlTG9hZGVyLCBBbmFseXplZE1vZHVsZSwgTW9kdWxlSXRlbSwgfSBmcm9tICcuL21vZHVsZS1sb2FkZXIuanMnO1xuZXhwb3J0IHsgbm9vcCwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5leHBvcnQgeyBQcm90b2NvbCwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQsIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0LCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCwgfSBmcm9tICcuL3Jlc291cmNlLmpzJztcbmV4cG9ydCB7IEV2ZW50QWdncmVnYXRvciwgSUV2ZW50QWdncmVnYXRvciwgfSBmcm9tICcuL2V2ZW50YWdncmVnYXRvci5qcyc7XG5leHBvcnQgeyBpc0FycmF5SW5kZXgsIGNhbWVsQ2FzZSwga2ViYWJDYXNlLCBwYXNjYWxDYXNlLCB0b0FycmF5LCBuZXh0SWQsIHJlc2V0SWQsIGNvbXBhcmVOdW1iZXIsIG1lcmdlRGlzdGluY3QsIGlzTnVtYmVyT3JCaWdJbnQsIGlzU3RyaW5nT3JEYXRlLCBib3VuZCwgbWVyZ2VBcnJheXMsIG1lcmdlT2JqZWN0cywgZmlyc3REZWZpbmVkLCBnZXRQcm90b3R5cGVDaGFpbiwgaXNOYXRpdmVGdW5jdGlvbiwgb25SZXNvbHZlLCByZXNvbHZlQWxsLCB9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgYWxsLCBESSwgaWdub3JlLCBvcHRpb25hbCwgUmVnaXN0cmF0aW9uIH0gZnJvbSAnLi9kaS5qcyc7XG5pbXBvcnQgeyBib3VuZCwgdG9Mb29rdXAgfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgeyBQcm90b2NvbCB9IGZyb20gJy4vcmVzb3VyY2UuanMnO1xuaW1wb3J0IHsgTWV0YWRhdGEgfSBmcm9tICdAYXVyZWxpYS9tZXRhZGF0YSc7XG5leHBvcnQgdmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGludGVybmFsIGFwcCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIERpc2FibGVkIGJ5IGRlZmF1bHQgYW5kIHNob3VsZCBuZXZlciBiZSBlbmFibGVkIGluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudC5cbiAgICAgKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcInRyYWNlXCJdID0gMF0gPSBcInRyYWNlXCI7XG4gICAgLyoqXG4gICAgICogSW5mb3JtYXRpb24gdGhhdCBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyBkdXJpbmcgZGV2ZWxvcG1lbnQgYW5kIGhhcyBubyBsb25nLXRlcm0gdmFsdWUuXG4gICAgICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJkZWJ1Z1wiXSA9IDFdID0gXCJkZWJ1Z1wiO1xuICAgIC8qKlxuICAgICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBnZW5lcmFsIGZsb3cgb2YgdGhlIGFwcGxpY2F0aW9uIHRoYXQgaGFzIGxvbmctdGVybSB2YWx1ZS5cbiAgICAgKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcImluZm9cIl0gPSAyXSA9IFwiaW5mb1wiO1xuICAgIC8qKlxuICAgICAqIFVuZXhwZWN0ZWQgY2lyY3Vtc3RhbmNlcyB0aGF0IHJlcXVpcmUgYXR0ZW50aW9uIGJ1dCBkbyBub3Qgb3RoZXJ3aXNlIGNhdXNlIHRoZSBjdXJyZW50IGZsb3cgb2YgZXhlY3V0aW9uIHRvIHN0b3AuXG4gICAgICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ3YXJuXCJdID0gM10gPSBcIndhcm5cIjtcbiAgICAvKipcbiAgICAgKiBVbmV4cGVjdGVkIGNpcmN1bXN0YW5jZXMgdGhhdCBjYXVzZSB0aGUgZmxvdyBvZiBleGVjdXRpb24gaW4gdGhlIGN1cnJlbnQgYWN0aXZpdHkgdG8gc3RvcCBidXQgZG8gbm90IGNhdXNlIGFuIGFwcC13aWRlIGZhaWx1cmUuXG4gICAgICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJlcnJvclwiXSA9IDRdID0gXCJlcnJvclwiO1xuICAgIC8qKlxuICAgICAqIFVuZXhwZWN0ZWQgY2lyY3Vtc3RhbmNlcyB0aGF0IGNhdXNlIGFuIGFwcC13aWRlIGZhaWx1cmUgb3Igb3RoZXJ3aXNlIHJlcXVpcmUgaW1tZWRpYXRlIGF0dGVudGlvbi5cbiAgICAgKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcImZhdGFsXCJdID0gNV0gPSBcImZhdGFsXCI7XG4gICAgLyoqXG4gICAgICogTm8gbWVzc2FnZXMgc2hvdWxkIGJlIHdyaXR0ZW4uXG4gICAgICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJub25lXCJdID0gNl0gPSBcIm5vbmVcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG4vKipcbiAqIEZsYWdzIHRvIGVuYWJsZS9kaXNhYmxlIGNvbG9yIHVzYWdlIGluIHRoZSBsb2dnaW5nIG91dHB1dC5cbiAqL1xuZXhwb3J0IHZhciBDb2xvck9wdGlvbnM7XG4oZnVuY3Rpb24gKENvbG9yT3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIERvIG5vdCB1c2UgQVNDSUkgY29sb3IgY29kZXMgaW4gbG9nZ2luZyBvdXRwdXQuXG4gICAgICovXG4gICAgQ29sb3JPcHRpb25zW0NvbG9yT3B0aW9uc1tcIm5vQ29sb3JzXCJdID0gMF0gPSBcIm5vQ29sb3JzXCI7XG4gICAgLyoqXG4gICAgICogVXNlIEFTQ0lJIGNvbG9yIGNvZGVzIGluIGxvZ2dpbmcgb3V0cHV0LiBCeSBkZWZhdWx0LCB0aW1lc3RhbXBzIGFuZCB0aGUgVFJDIGFuZCBEQkcgcHJlZml4IGFyZSBjb2xvcmVkIGdyZXkuIElORiB3aGl0ZSwgV1JOIHllbGxvdywgYW5kIEVSUiBhbmQgRlRMIHJlZC5cbiAgICAgKi9cbiAgICBDb2xvck9wdGlvbnNbQ29sb3JPcHRpb25zW1wiY29sb3JzXCJdID0gMV0gPSBcImNvbG9yc1wiO1xufSkoQ29sb3JPcHRpb25zIHx8IChDb2xvck9wdGlvbnMgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IElMb2dDb25maWcgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lMb2dDb25maWcnLCB4ID0+IHguaW5zdGFuY2UobmV3IExvZ0NvbmZpZygwIC8qIG5vQ29sb3JzICovLCAzIC8qIHdhcm4gKi8pKSk7XG5leHBvcnQgY29uc3QgSVNpbmsgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lTaW5rJyk7XG5leHBvcnQgY29uc3QgSUxvZ0V2ZW50RmFjdG9yeSA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUxvZ0V2ZW50RmFjdG9yeScsIHggPT4geC5zaW5nbGV0b24oRGVmYXVsdExvZ0V2ZW50RmFjdG9yeSkpO1xuZXhwb3J0IGNvbnN0IElMb2dnZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lMb2dnZXInLCB4ID0+IHguc2luZ2xldG9uKERlZmF1bHRMb2dnZXIpKTtcbmV4cG9ydCBjb25zdCBJTG9nU2NvcGVzID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJTG9nU2NvcGUnKTtcbmV4cG9ydCBjb25zdCBMb2dnZXJTaW5rID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAga2V5OiBQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcignbG9nZ2VyLXNpbmstaGFuZGxlcycpLFxuICAgIGRlZmluZSh0YXJnZXQsIGRlZmluaXRpb24pIHtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKHRoaXMua2V5LCBkZWZpbml0aW9uLmhhbmRsZXMsIHRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG4gICAgZ2V0SGFuZGxlcyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhLmdldCh0aGlzLmtleSwgdGFyZ2V0KTtcbiAgICB9LFxufSk7XG5leHBvcnQgZnVuY3Rpb24gc2luayhkZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIExvZ2dlclNpbmsuZGVmaW5lKHRhcmdldCwgZGVmaW5pdGlvbik7XG4gICAgfTtcbn1cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IHRvTG9va3VwKHtcbiAgICByZWQoc3RyKSB7XG4gICAgICAgIHJldHVybiBgXFx1MDAxYlszMW0ke3N0cn1cXHUwMDFiWzM5bWA7XG4gICAgfSxcbiAgICBncmVlbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIGBcXHUwMDFiWzMybSR7c3RyfVxcdTAwMWJbMzltYDtcbiAgICB9LFxuICAgIHllbGxvdyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIGBcXHUwMDFiWzMzbSR7c3RyfVxcdTAwMWJbMzltYDtcbiAgICB9LFxuICAgIGJsdWUoc3RyKSB7XG4gICAgICAgIHJldHVybiBgXFx1MDAxYlszNG0ke3N0cn1cXHUwMDFiWzM5bWA7XG4gICAgfSxcbiAgICBtYWdlbnRhKHN0cikge1xuICAgICAgICByZXR1cm4gYFxcdTAwMWJbMzVtJHtzdHJ9XFx1MDAxYlszOW1gO1xuICAgIH0sXG4gICAgY3lhbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIGBcXHUwMDFiWzM2bSR7c3RyfVxcdTAwMWJbMzltYDtcbiAgICB9LFxuICAgIHdoaXRlKHN0cikge1xuICAgICAgICByZXR1cm4gYFxcdTAwMWJbMzdtJHtzdHJ9XFx1MDAxYlszOW1gO1xuICAgIH0sXG4gICAgZ3JleShzdHIpIHtcbiAgICAgICAgcmV0dXJuIGBcXHUwMDFiWzkwbSR7c3RyfVxcdTAwMWJbMzltYDtcbiAgICB9LFxufSk7XG5leHBvcnQgY2xhc3MgTG9nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2xvck9wdGlvbnMsIGxldmVsKSB7XG4gICAgICAgIHRoaXMuY29sb3JPcHRpb25zID0gY29sb3JPcHRpb25zO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxufVxuY29uc3QgZ2V0TG9nTGV2ZWxTdHJpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGxvZ0xldmVsU3RyaW5nID0gW1xuICAgICAgICB0b0xvb2t1cCh7XG4gICAgICAgICAgICBUUkM6ICdUUkMnLFxuICAgICAgICAgICAgREJHOiAnREJHJyxcbiAgICAgICAgICAgIElORjogJ0lORicsXG4gICAgICAgICAgICBXUk46ICdXUk4nLFxuICAgICAgICAgICAgRVJSOiAnRVJSJyxcbiAgICAgICAgICAgIEZUTDogJ0ZUTCcsXG4gICAgICAgICAgICBRUVE6ICc/Pz8nLFxuICAgICAgICB9KSxcbiAgICAgICAgdG9Mb29rdXAoe1xuICAgICAgICAgICAgVFJDOiBmb3JtYXQuZ3JleSgnVFJDJyksXG4gICAgICAgICAgICBEQkc6IGZvcm1hdC5ncmV5KCdEQkcnKSxcbiAgICAgICAgICAgIElORjogZm9ybWF0LndoaXRlKCdJTkYnKSxcbiAgICAgICAgICAgIFdSTjogZm9ybWF0LnllbGxvdygnV1JOJyksXG4gICAgICAgICAgICBFUlI6IGZvcm1hdC5yZWQoJ0VSUicpLFxuICAgICAgICAgICAgRlRMOiBmb3JtYXQucmVkKCdGVEwnKSxcbiAgICAgICAgICAgIFFRUTogZm9ybWF0LmdyZXkoJz8/PycpLFxuICAgICAgICB9KSxcbiAgICBdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobGV2ZWwsIGNvbG9yT3B0aW9ucykge1xuICAgICAgICBpZiAobGV2ZWwgPD0gMCAvKiB0cmFjZSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsU3RyaW5nW2NvbG9yT3B0aW9uc10uVFJDO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA8PSAxIC8qIGRlYnVnICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nTGV2ZWxTdHJpbmdbY29sb3JPcHRpb25zXS5EQkc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsIDw9IDIgLyogaW5mbyAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsU3RyaW5nW2NvbG9yT3B0aW9uc10uSU5GO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA8PSAzIC8qIHdhcm4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dMZXZlbFN0cmluZ1tjb2xvck9wdGlvbnNdLldSTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPD0gNCAvKiBlcnJvciAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ0xldmVsU3RyaW5nW2NvbG9yT3B0aW9uc10uRVJSO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA8PSA1IC8qIGZhdGFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nTGV2ZWxTdHJpbmdbY29sb3JPcHRpb25zXS5GVEw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ0xldmVsU3RyaW5nW2NvbG9yT3B0aW9uc10uUVFRO1xuICAgIH07XG59KSgpO1xuZnVuY3Rpb24gZ2V0U2NvcGVTdHJpbmcoc2NvcGUsIGNvbG9yT3B0aW9ucykge1xuICAgIGlmIChjb2xvck9wdGlvbnMgPT09IDAgLyogbm9Db2xvcnMgKi8pIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlLm1hcChmb3JtYXQuY3lhbikuam9pbignLicpO1xufVxuZnVuY3Rpb24gZ2V0SXNvU3RyaW5nKHRpbWVzdGFtcCwgY29sb3JPcHRpb25zKSB7XG4gICAgaWYgKGNvbG9yT3B0aW9ucyA9PT0gMCAvKiBub0NvbG9ycyAqLykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0LmdyZXkobmV3IERhdGUodGltZXN0YW1wKS50b0lTT1N0cmluZygpKTtcbn1cbmV4cG9ydCBjbGFzcyBEZWZhdWx0TG9nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHNldmVyaXR5LCBtZXNzYWdlLCBvcHRpb25hbFBhcmFtcywgc2NvcGUsIGNvbG9yT3B0aW9ucywgdGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5vcHRpb25hbFBhcmFtcyA9IG9wdGlvbmFsUGFyYW1zO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuY29sb3JPcHRpb25zID0gY29sb3JPcHRpb25zO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHsgc2V2ZXJpdHksIG1lc3NhZ2UsIHNjb3BlLCBjb2xvck9wdGlvbnMsIHRpbWVzdGFtcCB9ID0gdGhpcztcbiAgICAgICAgaWYgKHNjb3BlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2dldElzb1N0cmluZyh0aW1lc3RhbXAsIGNvbG9yT3B0aW9ucyl9IFske2dldExvZ0xldmVsU3RyaW5nKHNldmVyaXR5LCBjb2xvck9wdGlvbnMpfV0gJHttZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2dldElzb1N0cmluZyh0aW1lc3RhbXAsIGNvbG9yT3B0aW9ucyl9IFske2dldExvZ0xldmVsU3RyaW5nKHNldmVyaXR5LCBjb2xvck9wdGlvbnMpfSAke2dldFNjb3BlU3RyaW5nKHNjb3BlLCBjb2xvck9wdGlvbnMpfV0gJHttZXNzYWdlfWA7XG4gICAgfVxufVxubGV0IERlZmF1bHRMb2dFdmVudEZhY3RvcnkgPSBjbGFzcyBEZWZhdWx0TG9nRXZlbnRGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIGNyZWF0ZUxvZ0V2ZW50KGxvZ2dlciwgbGV2ZWwsIG1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdExvZ0V2ZW50KGxldmVsLCBtZXNzYWdlLCBvcHRpb25hbFBhcmFtcywgbG9nZ2VyLnNjb3BlLCB0aGlzLmNvbmZpZy5jb2xvck9wdGlvbnMsIERhdGUubm93KCkpO1xuICAgIH1cbn07XG5EZWZhdWx0TG9nRXZlbnRGYWN0b3J5ID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJTG9nQ29uZmlnKVxuXSwgRGVmYXVsdExvZ0V2ZW50RmFjdG9yeSk7XG5leHBvcnQgeyBEZWZhdWx0TG9nRXZlbnRGYWN0b3J5IH07XG5leHBvcnQgY2xhc3MgQ29uc29sZVNpbmsge1xuICAgIGNvbnN0cnVjdG9yKCRjb25zb2xlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25hbFBhcmFtcyA9IGV2ZW50Lm9wdGlvbmFsUGFyYW1zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsUGFyYW1zID09PSB2b2lkIDAgfHwgb3B0aW9uYWxQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5zZXZlcml0eSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogdHJhY2UgKi86XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBkZWJ1ZyAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29uc29sZS5kZWJ1ZyhldmVudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIGluZm8gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnNvbGUuaW5mbyhldmVudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIHdhcm4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnNvbGUud2FybihldmVudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIGVycm9yICovOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDUgLyogZmF0YWwgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnNvbGUuZXJyb3IoZXZlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5zZXZlcml0eSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogdHJhY2UgKi86XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBkZWJ1ZyAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29uc29sZS5kZWJ1ZyhldmVudC50b1N0cmluZygpLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBpbmZvICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb25zb2xlLmluZm8oZXZlbnQudG9TdHJpbmcoKSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogd2FybiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29uc29sZS53YXJuKGV2ZW50LnRvU3RyaW5nKCksIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIGVycm9yICovOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDUgLyogZmF0YWwgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnNvbGUuZXJyb3IoZXZlbnQudG9TdHJpbmcoKSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5sZXQgRGVmYXVsdExvZ2dlciA9IGNsYXNzIERlZmF1bHRMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgbG9nZ2VyIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgY29uZmlnLCBmYWN0b3J5LCBzaW5rcywgXG4gICAgLyoqXG4gICAgICogVGhlIHNjb3BlcyB0aGF0IHRoaXMgbG9nZ2VyIHdhcyBjcmVhdGVkIGZvciwgaWYgYW55LlxuICAgICAqL1xuICAgIHNjb3BlID0gW10sIHBhcmVudCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5zY29wZWRMb2dnZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHRyYWNlU2lua3M7XG4gICAgICAgIGxldCBkZWJ1Z1NpbmtzO1xuICAgICAgICBsZXQgaW5mb1NpbmtzO1xuICAgICAgICBsZXQgd2FyblNpbmtzO1xuICAgICAgICBsZXQgZXJyb3JTaW5rcztcbiAgICAgICAgbGV0IGZhdGFsU2lua3M7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0cmFjZVNpbmtzID0gdGhpcy50cmFjZVNpbmtzID0gW107XG4gICAgICAgICAgICBkZWJ1Z1NpbmtzID0gdGhpcy5kZWJ1Z1NpbmtzID0gW107XG4gICAgICAgICAgICBpbmZvU2lua3MgPSB0aGlzLmluZm9TaW5rcyA9IFtdO1xuICAgICAgICAgICAgd2FyblNpbmtzID0gdGhpcy53YXJuU2lua3MgPSBbXTtcbiAgICAgICAgICAgIGVycm9yU2lua3MgPSB0aGlzLmVycm9yU2lua3MgPSBbXTtcbiAgICAgICAgICAgIGZhdGFsU2lua3MgPSB0aGlzLmZhdGFsU2lua3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgJHNpbmsgb2Ygc2lua3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVzID0gTG9nZ2VyU2luay5nZXRIYW5kbGVzKCRzaW5rKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcz8uaW5jbHVkZXMoMCAvKiB0cmFjZSAqLykgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZVNpbmtzLnB1c2goJHNpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcz8uaW5jbHVkZXMoMSAvKiBkZWJ1ZyAqLykgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1NpbmtzLnB1c2goJHNpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcz8uaW5jbHVkZXMoMiAvKiBpbmZvICovKSA/PyB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm9TaW5rcy5wdXNoKCRzaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXM/LmluY2x1ZGVzKDMgLyogd2FybiAqLykgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuU2lua3MucHVzaCgkc2luayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVzPy5pbmNsdWRlcyg0IC8qIGVycm9yICovKSA/PyB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yU2lua3MucHVzaCgkc2luayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVzPy5pbmNsdWRlcyg1IC8qIGZhdGFsICovKSA/PyB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhdGFsU2lua3MucHVzaCgkc2luayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcGFyZW50LnJvb3Q7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRyYWNlU2lua3MgPSB0aGlzLnRyYWNlU2lua3MgPSBwYXJlbnQudHJhY2VTaW5rcztcbiAgICAgICAgICAgIGRlYnVnU2lua3MgPSB0aGlzLmRlYnVnU2lua3MgPSBwYXJlbnQuZGVidWdTaW5rcztcbiAgICAgICAgICAgIGluZm9TaW5rcyA9IHRoaXMuaW5mb1NpbmtzID0gcGFyZW50LmluZm9TaW5rcztcbiAgICAgICAgICAgIHdhcm5TaW5rcyA9IHRoaXMud2FyblNpbmtzID0gcGFyZW50Lndhcm5TaW5rcztcbiAgICAgICAgICAgIGVycm9yU2lua3MgPSB0aGlzLmVycm9yU2lua3MgPSBwYXJlbnQuZXJyb3JTaW5rcztcbiAgICAgICAgICAgIGZhdGFsU2lua3MgPSB0aGlzLmZhdGFsU2lua3MgPSBwYXJlbnQuZmF0YWxTaW5rcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFjZShtZXNzYWdlT3JHZXRNZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubGV2ZWwgPD0gMCAvKiB0cmFjZSAqLykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMudHJhY2VTaW5rcywgMCAvKiB0cmFjZSAqLywgbWVzc2FnZU9yR2V0TWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYnVnKG1lc3NhZ2VPckdldE1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5sZXZlbCA8PSAxIC8qIGRlYnVnICovKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5kZWJ1Z1NpbmtzLCAxIC8qIGRlYnVnICovLCBtZXNzYWdlT3JHZXRNZXNzYWdlLCBvcHRpb25hbFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5mbyhtZXNzYWdlT3JHZXRNZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubGV2ZWwgPD0gMiAvKiBpbmZvICovKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5pbmZvU2lua3MsIDIgLyogaW5mbyAqLywgbWVzc2FnZU9yR2V0TWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhcm4obWVzc2FnZU9yR2V0TWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxldmVsIDw9IDMgLyogd2FybiAqLykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMud2FyblNpbmtzLCAzIC8qIHdhcm4gKi8sIG1lc3NhZ2VPckdldE1lc3NhZ2UsIG9wdGlvbmFsUGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcihtZXNzYWdlT3JHZXRNZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubGV2ZWwgPD0gNCAvKiBlcnJvciAqLykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXJyb3JTaW5rcywgNCAvKiBlcnJvciAqLywgbWVzc2FnZU9yR2V0TWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZhdGFsKG1lc3NhZ2VPckdldE1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5sZXZlbCA8PSA1IC8qIGZhdGFsICovKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5mYXRhbFNpbmtzLCA1IC8qIGZhdGFsICovLCBtZXNzYWdlT3JHZXRNZXNzYWdlLCBvcHRpb25hbFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGxvZ2dlciB3aXRoIGFuIGFkZGl0aW9uYWwgcGVybWFuZW50IHByZWZpeCBhZGRlZCB0byB0aGUgbG9nZ2luZyBvdXRwdXRzLlxuICAgICAqIFdoZW4gY2hhaW5lZCwgbXVsdGlwbGUgc2NvcGVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBkb3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHByZWxpbWluYXJ5IEFQSSBhbmQgc3ViamVjdCB0byBjaGFuZ2UgYmVmb3JlIGFscGhhIHJlbGVhc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgY29uc3RydWN0b3IoQElMb2dnZXIgcHJpdmF0ZSBsb2dnZXI6IElMb2dnZXIpIHtcbiAgICAgKiAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ2JlZm9yZSBzY29waW5nJyk7XG4gICAgICogICAgIC8vIGNvbnNvbGUgb3V0cHV0OiAnW0RCR10gYmVmb3JlIHNjb3BpbmcnXG4gICAgICogICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLnNjb3BlVG8oJ015Q29tcG9uZW50Jyk7XG4gICAgICogICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdhZnRlciBzY29waW5nJyk7XG4gICAgICogICAgIC8vIGNvbnNvbGUgb3V0cHV0OiAnW0RCRyBNeUNvbXBvbmVudF0gYWZ0ZXIgc2NvcGluZydcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgcHVibGljIGRvU3R1ZmYoKTogdm9pZCB7XG4gICAgICogICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2VyLnNjb3BlVG8oJ2RvU3R1ZmYoKScpO1xuICAgICAqICAgICBsb2dnZXIuZGVidWcoJ2RvaW5nIHN0dWZmJyk7XG4gICAgICogICAgIC8vIGNvbnNvbGUgb3V0cHV0OiAnW0RCRyBNeUNvbXBvbmVudC5kb1N0dWZmKCldIGRvaW5nIHN0dWZmJ1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzY29wZVRvKG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVkTG9nZ2VycyA9IHRoaXMuc2NvcGVkTG9nZ2VycztcbiAgICAgICAgbGV0IHNjb3BlZExvZ2dlciA9IHNjb3BlZExvZ2dlcnNbbmFtZV07XG4gICAgICAgIGlmIChzY29wZWRMb2dnZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc2NvcGVkTG9nZ2VyID0gc2NvcGVkTG9nZ2Vyc1tuYW1lXSA9IG5ldyBEZWZhdWx0TG9nZ2VyKHRoaXMuY29uZmlnLCB0aGlzLmZhY3RvcnksICh2b2lkIDApLCB0aGlzLnNjb3BlLmNvbmNhdChuYW1lKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlZExvZ2dlcjtcbiAgICB9XG4gICAgZW1pdChzaW5rcywgbGV2ZWwsIG1zZ09yR2V0TXNnLCBvcHRpb25hbFBhcmFtcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIG1zZ09yR2V0TXNnID09PSAnZnVuY3Rpb24nID8gbXNnT3JHZXRNc2coKSA6IG1zZ09yR2V0TXNnO1xuICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuZmFjdG9yeS5jcmVhdGVMb2dFdmVudCh0aGlzLCBsZXZlbCwgbWVzc2FnZSwgb3B0aW9uYWxQYXJhbXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzaW5rcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBzaW5rc1tpXS5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYm91bmRcbl0sIERlZmF1bHRMb2dnZXIucHJvdG90eXBlLCBcInRyYWNlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgYm91bmRcbl0sIERlZmF1bHRMb2dnZXIucHJvdG90eXBlLCBcImRlYnVnXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgYm91bmRcbl0sIERlZmF1bHRMb2dnZXIucHJvdG90eXBlLCBcImluZm9cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBib3VuZFxuXSwgRGVmYXVsdExvZ2dlci5wcm90b3R5cGUsIFwid2FyblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJvdW5kXG5dLCBEZWZhdWx0TG9nZ2VyLnByb3RvdHlwZSwgXCJlcnJvclwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJvdW5kXG5dLCBEZWZhdWx0TG9nZ2VyLnByb3RvdHlwZSwgXCJmYXRhbFwiLCBudWxsKTtcbkRlZmF1bHRMb2dnZXIgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElMb2dDb25maWcpLFxuICAgIF9fcGFyYW0oMSwgSUxvZ0V2ZW50RmFjdG9yeSksXG4gICAgX19wYXJhbSgyLCBhbGwoSVNpbmspKSxcbiAgICBfX3BhcmFtKDMsIG9wdGlvbmFsKElMb2dTY29wZXMpKSxcbiAgICBfX3BhcmFtKDQsIGlnbm9yZSlcbl0sIERlZmF1bHRMb2dnZXIpO1xuZXhwb3J0IHsgRGVmYXVsdExvZ2dlciB9O1xuLyoqXG4gKiBBIGJhc2ljIGBJTG9nZ2VyYCBjb25maWd1cmF0aW9uIHRoYXQgY29uZmlndXJlcyBhIHNpbmdsZSBgY29uc29sZWAgc2luayBiYXNlZCBvbiBwcm92aWRlZCBvcHRpb25zLlxuICpcbiAqIE5PVEU6IFlvdSAqbXVzdCogcmVnaXN0ZXIgdGhlIHJldHVybiB2YWx1ZSBvZiBgLmNyZWF0ZWAgd2l0aCB0aGUgY29udGFpbmVyIC8gYXUgaW5zdGFuY2UsIG5vdCB0aGlzIGBMb2dnZXJDb25maWd1cmF0aW9uYCBvYmplY3QgaXRzZWxmLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29udGFpbmVyLnJlZ2lzdGVyKExvZ2dlckNvbmZpZ3VyYXRpb24uY3JlYXRlKCkpO1xuICpcbiAqIGNvbnRhaW5lci5yZWdpc3RlcihMb2dnZXJDb25maWd1cmF0aW9uLmNyZWF0ZSh7JGNvbnNvbGU6IGNvbnNvbGV9KSlcbiAqXG4gKiBjb250YWluZXIucmVnaXN0ZXIoTG9nZ2VyQ29uZmlndXJhdGlvbi5jcmVhdGUoeyRjb25zb2xlOiBjb25zb2xlLCBsZXZlbDogTG9nTGV2ZWwuZGVidWd9KSlcbiAqXG4gKiBjb250YWluZXIucmVnaXN0ZXIoTG9nZ2VyQ29uZmlndXJhdGlvbi5jcmVhdGUoe1xuICogICRjb25zb2xlOiB7XG4gKiAgICAgZGVidWc6IG5vb3AsXG4gKiAgICAgaW5mbzogbm9vcCxcbiAqICAgICB3YXJuOiBub29wLFxuICogICAgIGVycm9yOiBtc2cgPT4ge1xuICogICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gKiAgICAgfVxuICogIH0sXG4gKiAgbGV2ZWw6IExvZ0xldmVsLmRlYnVnXG4gKiB9KSlcbiAqXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IExvZ2dlckNvbmZpZ3VyYXRpb24gPSB0b0xvb2t1cCh7XG4gICAgLyoqXG4gICAgICogQHBhcmFtICRjb25zb2xlIC0gVGhlIGBjb25zb2xlYCBvYmplY3QgdG8gdXNlLiBDYW4gYmUgdGhlIG5hdGl2ZSBgd2luZG93LmNvbnNvbGVgIC8gYGdsb2JhbC5jb25zb2xlYCwgYnV0IGNhbiBhbHNvIGJlIGEgd3JhcHBlciBvciBtb2NrIHRoYXQgaW1wbGVtZW50cyB0aGUgc2FtZSBpbnRlcmZhY2UuXG4gICAgICogQHBhcmFtIGxldmVsIC0gVGhlIGdsb2JhbCBgTG9nTGV2ZWxgIHRvIGNvbmZpZ3VyZS4gRGVmYXVsdHMgdG8gYHdhcm5gIG9yIGhpZ2hlci5cbiAgICAgKiBAcGFyYW0gY29sb3JPcHRpb25zIC0gV2hldGhlciB0byB1c2UgY29sb3JzIG9yIG5vdC4gRGVmYXVsdHMgdG8gYG5vQ29sb3JzYC4gQ29sb3JzIGFyZSBlc3BlY2lhbGx5IG5pY2UgaW4gbm9kZWpzIGVudmlyb25tZW50cyBidXQgZG9uJ3QgbmVjZXNzYXJpbHkgd29yayAod2VsbCkgaW4gYWxsIGVudmlyb25tZW50cywgc3VjaCBhcyBicm93c2Vycy5cbiAgICAgKi9cbiAgICBjcmVhdGUoeyAkY29uc29sZSwgbGV2ZWwgPSAzIC8qIHdhcm4gKi8sIGNvbG9yT3B0aW9ucyA9IDAgLyogbm9Db2xvcnMgKi8sIHNpbmtzID0gW10sIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gdG9Mb29rdXAoe1xuICAgICAgICAgICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShJTG9nQ29uZmlnLCBuZXcgTG9nQ29uZmlnKGNvbG9yT3B0aW9ucywgbGV2ZWwpKSk7XG4gICAgICAgICAgICAgICAgaWYgKCRjb25zb2xlICE9PSB2b2lkIDAgJiYgJGNvbnNvbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShJU2luaywgbmV3IENvbnNvbGVTaW5rKCRjb25zb2xlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0ICRzaW5rIG9mIHNpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlcihSZWdpc3RyYXRpb24uc2luZ2xldG9uKElTaW5rLCAkc2luaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnLi9kaS5qcyc7XG5pbXBvcnQgeyBlbXB0eUFycmF5IH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBQcm90b2NvbCB9IGZyb20gJy4vcmVzb3VyY2UuanMnO1xuZXhwb3J0IGNvbnN0IElNb2R1bGVMb2FkZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoeCA9PiB4LnNpbmdsZXRvbihNb2R1bGVMb2FkZXIpKTtcbmZ1bmN0aW9uIG5vVHJhbnNmb3JtKG0pIHtcbiAgICByZXR1cm4gbTtcbn1cbmNsYXNzIE1vZHVsZVRyYW5zZm9ybWVyIHtcbiAgICBjb25zdHJ1Y3RvcigkdHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuJHRyYW5zZm9ybSA9ICR0cmFuc2Zvcm07XG4gICAgICAgIHRoaXMucHJvbWlzZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9iamVjdENhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0ob2JqT3JQcm9taXNlKSB7XG4gICAgICAgIGlmIChvYmpPclByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Qcm9taXNlKG9iak9yUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iak9yUHJvbWlzZSA9PT0gJ29iamVjdCcgJiYgb2JqT3JQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1PYmplY3Qob2JqT3JQcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnB1dDogJHtTdHJpbmcob2JqT3JQcm9taXNlKX0uIEV4cGVjdGVkIFByb21pc2Ugb3IgT2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybVByb21pc2UocHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlQ2FjaGUuaGFzKHByb21pc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlQ2FjaGUuZ2V0KHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHByb21pc2UudGhlbihvYmogPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtT2JqZWN0KG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21pc2VDYWNoZS5zZXQocHJvbWlzZSwgcmV0KTtcbiAgICAgICAgdm9pZCByZXQudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAvLyBtYWtlIGl0IHN5bmNocm9ub3VzIGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZUNhY2hlLnNldChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB0cmFuc2Zvcm1PYmplY3Qob2JqKSB7XG4gICAgICAgIGlmICh0aGlzLm9iamVjdENhY2hlLmhhcyhvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RDYWNoZS5nZXQob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzLiR0cmFuc2Zvcm0odGhpcy5hbmFseXplKG9iaikpO1xuICAgICAgICB0aGlzLm9iamVjdENhY2hlLnNldChvYmosIHJldCk7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB2b2lkIHJldC50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIGl0IHN5bmNocm9ub3VzIGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdENhY2hlLnNldChvYmosIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGFuYWx5emUobSkge1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGxldCBpc1JlZ2lzdHJ5O1xuICAgICAgICBsZXQgaXNDb25zdHJ1Y3RhYmxlO1xuICAgICAgICBsZXQgZGVmaW5pdGlvbnM7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG0pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSA9IG1ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzUmVnaXN0cnkgPSB0eXBlb2YgdmFsdWUucmVnaXN0ZXIgPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIGlzQ29uc3RydWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9ucyA9IGVtcHR5QXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgaXNSZWdpc3RyeSA9IHR5cGVvZiB2YWx1ZS5yZWdpc3RlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICAgICAgaXNDb25zdHJ1Y3RhYmxlID0gdmFsdWUucHJvdG90eXBlICE9PSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zID0gUHJvdG9jb2wucmVzb3VyY2UuZ2V0QWxsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5wdXNoKG5ldyBNb2R1bGVJdGVtKGtleSwgdmFsdWUsIGlzUmVnaXN0cnksIGlzQ29uc3RydWN0YWJsZSwgZGVmaW5pdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFuYWx5emVkTW9kdWxlKG0sIGl0ZW1zKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTW9kdWxlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGxvYWQob2JqT3JQcm9taXNlLCB0cmFuc2Zvcm0gPSBub1RyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lcnMgPSB0aGlzLnRyYW5zZm9ybWVycztcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXJzLmdldCh0cmFuc2Zvcm0pO1xuICAgICAgICBpZiAodHJhbnNmb3JtZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZXJzLnNldCh0cmFuc2Zvcm0sIHRyYW5zZm9ybWVyID0gbmV3IE1vZHVsZVRyYW5zZm9ybWVyKHRyYW5zZm9ybSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm0ob2JqT3JQcm9taXNlKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lcnMuY2xlYXIoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQW5hbHl6ZWRNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKHJhdywgaXRlbXMpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTW9kdWxlSXRlbSB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgaXNSZWdpc3RyeSwgaXNDb25zdHJ1Y3RhYmxlLCBkZWZpbml0aW9ucykge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlzUmVnaXN0cnkgPSBpc1JlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmlzQ29uc3RydWN0YWJsZSA9IGlzQ29uc3RydWN0YWJsZTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS1sb2FkZXIuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmV4cG9ydCBjb25zdCBlbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5leHBvcnQgY29uc3QgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkgeyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS5qcy5tYXAiLCJpbXBvcnQgeyBNZXRhZGF0YSB9IGZyb20gJ0BhdXJlbGlhL21ldGFkYXRhJztcbmltcG9ydCB7IGVtcHR5QXJyYXkgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmNvbnN0IGFubm90YXRpb24gPSB7XG4gICAgbmFtZTogJ2F1OmFubm90YXRpb24nLFxuICAgIGFwcGVuZFRvKHRhcmdldCwga2V5KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBNZXRhZGF0YS5nZXRPd24oYW5ub3RhdGlvbi5uYW1lLCB0YXJnZXQpO1xuICAgICAgICBpZiAoa2V5cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoYW5ub3RhdGlvbi5uYW1lLCBba2V5XSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIHZhbHVlLCB0YXJnZXQpO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKGFubm90YXRpb24ua2V5Rm9yKHByb3ApLCB0YXJnZXQpO1xuICAgIH0sXG4gICAgZ2V0S2V5cyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IGtleXMgPSBNZXRhZGF0YS5nZXRPd24oYW5ub3RhdGlvbi5uYW1lLCB0YXJnZXQpO1xuICAgICAgICBpZiAoa2V5cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoYW5ub3RhdGlvbi5uYW1lLCBrZXlzID0gW10sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSxcbiAgICBpc0tleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKGFubm90YXRpb24ubmFtZSk7XG4gICAgfSxcbiAgICBrZXlGb3IobmFtZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YW5ub3RhdGlvbi5uYW1lfToke25hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7YW5ub3RhdGlvbi5uYW1lfToke25hbWV9OiR7Y29udGV4dH1gO1xuICAgIH0sXG59O1xuY29uc3QgcmVzb3VyY2UgPSB7XG4gICAgbmFtZTogJ2F1OnJlc291cmNlJyxcbiAgICBhcHBlbmRUbyh0YXJnZXQsIGtleSkge1xuICAgICAgICBjb25zdCBrZXlzID0gTWV0YWRhdGEuZ2V0T3duKHJlc291cmNlLm5hbWUsIHRhcmdldCk7XG4gICAgICAgIGlmIChrZXlzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShyZXNvdXJjZS5uYW1lLCBba2V5XSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYXModGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5oYXNPd24ocmVzb3VyY2UubmFtZSwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIGdldEFsbCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE1ldGFkYXRhLmdldE93bihyZXNvdXJjZS5uYW1lLCB0YXJnZXQpO1xuICAgICAgICBpZiAoa2V5cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLm1hcChrID0+IE1ldGFkYXRhLmdldE93bihrLCB0YXJnZXQpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0S2V5cyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IGtleXMgPSBNZXRhZGF0YS5nZXRPd24ocmVzb3VyY2UubmFtZSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKHJlc291cmNlLm5hbWUsIGtleXMgPSBbXSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9LFxuICAgIGlzS2V5KGtleSkge1xuICAgICAgICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgocmVzb3VyY2UubmFtZSk7XG4gICAgfSxcbiAgICBrZXlGb3IobmFtZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2UubmFtZX06JHtuYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3Jlc291cmNlLm5hbWV9OiR7bmFtZX06JHtjb250ZXh0fWA7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgUHJvdG9jb2wgPSB7XG4gICAgYW5ub3RhdGlvbixcbiAgICByZXNvdXJjZSxcbn07XG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqXG4gKiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIHZhbHVlcyBhcmUgY2hlY2tlZDpcbiAqIDEuIEFubm90YXRpb25zICh1c3VhbGx5IHNldCBieSBkZWNvcmF0b3JzKSBoYXZlIHRoZSBoaWdoZXN0IHByaW9yaXR5OyB0aGV5IG92ZXJyaWRlIHRoZSBkZWZpbml0aW9uIGFzIHdlbGwgYXMgc3RhdGljIHByb3BlcnRpZXMgb24gdGhlIHR5cGUuXG4gKiAyLiBEZWZpbml0aW9uIHByb3BlcnRpZXMgKHVzdWFsbHkgc2V0IGJ5IHRoZSBjdXN0b21FbGVtZW50IGRlY29yYXRvciBvYmplY3QgbGl0ZXJhbCkgY29tZSBuZXh0LiBUaGV5IG92ZXJyaWRlIHN0YXRpYyBwcm9wZXJ0aWVzIG9uIHRoZSB0eXBlLlxuICogMy4gU3RhdGljIHByb3BlcnRpZXMgb24gdGhlIHR5cGUgY29tZSBsYXN0LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBsb29rIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gKGJpbmRhYmxlcyBhcmUgYW4gZXhjZXB0aW9uIGhlcmUsIGJ1dCB3ZSBkbyB0aGF0IGRpZmZlcmVudGx5IGFueXdheSlcbiAqIDQuIFRoZSBkZWZhdWx0IHByb3BlcnR5IHRoYXQgaXMgcHJvdmlkZWQgbGFzdC4gVGhlIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoZSBkZWZhdWx0IHByb3BlcnR5IGlzIG5lZWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQobmFtZSwgZGVmLCBUeXBlLCBnZXREZWZhdWx0KSB7XG4gICAgbGV0IHZhbHVlID0gTWV0YWRhdGEuZ2V0T3duKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKG5hbWUpLCBUeXBlKTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICB2YWx1ZSA9IGRlZltuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gVHlwZVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8ICFoYXNPd24uY2FsbChUeXBlLCBuYW1lKSkgeyAvLyBGaXJzdCBqdXN0IGNoZWNrIHRoZSB2YWx1ZSAoY29tbW9uIGNhc2UgaXMgZmFzdGVyKSwgYnV0IGRvIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGNvbWUgZnJvbSB0aGUgcHJvdG8gY2hhaW5cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIHZhbHVlcyBhcmUgY2hlY2tlZDpcbiAqIDEuIEFubm90YXRpb25zICh1c3VhbGx5IHNldCBieSBkZWNvcmF0b3JzKSBoYXZlIHRoZSBoaWdoZXN0IHByaW9yaXR5OyB0aGV5IG92ZXJyaWRlIHN0YXRpYyBwcm9wZXJ0aWVzIG9uIHRoZSB0eXBlLlxuICogMi4gU3RhdGljIHByb3BlcnRpZXMgb24gdGhlIHR5cC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgbG9vayB1cCB0aGUgcHJvdG90eXBlIGNoYWluIChiaW5kYWJsZXMgYXJlIGFuIGV4Y2VwdGlvbiBoZXJlLCBidXQgd2UgZG8gdGhhdCBkaWZmZXJlbnRseSBhbnl3YXkpXG4gKiAzLiBUaGUgZGVmYXVsdCBwcm9wZXJ0eSB0aGF0IGlzIHByb3ZpZGVkIGxhc3QuIFRoZSBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGUgZGVmYXVsdCBwcm9wZXJ0eSBpcyBuZWVkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KG5hbWUsIFR5cGUsIGdldERlZmF1bHQpIHtcbiAgICBsZXQgdmFsdWUgPSBNZXRhZGF0YS5nZXRPd24oUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IobmFtZSksIFR5cGUpO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhbHVlID0gVHlwZVtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgIWhhc093bi5jYWxsKFR5cGUsIG5hbWUpKSB7IC8vIEZpcnN0IGp1c3QgY2hlY2sgdGhlIHZhbHVlIChjb21tb24gY2FzZSBpcyBmYXN0ZXIpLCBidXQgZG8gbWFrZSBzdXJlIGl0IGRvZXNuJ3QgY29tZSBmcm9tIHRoZSBwcm90byBjaGFpblxuICAgICAgICAgICAgcmV0dXJuIGdldERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogVGhlIG9yZGVyIGluIHdoaWNoIHRoZSB2YWx1ZXMgYXJlIGNoZWNrZWQ6XG4gKiAxLiBEZWZpbml0aW9uIHByb3BlcnRpZXMuXG4gKiAyLiBUaGUgZGVmYXVsdCBwcm9wZXJ0eSB0aGF0IGlzIHByb3ZpZGVkIGxhc3QuIFRoZSBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGUgZGVmYXVsdCBwcm9wZXJ0eSBpcyBuZWVkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KG5hbWUsIGRlZiwgZ2V0RGVmYXVsdCkge1xuICAgIGNvbnN0IHZhbHVlID0gZGVmW25hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBnZXREZWZhdWx0KCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlLmpzLm1hcCIsIi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKlxuICogVXNlcyBgdHlwZW9mYCB0byBndWFyYW50ZWUgdGhpcyB3b3JrcyBjcm9zcy1yZWFsbSwgd2hpY2ggaXMgd2hlcmUgYGluc3RhbmNlb2YgT2JqZWN0YCBtaWdodCBmYWlsLlxuICpcbiAqIFNvbWUgZW52aXJvbm1lbnRzIHdoZXJlIHRoZXNlIGlzc3VlcyBhcmUga25vd24gdG8gYXJpc2U6XG4gKiAtIHNhbWUtb3JpZ2luIGlmcmFtZXMgKGFjY2Vzc2luZyB0aGUgb3RoZXIgcmVhbG0gdmlhIGB3aW5kb3cudG9wYClcbiAqIC0gYGplc3RgLlxuICpcbiAqIFRoZSBleGFjdCB0ZXN0IGlzOlxuICogYGBgdHNcbiAqIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqIEFsc28gcGVyZm9ybXMgYSB0eXBlIGFzc2VydGlvbiB0aGF0IGRlZmF1bHRzIHRvIGB2YWx1ZSBpcyBPYmplY3QgfCBGdW5jdGlvbmAgd2hpY2gsIGlmIHRoZSBpbnB1dCB0eXBlIGlzIGEgdW5pb24gd2l0aCBhbiBvYmplY3QgdHlwZSwgd2lsbCBpbmZlciB0aGUgY29ycmVjdCB0eXBlLlxuICogVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoIHRoZSBnZW5lcmljIHR5cGUgYXJndW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgRm9vIHtcbiAqICAgYmFyID0gNDI7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gZG9TdHVmZihpbnB1dD86IEZvbyB8IG51bGwpIHtcbiAqICAgaW5wdXQuYmFyOyAvLyBPYmplY3QgaXMgcG9zc2libHkgJ251bGwnIG9yICd1bmRlZmluZWQnXG4gKlxuICogICAvLyBpbnB1dCBoYXMgYW4gb2JqZWN0IHR5cGUgaW4gaXRzIHVuaW9uIChGb28pIHNvIHRoYXQgdHlwZSB3aWxsIGJlIGV4dHJhY3RlZCBmb3IgdGhlICd0cnVlJyBjb25kaXRpb25cbiAqICAgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICogICAgIGlucHV0LmJhcjsgLy8gT0sgKGlucHV0IGlzIG5vdyB0eXBlZCBhcyBGb28pXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBkb090aGVyU3R1ZmYoaW5wdXQ6IHVua25vd24pIHtcbiAqICAgaW5wdXQuYmFyOyAvLyBPYmplY3QgaXMgb2YgdHlwZSAndW5rbm93bidcbiAqXG4gKiAgIC8vIGlucHV0IGlzICd1bmtub3duJyBzbyB0aGVyZSBpcyBubyB1bmlvbiB0eXBlIHRvIG1hdGNoIGFuZCBpdCB3aWxsIGRlZmF1bHQgdG8gJ09iamVjdCB8IEZ1bmN0aW9uJ1xuICogICBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gKiAgICAgaW5wdXQuYmFyOyAvLyBQcm9wZXJ0eSAnYmFyJyBkb2VzIG5vdCBleGlzdCBvbiB0eXBlICdPYmplY3QgfCBGdW5jdGlvbidcbiAqICAgfVxuICpcbiAqICAgLy8gaWYgd2Uga25vdyBmb3Igc3VyZSB0aGF0LCBpZiBpbnB1dCBpcyBhbiBvYmplY3QsIGl0IG11c3QgYmUgYSBzcGVjaWZpYyB0eXBlLCB3ZSBjYW4gZXhwbGljaXRseSB0ZWxsIHRoZSBmdW5jdGlvbiB0byBhc3NlcnQgdGhhdCBmb3IgdXNcbiAqICAgaWYgKGlzT2JqZWN0PEZvbz4oaW5wdXQpKSB7XG4gKiAgICBpbnB1dC5iYXI7IC8vIE9LIChpbnB1dCBpcyBub3cgdHlwZWQgYXMgRm9vKVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKiBBbHNvIHBlcmZvcm1zIGEgdHlwZSBhc3NlcnRpb24gdGhhdCBlbnN1cmVzIFR5cGVTY3JpcHQgdHJlYXRzIHRoZSB2YWx1ZSBhcHByb3ByaWF0ZWx5IGluIHRoZSBgaWZgIGFuZCBgZWxzZWAgYnJhbmNoZXMgYWZ0ZXIgdGhpcyBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDA7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzICovXG5jb25zdCBtZXRhZGF0YUludGVybmFsU2xvdCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkdHlwZUVycm9yKG9wZXJhdGlvbiwgYXJncywgcGFyYW1OYW1lLCBhY3R1YWxWYWx1ZSwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7b3BlcmF0aW9ufSgke2FyZ3MubWFwKFN0cmluZykuam9pbignLCcpfSkgLSBFeHBlY3RlZCAnJHtwYXJhbU5hbWV9JyB0byBiZSBvZiB0eXBlICR7ZXhwZWN0ZWRUeXBlfSwgYnV0IGdvdDogJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYWN0dWFsVmFsdWUpfSAoJHtTdHJpbmcoYWN0dWFsVmFsdWUpfSlgKTtcbn1cbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlLZXk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJvcGVydHlLZXl9YDtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUtleTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBgJHtwcm9wZXJ0eUtleX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVByb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wZXJ0eUtleSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5S2V5O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtZXRhZGF0YSBwcm9wZXJ0eUtleTogJHtwcm9wZXJ0eUtleX0uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBDcmVhdGUpIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgdGFyZ2V0TWV0YWRhdGEgYmUgdGhlIHZhbHVlIG9mIE8ncyBbW01ldGFkYXRhXV0gaW50ZXJuYWwgc2xvdC5cbiAgICBsZXQgdGFyZ2V0TWV0YWRhdGEgPSBtZXRhZGF0YUludGVybmFsU2xvdC5nZXQoTyk7XG4gICAgLy8gMy4gSWYgdGFyZ2V0TWV0YWRhdGEgaXMgdW5kZWZpbmVkLCB0aGVuXG4gICAgaWYgKHRhcmdldE1ldGFkYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgLy8gMy4gYS4gSWYgQ3JlYXRlIGlzIGZhbHNlLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICBpZiAoIUNyZWF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBiLiBTZXQgdGFyZ2V0TWV0YWRhdGEgdG8gYmUgYSBuZXdseSBjcmVhdGVkIE1hcCBvYmplY3QuXG4gICAgICAgIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAzLiBjLiBTZXQgdGhlIFtbTWV0YWRhdGFdXSBpbnRlcm5hbCBzbG90IG9mIE8gdG8gdGFyZ2V0TWV0YWRhdGEuXG4gICAgICAgIG1ldGFkYXRhSW50ZXJuYWxTbG90LnNldChPLCB0YXJnZXRNZXRhZGF0YSk7XG4gICAgfVxuICAgIC8vIDQuIExldCBtZXRhZGF0YU1hcCBiZSA/IEludm9rZSh0YXJnZXRNZXRhZGF0YSwgXCJnZXRcIiwgUCkuXG4gICAgbGV0IG1ldGFkYXRhTWFwID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KFApO1xuICAgIC8vIDUuIElmIG1ldGFkYXRhTWFwIGlzIHVuZGVmaW5lZCwgdGhlblxuICAgIGlmIChtZXRhZGF0YU1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIC8vIDUuIGEuIElmIENyZWF0ZSBpcyBmYWxzZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKCFDcmVhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gYi4gU2V0IG1ldGFkYXRhTWFwIHRvIGJlIGEgbmV3bHkgY3JlYXRlZCBNYXAgb2JqZWN0LlxuICAgICAgICBtZXRhZGF0YU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gNS4gYy4gUGVyZm9ybSA/IEludm9rZSh0YXJnZXRNZXRhZGF0YSwgXCJzZXRcIiwgUCwgbWV0YWRhdGFNYXApLlxuICAgICAgICB0YXJnZXRNZXRhZGF0YS5zZXQoUCwgbWV0YWRhdGFNYXApO1xuICAgIH1cbiAgICAvLyA2LiBSZXR1cm4gbWV0YWRhdGFNYXAuXG4gICAgcmV0dXJuIG1ldGFkYXRhTWFwO1xufVxuLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNvd25tZXRhZGF0YVxuZnVuY3Rpb24gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgIC8vIDEuIEFzc2VydDogUCBpcyB1bmRlZmluZWQgb3IgSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICAgIC8vIDIuIExldCBtZXRhZGF0YU1hcCBiZSA/IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpLlxuICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKiBDcmVhdGUgKi8gZmFsc2UpO1xuICAgIC8vIDMuIElmIG1ldGFkYXRhTWFwIGlzIHVuZGVmaW5lZCwgcmV0dXJuIGZhbHNlLlxuICAgIGlmIChtZXRhZGF0YU1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gNC4gUmV0dXJuID8gVG9Cb29sZWFuKD8gSW52b2tlKG1ldGFkYXRhTWFwLCBcImhhc1wiLCBNZXRhZGF0YUtleSkpLlxuICAgIHJldHVybiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufVxuLy8gMy4xLjEuMSBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNtZXRhZGF0YVxuZnVuY3Rpb24gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgIC8vIDEuIEFzc2VydDogUCBpcyB1bmRlZmluZWQgb3IgSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICAgIC8vIDIuIExldCBoYXNPd24gYmUgPyBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKS5cbiAgICAvLyAzLiBJZiBoYXNPd24gaXMgdHJ1ZSwgcmV0dXJuIHRydWUuXG4gICAgaWYgKE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyA0LiBMZXQgcGFyZW50IGJlID8gTy5bW0dldFByb3RvdHlwZU9mXV0oKS5cbiAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XG4gICAgLy8gNS4gSWYgcGFyZW50IGlzIG5vdCBudWxsLCBSZXR1cm4gPyBwYXJlbnQuW1tIYXNNZXRhZGF0YV1dKE1ldGFkYXRhS2V5LCBQKS5cbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xuICAgIH1cbiAgICAvLyA2LiBSZXR1cm4gZmFsc2UuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMy4xLjQuMSBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlnZXRvd25tZXRhZGF0YVxuZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgIC8vIDEuIEFzc2VydDogUCBpcyB1bmRlZmluZWQgb3IgSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICAgIC8vIDIuIExldCBtZXRhZGF0YU1hcCBiZSA/IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpLlxuICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKiBDcmVhdGUgKi8gZmFsc2UpO1xuICAgIC8vIDMuIElmIG1ldGFkYXRhTWFwIGlzIHVuZGVmaW5lZCwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICBpZiAobWV0YWRhdGFNYXAgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICAvLyA0LiBSZXR1cm4gPyBJbnZva2UobWV0YWRhdGFNYXAsIFwiZ2V0XCIsIE1ldGFkYXRhS2V5KS5cbiAgICByZXR1cm4gbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn1cbi8vIDMuMS4zLjEgT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcbi8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0bWV0YWRhdGFcbmZ1bmN0aW9uIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgaGFzT3duIGJlID8gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkuXG4gICAgLy8gMy4gSWYgaGFzT3duIGlzIHRydWUsIHJldHVybiA/IE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApLlxuICAgIGlmIChPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSkge1xuICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gICAgfVxuICAgIC8vIDQuIExldCBwYXJlbnQgYmUgPyBPLltbR2V0UHJvdG90eXBlT2ZdXSgpLlxuICAgIGNvbnN0IHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKTtcbiAgICAvLyA1LiBJZiBwYXJlbnQgaXMgbm90IG51bGwsIHJldHVybiA/IHBhcmVudC5bW0dldE1ldGFkYXRhXV0oTWV0YWRhdGFLZXksIFApLlxuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCk7XG4gICAgfVxuICAgIC8vIDYuIFJldHVybiB1bmRlZmluZWQuXG4gICAgcmV0dXJuIHZvaWQgMDtcbn1cbi8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcbi8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5ZGVmaW5lb3dubWV0YWRhdGFcbmZ1bmN0aW9uIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcbiAgICAvLyAxLiBBc3NlcnQ6IFAgaXMgdW5kZWZpbmVkIG9yIElzUHJvcGVydHlLZXkoUCkgaXMgdHJ1ZS5cbiAgICAvLyAyLiBMZXQgbWV0YWRhdGFNYXAgYmUgPyBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLlxuICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKiBDcmVhdGUgKi8gdHJ1ZSk7XG4gICAgLy8gMy4gUmV0dXJuID8gSW52b2tlKG1ldGFkYXRhTWFwLCBcInNldFwiLCBNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSkuXG4gICAgbWV0YWRhdGFNYXAuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn1cbi8vIDMuMS43LjEgT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUClcbi8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5b3dubWV0YWRhdGFrZXlzXG5mdW5jdGlvbiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKSB7XG4gICAgLy8gMS4gQXNzZXJ0OiBQIGlzIHVuZGVmaW5lZCBvciBJc1Byb3BlcnR5S2V5KFApIGlzIHRydWUuXG4gICAgLy8gMi4gTGV0IGtleXMgYmUgPyBBcnJheUNyZWF0ZSgwKS5cbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgLy8gMy4gTGV0IG1ldGFkYXRhTWFwIGJlID8gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSkuXG4gICAgY29uc3QgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIC8qIENyZWF0ZSAqLyBmYWxzZSk7XG4gICAgLy8gNC4gSWYgbWV0YWRhdGFNYXAgaXMgdW5kZWZpbmVkLCByZXR1cm4ga2V5cy5cbiAgICBpZiAobWV0YWRhdGFNYXAgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgLy8gNS4gTGV0IGtleXNPYmogYmUgPyBJbnZva2UobWV0YWRhdGFNYXAsIFwia2V5c1wiKS5cbiAgICBjb25zdCBrZXlzT2JqID0gbWV0YWRhdGFNYXAua2V5cygpO1xuICAgIC8vIDYuIExldCBpdGVyYXRvciBiZSA/IEdldEl0ZXJhdG9yKGtleXNPYmopLlxuICAgIC8vIDcuIExldCBrIGJlIDAuXG4gICAgbGV0IGsgPSAwO1xuICAgIC8vIDguIFJlcGVhdFxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNPYmopIHtcbiAgICAgICAgLy8gOC4gYS4gTGV0IFBrIGJlICEgVG9TdHJpbmcoaykuXG4gICAgICAgIC8vIDguIGIuIExldCBuZXh0IGJlID8gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKS5cbiAgICAgICAgLy8gOC4gYy4gSWYgbmV4dCBpcyBmYWxzZSwgdGhlblxuICAgICAgICAvLyA4LiBjLiBpLiBMZXQgc2V0U3RhdHVzIGJlID8gU2V0KGtleXMsIFwibGVuZ3RoXCIsIGssIHRydWUpLlxuICAgICAgICAvLyA4LiBjLiBpaS4gQXNzZXJ0OiBzZXRTdGF0dXMgaXMgdHJ1ZS5cbiAgICAgICAgLy8gOC4gYy4gaWlpLiBSZXR1cm4ga2V5cy5cbiAgICAgICAgLy8gOC4gZC4gTGV0IG5leHRWYWx1ZSBiZSA/IEl0ZXJhdG9yVmFsdWUobmV4dCkuXG4gICAgICAgIC8vIDguIGUuIExldCBkZWZpbmVTdGF0dXMgYmUgQ3JlYXRlRGF0YVByb3BlcnR5T3JUaHJvdyhrZXlzLCBQaywgbmV4dFZhbHVlKS5cbiAgICAgICAga2V5c1trXSA9IGtleTtcbiAgICAgICAgLy8gOC4gZi4gSWYgZGVmaW5lU3RhdHVzIGlzIGFuIGFicnVwdCBjb21wbGV0aW9uLCByZXR1cm4gPyBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBkZWZpbmVTdGF0dXMpLlxuICAgICAgICAvLyA4LiBnLiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICAgICsraztcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vLyAzLjEuNi4xIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApXG4vLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW1ldGFkYXRha2V5c1xuZnVuY3Rpb24gT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUCkge1xuICAgIC8vIDEuIEFzc2VydDogUCBpcyB1bmRlZmluZWQgb3IgSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICAgIC8vIDIuIExldCBvd25LZXlzIGJlID8gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCkuXG4gICAgY29uc3Qgb3duS2V5cyA9IE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICAgIC8vIDMuIExldCBwYXJlbnQgYmUgPyBPLltbR2V0UHJvdG90eXBlT2ZdXSgpLlxuICAgIGNvbnN0IHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKTtcbiAgICAvLyA0LiBJZiBwYXJlbnQgaXMgbnVsbCwgdGhlbiByZXR1cm4gb3duS2V5cy5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvd25LZXlzO1xuICAgIH1cbiAgICAvLyA1LiBMZXQgcGFyZW50S2V5cyBiZSA/IE8uW1tPcmRpbmFyeU1ldGFkYXRhS2V5c11dKFApLlxuICAgIGNvbnN0IHBhcmVudEtleXMgPSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICAgIC8vIDYuIExldCBvd25LZXlzTGVuID0gPyBHZXQob3duS2V5cywgXCJsZW5ndGhcIikuXG4gICAgY29uc3Qgb3duS2V5c0xlbiA9IG93bktleXMubGVuZ3RoO1xuICAgIC8vIDcuIElmIG93bktleXNMZW4gaXMgMCwgcmV0dXJuIHBhcmVudEtleXMuXG4gICAgaWYgKG93bktleXNMZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudEtleXM7XG4gICAgfVxuICAgIC8vIDguIExldCBwYXJlbnRLZXlzTGVuID0gPyBHZXQocGFyZW50S2V5cywgXCJsZW5ndGhcIikuXG4gICAgY29uc3QgcGFyZW50S2V5c0xlbiA9IHBhcmVudEtleXMubGVuZ3RoO1xuICAgIC8vIDkuIElmIHBhcmVudEtleXNMZW4gaXMgMCwgcmV0dXJuIG93bktleXMuXG4gICAgaWYgKHBhcmVudEtleXNMZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG93bktleXM7XG4gICAgfVxuICAgIC8vIDEwLiBMZXQgc2V0IGJlIGEgbmV3bHkgY3JlYXRlZCBTZXQgb2JqZWN0LlxuICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgICAvLyAxMS4gTGV0IGtleXMgYmUgPyBBcnJheUNyZWF0ZSgwKS5cbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgLy8gMTIuIExldCBrIGJlIDAuXG4gICAgbGV0IGsgPSAwO1xuICAgIC8vIDEzLiBGb3IgZWFjaCBlbGVtZW50IGtleSBvZiBvd25LZXlzXG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG93bktleXNMZW47ICsraSkge1xuICAgICAgICBrZXkgPSBvd25LZXlzW2ldO1xuICAgICAgICAvLyAxMy4gYS4gTGV0IGhhc0tleSBiZSA/IEludm9rZShzZXQsIFwiaGFzXCIsIGtleSkuXG4gICAgICAgIC8vIDEzLiBiLiBJZiBoYXNLZXkgaXMgZmFsc2UsIHRoZW5cbiAgICAgICAgaWYgKCFzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIDEzLiBiLiBpLiBMZXQgUGsgYmUgISBUb1N0cmluZyhrKS5cbiAgICAgICAgICAgIC8vIDEzLiBiLiBpaS4gUGVyZm9ybSA/IEludm9rZShzZXQsIFwiYWRkXCIsIGtleSkuXG4gICAgICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICAgICAgICAvLyAxMy4gYi4gaWlpLiBMZXQgZGVmaW5lU3RhdHVzIGJlIENyZWF0ZURhdGFQcm9wZXJ0eShrZXlzLCBQaywga2V5KS5cbiAgICAgICAgICAgIC8vIDEzLiBiLiBpdi4gQXNzZXJ0OiBkZWZpbmVTdGF0dXMgaXMgdHJ1ZS5cbiAgICAgICAgICAgIGtleXNba10gPSBrZXk7XG4gICAgICAgICAgICAvLyAxMy4gYi4gdi4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgKytrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDE0LiBGb3IgZWFjaCBlbGVtZW50IGtleSBvZiBwYXJlbnRLZXlzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRLZXlzTGVuOyArK2kpIHtcbiAgICAgICAga2V5ID0gcGFyZW50S2V5c1tpXTtcbiAgICAgICAgLy8gMTQuIGEuIExldCBoYXNLZXkgYmUgPyBJbnZva2Uoc2V0LCBcImhhc1wiLCBrZXkpLlxuICAgICAgICAvLyAxNC4gYi4gSWYgaGFzS2V5IGlzIGZhbHNlLCB0aGVuXG4gICAgICAgIGlmICghc2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyAxNC4gYi4gaS4gTGV0IFBrIGJlICEgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAvLyAxNC4gYi4gaWkuIFBlcmZvcm0gPyBJbnZva2Uoc2V0LCBcImFkZFwiLCBrZXkpLlxuICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgICAgICAgLy8gMTQuIGIuIGlpaS4gTGV0IGRlZmluZVN0YXR1cyBiZSBDcmVhdGVEYXRhUHJvcGVydHkoa2V5cywgUGssIGtleSkuXG4gICAgICAgICAgICAvLyAxNC4gYi4gaXYuIEFzc2VydDogZGVmaW5lU3RhdHVzIGlzIHRydWUuXG4gICAgICAgICAgICBrZXlzW2tdID0ga2V5O1xuICAgICAgICAgICAgLy8gMTQuIGIuIHYuIEluY3JlYXNlIGsgYnkgMS5cbiAgICAgICAgICAgICsraztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAxNS4gUGVyZm9ybSA/IFNldChrZXlzLCBcImxlbmd0aFwiLCBrKS5cbiAgICAvLyAxNi4gcmV0dXJuIGtleXMuXG4gICAgcmV0dXJuIGtleXM7XG59XG4vLyAzLjEuOCBEZWxldGVNZXRhZGF0YShNZXRhZGF0YUtleSwgUClcbi8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5LW9iamVjdC1pbnRlcm5hbC1tZXRob2RzLWFuZC1pbnRlcm5hbC1zbG90cy1kZWxldGVtZXRhZGF0YVxuZnVuY3Rpb24gT3JkaW5hcnlEZWxldGVNZXRhZGF0YShPLCBNZXRhZGF0YUtleSwgUCkge1xuICAgIC8vIDEuIEFzc2VydDogUCBpcyB1bmRlZmluZWQgb3IgSXNQcm9wZXJ0eUtleShQKSBpcyB0cnVlLlxuICAgIC8vIDIuIExldCBtZXRhZGF0YU1hcCBiZSA/IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpLlxuICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gICAgLy8gMy4gSWYgbWV0YWRhdGFNYXAgaXMgdW5kZWZpbmVkLCByZXR1cm4gZmFsc2UuXG4gICAgaWYgKG1ldGFkYXRhTWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyA0LiBSZXR1cm4gPyBJbnZva2UobWV0YWRhdGFNYXAsIFwiZGVsZXRlXCIsIE1ldGFkYXRhS2V5KS5cbiAgICByZXR1cm4gbWV0YWRhdGFNYXAuZGVsZXRlKE1ldGFkYXRhS2V5KTtcbn1cbi8vIDQuMS4yIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpXG4vLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNyZWZsZWN0Lm1ldGFkYXRhXG4vKipcbiAqIEEgZGVmYXVsdCBtZXRhZGF0YSBkZWNvcmF0b3IgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIG9uIGEgY2xhc3MsIGNsYXNzIG1lbWJlciwgb3IgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSBtZXRhZGF0YUtleSAtIFRoZSBrZXkgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cbiAqIElmIGBtZXRhZGF0YUtleWAgaXMgYWxyZWFkeSBkZWZpbmVkIGZvciB0aGUgdGFyZ2V0IGFuZCB0YXJnZXQga2V5LCB0aGVcbiAqIG1ldGFkYXRhVmFsdWUgZm9yIHRoYXQga2V5IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gKiBAcGFyYW0gbWV0YWRhdGFWYWx1ZSAtIFRoZSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxuICogQHJldHVybnMgQSBkZWNvcmF0b3IgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICAgIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIC8vIDEuIEFzc2VydDogRiBoYXMgYSBbW01ldGFkYXRhS2V5XV0gaW50ZXJuYWwgc2xvdCB3aG9zZSB2YWx1ZSBpcyBhbiBFQ01BU2NyaXB0IGxhbmd1YWdlIHZhbHVlLCBvciB1bmRlZmluZWQuXG4gICAgICAgIC8vIDIuIEFzc2VydDogRiBoYXMgYSBbW01ldGFkYXRhVmFsdWVdXSBpbnRlcm5hbCBzbG90IHdob3NlIHZhbHVlIGlzIGFuIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdmFsdWUsIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgLy8gMy4gSWYgVHlwZSh0YXJnZXQpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdAbWV0YWRhdGEnLCBbbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXldLCAndGFyZ2V0JywgdGFyZ2V0LCAnT2JqZWN0IG9yIEZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNC4gSWYga2V5IGlzIG5vdCB1bmRlZmluZWQgYW5kIElzUHJvcGVydHlLZXkoa2V5KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAvLyA1LiBMZXQgbWV0YWRhdGFLZXkgYmUgdGhlIHZhbHVlIG9mIEYncyBbW01ldGFkYXRhS2V5XV0gaW50ZXJuYWwgc2xvdC5cbiAgICAgICAgLy8gNi4gTGV0IG1ldGFkYXRhVmFsdWUgYmUgdGhlIHZhbHVlIG9mIEYncyBbW01ldGFkYXRhVmFsdWVdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgICAvLyA3LiBQZXJmb3JtID8gdGFyZ2V0LltbRGVmaW5lTWV0YWRhdGFdXShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCBrZXkpLlxuICAgICAgICBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIGVuc3VyZVByb3BlcnR5S2V5T3JVbmRlZmluZWQocHJvcGVydHlLZXkpKTtcbiAgICAgICAgLy8gOC4gUmV0dXJuIHVuZGVmaW5lZC5cbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRvcjtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAocHJvcGVydHlLZXkgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVjb3JhdG9ycykpIHtcbiAgICAgICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmRlY29yYXRlJywgW2RlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXNdLCAnZGVjb3JhdG9ycycsIGRlY29yYXRvcnMsICdBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignTWV0YWRhdGEuZGVjb3JhdGUnLCBbZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlc10sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpICYmICFpc051bGxPclVuZGVmaW5lZChhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignTWV0YWRhdGEuZGVjb3JhdGUnLCBbZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlc10sICdhdHRyaWJ1dGVzJywgYXR0cmlidXRlcywgJ09iamVjdCwgRnVuY3Rpb24sIG51bGwsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgIHJldHVybiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRlY29yYXRvcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyAkdHlwZUVycm9yKCdNZXRhZGF0YS5kZWNvcmF0ZScsIFtkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzXSwgJ2RlY29yYXRvcnMnLCBkZWNvcmF0b3JzLCAnQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignTWV0YWRhdGEuZGVjb3JhdGUnLCBbZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlc10sICd0YXJnZXQnLCB0YXJnZXQsICdGdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCk7XG4gICAgfVxufVxuZnVuY3Rpb24gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xuICAgICAgICBjb25zdCBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChkZWNvcmF0ZWQpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlY29yYXRlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ0RlY29yYXRlQ29uc3RydWN0b3InLCBbZGVjb3JhdG9ycywgdGFyZ2V0XSwgJ2RlY29yYXRlZCcsIGRlY29yYXRlZCwgJ0Z1bmN0aW9uLCBudWxsLCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldCA9IGRlY29yYXRlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gRGVjb3JhdGVQcm9wZXJ0eShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgZm9yIChsZXQgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXTtcbiAgICAgICAgY29uc3QgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRlY29yYXRlZCkpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoZGVjb3JhdGVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ0RlY29yYXRlUHJvcGVydHknLCBbZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcl0sICdkZWNvcmF0ZWQnLCBkZWNvcmF0ZWQsICdPYmplY3QsIEZ1bmN0aW9uLCBudWxsLCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBkZWNvcmF0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5mdW5jdGlvbiAkZGVmaW5lKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgLy8gMS4gSWYgVHlwZSh0YXJnZXQpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignTWV0YWRhdGEuZGVmaW5lJywgW21ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5XSwgJ3RhcmdldCcsIHRhcmdldCwgJ09iamVjdCBvciBGdW5jdGlvbicpO1xuICAgIH1cbiAgICAvLyAyLiBSZXR1cm4gPyB0YXJnZXQuW1tEZWZpbmVNZXRhZGF0YV1dKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBwcm9wZXJ0eUtleSkuXG4gICAgcmV0dXJuIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdG9Qcm9wZXJ0eUtleU9yVW5kZWZpbmVkKHByb3BlcnR5S2V5KSk7XG59XG5mdW5jdGlvbiAkaGFzKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgLy8gMS4gSWYgVHlwZSh0YXJnZXQpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignTWV0YWRhdGEuaGFzJywgW21ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5XSwgJ3RhcmdldCcsIHRhcmdldCwgJ09iamVjdCBvciBGdW5jdGlvbicpO1xuICAgIH1cbiAgICAvLyAyLiBSZXR1cm4gPyB0YXJnZXQuW1tIYXNNZXRhZGF0YV1dKG1ldGFkYXRhS2V5LCBwcm9wZXJ0eUtleSkuXG4gICAgcmV0dXJuIE9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgdG9Qcm9wZXJ0eUtleU9yVW5kZWZpbmVkKHByb3BlcnR5S2V5KSk7XG59XG5mdW5jdGlvbiAkaGFzT3duKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgLy8gMS4gSWYgVHlwZSh0YXJnZXQpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgJHR5cGVFcnJvcignTWV0YWRhdGEuaGFzT3duJywgW21ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5XSwgJ3RhcmdldCcsIHRhcmdldCwgJ09iamVjdCBvciBGdW5jdGlvbicpO1xuICAgIH1cbiAgICAvLyAyLiBSZXR1cm4gPyB0YXJnZXQuW1tIYXNPd25dXShtZXRhZGF0YUtleSwgcHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZnVuY3Rpb24gJGdldChtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmdldCcsIFttZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbR2V0TWV0YWRhdGFdXShtZXRhZGF0YUtleSwgcHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZnVuY3Rpb24gJGdldE93bihtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmdldE93bicsIFttZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbR2V0T3duTWV0YWRhdGFdXShtZXRhZGF0YUtleSwgcHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZnVuY3Rpb24gJGdldEtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmdldEtleXMnLCBbdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbR2V0TWV0YWRhdGFLZXlzXV0ocHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeU1ldGFkYXRhS2V5cyh0YXJnZXQsIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZnVuY3Rpb24gJGdldE93bktleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmdldE93bktleXMnLCBbdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbR2V0T3duTWV0YWRhdGFLZXlzXV0ocHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZnVuY3Rpb24gJGRlbGV0ZShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIC8vIDEuIElmIFR5cGUodGFyZ2V0KSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93ICR0eXBlRXJyb3IoJ01ldGFkYXRhLmRlbGV0ZScsIFttZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleV0sICd0YXJnZXQnLCB0YXJnZXQsICdPYmplY3Qgb3IgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gMi4gUmV0dXJuID8gdGFyZ2V0LltbRGVsZXRlTWV0YWRhdGFdXShtZXRhZGF0YUtleSwgcHJvcGVydHlLZXkpLlxuICAgIHJldHVybiBPcmRpbmFyeURlbGV0ZU1ldGFkYXRhKHRhcmdldCwgbWV0YWRhdGFLZXksIHRvUHJvcGVydHlLZXlPclVuZGVmaW5lZChwcm9wZXJ0eUtleSkpO1xufVxuZXhwb3J0IGNvbnN0IE1ldGFkYXRhID0ge1xuICAgIGRlZmluZTogJGRlZmluZSxcbiAgICBoYXM6ICRoYXMsXG4gICAgaGFzT3duOiAkaGFzT3duLFxuICAgIGdldDogJGdldCxcbiAgICBnZXRPd246ICRnZXRPd24sXG4gICAgZ2V0S2V5czogJGdldEtleXMsXG4gICAgZ2V0T3duS2V5czogJGdldE93bktleXMsXG4gICAgZGVsZXRlOiAkZGVsZXRlLFxufTtcbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsdWUsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpIHtcbiAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgd3JpdGFibGUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGUsXG4gICAgICAgIHZhbHVlLFxuICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGFwcGx5IG1ldGFkYXRhIHBvbHlmaWxsOiBjb3VsZCBub3QgYWRkIHByb3BlcnR5ICcke2tleX0nIHRvIHRoZSBnbG9iYWwgUmVmbGVjdCBvYmplY3RgKTtcbiAgICB9XG59XG5jb25zdCBpbnRlcm5hbFNsb3ROYW1lID0gJ1tbJGF1XV0nO1xuZnVuY3Rpb24gaGFzSW50ZXJuYWxTbG90KHJlZmxlY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxTbG90TmFtZSBpbiByZWZsZWN0O1xufVxuZnVuY3Rpb24gJGFwcGx5TWV0YWRhdGFQb2x5ZmlsbChyZWZsZWN0LCB3cml0YWJsZSwgY29uZmlndXJhYmxlKSB7XG4gICAgZGVmKHJlZmxlY3QsIGludGVybmFsU2xvdE5hbWUsIG1ldGFkYXRhSW50ZXJuYWxTbG90LCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ21ldGFkYXRhJywgbWV0YWRhdGEsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xuICAgIGRlZihyZWZsZWN0LCAnZGVjb3JhdGUnLCBkZWNvcmF0ZSwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG4gICAgZGVmKHJlZmxlY3QsICdkZWZpbmVNZXRhZGF0YScsICRkZWZpbmUsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xuICAgIGRlZihyZWZsZWN0LCAnaGFzTWV0YWRhdGEnLCAkaGFzLCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ2hhc093bk1ldGFkYXRhJywgJGhhc093biwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG4gICAgZGVmKHJlZmxlY3QsICdnZXRNZXRhZGF0YScsICRnZXQsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xuICAgIGRlZihyZWZsZWN0LCAnZ2V0T3duTWV0YWRhdGEnLCAkZ2V0T3duLCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ2dldE1ldGFkYXRhS2V5cycsICRnZXRLZXlzLCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ2dldE93bk1ldGFkYXRhS2V5cycsICRnZXRPd25LZXlzLCB3cml0YWJsZSwgY29uZmlndXJhYmxlKTtcbiAgICBkZWYocmVmbGVjdCwgJ2RlbGV0ZU1ldGFkYXRhJywgJGRlbGV0ZSwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNZXRhZGF0YVBvbHlmaWxsKHJlZmxlY3QsIHRocm93SWZDb25mbGljdCA9IHRydWUsIGZvcmNlT3ZlcndyaXRlID0gZmFsc2UsIHdyaXRhYmxlID0gdHJ1ZSwgY29uZmlndXJhYmxlID0gdHJ1ZSkge1xuICAgIGlmIChoYXNJbnRlcm5hbFNsb3QocmVmbGVjdCkpIHtcbiAgICAgICAgaWYgKHJlZmxlY3RbaW50ZXJuYWxTbG90TmFtZV0gPT09IG1ldGFkYXRhSW50ZXJuYWxTbG90KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25mbGljdGluZyBAYXVyZWxpYS9tZXRhZGF0YSBtb2R1bGUgaW1wb3J0IGRldGVjdGVkLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIHRoZSBzYW1lIHZlcnNpb24gb2YgYWxsIEF1cmVsaWEgcGFja2FnZXMgaW4geW91ciBkZXBlbmRlbmN5IHRyZWUuYCk7XG4gICAgfVxuICAgIGNvbnN0IHByZXNlbnRQcm9wcyA9IFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2RlY29yYXRlJyxcbiAgICAgICAgJ2RlZmluZU1ldGFkYXRhJyxcbiAgICAgICAgJ2hhc01ldGFkYXRhJyxcbiAgICAgICAgJ2hhc093bk1ldGFkYXRhJyxcbiAgICAgICAgJ2dldE1ldGFkYXRhJyxcbiAgICAgICAgJ2dldE93bk1ldGFkYXRhJyxcbiAgICAgICAgJ2dldE1ldGFkYXRhS2V5cycsXG4gICAgICAgICdnZXRPd25NZXRhZGF0YUtleXMnLFxuICAgICAgICAnZGVsZXRlTWV0YWRhdGEnLFxuICAgIF0uZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwIGluIFJlZmxlY3Q7XG4gICAgfSk7XG4gICAgaWYgKHByZXNlbnRQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aHJvd0lmQ29uZmxpY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGltcGxlbWVudGF0aW9uU3VtbWFyeSA9IHByZXNlbnRQcm9wcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbXBsID0gYCR7UmVmbGVjdFtwXS50b1N0cmluZygpLnNsaWNlKDAsIDEwMCl9Li4uYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cH06XFxuJHtpbXBsfWA7XG4gICAgICAgICAgICB9KS5qb2luKCdcXG5cXG4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uZmxpY3RpbmcgcmVmbGVjdC5tZXRhZGF0YSBwb2x5ZmlsbCBmb3VuZC4gSWYgeW91IGhhdmUgJ3JlZmxlY3QtbWV0YWRhdGEnIG9yIGFueSBvdGhlciByZWZsZWN0IHBvbHlmaWxsIGltcG9ydGVkLCBwbGVhc2UgcmVtb3ZlIGl0LCBpZiBub3QgKG9yIGlmIHlvdSBtdXN0IHVzZSBhIHNwZWNpZmljIHBvbHlmaWxsKSBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vYXVyZWxpYS9hdXJlbGlhL2lzc3VlcyBzbyB0aGF0IHdlIGNhbiBsb29rIGludG8gY29tcGF0aWJpbGl0eSBvcHRpb25zIGZvciB0aGlzIHNjZW5hcmlvLiBJbXBsZW1lbnRhdGlvbiBzdW1tYXJ5OlxcblxcbiR7aW1wbGVtZW50YXRpb25TdW1tYXJ5fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlT3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAkYXBwbHlNZXRhZGF0YVBvbHlmaWxsKHJlZmxlY3QsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkYXBwbHlNZXRhZGF0YVBvbHlmaWxsKHJlZmxlY3QsIHdyaXRhYmxlLCBjb25maWd1cmFibGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IFBsYXRmb3JtLCBUYXNrUXVldWUgfSBmcm9tICdAYXVyZWxpYS9wbGF0Zm9ybSc7XG5jb25zdCBsb29rdXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZChuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBQTEFURk9STSBkaWQgbm90IHJlY2VpdmUgYSB2YWxpZCByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBmdW5jdGlvbiAnJHtuYW1lfScuYCk7IC8vIFRPRE86IGxpbmsgdG8gZG9jcyBkZXNjcmliaW5nIGhvdyB0byBmaXggdGhpcyBpc3N1ZVxuICAgIH07XG59XG5leHBvcnQgY2xhc3MgQnJvd3NlclBsYXRmb3JtIGV4dGVuZHMgUGxhdGZvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGcsIG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGcsIG92ZXJyaWRlcyk7XG4gICAgICAgIHRoaXMuZG9tUmVhZFJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbVJlYWRIYW5kbGUgPSAtMTtcbiAgICAgICAgdGhpcy5kb21Xcml0ZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbVdyaXRlSGFuZGxlID0gLTE7XG4gICAgICAgIHRoaXMuTm9kZSA9ICdOb2RlJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuTm9kZSA6IGcuTm9kZTtcbiAgICAgICAgdGhpcy5FbGVtZW50ID0gJ0VsZW1lbnQnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5FbGVtZW50IDogZy5FbGVtZW50O1xuICAgICAgICB0aGlzLkhUTUxFbGVtZW50ID0gJ0hUTUxFbGVtZW50JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuSFRNTEVsZW1lbnQgOiBnLkhUTUxFbGVtZW50O1xuICAgICAgICB0aGlzLkN1c3RvbUV2ZW50ID0gJ0N1c3RvbUV2ZW50JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuQ3VzdG9tRXZlbnQgOiBnLkN1c3RvbUV2ZW50O1xuICAgICAgICB0aGlzLkNTU1N0eWxlU2hlZXQgPSAnQ1NTU3R5bGVTaGVldCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLkNTU1N0eWxlU2hlZXQgOiBnLkNTU1N0eWxlU2hlZXQ7XG4gICAgICAgIHRoaXMuU2hhZG93Um9vdCA9ICdTaGFkb3dSb290JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuU2hhZG93Um9vdCA6IGcuU2hhZG93Um9vdDtcbiAgICAgICAgdGhpcy5NdXRhdGlvbk9ic2VydmVyID0gJ011dGF0aW9uT2JzZXJ2ZXInIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5NdXRhdGlvbk9ic2VydmVyIDogZy5NdXRhdGlvbk9ic2VydmVyO1xuICAgICAgICB0aGlzLndpbmRvdyA9ICd3aW5kb3cnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy53aW5kb3cgOiBnLndpbmRvdztcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9ICdkb2N1bWVudCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmRvY3VtZW50IDogZy5kb2N1bWVudDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9ICdsb2NhdGlvbicgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmxvY2F0aW9uIDogZy5sb2NhdGlvbjtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gJ2hpc3RvcnknIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5oaXN0b3J5IDogZy5oaXN0b3J5O1xuICAgICAgICB0aGlzLm5hdmlnYXRvciA9ICduYXZpZ2F0b3InIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5uYXZpZ2F0b3IgOiBnLm5hdmlnYXRvcjtcbiAgICAgICAgdGhpcy5mZXRjaCA9ICdmZXRjaCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmZldGNoIDogZy5mZXRjaD8uYmluZChnKSA/PyBub3RJbXBsZW1lbnRlZCgnZmV0Y2gnKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogZy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/LmJpbmQoZykgPz8gbm90SW1wbGVtZW50ZWQoJ3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gJ2NhbmNlbEFuaW1hdGlvbkZyYW1lJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBnLmNhbmNlbEFuaW1hdGlvbkZyYW1lPy5iaW5kKGcpID8/IG5vdEltcGxlbWVudGVkKCdjYW5jZWxBbmltYXRpb25GcmFtZScpO1xuICAgICAgICB0aGlzLmN1c3RvbUVsZW1lbnRzID0gJ2N1c3RvbUVsZW1lbnRzJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuY3VzdG9tRWxlbWVudHMgOiBnLmN1c3RvbUVsZW1lbnRzO1xuICAgICAgICB0aGlzLmZsdXNoRG9tUmVhZCA9IHRoaXMuZmx1c2hEb21SZWFkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZmx1c2hEb21Xcml0ZSA9IHRoaXMuZmx1c2hEb21Xcml0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbVJlYWRRdWV1ZSA9IG5ldyBUYXNrUXVldWUodGhpcywgdGhpcy5yZXF1ZXN0RG9tUmVhZC5iaW5kKHRoaXMpLCB0aGlzLmNhbmNlbERvbVJlYWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZG9tV3JpdGVRdWV1ZSA9IG5ldyBUYXNrUXVldWUodGhpcywgdGhpcy5yZXF1ZXN0RG9tV3JpdGUuYmluZCh0aGlzKSwgdGhpcy5jYW5jZWxEb21Xcml0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb24gKi9cbiAgICB9XG4gICAgc3RhdGljIGdldE9yQ3JlYXRlKGcsIG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIGxldCBwbGF0Zm9ybSA9IGxvb2t1cC5nZXQoZyk7XG4gICAgICAgIGlmIChwbGF0Zm9ybSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsb29rdXAuc2V0KGcsIHBsYXRmb3JtID0gbmV3IEJyb3dzZXJQbGF0Zm9ybShnLCBvdmVycmlkZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhdGZvcm07XG4gICAgfVxuICAgIHN0YXRpYyBzZXQoZywgcGxhdGZvcm0pIHtcbiAgICAgICAgbG9va3VwLnNldChnLCBwbGF0Zm9ybSk7XG4gICAgfVxuICAgIHJlcXVlc3REb21SZWFkKCkge1xuICAgICAgICB0aGlzLmRvbVJlYWRSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBZZXMsIHRoaXMgaXMgaW50ZW50aW9uYWw6IHRoZSB0aW1pbmcgb2YgdGhlIHJlYWQgY2FuIG9ubHkgYmUgXCJmb3VuZFwiIGJ5IGRvaW5nIGEgd3JpdGUgZmlyc3QuXG4gICAgICAgIC8vIFRoZSBmbHVzaERvbVdyaXRlIHF1ZXVlcyB0aGUgcmVhZC5cbiAgICAgICAgLy8gSWYvd2hlbiByZXF1ZXN0UG9zdEFuaW1hdGlvbkZyYW1lIGlzIGltcGxlbWVudGVkIGluIGJyb3dzZXJzLCB3ZSBjYW4gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgaWYgKHRoaXMuZG9tV3JpdGVIYW5kbGUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVdyaXRlSGFuZGxlID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaERvbVdyaXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxEb21SZWFkKCkge1xuICAgICAgICB0aGlzLmRvbVJlYWRSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZG9tUmVhZEhhbmRsZSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCh0aGlzLmRvbVJlYWRIYW5kbGUpO1xuICAgICAgICAgICAgdGhpcy5kb21SZWFkSGFuZGxlID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9tV3JpdGVSZXF1ZXN0ZWQgPT09IGZhbHNlICYmIHRoaXMuZG9tV3JpdGVIYW5kbGUgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRvbVdyaXRlSGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMuZG9tV3JpdGVIYW5kbGUgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaERvbVJlYWQoKSB7XG4gICAgICAgIHRoaXMuZG9tUmVhZEhhbmRsZSA9IC0xO1xuICAgICAgICBpZiAodGhpcy5kb21SZWFkUmVxdWVzdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVJlYWRSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZG9tUmVhZFF1ZXVlLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdERvbVdyaXRlKCkge1xuICAgICAgICB0aGlzLmRvbVdyaXRlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZG9tV3JpdGVIYW5kbGUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVdyaXRlSGFuZGxlID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaERvbVdyaXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxEb21Xcml0ZSgpIHtcbiAgICAgICAgdGhpcy5kb21Xcml0ZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5kb21Xcml0ZUhhbmRsZSA+IC0xICYmXG4gICAgICAgICAgICAvLyBpZiBkb20gcmVhZCBpcyByZXF1ZXN0ZWQgYW5kIHRoZXJlIGlzIG5vIHJlYWRIYW5kbGUgeWV0LCB3ZSBuZWVkIHRoZSByQUYgdG8gcHJvY2VlZCByZWdhcmRsZXNzLlxuICAgICAgICAgICAgLy8gVGhlIGRvbVdyaXRlUmVxdWVzdGVkPWZhbHNlIHdpbGwgcHJldmVudCB0aGUgcmVhZCBmbHVzaCBmcm9tIGhhcHBlbmluZy5cbiAgICAgICAgICAgICh0aGlzLmRvbVJlYWRSZXF1ZXN0ZWQgPT09IGZhbHNlIHx8IHRoaXMuZG9tUmVhZEhhbmRsZSA+IC0xKSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRvbVdyaXRlSGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMuZG9tV3JpdGVIYW5kbGUgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaERvbVdyaXRlKCkge1xuICAgICAgICB0aGlzLmRvbVdyaXRlSGFuZGxlID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmRvbVdyaXRlUmVxdWVzdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbVdyaXRlUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRvbVdyaXRlUXVldWUuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kb21SZWFkUmVxdWVzdGVkID09PSB0cnVlICYmIHRoaXMuZG9tUmVhZEhhbmRsZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tUmVhZEhhbmRsZSA9IHRoaXMuc2V0VGltZW91dCh0aGlzLmZsdXNoRG9tUmVhZCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJjb25zdCBsb29rdXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZChuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBQTEFURk9STSBkaWQgbm90IHJlY2VpdmUgYSB2YWxpZCByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBmdW5jdGlvbiAnJHtuYW1lfScuYCk7IC8vIFRPRE86IGxpbmsgdG8gZG9jcyBkZXNjcmliaW5nIGhvdyB0byBmaXggdGhpcyBpc3N1ZVxuICAgIH07XG59XG5leHBvcnQgY2xhc3MgUGxhdGZvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGcsIG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIHRoaXMubWFjcm9UYXNrUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFjcm9UYXNrSGFuZGxlID0gLTE7XG4gICAgICAgIHRoaXMuZ2xvYmFsVGhpcyA9IGc7XG4gICAgICAgIHRoaXMuZGVjb2RlVVJJID0gJ2RlY29kZVVSSScgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmRlY29kZVVSSSA6IGcuZGVjb2RlVVJJO1xuICAgICAgICB0aGlzLmRlY29kZVVSSUNvbXBvbmVudCA9ICdkZWNvZGVVUklDb21wb25lbnQnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5kZWNvZGVVUklDb21wb25lbnQgOiBnLmRlY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5lbmNvZGVVUkkgPSAnZW5jb2RlVVJJJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuZW5jb2RlVVJJIDogZy5lbmNvZGVVUkk7XG4gICAgICAgIHRoaXMuZW5jb2RlVVJJQ29tcG9uZW50ID0gJ2VuY29kZVVSSUNvbXBvbmVudCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmVuY29kZVVSSUNvbXBvbmVudCA6IGcuZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgICAgICB0aGlzLkRhdGUgPSAnRGF0ZScgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLkRhdGUgOiBnLkRhdGU7XG4gICAgICAgIHRoaXMuUmVmbGVjdCA9ICdSZWZsZWN0JyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuUmVmbGVjdCA6IGcuUmVmbGVjdDtcbiAgICAgICAgdGhpcy5jbGVhckludGVydmFsID0gJ2NsZWFySW50ZXJ2YWwnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5jbGVhckludGVydmFsIDogZy5jbGVhckludGVydmFsPy5iaW5kKGcpID8/IG5vdEltcGxlbWVudGVkKCdjbGVhckludGVydmFsJyk7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0ID0gJ2NsZWFyVGltZW91dCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLmNsZWFyVGltZW91dCA6IGcuY2xlYXJUaW1lb3V0Py5iaW5kKGcpID8/IG5vdEltcGxlbWVudGVkKCdjbGVhclRpbWVvdXQnKTtcbiAgICAgICAgdGhpcy5xdWV1ZU1pY3JvdGFzayA9ICdxdWV1ZU1pY3JvdGFzaycgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLnF1ZXVlTWljcm90YXNrIDogZy5xdWV1ZU1pY3JvdGFzaz8uYmluZChnKSA/PyBub3RJbXBsZW1lbnRlZCgncXVldWVNaWNyb3Rhc2snKTtcbiAgICAgICAgdGhpcy5zZXRJbnRlcnZhbCA9ICdzZXRJbnRlcnZhbCcgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLnNldEludGVydmFsIDogZy5zZXRJbnRlcnZhbD8uYmluZChnKSA/PyBub3RJbXBsZW1lbnRlZCgnc2V0SW50ZXJ2YWwnKTtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0ID0gJ3NldFRpbWVvdXQnIGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlcy5zZXRUaW1lb3V0IDogZy5zZXRUaW1lb3V0Py5iaW5kKGcpID8/IG5vdEltcGxlbWVudGVkKCdzZXRUaW1lb3V0Jyk7XG4gICAgICAgIHRoaXMuY29uc29sZSA9ICdjb25zb2xlJyBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXMuY29uc29sZSA6IGcuY29uc29sZTtcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZU5vdyA9ICdwZXJmb3JtYW5jZU5vdycgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzLnBlcmZvcm1hbmNlTm93IDogZy5wZXJmb3JtYW5jZT8ubm93Py5iaW5kKGcucGVyZm9ybWFuY2UpID8/IG5vdEltcGxlbWVudGVkKCdwZXJmb3JtYW5jZS5ub3cnKTtcbiAgICAgICAgdGhpcy5mbHVzaE1hY3JvVGFzayA9IHRoaXMuZmx1c2hNYWNyb1Rhc2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYWNyb1Rhc2tRdWV1ZSA9IG5ldyBUYXNrUXVldWUodGhpcywgdGhpcy5yZXF1ZXN0TWFjcm9UYXNrLmJpbmQodGhpcyksIHRoaXMuY2FuY2VsTWFjcm9UYXNrLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0T3JDcmVhdGUoZywgb3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgbGV0IHBsYXRmb3JtID0gbG9va3VwLmdldChnKTtcbiAgICAgICAgaWYgKHBsYXRmb3JtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxvb2t1cC5zZXQoZywgcGxhdGZvcm0gPSBuZXcgUGxhdGZvcm0oZywgb3ZlcnJpZGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0KGcsIHBsYXRmb3JtKSB7XG4gICAgICAgIGxvb2t1cC5zZXQoZywgcGxhdGZvcm0pO1xuICAgIH1cbiAgICByZXF1ZXN0TWFjcm9UYXNrKCkge1xuICAgICAgICB0aGlzLm1hY3JvVGFza1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm1hY3JvVGFza0hhbmRsZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMubWFjcm9UYXNrSGFuZGxlID0gdGhpcy5zZXRUaW1lb3V0KHRoaXMuZmx1c2hNYWNyb1Rhc2ssIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbE1hY3JvVGFzaygpIHtcbiAgICAgICAgdGhpcy5tYWNyb1Rhc2tSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMubWFjcm9UYXNrSGFuZGxlID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRoaXMubWFjcm9UYXNrSGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMubWFjcm9UYXNrSGFuZGxlID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hNYWNyb1Rhc2soKSB7XG4gICAgICAgIHRoaXMubWFjcm9UYXNrSGFuZGxlID0gLTE7XG4gICAgICAgIGlmICh0aGlzLm1hY3JvVGFza1JlcXVlc3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWNyb1Rhc2tSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWFjcm9UYXNrUXVldWUuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGVyc2lzdGVudCh0YXNrKSB7XG4gICAgcmV0dXJuIHRhc2sucGVyc2lzdGVudDtcbn1cbmV4cG9ydCBjbGFzcyBUYXNrUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtLCAkcmVxdWVzdCwgJGNhbmNlbCkge1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMuJHJlcXVlc3QgPSAkcmVxdWVzdDtcbiAgICAgICAgdGhpcy4kY2FuY2VsID0gJGNhbmNlbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gW107XG4gICAgICAgIHRoaXMuc3VzcGVuZGVyVGFzayA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQXN5bmNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaFJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnlpZWxkUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy50YXNrUG9vbCA9IFtdO1xuICAgICAgICB0aGlzLnRhc2tQb29sU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFJlcXVlc3QgPSAwO1xuICAgICAgICB0aGlzLmxhc3RGbHVzaCA9IDA7XG4gICAgICAgIHRoaXMucmVxdWVzdEZsdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAncmVxdWVzdEZsdXNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmx1c2hSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0ID0gdGhpcy5wbGF0Zm9ybS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3JlcXVlc3RGbHVzaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNlciA9IG5ldyBUcmFjZXIocGxhdGZvcm0uY29uc29sZSk7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwICYmIHRoaXMuZGVsYXllZC5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcnNpc3RlbnQgdGFza3Mgd2lsbCByZS1xdWV1ZSB0aGVtc2VsdmVzIGluZGVmaW5pdGVseSB1bnRpbCB0aGV5IGFyZSBleHBsaWNpdGx5IGNhbmNlbGVkLFxuICAgICAqIHNvIHdlIGNvbnNpZGVyIHRoZW0gJ2luZmluaXRlIHdvcmsnIHdoZXJlYXMgbm9uLXBlcnNpc3RlbnQgKG9uZS1vZmYpIHRhc2tzIGFyZSAnZmluaXRlIHdvcmsnLlxuICAgICAqXG4gICAgICogVGhpcyBgaGFzTm9Nb3JlRmluaXRlV29ya2AgZ2V0dGVycyByZXR1cm5zIHRydWUgaWYgZWl0aGVyIGFsbCByZW1haW5pbmcgdGFza3MgYXJlIHBlcnNpc3RlbnQsIG9yIGlmIHRoZXJlIGFyZSBubyBtb3JlIHRhc2tzLlxuICAgICAqXG4gICAgICogSWYgdGhhdCBpcyB0aGUgY2FzZSwgd2UgY2FuIHJlc29sdmUgdGhlIHByb21pc2UgdGhhdCB3YXMgY3JlYXRlZCB3aGVuIGB5aWVsZCgpYCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZ2V0IGhhc05vTW9yZUZpbml0ZVdvcmsoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wZW5kaW5nQXN5bmNDb3VudCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nLmV2ZXJ5KGlzUGVyc2lzdGVudCkgJiZcbiAgICAgICAgICAgIHRoaXMucGVuZGluZy5ldmVyeShpc1BlcnNpc3RlbnQpICYmXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWQuZXZlcnkoaXNQZXJzaXN0ZW50KSk7XG4gICAgfVxuICAgIGZsdXNoKHRpbWUgPSB0aGlzLnBsYXRmb3JtLnBlcmZvcm1hbmNlTm93KCkpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdmbHVzaCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2hSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0Rmx1c2ggPSB0aW1lO1xuICAgICAgICAvLyBPbmx5IHByb2Nlc3Mgbm9ybWFsbHkgaWYgd2UgYXJlICpub3QqIGN1cnJlbnRseSB3YWl0aW5nIGZvciBhbiBhc3luYyB0YXNrIHRvIGZpbmlzaFxuICAgICAgICBpZiAodGhpcy5zdXNwZW5kZXJUYXNrID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5wdXNoKC4uLnRoaXMucGVuZGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxheWVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCB0aGlzLmRlbGF5ZWQubGVuZ3RoICYmIHRoaXMuZGVsYXllZFtpXS5xdWV1ZVRpbWUgPD0gdGltZSkgeyAvKiBkbyBub3RoaW5nICovIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcucHVzaCguLi50aGlzLmRlbGF5ZWQuc3BsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXI7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wcm9jZXNzaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAoY3VyID0gdGhpcy5wcm9jZXNzaW5nLnNoaWZ0KCkpLnJ1bigpO1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgc3RpbGwgcnVubmluZywgaXQgY2FuIG9ubHkgYmUgYW4gYXN5bmMgdGFza1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc3RhdHVzID09PSAxIC8qIHJ1bm5pbmcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5zdXNwZW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1c3BlbmRlclRhc2sgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAnZmx1c2ggZWFybHkgYXN5bmMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5wZW5kaW5nQXN5bmNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5wdXNoKC4uLnRoaXMucGVuZGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxheWVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCB0aGlzLmRlbGF5ZWQubGVuZ3RoICYmIHRoaXMuZGVsYXllZFtpXS5xdWV1ZVRpbWUgPD0gdGltZSkgeyAvKiBkbyBub3RoaW5nICovIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcucHVzaCguLi50aGlzLmRlbGF5ZWQuc3BsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmcubGVuZ3RoID4gMCB8fCB0aGlzLmRlbGF5ZWQubGVuZ3RoID4gMCB8fCB0aGlzLnBlbmRpbmdBc3luY0NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy55aWVsZFByb21pc2UgIT09IHZvaWQgMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaGFzTm9Nb3JlRmluaXRlV29yaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnlpZWxkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnlpZWxkUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBwLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBzdGlsbCB3YWl0aW5nIGZvciBhbiBhc3luYyB0YXNrIHRvIGZpbmlzaCwganVzdCBzY2hlZHVsZSB0aGUgbmV4dCBmbHVzaCBhbmQgZG8gbm90aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gU2hvdWxkIHRoZSB0YXNrIGZpbmlzaCBiZWZvcmUgdGhlIG5leHQgZmx1c2ggaXMgaW52b2tlZCxcbiAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjayB0byBgY29tcGxldGVBc3luY1Rhc2tgIHdpbGwgaGF2ZSByZXNldCBgdGhpcy5zdXNwZW5kZXJUYXNrYCBiYWNrIHRvIHVuZGVmaW5lZCBzbyBwcm9jZXNzaW5nIGNhbiByZXR1cm4gYmFjayB0byBub3JtYWwgbmV4dCBmbHVzaC5cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdmbHVzaCBmdWxsJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSBuZXh0IGZsdXNoIGN5Y2xlIChhbmQvb3IgdGhlIG1hY3JvdGFzayB0aGF0IHNjaGVkdWxlcyB0aGUgbmV4dCBmbHVzaCBjeWNsZSwgaW4gY2FzZSB0aGlzIGlzIGEgbWljcm90YXNrIHF1ZXVlKSwgaWYgaXQgd2FzIHJlcXVlc3RlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgb3BlcmF0aW9uIGlzIGlkZW1wb3RlbnQgYW5kIHdpbGwgZG8gbm90aGluZyBpZiBubyBmbHVzaCBpcyBzY2hlZHVsZWQuXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIuZW50ZXIodGhpcywgJ2NhbmNlbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZsdXNoUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICB0aGlzLiRjYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ2NhbmNlbCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQsIHdoZW4gYXdhaXRlZCwgcmVzb2x2ZXMgd2hlbjpcbiAgICAgKiAtIGFsbCAqbm9uKi1wZXJzaXN0ZW50IChpbmNsdWRpbmcgYXN5bmMpIHRhc2tzIGhhdmUgZmluaXNoZWQ7XG4gICAgICogLSB0aGUgbGFzdC1hZGRlZCBwZXJzaXN0ZW50IHRhc2sgaGFzIHJ1biBleGFjdGx5IG9uY2U7XG4gICAgICpcbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBpZGVtcG90ZW50OiB0aGUgc2FtZSBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQgdW50aWwgaXQgcmVzb2x2ZXMuXG4gICAgICpcbiAgICAgKiBJZiBgeWllbGQoKWAgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGEgcm93IHdoZW4gdGhlcmUgYXJlIG9uZSBvciBtb3JlIHBlcnNpc3RlbnQgdGFza3MgaW4gdGhlIHF1ZXVlLCBlYWNoIGNhbGwgd2lsbCBhd2FpdCBleGFjdGx5IG9uZSBjeWNsZSBvZiB0aG9zZSB0YXNrcy5cbiAgICAgKi9cbiAgICBhc3luYyB5aWVsZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICd5aWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3lpZWxkIGVtcHR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy55aWVsZFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLnRyYWNlKHRoaXMsICd5aWVsZCAtIGNyZWF0aW5nIHByb21pc2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy55aWVsZFByb21pc2UgPSBjcmVhdGVFeHBvc2VkUHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy55aWVsZFByb21pc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICd5aWVsZCB0YXNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWVUYXNrKGNhbGxiYWNrLCBvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAncXVldWVUYXNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkZWxheSwgcHJlZW1wdCwgcGVyc2lzdGVudCwgcmV1c2FibGUsIHN1c3BlbmQgfSA9IHsgLi4uZGVmYXVsdFF1ZXVlVGFza09wdGlvbnMsIC4uLm9wdHMgfTtcbiAgICAgICAgaWYgKHByZWVtcHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJndW1lbnRzOiBwcmVlbXB0IGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGEgZ3JlYXRlci10aGFuLXplcm8gZGVsYXlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFyZ3VtZW50czogcHJlZW1wdCBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBwZXJzaXN0ZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMucGxhdGZvcm0ucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgIGlmIChyZXVzYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgdGFza1Bvb2wgPSB0aGlzLnRhc2tQb29sO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhc2tQb29sU2l6ZSAtIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRhc2sgPSB0YXNrUG9vbFtpbmRleF07XG4gICAgICAgICAgICAgICAgdGFza1Bvb2xbaW5kZXhdID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy50YXNrUG9vbFNpemUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0YXNrLnJldXNlKHRpbWUsIGRlbGF5LCBwcmVlbXB0LCBwZXJzaXN0ZW50LCBzdXNwZW5kLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrID0gbmV3IFRhc2sodGhpcy50cmFjZXIsIHRoaXMsIHRpbWUsIHRpbWUgKyBkZWxheSwgcHJlZW1wdCwgcGVyc2lzdGVudCwgc3VzcGVuZCwgcmV1c2FibGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhc2sgPSBuZXcgVGFzayh0aGlzLnRyYWNlciwgdGhpcywgdGltZSwgdGltZSArIGRlbGF5LCBwcmVlbXB0LCBwZXJzaXN0ZW50LCBzdXNwZW5kLCByZXVzYWJsZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVlbXB0KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdbdGhpcy5wcm9jZXNzaW5nLmxlbmd0aF0gPSB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdbdGhpcy5wZW5kaW5nLmxlbmd0aF0gPSB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkW3RoaXMuZGVsYXllZC5sZW5ndGhdID0gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3F1ZXVlVGFzaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHRhc2sgZnJvbSB0aGlzIHF1ZXVlLlxuICAgICAqL1xuICAgIHJlbW92ZSh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5lbnRlcih0aGlzLCAncmVtb3ZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkeCA9IHRoaXMucHJvY2Vzc2luZy5pbmRleE9mKHRhc2spO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ3JlbW92ZSBwcm9jZXNzaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWR4ID0gdGhpcy5wZW5kaW5nLmluZGV4T2YodGFzayk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncmVtb3ZlIHBlbmRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZHggPSB0aGlzLmRlbGF5ZWQuaW5kZXhPZih0YXNrKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWQuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdyZW1vdmUgZGVsYXllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncmVtb3ZlIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXNrICMke3Rhc2suaWR9IGNvdWxkIG5vdCBiZSBmb3VuZGApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZXVzYWJsZSB0YXNrIHRvIHRoZSBzaGFyZWQgdGFzayBwb29sLlxuICAgICAqIFRoZSBuZXh0IHF1ZXVlZCBjYWxsYmFjayB3aWxsIHJldXNlIHRoaXMgdGFzayBvYmplY3QgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUsIHRvIHNhdmUgb3ZlcmhlYWQgb2YgY3JlYXRpbmcgYWRkaXRpb25hbCBvYmplY3RzLlxuICAgICAqL1xuICAgIHJldHVyblRvUG9vbCh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci50cmFjZSh0aGlzLCAncmV0dXJuVG9Qb29sJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXNrUG9vbFt0aGlzLnRhc2tQb29sU2l6ZSsrXSA9IHRhc2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwZXJzaXN0ZW50IHRhc2sgYmFjayB0byBpdHMgcGVuZGluZyBzdGF0ZSwgcHJlcGFyaW5nIGl0IGZvciBiZWluZyBpbnZva2VkIGFnYWluIG9uIHRoZSBuZXh0IGZsdXNoLlxuICAgICAqL1xuICAgIHJlc2V0UGVyc2lzdGVudFRhc2sodGFzaykge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIuZW50ZXIodGhpcywgJ3Jlc2V0UGVyc2lzdGVudFRhc2snKTtcbiAgICAgICAgfVxuICAgICAgICB0YXNrLnJlc2V0KHRoaXMucGxhdGZvcm0ucGVyZm9ybWFuY2VOb3coKSk7XG4gICAgICAgIGlmICh0YXNrLmNyZWF0ZWRUaW1lID09PSB0YXNrLnF1ZXVlVGltZSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nW3RoaXMucGVuZGluZy5sZW5ndGhdID0gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFt0aGlzLmRlbGF5ZWQubGVuZ3RoXSA9IHRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdyZXNldFBlcnNpc3RlbnRUYXNrJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoZSBxdWV1ZSB0aGF0IHRoaXMgYXN5bmMgdGFzayBoYXMgaGFkIGl0cyBwcm9taXNlIHJlc29sdmVkLCBzbyB0aGF0IHRoZSBxdWV1ZSBjYW4gcHJvY2VlZCB3aXRoIGNvbnNlY3V0aXZlIHRhc2tzIG9uIHRoZSBuZXh0IGZsdXNoLlxuICAgICAqL1xuICAgIGNvbXBsZXRlQXN5bmNUYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdjb21wbGV0ZUFzeW5jVGFzaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXNrLnN1c3BlbmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1c3BlbmRlclRhc2sgIT09IHRhc2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAnY29tcGxldGVBc3luY1Rhc2sgZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luYyB0YXNrIGNvbXBsZXRpb24gbWlzbWF0Y2g6IHN1c3BlbmRlclRhc2s9JHt0aGlzLnN1c3BlbmRlclRhc2s/LmlkfSwgdGFzaz0ke3Rhc2suaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1c3BlbmRlclRhc2sgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAtLXRoaXMucGVuZGluZ0FzeW5jQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMueWllbGRQcm9taXNlICE9PSB2b2lkIDAgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzTm9Nb3JlRmluaXRlV29yaykge1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMueWllbGRQcm9taXNlO1xuICAgICAgICAgICAgdGhpcy55aWVsZFByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICBwLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAnY29tcGxldGVBc3luY1Rhc2snKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUYXNrQWJvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXNrKSB7XG4gICAgICAgIHN1cGVyKCdUYXNrIHdhcyBjYW5jZWxlZC4nKTtcbiAgICAgICAgdGhpcy50YXNrID0gdGFzaztcbiAgICB9XG59XG5sZXQgaWQgPSAwO1xuZXhwb3J0IHZhciBUYXNrU3RhdHVzO1xuKGZ1bmN0aW9uIChUYXNrU3RhdHVzKSB7XG4gICAgVGFza1N0YXR1c1tUYXNrU3RhdHVzW1wicGVuZGluZ1wiXSA9IDBdID0gXCJwZW5kaW5nXCI7XG4gICAgVGFza1N0YXR1c1tUYXNrU3RhdHVzW1wicnVubmluZ1wiXSA9IDFdID0gXCJydW5uaW5nXCI7XG4gICAgVGFza1N0YXR1c1tUYXNrU3RhdHVzW1wiY29tcGxldGVkXCJdID0gMl0gPSBcImNvbXBsZXRlZFwiO1xuICAgIFRhc2tTdGF0dXNbVGFza1N0YXR1c1tcImNhbmNlbGVkXCJdID0gM10gPSBcImNhbmNlbGVkXCI7XG59KShUYXNrU3RhdHVzIHx8IChUYXNrU3RhdHVzID0ge30pKTtcbmV4cG9ydCBjbGFzcyBUYXNrIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFjZXIsIHRhc2tRdWV1ZSwgY3JlYXRlZFRpbWUsIHF1ZXVlVGltZSwgcHJlZW1wdCwgcGVyc2lzdGVudCwgc3VzcGVuZCwgcmV1c2FibGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudHJhY2VyID0gdHJhY2VyO1xuICAgICAgICB0aGlzLnRhc2tRdWV1ZSA9IHRhc2tRdWV1ZTtcbiAgICAgICAgdGhpcy5jcmVhdGVkVGltZSA9IGNyZWF0ZWRUaW1lO1xuICAgICAgICB0aGlzLnF1ZXVlVGltZSA9IHF1ZXVlVGltZTtcbiAgICAgICAgdGhpcy5wcmVlbXB0ID0gcHJlZW1wdDtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50ID0gcGVyc2lzdGVudDtcbiAgICAgICAgdGhpcy5zdXNwZW5kID0gc3VzcGVuZDtcbiAgICAgICAgdGhpcy5yZXVzYWJsZSA9IHJldXNhYmxlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuaWQgPSArK2lkO1xuICAgICAgICB0aGlzLnJlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICB9XG4gICAgZ2V0IHJlc3VsdCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcmVzdWx0O1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIHBlbmRpbmcgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX3Jlc3VsdCA9IGNyZWF0ZUV4cG9zZWRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHByb21pc2UucmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QgPSBwcm9taXNlLnJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBydW5uaW5nICovOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhd2FpdCB0YXNrIGZyb20gd2l0aGluIHRhc2sgd2lsbCBjYXVzZSBhIGRlYWRsb2NrLicpO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBjb21wbGV0ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogY2FuY2VsZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHQgPSBQcm9taXNlLnJlamVjdChuZXcgVGFza0Fib3J0RXJyb3IodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gICAgfVxuICAgIHJ1bih0aW1lID0gdGhpcy50YXNrUXVldWUucGxhdGZvcm0ucGVyZm9ybWFuY2VOb3coKSkge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIuZW50ZXIodGhpcywgJ3J1bicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0dXMgIT09IDAgLyogcGVuZGluZyAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncnVuIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBydW4gdGFzayBpbiAke3RoaXMuX3N0YXR1c30gc3RhdGVgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLnBlcnNpc3RlbnQgY291bGQgYmUgY2hhbmdlZCB3aGlsZSB0aGUgdGFzayBpcyBydW5uaW5nICh0aGlzIGNhbiBvbmx5IGJlIGRvbmUgYnkgdGhlIHRhc2sgaXRzZWxmIGlmIGNhbmNlbGVkLCBhbmQgaXMgYSB2YWxpZCB3YXkgb2Ygc3RvcHBpbmcgYSBsb29wKVxuICAgICAgICAvLyBzbyB3ZSBkZWxpYmVyYXRlbHkgcmVmZXJlbmNlIHRoaXMucGVyc2lzdGVudCBpbnN0ZWFkIG9mIHRoZSBsb2NhbCB2YXJpYWJsZSwgYnV0IHdlIGtlZXAgaXQgYXJvdW5kIHRvIGtub3cgd2hldGhlciB0aGUgdGFzayAqd2FzKiBwZXJzaXN0ZW50IGJlZm9yZSBydW5uaW5nIGl0LFxuICAgICAgICAvLyBzbyB3ZSBjYW4gc2V0IHRoZSBjb3JyZWN0IGNhbmNlbGF0aW9uIHN0YXRlLlxuICAgICAgICBjb25zdCB7IHBlcnNpc3RlbnQsIHJldXNhYmxlLCB0YXNrUXVldWUsIGNhbGxiYWNrLCByZXNvbHZlLCByZWplY3QsIGNyZWF0ZWRUaW1lLCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBydW5uaW5nICovO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gY2FsbGJhY2sodGltZSAtIGNyZWF0ZWRUaW1lKTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0LnRoZW4oJHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVsncmVzZXRQZXJzaXN0ZW50VGFzayddKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJzaXN0ZW50IHRhc2tzIG5ldmVyIHJlYWNoIGNvbXBsZXRlZCBzdGF0dXMuIFRoZXkncmUgZWl0aGVyIHBlbmRpbmcsIHJ1bm5pbmcsIG9yIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDMgLyogY2FuY2VsZWQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSAyIC8qIGNvbXBsZXRlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVsnY29tcGxldGVBc3luY1Rhc2snXSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdydW4gYXN5bmMgdGhlbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJHJldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RlbnQgJiYgcmV1c2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVsncmV0dXJuVG9Qb29sJ10odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVsnY29tcGxldGVBc3luY1Rhc2snXSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdydW4gYXN5bmMgY2F0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVqZWN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tRdWV1ZVsncmVzZXRQZXJzaXN0ZW50VGFzayddKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlcnNpc3RlbnQgdGFza3MgbmV2ZXIgcmVhY2ggY29tcGxldGVkIHN0YXR1cy4gVGhleSdyZSBlaXRoZXIgcGVuZGluZywgcnVubmluZywgb3IgY2FuY2VsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSAzIC8qIGNhbmNlbGVkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gMiAvKiBjb21wbGV0ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdydW4gc3luYyBzdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGVyc2lzdGVudCAmJiByZXVzYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrUXVldWVbJ3JldHVyblRvUG9vbCddKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGVyc2lzdGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncnVuIHN5bmMgZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWplY3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdjYW5jZWwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdHVzID09PSAwIC8qIHBlbmRpbmcgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tRdWV1ZSA9IHRoaXMudGFza1F1ZXVlO1xuICAgICAgICAgICAgY29uc3QgcmV1c2FibGUgPSB0aGlzLnJldXNhYmxlO1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gdGhpcy5yZWplY3Q7XG4gICAgICAgICAgICB0YXNrUXVldWUucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRhc2tRdWV1ZS5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgdGFza1F1ZXVlLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gMyAvKiBjYW5jZWxlZCAqLztcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgaWYgKHJldXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGFza1F1ZXVlWydyZXR1cm5Ub1Bvb2wnXSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWplY3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3IodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAnY2FuY2VsIHRydWUgPXBlbmRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXR1cyA9PT0gMSAvKiBydW5uaW5nICovICYmIHRoaXMucGVyc2lzdGVudCkge1xuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VyLmxlYXZlKHRoaXMsICdjYW5jZWwgdHJ1ZSA9cnVubmluZytwZXJzaXN0ZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIubGVhdmUodGhpcywgJ2NhbmNlbCBmYWxzZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmVzZXQodGltZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIuZW50ZXIodGhpcywgJ3Jlc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLnF1ZXVlVGltZSAtIHRoaXMuY3JlYXRlZFRpbWU7XG4gICAgICAgIHRoaXMuY3JlYXRlZFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLnF1ZXVlVGltZSA9IHRpbWUgKyBkZWxheTtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gMCAvKiBwZW5kaW5nICovO1xuICAgICAgICB0aGlzLnJlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncmVzZXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZSh0aW1lLCBkZWxheSwgcHJlZW1wdCwgcGVyc2lzdGVudCwgc3VzcGVuZCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VyLmVudGVyKHRoaXMsICdyZXVzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlZFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLnF1ZXVlVGltZSA9IHRpbWUgKyBkZWxheTtcbiAgICAgICAgdGhpcy5wcmVlbXB0ID0gcHJlZW1wdDtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50ID0gcGVyc2lzdGVudDtcbiAgICAgICAgdGhpcy5zdXNwZW5kID0gc3VzcGVuZDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSAwIC8qIHBlbmRpbmcgKi87XG4gICAgICAgIGlmICh0aGlzLnRyYWNlci5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlci5sZWF2ZSh0aGlzLCAncmV1c2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy50cmFjZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZXIudHJhY2UodGhpcywgJ2Rpc3Bvc2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gKHZvaWQgMCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5yZWplY3QgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3Jlc3VsdCA9IHZvaWQgMDtcbiAgICB9XG59XG5mdW5jdGlvbiB0YXNrU3RhdHVzKHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgMCAvKiBwZW5kaW5nICovOiByZXR1cm4gJ3BlbmRpbmcnO1xuICAgICAgICBjYXNlIDEgLyogcnVubmluZyAqLzogcmV0dXJuICdydW5uaW5nJztcbiAgICAgICAgY2FzZSAzIC8qIGNhbmNlbGVkICovOiByZXR1cm4gJ2NhbmNlbGVkJztcbiAgICAgICAgY2FzZSAyIC8qIGNvbXBsZXRlZCAqLzogcmV0dXJuICdjb21wbGV0ZWQnO1xuICAgIH1cbn1cbmNsYXNzIFRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoY29uc29sZSkge1xuICAgICAgICB0aGlzLmNvbnNvbGUgPSBjb25zb2xlO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgfVxuICAgIGVudGVyKG9iaiwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMubG9nKGAkeycgICcucmVwZWF0KHRoaXMuZGVwdGgrKyl9PiBgLCBvYmosIG1ldGhvZCk7XG4gICAgfVxuICAgIGxlYXZlKG9iaiwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMubG9nKGAkeycgICcucmVwZWF0KC0tdGhpcy5kZXB0aCl9PCBgLCBvYmosIG1ldGhvZCk7XG4gICAgfVxuICAgIHRyYWNlKG9iaiwgbWV0aG9kKSB7XG4gICAgICAgIHRoaXMubG9nKGAkeycgICcucmVwZWF0KHRoaXMuZGVwdGgpfS0gYCwgb2JqLCBtZXRob2QpO1xuICAgIH1cbiAgICBsb2cocHJlZml4LCBvYmosIG1ldGhvZCkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVGFza1F1ZXVlKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzaW5nID0gb2JqWydwcm9jZXNzaW5nJ10ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcGVuZGluZyA9IG9ialsncGVuZGluZyddLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSBvYmpbJ2RlbGF5ZWQnXS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBmbHVzaFJlcSA9IG9ialsnZmx1c2hSZXF1ZXN0ZWQnXTtcbiAgICAgICAgICAgIGNvbnN0IHN1c1Rhc2sgPSAhIW9ialsnc3VzcGVuZGVyVGFzayddO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGBwcm9jZXNzaW5nPSR7cHJvY2Vzc2luZ30gcGVuZGluZz0ke3BlbmRpbmd9IGRlbGF5ZWQ9JHtkZWxheWVkfSBmbHVzaFJlcT0ke2ZsdXNoUmVxfSBzdXNUYXNrPSR7c3VzVGFza31gO1xuICAgICAgICAgICAgdGhpcy5jb25zb2xlLmxvZyhgJHtwcmVmaXh9W1EuJHttZXRob2R9XSAke2luZm99YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IG9ialsnaWQnXTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBNYXRoLnJvdW5kKG9ialsnY3JlYXRlZFRpbWUnXSAqIDEwKSAvIDEwO1xuICAgICAgICAgICAgY29uc3QgcXVldWUgPSBNYXRoLnJvdW5kKG9ialsncXVldWVUaW1lJ10gKiAxMCkgLyAxMDtcbiAgICAgICAgICAgIGNvbnN0IHByZWVtcHQgPSBvYmpbJ3ByZWVtcHQnXTtcbiAgICAgICAgICAgIGNvbnN0IHJldXNhYmxlID0gb2JqWydyZXVzYWJsZSddO1xuICAgICAgICAgICAgY29uc3QgcGVyc2lzdGVudCA9IG9ialsncGVyc2lzdGVudCddO1xuICAgICAgICAgICAgY29uc3Qgc3VzcGVuZCA9IG9ialsnc3VzcGVuZCddO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gdGFza1N0YXR1cyhvYmpbJ19zdGF0dXMnXSk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gYGlkPSR7aWR9IGNyZWF0ZWQ9JHtjcmVhdGVkfSBxdWV1ZT0ke3F1ZXVlfSBwcmVlbXB0PSR7cHJlZW1wdH0gcGVyc2lzdGVudD0ke3BlcnNpc3RlbnR9IHJldXNhYmxlPSR7cmV1c2FibGV9IHN0YXR1cz0ke3N0YXR1c30gc3VzcGVuZD0ke3N1c3BlbmR9YDtcbiAgICAgICAgICAgIHRoaXMuY29uc29sZS5sb2coYCR7cHJlZml4fVtULiR7bWV0aG9kfV0gJHtpbmZvfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IHZhciBUYXNrUXVldWVQcmlvcml0eTtcbihmdW5jdGlvbiAoVGFza1F1ZXVlUHJpb3JpdHkpIHtcbiAgICBUYXNrUXVldWVQcmlvcml0eVtUYXNrUXVldWVQcmlvcml0eVtcInJlbmRlclwiXSA9IDBdID0gXCJyZW5kZXJcIjtcbiAgICBUYXNrUXVldWVQcmlvcml0eVtUYXNrUXVldWVQcmlvcml0eVtcIm1hY3JvVGFza1wiXSA9IDFdID0gXCJtYWNyb1Rhc2tcIjtcbiAgICBUYXNrUXVldWVQcmlvcml0eVtUYXNrUXVldWVQcmlvcml0eVtcInBvc3RSZW5kZXJcIl0gPSAyXSA9IFwicG9zdFJlbmRlclwiO1xufSkoVGFza1F1ZXVlUHJpb3JpdHkgfHwgKFRhc2tRdWV1ZVByaW9yaXR5ID0ge30pKTtcbmNvbnN0IGRlZmF1bHRRdWV1ZVRhc2tPcHRpb25zID0ge1xuICAgIGRlbGF5OiAwLFxuICAgIHByZWVtcHQ6IGZhbHNlLFxuICAgIHBlcnNpc3RlbnQ6IGZhbHNlLFxuICAgIHJldXNhYmxlOiB0cnVlLFxuICAgIHN1c3BlbmQ6IGZhbHNlLFxufTtcbmxldCAkcmVzb2x2ZTtcbmxldCAkcmVqZWN0O1xuZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgJHJlc29sdmUgPSByZXNvbHZlO1xuICAgICRyZWplY3QgPSByZWplY3Q7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGNyZWF0ZSBhIHByb21pc2Ugd2hlcmUgdGhlIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zIGFyZSBzdG9yZWQgYXMgcHJvcGVydGllcyBvbiB0aGUgcHJvbW1pc2UgaXRzZWxmLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFeHBvc2VkUHJvbWlzZSgpIHtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoZXhlY3V0b3IpO1xuICAgIHAucmVzb2x2ZSA9ICRyZXNvbHZlO1xuICAgIHAucmVqZWN0ID0gJHJlamVjdDtcbiAgICByZXR1cm4gcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjbGFzcyBDb25maWd1cmFibGVSb3V0ZSB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY2FzZVNlbnNpdGl2ZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFbmRwb2ludCB7XG4gICAgY29uc3RydWN0b3Iocm91dGUsIHBhcmFtTmFtZXMpIHtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB0aGlzLnBhcmFtTmFtZXMgPSBwYXJhbU5hbWVzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZWNvZ25pemVkUm91dGUge1xuICAgIGNvbnN0cnVjdG9yKGVuZHBvaW50LCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG59XG5jbGFzcyBDYW5kaWRhdGUge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJzLCBzdGF0ZXMsIHNraXBwZWRTdGF0ZXMsIHJlc3VsdCkge1xuICAgICAgICB0aGlzLmNoYXJzID0gY2hhcnM7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgICAgICB0aGlzLnNraXBwZWRTdGF0ZXMgPSBza2lwcGVkU3RhdGVzO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5oZWFkID0gc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRlZC1vcHRpb25hbC1jaGFpblxuICAgICAgICB0aGlzLmVuZHBvaW50ID0gdGhpcy5oZWFkPy5lbmRwb2ludDtcbiAgICB9XG4gICAgYWR2YW5jZShjaCkge1xuICAgICAgICBjb25zdCB7IGNoYXJzLCBzdGF0ZXMsIHNraXBwZWRTdGF0ZXMsIHJlc3VsdCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0YXRlVG9BZGQgPSBudWxsO1xuICAgICAgICBsZXQgbWF0Y2hDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZnVuY3Rpb24gJHByb2Nlc3MobmV4dFN0YXRlLCBza2lwcGVkU3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChuZXh0U3RhdGUuaXNNYXRjaChjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKyttYXRjaENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlVG9BZGQgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKG5ldyBDYW5kaWRhdGUoY2hhcnMuY29uY2F0KGNoKSwgc3RhdGVzLmNvbmNhdChuZXh0U3RhdGUpLCBza2lwcGVkU3RhdGUgPT09IG51bGwgPyBza2lwcGVkU3RhdGVzIDogc2tpcHBlZFN0YXRlcy5jb25jYXQoc2tpcHBlZFN0YXRlKSwgcmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLnNlZ21lbnQgPT09IG51bGwgJiYgbmV4dFN0YXRlLmlzT3B0aW9uYWwgJiYgbmV4dFN0YXRlLm5leHRTdGF0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLm5leHRTdGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmV4dFN0YXRlLm5leHRTdGF0ZXMubGVuZ3RofSBuZXh0U3RhdGVzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG5leHRTdGF0ZS5uZXh0U3RhdGVzWzBdO1xuICAgICAgICAgICAgICAgIGlmICghc2VwYXJhdG9yLmlzU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgc2VwYXJhdG9yYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubmV4dFN0YXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0ICRuZXh0U3RhdGUgb2Ygc2VwYXJhdG9yLm5leHRTdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwcm9jZXNzKCRuZXh0U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmlzRHluYW1pYykge1xuICAgICAgICAgICAgJHByb2Nlc3Moc3RhdGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5uZXh0U3RhdGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5leHRTdGF0ZSBvZiBzdGF0ZS5uZXh0U3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgJHByb2Nlc3MobmV4dFN0YXRlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGVUb0FkZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGVzLnB1c2godGhpcy5oZWFkID0gc3RhdGVUb0FkZCk7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGNoKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZVRvQWRkLmVuZHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludCA9IHN0YXRlVG9BZGQuZW5kcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbGxlY3RTa2lwcGVkU3RhdGVzKHNraXBwZWRTdGF0ZXMsIHN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0U3RhdGVzID0gc3RhdGUubmV4dFN0YXRlcztcbiAgICAgICAgICAgIGlmIChuZXh0U3RhdGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZXMubGVuZ3RoID09PSAxICYmIG5leHRTdGF0ZXNbMF0uc2VnbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0U2tpcHBlZFN0YXRlcyhza2lwcGVkU3RhdGVzLCBuZXh0U3RhdGVzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dFN0YXRlIG9mIG5leHRTdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUuaXNPcHRpb25hbCAmJiBuZXh0U3RhdGUuZW5kcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkU3RhdGVzLnB1c2gobmV4dFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLm5leHRTdGF0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCAkbmV4dFN0YXRlIG9mIG5leHRTdGF0ZS5uZXh0U3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0U2tpcHBlZFN0YXRlcyhza2lwcGVkU3RhdGVzLCAkbmV4dFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0U2tpcHBlZFN0YXRlcyh0aGlzLnNraXBwZWRTdGF0ZXMsIHRoaXMuaGVhZCk7XG4gICAgfVxuICAgIGdldFBhcmFtcygpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZXMsIGNoYXJzLCBlbmRwb2ludCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIC8vIEZpcnN0IGluaXRpYWxpemUgYWxsIHByb3BlcnRpZXMgd2l0aCB1bmRlZmluZWQgc28gdGhleSBhbGwgZXhpc3QgKGV2ZW4gaWYgdGhleSdyZSBub3QgZmlsbGVkLCBlLmcuIG5vbi1tYXRjaGVkIG9wdGlvbmFsIHBhcmFtcylcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGVuZHBvaW50LnBhcmFtTmFtZXMpIHtcbiAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHN0YXRlLnNlZ21lbnQubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW25hbWVdID0gY2hhcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV0gKz0gY2hhcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoaXMgY2FuZGlkYXRlIHRvIGFub3RoZXIgY2FuZGlkYXRlIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCBzb3J0aW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogVGhpcyBhbGdvcml0aG0gaXMgZGlmZmVyZW50IGZyb20gYHNvcnRTb2x1dGlvbnNgIGluIHYxJ3Mgcm91dGUtcmVjb2duaXplciBpbiB0aGF0IGl0IGNvbXBhcmVzXG4gICAgICogdGhlIGNhbmRpZGF0ZXMgc2VnbWVudC1ieS1zZWdtZW50LCByYXRoZXIgdGhhbiBtZXJlbHkgY29tcGFyaW5nIHRoZSBjdW11bGF0aXZlIG9mIHNlZ21lbnQgdHlwZXNcbiAgICAgKlxuICAgICAqIFRoaXMgcmVzb2x2ZXMgdjEncyBhbWJpZ3VpdHkgaW4gc2l0dWF0aW9ucyBsaWtlIGAvZm9vLzppZC9iYXJgIHZzLiBgL2Zvby9iYXIvOmlkYCwgd2hpY2ggaGFkIHRoZVxuICAgICAqIHNhbWUgc29ydGluZyB2YWx1ZSBiZWNhdXNlIHRoZXkgYm90aCBjb25zaXN0IG9mIHR3byBzdGF0aWMgc2VnbWVudHMgYW5kIG9uZSBkeW5hbWljIHNlZ21lbnQuXG4gICAgICpcbiAgICAgKiBXaXRoIHRoaXMgYWxnb3JpdGhtLCBgL2Zvby9iYXIvOmlkYCB3b3VsZCBhbHdheXMgYmUgc29ydGVkIGZpcnN0IGJlY2F1c2UgdGhlIHNlY29uZCBzZWdtZW50IGlzIGRpZmZlcmVudCxcbiAgICAgKiBhbmQgc3RhdGljIHdpbnMgb3ZlciBkeW5hbWljLlxuICAgICAqXG4gICAgICogIyMjIE5PVEVcbiAgICAgKiBUaGlzIGFsZ29yaXRobSB2aW9sYXRlcyBzb21lIG9mIHRoZSBpbnZhcmlhbnRzIG9mIHYxJ3MgYWxnb3JpdGhtLFxuICAgICAqIGJ1dCB0aG9zZSBpbnZhcmlhbnRzIHdlcmUgYXJndWFibHkgbm90IHZlcnkgc291bmQgdG8gYmVnaW4gd2l0aC4gRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGAvZm9vLypwYXRoL2Jhci9iYXpgIHZzLiBgL2Zvby9iYXIvKnBhdGgxLypwYXRoMmBcbiAgICAgKiAtIGluIHYxLCB0aGUgZmlyc3Qgd291bGQgd2luIGJlY2F1c2UgdGhhdCBtYXRjaCBoYXMgZmV3ZXIgc3RhcnNcbiAgICAgKiAtIGluIHYyLCB0aGUgc2Vjb25kIHdpbGwgd2luIGJlY2F1c2UgdGhlcmUgaXMgYSBiaWdnZXIgc3RhdGljIG1hdGNoIGF0IHRoZSBzdGFydCBvZiB0aGUgcGF0dGVyblxuICAgICAqXG4gICAgICogVGhlIGFsZ29yaXRobSBzaG91bGQgYmUgbW9yZSBsb2dpY2FsIGFuZCBlYXNpZXIgdG8gcmVhc29uIGFib3V0IGluIHYyLCBidXQgaXQncyBpbXBvcnRhbnQgdG8gYmUgYXdhcmUgb2ZcbiAgICAgKiBzdWJ0bGUgZGlmZmVyZW5jZSBsaWtlIHRoaXMgd2hpY2ggbWlnaHQgc3VycHJpc2Ugc29tZSB1c2VycyB3aG8gaGFwcGVuZWQgdG8gcmVseSBvbiB0aGlzIGJlaGF2aW9yIGZyb20gdjEsXG4gICAgICogaW50ZW50aW9uYWxseSBvciB1bmludGVudGlvbmFsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYiAtIFRoZSBjYW5kaWRhdGUgdG8gY29tcGFyZSB0aGlzIHRvLlxuICAgICAqIFBhcmFtZXRlciBuYW1lIGlzIGBiYCBiZWNhdXNlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgbGlrZSBzbzogYHN0YXRlcy5zb3J0KChhLCBiKSA9PiBhLmNvbXBhcmVUbyhiKSlgLlxuICAgICAqIFRoaXMgd2lsbCBicmluZyB0aGUgY2FuZGlkYXRlIHdpdGggdGhlIGhpZ2hlc3Qgc2NvcmUgdG8gdGhlIGZpcnN0IHBvc2l0aW9uIG9mIHRoZSBhcnJheS5cbiAgICAgKi9cbiAgICBjb21wYXJlVG8oYikge1xuICAgICAgICBjb25zdCBzdGF0ZXNBID0gdGhpcy5zdGF0ZXM7XG4gICAgICAgIGNvbnN0IHN0YXRlc0IgPSBiLnN0YXRlcztcbiAgICAgICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDAsIGlpID0gTWF0aC5tYXgoc3RhdGVzQS5sZW5ndGgsIHN0YXRlc0IubGVuZ3RoKTsgaUEgPCBpaTsgKytpQSkge1xuICAgICAgICAgICAgbGV0IHN0YXRlQSA9IHN0YXRlc0FbaUFdO1xuICAgICAgICAgICAgaWYgKHN0YXRlQSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhdGVCID0gc3RhdGVzQltpQl07XG4gICAgICAgICAgICBpZiAoc3RhdGVCID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2VnbWVudEEgPSBzdGF0ZUEuc2VnbWVudDtcbiAgICAgICAgICAgIGxldCBzZWdtZW50QiA9IHN0YXRlQi5zZWdtZW50O1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRBID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRCID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICsraUI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHN0YXRlQSA9IHN0YXRlc0FbKytpQV0pID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZ21lbnRBID0gc3RhdGVBLnNlZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWdtZW50QiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICgoc3RhdGVCID0gc3RhdGVzQlsrK2lCXSkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZ21lbnRCID0gc3RhdGVCLnNlZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudEEua2luZCA8IHNlZ21lbnRCLmtpbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50QS5raW5kID4gc2VnbWVudEIua2luZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraUI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2tpcHBlZFN0YXRlc0EgPSB0aGlzLnNraXBwZWRTdGF0ZXM7XG4gICAgICAgIGNvbnN0IHNraXBwZWRTdGF0ZXNCID0gYi5za2lwcGVkU3RhdGVzO1xuICAgICAgICBjb25zdCBza2lwcGVkU3RhdGVzQUxlbiA9IHNraXBwZWRTdGF0ZXNBLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2tpcHBlZFN0YXRlc0JMZW4gPSBza2lwcGVkU3RhdGVzQi5sZW5ndGg7XG4gICAgICAgIGlmIChza2lwcGVkU3RhdGVzQUxlbiA8IHNraXBwZWRTdGF0ZXNCTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcHBlZFN0YXRlc0FMZW4gPiBza2lwcGVkU3RhdGVzQkxlbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2tpcHBlZFN0YXRlc0FMZW47ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZFN0YXRlQSA9IHNraXBwZWRTdGF0ZXNBW2ldO1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZFN0YXRlQiA9IHNraXBwZWRTdGF0ZXNCW2ldO1xuICAgICAgICAgICAgaWYgKHNraXBwZWRTdGF0ZUEubGVuZ3RoIDwgc2tpcHBlZFN0YXRlQi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChza2lwcGVkU3RhdGVBLmxlbmd0aCA+IHNraXBwZWRTdGF0ZUIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgcG9zc2libGUgd2l0aCBhIHNpbmdsZSBwYXR0ZXJuIHdpdGggbXVsdGlwbGUgY29uc2VjdXRpdmUgc3RhciBzZWdtZW50cy5cbiAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgd2FudCB0byB3YXJuIG9yIGV2ZW4gdGhyb3cgaGVyZSwgYnV0IGxlYXZlIGl0IGJlIGZvciBub3cuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0VuZHBvaW50KGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiBjYW5kaWRhdGUuaGVhZC5lbmRwb2ludCAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVDaGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbn1cbmNsYXNzIFJlY29nbml6ZVJlc3VsdCB7XG4gICAgY29uc3RydWN0b3Iocm9vdFN0YXRlKSB7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZXMgPSBbbmV3IENhbmRpZGF0ZShbJyddLCBbcm9vdFN0YXRlXSwgW10sIHRoaXMpXTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBnZXRTb2x1dGlvbigpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuY2FuZGlkYXRlcy5maWx0ZXIoaGFzRW5kcG9pbnQpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5maW5hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbmRpZGF0ZXMuc29ydChjb21wYXJlQ2hhaW5zKTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF07XG4gICAgfVxuICAgIGFkZChjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy5jYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9XG4gICAgcmVtb3ZlKGNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZXMuc3BsaWNlKHRoaXMuY2FuZGlkYXRlcy5pbmRleE9mKGNhbmRpZGF0ZSksIDEpO1xuICAgIH1cbiAgICBhZHZhbmNlKGNoKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLmNhbmRpZGF0ZXMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICAgICAgY2FuZGlkYXRlLmFkdmFuY2UoY2gpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJvdXRlUmVjb2duaXplciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucm9vdFN0YXRlID0gbmV3IFN0YXRlKG51bGwsIG51bGwsICcnKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYWRkKHJvdXRlT3JSb3V0ZXMpIHtcbiAgICAgICAgaWYgKHJvdXRlT3JSb3V0ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZU9yUm91dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kYWRkKHJvdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGFkZChyb3V0ZU9yUm91dGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0aGUgY2FjaGUgd2hlbmV2ZXIgdGhlcmUgYXJlIHN0YXRlIGNoYW5nZXMsIGJlY2F1c2UgdGhlIHJlY29nbml6ZVJlc3VsdHMgY291bGQgYmUgYXJiaXRyYXJpbHkgZGlmZmVyZW50IGFzIGEgcmVzdWx0XG4gICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgJGFkZChyb3V0ZSkge1xuICAgICAgICBjb25zdCBwYXRoID0gcm91dGUucGF0aDtcbiAgICAgICAgY29uc3QgJHJvdXRlID0gbmV3IENvbmZpZ3VyYWJsZVJvdXRlKHJvdXRlLnBhdGgsIHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsIHJvdXRlLmhhbmRsZXIpO1xuICAgICAgICAvLyBOb3JtYWxpemUgbGVhZGluZywgdHJhaWxpbmcgYW5kIGRvdWJsZSBzbGFzaGVzIGJ5IGlnbm9yaW5nIGVtcHR5IHNlZ21lbnRzXG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aCA9PT0gJycgPyBbJyddIDogcGF0aC5zcGxpdCgnLycpLmZpbHRlcihpc05vdEVtcHR5KTtcbiAgICAgICAgY29uc3QgcGFyYW1OYW1lcyA9IFtdO1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnJvb3RTdGF0ZTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAvLyBFYWNoIHNlZ21lbnQgYWx3YXlzIGJlZ2lucyB3aXRoIGEgc2xhc2gsIHNvIHdlIHJlcHJlc2VudCB0aGlzIHdpdGggYSBub24tc2VnbWVudCBzdGF0ZVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hcHBlbmQobnVsbCwgJy8nKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICc6JzogeyAvLyByb3V0ZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNPcHRpb25hbCA9IHBhcnQuZW5kc1dpdGgoJz8nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGlzT3B0aW9uYWwgPyBwYXJ0LnNsaWNlKDEsIC0xKSA6IHBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBuZXcgRHluYW1pY1NlZ21lbnQobmFtZSwgaXNPcHRpb25hbCkuYXBwZW5kVG8oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6IHsgLy8gZHluYW1pYyByb3V0ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGFyU2VnbWVudChuYW1lKS5hcHBlbmRUbyhzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7IC8vIHN0YW5kYXJkIHBhdGggcm91dGVcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGljU2VnbWVudChwYXJ0LCAkcm91dGUuY2FzZVNlbnNpdGl2ZSkuYXBwZW5kVG8oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBuZXcgRW5kcG9pbnQoJHJvdXRlLCBwYXJhbU5hbWVzKTtcbiAgICAgICAgc3RhdGUuc2V0RW5kcG9pbnQoZW5kcG9pbnQpO1xuICAgIH1cbiAgICByZWNvZ25pemUocGF0aCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jYWNoZS5nZXQocGF0aCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgcmVzdWx0ID0gdGhpcy4kcmVjb2duaXplKHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAkcmVjb2duaXplKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcbiAgICAgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVjb2duaXplUmVzdWx0KHRoaXMucm9vdFN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHBhdGguY2hhckF0KGkpO1xuICAgICAgICAgICAgcmVzdWx0LmFkdmFuY2UoY2gpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gcmVzdWx0LmdldFNvbHV0aW9uKCk7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZW5kcG9pbnQgfSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gY2FuZGlkYXRlLmdldFBhcmFtcygpO1xuICAgICAgICByZXR1cm4gbmV3IFJlY29nbml6ZWRSb3V0ZShlbmRwb2ludCwgcGFyYW1zKTtcbiAgICB9XG59XG5jbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocHJldlN0YXRlLCBzZWdtZW50LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZXZTdGF0ZSA9IHByZXZTdGF0ZTtcbiAgICAgICAgdGhpcy5zZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5leHRTdGF0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChzZWdtZW50Py5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogZHluYW1pYyAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHByZXZTdGF0ZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTZXBhcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gc2VnbWVudC5vcHRpb25hbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBzdGFyICovOlxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gcHJldlN0YXRlLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NlcGFyYXRvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBzdGF0aWMgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBwcmV2U3RhdGUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gcHJldlN0YXRlID09PSBudWxsID8gMCA6IHByZXZTdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NlcGFyYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQoc2VnbWVudCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHN0YXRlO1xuICAgICAgICBsZXQgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcztcbiAgICAgICAgaWYgKG5leHRTdGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlID0gdm9pZCAwO1xuICAgICAgICAgICAgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlID0gbmV4dFN0YXRlcy5maW5kKHMgPT4gcy52YWx1ZSA9PT0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBuZXh0U3RhdGVzLmZpbmQocyA9PiBzLnNlZ21lbnQ/LmVxdWFscyhzZWdtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZXMucHVzaChzdGF0ZSA9IG5ldyBTdGF0ZSh0aGlzLCBzZWdtZW50LCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgc2V0RW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFkZCBhbWJpZ3VvdXMgcm91dGUuIFRoZSBwYXR0ZXJuICcke2VuZHBvaW50LnJvdXRlLnBhdGh9JyBjbGFzaGVzIHdpdGggJyR7dGhpcy5lbmRwb2ludC5yb3V0ZS5wYXRofSdgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIGlmICh0aGlzLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRoaXMucHJldlN0YXRlLnNldEVuZHBvaW50KGVuZHBvaW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZTdGF0ZS5pc1NlcGFyYXRvciAmJiB0aGlzLnByZXZTdGF0ZS5wcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTdGF0ZS5wcmV2U3RhdGUuc2V0RW5kcG9pbnQoZW5kcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlzTWF0Y2goY2gpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuc2VnbWVudDtcbiAgICAgICAgc3dpdGNoIChzZWdtZW50Py5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogZHluYW1pYyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMudmFsdWUuaW5jbHVkZXMoY2gpO1xuICAgICAgICAgICAgY2FzZSAxIC8qIHN0YXIgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDMgLyogc3RhdGljICovOlxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudCBzZXBhcmF0b3JzIChzbGFzaGVzKSBhcmUgbm9uLXNlZ21lbnRzLiBXZSBjb3VsZCBzYXkgcmV0dXJuIGNoID09PSAnLycgYXMgd2VsbCwgdGVjaG5pY2FsbHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuaW5jbHVkZXMoY2gpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOb3RFbXB0eShzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMDtcbn1cbnZhciBTZWdtZW50S2luZDtcbihmdW5jdGlvbiAoU2VnbWVudEtpbmQpIHtcbiAgICBTZWdtZW50S2luZFtTZWdtZW50S2luZFtcInN0YXJcIl0gPSAxXSA9IFwic3RhclwiO1xuICAgIFNlZ21lbnRLaW5kW1NlZ21lbnRLaW5kW1wiZHluYW1pY1wiXSA9IDJdID0gXCJkeW5hbWljXCI7XG4gICAgU2VnbWVudEtpbmRbU2VnbWVudEtpbmRbXCJzdGF0aWNcIl0gPSAzXSA9IFwic3RhdGljXCI7XG59KShTZWdtZW50S2luZCB8fCAoU2VnbWVudEtpbmQgPSB7fSkpO1xuY2xhc3MgU3RhdGljU2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIGNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlO1xuICAgIH1cbiAgICBnZXQga2luZCgpIHsgcmV0dXJuIDMgLyogc3RhdGljICovOyB9XG4gICAgYXBwZW5kVG8oc3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgdmFsdWU6IHsgbGVuZ3RoIH0gfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFwcGVuZChcbiAgICAgICAgICAgICAgICAvKiBzZWdtZW50ICovIHRoaXMsIFxuICAgICAgICAgICAgICAgIC8qIHZhbHVlICAgKi8gdmFsdWUuY2hhckF0KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHZhbHVlLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFwcGVuZChcbiAgICAgICAgICAgICAgICAvKiBzZWdtZW50ICovIHRoaXMsIFxuICAgICAgICAgICAgICAgIC8qIHZhbHVlICAgKi8gY2gudG9VcHBlckNhc2UoKSArIGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZXF1YWxzKGIpIHtcbiAgICAgICAgcmV0dXJuIChiLmtpbmQgPT09IDMgLyogc3RhdGljICovICYmXG4gICAgICAgICAgICBiLmNhc2VTZW5zaXRpdmUgPT09IHRoaXMuY2FzZVNlbnNpdGl2ZSAmJlxuICAgICAgICAgICAgYi52YWx1ZSA9PT0gdGhpcy52YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgRHluYW1pY1NlZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbmFsKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICB9XG4gICAgZ2V0IGtpbmQoKSB7IHJldHVybiAyIC8qIGR5bmFtaWMgKi87IH1cbiAgICBhcHBlbmRUbyhzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YXRlLmFwcGVuZChcbiAgICAgICAgLyogc2VnbWVudCAqLyB0aGlzLCBcbiAgICAgICAgLyogdmFsdWUgICAqLyAnLycpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGVxdWFscyhiKSB7XG4gICAgICAgIHJldHVybiAoYi5raW5kID09PSAyIC8qIGR5bmFtaWMgKi8gJiZcbiAgICAgICAgICAgIGIub3B0aW9uYWwgPT09IHRoaXMub3B0aW9uYWwgJiZcbiAgICAgICAgICAgIGIubmFtZSA9PT0gdGhpcy5uYW1lKTtcbiAgICB9XG59XG5jbGFzcyBTdGFyU2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBnZXQga2luZCgpIHsgcmV0dXJuIDEgLyogc3RhciAqLzsgfVxuICAgIGFwcGVuZFRvKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdGUuYXBwZW5kKFxuICAgICAgICAvKiBzZWdtZW50ICovIHRoaXMsIFxuICAgICAgICAvKiB2YWx1ZSAgICovICcnKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBlcXVhbHMoYikge1xuICAgICAgICByZXR1cm4gKGIua2luZCA9PT0gMSAvKiBzdGFyICovICYmXG4gICAgICAgICAgICBiLm5hbWUgPT09IHRoaXMubmFtZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gZXhwb3J0IGNsYXNzIE9wZW5Qcm9taXNlPFQ+IHtcbi8vICAgcHVibGljIGlzUGVuZGluZzogYm9vbGVhbiA9IHRydWU7XG4vLyAgIHB1YmxpYyBwcm9taXNlITogUHJvbWlzZTxUPjtcbi8vICAgcHVibGljIHJlc29sdmUhOiAodmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZDtcbi8vICAgcHVibGljIHJlamVjdCE6ICgpID0+IHZvaWQ7XG4vLyB9XG5pbXBvcnQgeyBPcGVuUHJvbWlzZSB9IGZyb20gJy4vb3Blbi1wcm9taXNlLmpzJztcbmV4cG9ydCBjbGFzcyBBd2FpdGFibGVNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb3BlblByb21pc2UgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG9wZW5Qcm9taXNlIGluc3RhbmNlb2YgT3BlblByb21pc2UpIHtcbiAgICAgICAgICAgIG9wZW5Qcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgLy8gb3BlblByb21pc2UuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBPcGVuUHJvbWlzZSkge1xuICAgICAgICAgICAgY3VycmVudC5yZWplY3QoKTtcbiAgICAgICAgICAgIC8vIGN1cnJlbnQuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGF3YWl0KGtleSkge1xuICAgICAgICBpZiAoIXRoaXMubWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuUHJvbWlzZSA9IG5ldyBPcGVuUHJvbWlzZSgpO1xuICAgICAgICAgICAgLy8gb3BlblByb21pc2UucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgLy8gICBvcGVuUHJvbWlzZS5yZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgLy8gICBvcGVuUHJvbWlzZS5yZWplY3QgPSByZWo7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChrZXksIG9wZW5Qcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiBvcGVuUHJvbWlzZS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBPcGVuUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleSkgJiYgISh0aGlzLm1hcC5nZXQoa2V5KSBpbnN0YW5jZW9mIE9wZW5Qcm9taXNlKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEF3YWl0YWJsZU1hcCgpO1xuICAgICAgICBjbG9uZS5tYXAgPSBuZXcgTWFwKHRoaXMubWFwKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF3YWl0YWJsZS1tYXAuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBJV2luZG93LCBJSGlzdG9yeSwgSUxvY2F0aW9uLCBJUGxhdGZvcm0gfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgVGFza1F1ZXVlIH0gZnJvbSAnLi90YXNrLXF1ZXVlLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xubGV0IEJyb3dzZXJWaWV3ZXJTdG9yZSA9IGNsYXNzIEJyb3dzZXJWaWV3ZXJTdG9yZSB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm0sIHdpbmRvdywgaGlzdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayA9IDI7IC8vIExpbWl0IG5vIG9mIGV4ZWN1dGVkIGFjdGlvbnMgd2l0aGluIHRoZSBzYW1lIFJBRiAoZHVlIHRvIGJyb3dzZXIgbGltaXRhdGlvbilcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1c2VVcmxGcmFnbWVudEhhc2g6IHRydWUsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4geyByZXR1cm47IH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9yd2FyZGVkU3RhdGUgPSB7IGV2ZW50VGFzazogbnVsbCwgc3VwcHJlc3NQb3BzdGF0ZTogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3BzdGF0ZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBldmVudFRhc2ssIHN1cHByZXNzUG9wc3RhdGUgfSA9IHRoaXMuZm9yd2FyZGVkU3RhdGU7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRlZFN0YXRlID0geyBldmVudFRhc2s6IG51bGwsIHN1cHByZXNzUG9wc3RhdGU6IGZhbHNlIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nQ2FsbHMuZW5xdWV1ZShhc3luYyAodGFzaykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCBldiA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2VGFzayA9IGV2ZW50VGFzaztcbiAgICAgICAgICAgICAgICBjb25zdCBzdXBwcmVzc1BvcHN0YXRlRXZlbnQgPSBzdXBwcmVzc1BvcHN0YXRlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0b3JlLnBvcHN0YXRlKGV2LCBldlRhc2ssIHN1cHByZXNzUG9wc3RhdGVFdmVudCk7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCAxKS53YWl0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbGxzID0gbmV3IFRhc2tRdWV1ZSgpO1xuICAgIH1cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgbmF2aWdhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICAgICAgaWYgKG9wdGlvbnMudXNlVXJsRnJhZ21lbnRIYXNoICE9IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVzZVVybEZyYWdtZW50SGFzaCA9IG9wdGlvbnMudXNlVXJsRnJhZ21lbnRIYXNoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbGxzLnN0YXJ0KHsgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sIGFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljazogdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgfSk7XG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5oYW5kbGVQb3BzdGF0ZSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIG5hdmlnYXRpb24gaGFzIG5vdCBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wc3RhdGUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdDYWxscy5zdG9wKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgdXNlVXJsRnJhZ21lbnRIYXNoOiB0cnVlLCBjYWxsYmFjazogKCkgPT4geyByZXR1cm47IH0gfTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaXN0b3J5Lmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaXN0b3J5LnN0YXRlO1xuICAgIH1cbiAgICBnZXQgdmlld2VyU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9ID0gdGhpcy5sb2NhdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnk6IHNlYXJjaCxcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBpbnN0cnVjdGlvbjogdGhpcy5vcHRpb25zLnVzZVVybEZyYWdtZW50SGFzaCA/IGhhc2guc2xpY2UoMSkgOiBwYXRobmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ28oZGVsdGEsIHN1cHByZXNzUG9wc3RhdGVFdmVudCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGRvbmVUYXNrID0gdGhpcy5wZW5kaW5nQ2FsbHMuY3JlYXRlUXVldWVUYXNrKCh0YXNrKSA9PiB0YXNrLnJlc29sdmUoKSwgMSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbGxzLmVucXVldWUoW1xuICAgICAgICAgICAgKHRhc2spID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRUYXNrID0gZG9uZVRhc2s7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VwcHJlc3NQb3BzdGF0ZSA9IHN1cHByZXNzUG9wc3RhdGVFdmVudDtcbiAgICAgICAgICAgICAgICBzdG9yZS5mb3J3YXJkU3RhdGUoeyBldmVudFRhc2ssIHN1cHByZXNzUG9wc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKHRhc2spID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBzID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgaGlzdG9yeS5nbyhzdGVwcyk7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICBdLCBbMCwgMV0pO1xuICAgICAgICByZXR1cm4gZG9uZVRhc2sud2FpdCgpO1xuICAgIH1cbiAgICBhc3luYyBwdXNoTmF2aWdhdG9yU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyB0aXRsZSwgcGF0aCB9ID0gc3RhdGUuY3VycmVudEVudHJ5O1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMub3B0aW9ucy51c2VVcmxGcmFnbWVudEhhc2ggPyAnIy8nIDogJyc7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdDYWxscy5lbnF1ZXVlKCh0YXNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdGl0bGVPckVtcHR5ID0gdGl0bGUgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtmcmFnbWVudH0ke3BhdGh9YDtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKGRhdGEsIHRpdGxlT3JFbXB0eSwgdXJsKTtcbiAgICAgICAgICAgIHRhc2sucmVzb2x2ZSgpO1xuICAgICAgICB9LCAxKS53YWl0KCk7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VOYXZpZ2F0b3JTdGF0ZShzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IHRpdGxlLCBwYXRoIH0gPSBzdGF0ZS5jdXJyZW50RW50cnk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5vcHRpb25zLnVzZVVybEZyYWdtZW50SGFzaCA/ICcjLycgOiAnJztcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0NhbGxzLmVucXVldWUoKHRhc2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcnkgPSB0aGlzLmhpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB0aXRsZU9yRW1wdHkgPSB0aXRsZSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke2ZyYWdtZW50fSR7cGF0aH1gO1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoZGF0YSwgdGl0bGVPckVtcHR5LCB1cmwpO1xuICAgICAgICAgICAgdGFzay5yZXNvbHZlKCk7XG4gICAgICAgIH0sIDEpLndhaXQoKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wTmF2aWdhdG9yU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGRvbmVUYXNrID0gdGhpcy5wZW5kaW5nQ2FsbHMuY3JlYXRlUXVldWVUYXNrKCh0YXNrKSA9PiB0YXNrLnJlc29sdmUoKSwgMSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbGxzLmVucXVldWUoYXN5bmMgKHRhc2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFzayA9IGRvbmVUYXNrO1xuICAgICAgICAgICAgYXdhaXQgc3RvcmUucG9wU3RhdGUoZXZlbnRUYXNrKTtcbiAgICAgICAgICAgIHRhc2sucmVzb2x2ZSgpO1xuICAgICAgICB9LCAxKTtcbiAgICAgICAgcmV0dXJuIGRvbmVUYXNrLndhaXQoKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wU3RhdGUoZG9uZVRhc2spIHtcbiAgICAgICAgYXdhaXQgdGhpcy5nbygtMSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5oaXN0b3J5LnN0YXRlO1xuICAgICAgICAvLyBUT0RPOiBGaXggYnJvd3NlciBmb3J3YXJkIGJ1ZyBhZnRlciBwb3Agb24gZmlyc3QgZW50cnlcbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLmN1cnJlbnRFbnRyeSAmJiAhc3RhdGUuY3VycmVudEVudHJ5LmZpcnN0RW50cnkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ28oLTEsIHRydWUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoTmF2aWdhdG9yU3RhdGUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGRvbmVUYXNrLmV4ZWN1dGUoKTtcbiAgICB9XG4gICAgZm9yd2FyZFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZGVkU3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgYXN5bmMgcG9wc3RhdGUoZXYsIGV2ZW50VGFzaywgc3VwcHJlc3NQb3BzdGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghc3VwcHJlc3NQb3BzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnZpZXdlclN0YXRlLFxuICAgICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5oaXN0b3J5LnN0YXRlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCBldmVudFRhc2suZXhlY3V0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFRpdGxlKHRpdGxlKSB7XG4gICAgICAgIHRoaXMud2luZG93LmRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gICAgfVxufTtcbkJyb3dzZXJWaWV3ZXJTdG9yZSA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgSVBsYXRmb3JtKSxcbiAgICBfX3BhcmFtKDEsIElXaW5kb3cpLFxuICAgIF9fcGFyYW0oMiwgSUhpc3RvcnkpLFxuICAgIF9fcGFyYW0oMywgSUxvY2F0aW9uKVxuXSwgQnJvd3NlclZpZXdlclN0b3JlKTtcbmV4cG9ydCB7IEJyb3dzZXJWaWV3ZXJTdG9yZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci12aWV3ZXItc3RvcmUuanMubWFwIiwiaW1wb3J0IHsgYXJyYXlSZW1vdmUgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gSGVscGVyIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IC0xO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLmN1cnJlbnRJbmRleCArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWysrdGhpcy5jdXJyZW50SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAtMTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUN1cnJlbnQoKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKHRoaXMuY3VycmVudEluZGV4LS0sIDEpO1xuICAgIH1cbiAgICByZW1vdmUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgYXJyYXlSZW1vdmUodGhpcywgdmFsdWUgPT4gdmFsdWUgPT09IGluc3RydWN0aW9uKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEFwcFRhc2sgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgTmF2Q3VzdG9tRWxlbWVudCB9IGZyb20gJy4vcmVzb3VyY2VzL25hdi5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3Jlc291cmNlcy92aWV3cG9ydC5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCB9IGZyb20gJy4vcmVzb3VyY2VzL3ZpZXdwb3J0LXNjb3BlLmpzJztcbmltcG9ydCB7IEdvdG9DdXN0b21BdHRyaWJ1dGUgfSBmcm9tICcuL3Jlc291cmNlcy9nb3RvLmpzJztcbmltcG9ydCB7IExvYWRDdXN0b21BdHRyaWJ1dGUgfSBmcm9tICcuL3Jlc291cmNlcy9sb2FkLmpzJztcbmltcG9ydCB7IEhyZWZDdXN0b21BdHRyaWJ1dGUgfSBmcm9tICcuL3Jlc291cmNlcy9ocmVmLmpzJztcbmltcG9ydCB7IElSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci5qcyc7XG5leHBvcnQgY29uc3QgUm91dGVyUmVnaXN0cmF0aW9uID0gSVJvdXRlcjtcbi8qKlxuICogRGVmYXVsdCBydW50aW1lL2Vudmlyb25tZW50LWFnbm9zdGljIGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBpbnRlcmZhY2VzOlxuICogLSBgSVJvdXRlcmBcbiAqL1xuZXhwb3J0IGNvbnN0IERlZmF1bHRDb21wb25lbnRzID0gW1xuICAgIFJvdXRlclJlZ2lzdHJhdGlvbixcbl07XG5leHBvcnQgeyBWaWV3cG9ydEN1c3RvbUVsZW1lbnQsIFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50LCBOYXZDdXN0b21FbGVtZW50LCBHb3RvQ3VzdG9tQXR0cmlidXRlLCBMb2FkQ3VzdG9tQXR0cmlidXRlLCBIcmVmQ3VzdG9tQXR0cmlidXRlLCB9O1xuZXhwb3J0IGNvbnN0IFZpZXdwb3J0Q3VzdG9tRWxlbWVudFJlZ2lzdHJhdGlvbiA9IFZpZXdwb3J0Q3VzdG9tRWxlbWVudDtcbmV4cG9ydCBjb25zdCBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudFJlZ2lzdHJhdGlvbiA9IFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50O1xuZXhwb3J0IGNvbnN0IE5hdkN1c3RvbUVsZW1lbnRSZWdpc3RyYXRpb24gPSBOYXZDdXN0b21FbGVtZW50O1xuZXhwb3J0IGNvbnN0IEdvdG9DdXN0b21BdHRyaWJ1dGVSZWdpc3RyYXRpb24gPSBHb3RvQ3VzdG9tQXR0cmlidXRlO1xuZXhwb3J0IGNvbnN0IExvYWRDdXN0b21BdHRyaWJ1dGVSZWdpc3RyYXRpb24gPSBMb2FkQ3VzdG9tQXR0cmlidXRlO1xuZXhwb3J0IGNvbnN0IEhyZWZDdXN0b21BdHRyaWJ1dGVSZWdpc3RyYXRpb24gPSBIcmVmQ3VzdG9tQXR0cmlidXRlO1xuLyoqXG4gKiBEZWZhdWx0IHJvdXRlciByZXNvdXJjZXM6XG4gKiAtIEN1c3RvbSBFbGVtZW50czogYGF1LXZpZXdwb3J0YCwgYGF1LW5hdmBcbiAqIC0gQ3VzdG9tIEF0dHJpYnV0ZXM6IGBnb3RvYCwgYGxvYWRgLCBgaHJlZmBcbiAqL1xuZXhwb3J0IGNvbnN0IERlZmF1bHRSZXNvdXJjZXMgPSBbXG4gICAgVmlld3BvcnRDdXN0b21FbGVtZW50LFxuICAgIFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50LFxuICAgIE5hdkN1c3RvbUVsZW1lbnQsXG4gICAgR290b0N1c3RvbUF0dHJpYnV0ZSxcbiAgICBMb2FkQ3VzdG9tQXR0cmlidXRlLFxuICAgIEhyZWZDdXN0b21BdHRyaWJ1dGUsXG5dO1xubGV0IGNvbmZpZ3VyYXRpb25PcHRpb25zID0ge307XG5sZXQgY29uZmlndXJhdGlvbkNhbGwgPSAocm91dGVyKSA9PiB7XG4gICAgcm91dGVyLnN0YXJ0KGNvbmZpZ3VyYXRpb25PcHRpb25zKTtcbn07XG4vKipcbiAqIEEgREkgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyByb3V0ZXIgcmVzb3VyY2UgcmVnaXN0cmF0aW9ucy5cbiAqL1xuY29uc3Qgcm91dGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGNvbmZpZ3VyYXRpb24gdG8gdGhlIHByb3ZpZGVkIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5yZWdpc3RlciguLi5EZWZhdWx0Q29tcG9uZW50cywgLi4uRGVmYXVsdFJlc291cmNlcywgQXBwVGFzay53aXRoKElSb3V0ZXIpLmJlZm9yZUFjdGl2YXRlKCkuY2FsbChjb25maWd1cmF0aW9uQ2FsbCksIEFwcFRhc2sud2l0aChJUm91dGVyKS5hZnRlckFjdGl2YXRlKCkuY2FsbChyb3V0ZXIgPT4gcm91dGVyLmxvYWRVcmwoKSksIEFwcFRhc2sud2l0aChJUm91dGVyKS5hZnRlckRlYWN0aXZhdGUoKS5jYWxsKHJvdXRlciA9PiByb3V0ZXIuc3RvcCgpKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29udGFpbmVyIHdpdGggdGhpcyBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gaXQuXG4gICAgICovXG4gICAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlcihESS5jcmVhdGVDb250YWluZXIoKSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBSb3V0ZXJDb25maWd1cmF0aW9uID0ge1xuICAgIC8qKlxuICAgICAqIE1ha2UgaXQgcG9zc2libGUgdG8gc3BlY2lmeSBvcHRpb25zIHRvIFJvdXRlciBhY3RpdmF0aW9uLlxuICAgICAqIFBhcmFtZXRlciBpcyBlaXRoZXIgYSBjb25maWcgb2JqZWN0IHRoYXQncyBwYXNzZWQgdG8gUm91dGVyJ3Mgc3RhcnRcbiAgICAgKiBvciBhIGNvbmZpZyBmdW5jdGlvbiB0aGF0J3MgY2FsbGVkIGluc3RlYWQgb2YgUm91dGVyJ3Mgc3RhcnQuXG4gICAgICovXG4gICAgY3VzdG9taXplKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25PcHRpb25zID0ge307XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uQ2FsbCA9IChyb3V0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICByb3V0ZXIuc3RhcnQoY29uZmlndXJhdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbkNhbGwgPSBjb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uT3B0aW9ucyA9IGNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5yb3V0ZXJDb25maWd1cmF0aW9uIH07XG4gICAgfSxcbiAgICAuLi5yb3V0ZXJDb25maWd1cmF0aW9uLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZ3VyYXRpb24uanMubWFwIiwiLyoqXG4gKiBAaW50ZXJuYWwgLSBVc2VkIHdoZW4gZm91bmRpbmcgcm91dGUvaW5zdHJ1Y3Rpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3VuZFJvdXRlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXRjaCA9IG51bGwsIG1hdGNoaW5nID0gJycsIGluc3RydWN0aW9ucyA9IFtdLCByZW1haW5pbmcgPSAnJywgXG4gICAgLy8gcHVibGljIHJlbWFpbmluZzogc3RyaW5nIHwgbnVsbCA9IG51bGwsXG4gICAgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgICAgICB0aGlzLm1hdGNoaW5nID0gbWF0Y2hpbmc7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuICAgIGdldCBmb3VuZENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoICE9PSBudWxsO1xuICAgIH1cbiAgICBnZXQgZm91bmRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgaGFzUmVtYWluaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmcgIT09IG51bGwgJiYgdGhpcy5yZW1haW5pbmcubGVuZ3RoID4gMDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3VuZC1yb3V0ZS5qcy5tYXAiLCJpbXBvcnQgeyBIb29rIH0gZnJvbSAnLi9ob29rLmpzJztcbi8qKlxuICogUHVibGljIEFQSVxuICovXG5leHBvcnQgdmFyIEhvb2tUeXBlcztcbihmdW5jdGlvbiAoSG9va1R5cGVzKSB7XG4gICAgSG9va1R5cGVzW1wiQmVmb3JlTmF2aWdhdGlvblwiXSA9IFwiYmVmb3JlTmF2aWdhdGlvblwiO1xuICAgIEhvb2tUeXBlc1tcIlRyYW5zZm9ybUZyb21VcmxcIl0gPSBcInRyYW5zZm9ybUZyb21VcmxcIjtcbiAgICBIb29rVHlwZXNbXCJUcmFuc2Zvcm1Ub1VybFwiXSA9IFwidHJhbnNmb3JtVG9VcmxcIjtcbiAgICBIb29rVHlwZXNbXCJTZXRUaXRsZVwiXSA9IFwic2V0VGl0bGVcIjtcbn0pKEhvb2tUeXBlcyB8fCAoSG9va1R5cGVzID0ge30pKTtcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IGNsYXNzIEhvb2tNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IHtcbiAgICAgICAgICAgIGJlZm9yZU5hdmlnYXRpb246IFtdLFxuICAgICAgICAgICAgdHJhbnNmb3JtRnJvbVVybDogW10sXG4gICAgICAgICAgICB0cmFuc2Zvcm1Ub1VybDogW10sXG4gICAgICAgICAgICBzZXRUaXRsZTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGFzdElkZW50aXR5ID0gMDtcbiAgICB9XG4gICAgYWRkSG9vayhob29rRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaG9vayA9IG5ldyBIb29rKGhvb2tGdW5jdGlvbiwgb3B0aW9ucyB8fCB7fSwgKyt0aGlzLmxhc3RJZGVudGl0eSk7XG4gICAgICAgIHRoaXMuaG9va3NbaG9vay50eXBlXS5wdXNoKGhvb2spO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0SWRlbnRpdHk7XG4gICAgfVxuICAgIHJlbW92ZUhvb2soaWQpIHtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIGluIHRoaXMuaG9va3MpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ob29rcywgdHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaG9va3NbdHlwZV0uZmluZEluZGV4KGhvb2sgPT4gaG9vay5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9va3NbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlQmVmb3JlTmF2aWdhdGlvbih2aWV3cG9ydEluc3RydWN0aW9ucywgbmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludm9rZShcImJlZm9yZU5hdmlnYXRpb25cIiAvKiBCZWZvcmVOYXZpZ2F0aW9uICovLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24sIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlVHJhbnNmb3JtRnJvbVVybCh1cmwsIG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UoXCJ0cmFuc2Zvcm1Gcm9tVXJsXCIgLyogVHJhbnNmb3JtRnJvbVVybCAqLywgbmF2aWdhdGlvbkluc3RydWN0aW9uLCB1cmwpO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2VUcmFuc2Zvcm1Ub1VybChzdGF0ZSwgbmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludm9rZShcInRyYW5zZm9ybVRvVXJsXCIgLyogVHJhbnNmb3JtVG9VcmwgKi8sIG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgc3RhdGUpO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2VTZXRUaXRsZSh0aXRsZSwgbmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludm9rZShcInNldFRpdGxlXCIgLyogU2V0VGl0bGUgKi8sIG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgdGl0bGUpO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UodHlwZSwgbmF2aWdhdGlvbkluc3RydWN0aW9uLCBhcmcpIHtcbiAgICAgICAgZm9yIChjb25zdCBob29rIG9mIHRoaXMuaG9va3NbdHlwZV0pIHtcbiAgICAgICAgICAgIGlmICghaG9vay53YW50c01hdGNoIHx8IGhvb2subWF0Y2hlcyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IGhvb2suaW52b2tlKG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG91dGNvbWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW91dGNvbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gb3V0Y29tZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rLW1hbmFnZXIuanMubWFwIiwiaW1wb3J0IHsgQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlciwgVmlld3BvcnRIYW5kbGVSZXNvbHZlciB9IGZyb20gJy4vdHlwZS1yZXNvbHZlcnMuanMnO1xuaW1wb3J0IHsgVmlld3BvcnRJbnN0cnVjdGlvbiB9IGZyb20gJy4vdmlld3BvcnQtaW5zdHJ1Y3Rpb24uanMnO1xuLyoqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuICovXG5leHBvcnQgY2xhc3MgSG9vayB7XG4gICAgY29uc3RydWN0b3IoaG9vaywgb3B0aW9ucywgaWQpIHtcbiAgICAgICAgdGhpcy5ob29rID0gaG9vaztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnR5cGUgPSBcImJlZm9yZU5hdmlnYXRpb25cIiAvKiBCZWZvcmVOYXZpZ2F0aW9uICovO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYXJnZXRzID0gW107XG4gICAgICAgIHRoaXMuZXhjbHVkZVRhcmdldHMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2Ygb3B0aW9ucy5pbmNsdWRlIHx8IFtdKSB7XG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYXJnZXRzLnB1c2gobmV3IFRhcmdldCh0YXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBvcHRpb25zLmV4Y2x1ZGUgfHwgW10pIHtcbiAgICAgICAgICAgIHRoaXMuZXhjbHVkZVRhcmdldHMucHVzaChuZXcgVGFyZ2V0KHRhcmdldCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB3YW50c01hdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmNsdWRlVGFyZ2V0cy5sZW5ndGggPiAwIHx8IHRoaXMuZXhjbHVkZVRhcmdldHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgbWF0Y2hlcyh2aWV3cG9ydEluc3RydWN0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFyZ2V0cy5sZW5ndGggJiYgIXRoaXMuaW5jbHVkZVRhcmdldHMuc29tZSh0YXJnZXQgPT4gdGFyZ2V0Lm1hdGNoZXModmlld3BvcnRJbnN0cnVjdGlvbnMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYXJnZXRzLmxlbmd0aCAmJiB0aGlzLmV4Y2x1ZGVUYXJnZXRzLnNvbWUodGFyZ2V0ID0+IHRhcmdldC5tYXRjaGVzKHZpZXdwb3J0SW5zdHJ1Y3Rpb25zKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW52b2tlKG5hdmlnYXRpb25JbnN0cnVjdGlvbiwgYXJnKSB7XG4gICAgICAgIC8vIFRPRE86IEZpeCB0aGUgdHlwZSBoZXJlXG4gICAgICAgIHJldHVybiB0aGlzLmhvb2soYXJnLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbn1cbmNsYXNzIFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXdwb3J0TmFtZSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnROYW1lID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNUeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TmFtZSA9IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0TmFtZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3ZUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAoY3ZUYXJnZXQuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc1R5cGUoY3ZUYXJnZXQuY29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICA/IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0VHlwZShjdlRhcmdldC5jb21wb25lbnQpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmdldE5hbWUoY3ZUYXJnZXQuY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdlRhcmdldC52aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSBWaWV3cG9ydEhhbmRsZVJlc29sdmVyLmlzSW5zdGFuY2UoY3ZUYXJnZXQudmlld3BvcnQpID8gY3ZUYXJnZXQudmlld3BvcnQgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnROYW1lID0gVmlld3BvcnRIYW5kbGVSZXNvbHZlci5nZXROYW1lKGN2VGFyZ2V0LnZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaGVzKHZpZXdwb3J0SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG4gICAgICAgIGlmICghaW5zdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFZpZXdwb3J0SW5zdHJ1Y3Rpb24oJycpKTtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKFZpZXdwb3J0SW5zdHJ1Y3Rpb24uY3JlYXRlKG51bGwsICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICgodGhpcy5jb21wb25lbnROYW1lICE9PSBudWxsICYmIHRoaXMuY29tcG9uZW50TmFtZSA9PT0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5jb21wb25lbnRUeXBlICE9PSBudWxsICYmIHRoaXMuY29tcG9uZW50VHlwZSA9PT0gaW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZSkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy52aWV3cG9ydE5hbWUgIT09IG51bGwgJiYgdGhpcy52aWV3cG9ydE5hbWUgPT09IGluc3RydWN0aW9uLnZpZXdwb3J0TmFtZSkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy52aWV3cG9ydCAhPT0gbnVsbCAmJiB0aGlzLnZpZXdwb3J0ID09PSBpbnN0cnVjdGlvbi52aWV3cG9ydCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9vay5qcy5tYXAiLCJleHBvcnQgeyBMaW5rSGFuZGxlciwgfSBmcm9tICcuL2xpbmstaGFuZGxlci5qcyc7XG5leHBvcnQgeyBJbnN0cnVjdGlvblJlc29sdmVyLCB9IGZyb20gJy4vaW5zdHJ1Y3Rpb24tcmVzb2x2ZXIuanMnO1xuZXhwb3J0IHsgUmVlbnRyeUJlaGF2aW9yLCB9IGZyb20gJy4vaW50ZXJmYWNlcy5qcyc7XG5leHBvcnQgeyBsaWZlY3ljbGVMb2dnZXIsIExpZmVjeWNsZUNsYXNzLCB9IGZyb20gJy4vbGlmZWN5Y2xlLWxvZ2dlci5qcyc7XG5leHBvcnQgeyBIb29rTWFuYWdlciwgSG9va1R5cGVzLCB9IGZyb20gJy4vaG9vay1tYW5hZ2VyLmpzJztcbmV4cG9ydCB7IE5hdiwgfSBmcm9tICcuL25hdi5qcyc7XG5leHBvcnQgeyBOYXZSb3V0ZSwgfSBmcm9tICcuL25hdi1yb3V0ZS5qcyc7XG5leHBvcnQgeyBOYXZpZ2F0aW9uLCB9IGZyb20gJy4vbmF2aWdhdGlvbi5qcyc7XG5leHBvcnQgeyBOYXZpZ2F0b3IsIH0gZnJvbSAnLi9uYXZpZ2F0b3IuanMnO1xuZXhwb3J0IHsgUnVubmVyLCB9IGZyb20gJy4vcnVubmVyLmpzJztcbmV4cG9ydCB7IFF1ZXVlLCB9IGZyb20gJy4vcXVldWUuanMnO1xuZXhwb3J0IHsgUm91dGVSZWNvZ25pemVyLCBDb25maWd1cmFibGVSb3V0ZSwgUmVjb2duaXplZFJvdXRlLCBFbmRwb2ludCwgfSBmcm9tICcuL3JvdXRlLXJlY29nbml6ZXIuanMnO1xuZXhwb3J0IHsgXG4vLyBJUm91dGVyQWN0aXZhdGVPcHRpb25zLFxuLy8gSVJvdXRlck9wdGlvbnMsXG4vLyBJUm91dGVyVGl0bGUsXG5JUm91dGVyLCBSb3V0ZXIsIH0gZnJvbSAnLi9yb3V0ZXIuanMnO1xuZXhwb3J0IHsgUm91dGVyT3B0aW9ucywgfSBmcm9tICcuL3JvdXRlci1vcHRpb25zLmpzJztcbmV4cG9ydCB7IFZpZXdwb3J0LCB9IGZyb20gJy4vdmlld3BvcnQuanMnO1xuZXhwb3J0IHsgQ29udGVudFN0YXR1cywgVmlld3BvcnRDb250ZW50LCB9IGZyb20gJy4vdmlld3BvcnQtY29udGVudC5qcyc7XG5leHBvcnQgeyBWaWV3cG9ydEluc3RydWN0aW9uLCB9IGZyb20gJy4vdmlld3BvcnQtaW5zdHJ1Y3Rpb24uanMnO1xuZXhwb3J0IHsgUm91dGVyQ29uZmlndXJhdGlvbiwgUm91dGVyUmVnaXN0cmF0aW9uLCBEZWZhdWx0Q29tcG9uZW50cywgRGVmYXVsdFJlc291cmNlcywgVmlld3BvcnRDdXN0b21FbGVtZW50LCBWaWV3cG9ydEN1c3RvbUVsZW1lbnRSZWdpc3RyYXRpb24sIE5hdkN1c3RvbUVsZW1lbnQsIE5hdkN1c3RvbUVsZW1lbnRSZWdpc3RyYXRpb24sIEdvdG9DdXN0b21BdHRyaWJ1dGUsIEdvdG9DdXN0b21BdHRyaWJ1dGVSZWdpc3RyYXRpb24sIExvYWRDdXN0b21BdHRyaWJ1dGUsIExvYWRDdXN0b21BdHRyaWJ1dGVSZWdpc3RyYXRpb24sIEhyZWZDdXN0b21BdHRyaWJ1dGUsIEhyZWZDdXN0b21BdHRyaWJ1dGVSZWdpc3RyYXRpb24sIH0gZnJvbSAnLi9jb25maWd1cmF0aW9uLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IFZpZXdwb3J0SW5zdHJ1Y3Rpb24gfSBmcm9tICcuL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzJztcbmV4cG9ydCBjbGFzcyBJbnN0cnVjdGlvblJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXBhcmF0b3JzID0ge1xuICAgICAgICAgICAgdmlld3BvcnQ6ICdAJyxcbiAgICAgICAgICAgIHNpYmxpbmc6ICcrJyxcbiAgICAgICAgICAgIHNjb3BlOiAnLycsXG4gICAgICAgICAgICBzY29wZVN0YXJ0OiAnKCcsXG4gICAgICAgICAgICBzY29wZUVuZDogJyknLFxuICAgICAgICAgICAgbm9TY29wZTogJyEnLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogJygnLFxuICAgICAgICAgICAgcGFyYW1ldGVyc0VuZDogJyknLFxuICAgICAgICAgICAgcGFyYW1ldGVyU2VwYXJhdG9yOiAnLCcsXG4gICAgICAgICAgICBwYXJhbWV0ZXJLZXlTZXBhcmF0b3I6ICc9JyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogJyYnLFxuICAgICAgICAgICAgYWRkOiAnKycsXG4gICAgICAgICAgICBjbGVhcjogJy0nLFxuICAgICAgICAgICAgYWN0aW9uOiAnLicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuc2VwYXJhdG9ycyA9IHsgLi4udGhpcy5zZXBhcmF0b3JzLCAuLi5vcHRpb25zLnNlcGFyYXRvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VwYXJhdG9ycy5jbGVhcjtcbiAgICB9XG4gICAgZ2V0IGFkZFZpZXdwb3J0SW5zdHJ1Y3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcGFyYXRvcnMuYWRkO1xuICAgIH1cbiAgICBpc0NsZWFyVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICA/IGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUgPT09IHRoaXMuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uICYmICEhaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lXG4gICAgICAgICAgICA6IGluc3RydWN0aW9uLnN0YXJ0c1dpdGgodGhpcy5jbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb24pICYmIGluc3RydWN0aW9uICE9PSB0aGlzLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbjtcbiAgICB9XG4gICAgaXNBZGRWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbiBpbnN0YW5jZW9mIFZpZXdwb3J0SW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgID8gaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSA9PT0gdGhpcy5hZGRWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICA6IChpbnN0cnVjdGlvbiA9PT0gdGhpcy5hZGRWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgfHwgaW5zdHJ1Y3Rpb24uc3RhcnRzV2l0aChgJHt0aGlzLnNlcGFyYXRvcnMuYWRkfSR7dGhpcy5zZXBhcmF0b3JzLnZpZXdwb3J0fWApKTtcbiAgICB9XG4gICAgaXNDbGVhclZpZXdwb3J0U2NvcGVJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICA/IGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUgPT09IHRoaXMuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uICYmICEhaW5zdHJ1Y3Rpb24udmlld3BvcnRTY29wZVxuICAgICAgICAgICAgOiBpbnN0cnVjdGlvbi5zdGFydHNXaXRoKHRoaXMuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uKSAmJiBpbnN0cnVjdGlvbiAhPT0gdGhpcy5jbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb247XG4gICAgfVxuICAgIGlzQ2xlYXJBbGxWaWV3cG9ydHNJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBWaWV3cG9ydEluc3RydWN0aW9uXG4gICAgICAgICAgICA/IGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUgPT09IHRoaXMuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uICYmICFpbnN0cnVjdGlvbi52aWV3cG9ydE5hbWVcbiAgICAgICAgICAgIDogaW5zdHJ1Y3Rpb24gPT09IHRoaXMuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uO1xuICAgIH1cbiAgICBpc0FkZEFsbFZpZXdwb3J0c0luc3RydWN0aW9uKGluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbiBpbnN0YW5jZW9mIFZpZXdwb3J0SW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgID8gaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSA9PT0gdGhpcy5hZGRWaWV3cG9ydEluc3RydWN0aW9uICYmICFpbnN0cnVjdGlvbi52aWV3cG9ydE5hbWVcbiAgICAgICAgICAgIDogaW5zdHJ1Y3Rpb24gPT09IHRoaXMuYWRkVmlld3BvcnRJbnN0cnVjdGlvbjtcbiAgICB9XG4gICAgY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbihjb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzLCBvd25zU2NvcGUgPSB0cnVlLCBuZXh0U2NvcGVJbnN0cnVjdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LnRoZW4oKHJlc29sdmVkQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbihyZXNvbHZlZENvbXBvbmVudCwgdmlld3BvcnQsIHBhcmFtZXRlcnMsIG93bnNTY29wZSwgbmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnN0IGluc3RydWN0aW9uOiBWaWV3cG9ydEluc3RydWN0aW9uID0gbmV3IFZpZXdwb3J0SW5zdHJ1Y3Rpb24oY29tcG9uZW50LCB2aWV3cG9ydCwgcGFyYW1ldGVycywgb3duc1Njb3BlLCBuZXh0U2NvcGVJbnN0cnVjdGlvbnMpO1xuICAgICAgICAvLyBpbnN0cnVjdGlvbi5zZXRJbnN0cnVjdGlvblJlc29sdmVyKHRoaXMpO1xuICAgICAgICAvLyByZXR1cm4gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHJldHVybiBWaWV3cG9ydEluc3RydWN0aW9uLmNyZWF0ZSh0aGlzLCBjb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzLCBvd25zU2NvcGUsIG5leHRTY29wZUluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gL15bLi9dKy8uZXhlYyhpbnN0cnVjdGlvbnMpO1xuICAgICAgICBsZXQgY29udGV4dCA9ICcnO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaCkgJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLnNsaWNlKGNvbnRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRJbnN0cnVjdGlvbnMgPSB0aGlzLnBhcnNlVmlld3BvcnRJbnN0cnVjdGlvbnNXb3JrZXIoaW5zdHJ1Y3Rpb25zLCB0cnVlKS5pbnN0cnVjdGlvbnM7XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgcGFyc2VkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkSW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBwYXJzZVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGhpcy5wYXJzZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9uKTtcbiAgICAgICAgaWYgKGluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbignJyk7XG4gICAgfVxuICAgIHN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucywgZXhjbHVkZVZpZXdwb3J0ID0gZmFsc2UsIHZpZXdwb3J0Q29udGV4dCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgKGluc3RydWN0aW9ucykgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGluc3RydWN0aW9uc1xuICAgICAgICAgICAgOiBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgICAgICAubWFwKGluc3RydWN0aW9uID0+IHRoaXMuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgZXhjbHVkZVZpZXdwb3J0LCB2aWV3cG9ydENvbnRleHQpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24gJiYgaW5zdHJ1Y3Rpb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5qb2luKHRoaXMuc2VwYXJhdG9ycy5zaWJsaW5nKTtcbiAgICB9XG4gICAgc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgZXhjbHVkZVZpZXdwb3J0ID0gZmFsc2UsIHZpZXdwb3J0Q29udGV4dCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnlBVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgZXhjbHVkZVZpZXdwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBleGNsdWRlQ3VycmVudFZpZXdwb3J0ID0gZXhjbHVkZVZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IGV4Y2x1ZGVDdXJyZW50Q29tcG9uZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodmlld3BvcnRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnZpZXdwb3J0ICYmIGluc3RydWN0aW9uLnZpZXdwb3J0Lm9wdGlvbnMubm9MaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0cnVjdGlvbi5uZWVkc1ZpZXdwb3J0RGVzY3JpYmVkICYmIGluc3RydWN0aW9uLnZpZXdwb3J0ICYmICFpbnN0cnVjdGlvbi52aWV3cG9ydC5vcHRpb25zLmZvcmNlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUN1cnJlbnRWaWV3cG9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi52aWV3cG9ydCAmJiBpbnN0cnVjdGlvbi52aWV3cG9ydC5vcHRpb25zLmZhbGxiYWNrID09PSBpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDdXJyZW50Q29tcG9uZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0cnVjdGlvbi5uZWVkc1ZpZXdwb3J0RGVzY3JpYmVkICYmIGluc3RydWN0aW9uLnZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUN1cnJlbnRWaWV3cG9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJvdXRlID0gaW5zdHJ1Y3Rpb24ucm91dGUgPz8gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICBsZXQgc3RyaW5naWZpZWQgPSBpbnN0cnVjdGlvbi5jb250ZXh0O1xuICAgICAgICAgICAgLy8gSXQncyBhIGNvbmZpZ3VyZWQgcm91dGVcbiAgICAgICAgICAgIGlmIChyb3V0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgYWRkZWQgYXMgcGFydCBvZiBhIGNvbmZpZ3VyYXRpb24sIHNraXAgdG8gbmV4dCBzY29wZVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobmV4dEluc3RydWN0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9ucyhuZXh0SW5zdHJ1Y3Rpb25zLCBleGNsdWRlVmlld3BvcnQsIHZpZXdwb3J0Q29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvdXRlID0gcm91dGUubWF0Y2hpbmc7XG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWQgKz0gcm91dGUuZW5kc1dpdGgodGhpcy5zZXBhcmF0b3JzLnNjb3BlKSA/IHJvdXRlLnNsaWNlKDAsIC10aGlzLnNlcGFyYXRvcnMuc2NvcGUubGVuZ3RoKSA6IHJvdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWQgKz0gdGhpcy5zdHJpbmdpZnlBVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgZXhjbHVkZUN1cnJlbnRWaWV3cG9ydCwgZXhjbHVkZUN1cnJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dEluc3RydWN0aW9ucykgJiYgbmV4dEluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3RyaW5naWZpZWQgPSB0aGlzLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKG5leHRJbnN0cnVjdGlvbnMsIGV4Y2x1ZGVWaWV3cG9ydCwgdmlld3BvcnRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFN0cmluZ2lmaWVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZpZWQgKz0gbmV4dEluc3RydWN0aW9ucy5sZW5ndGggPT09IDEgLy8gVE9ETzogVGhpcyBzaG91bGQgcmVhbGx5IGFsc28gY2hlY2sgdGhhdCB0aGUgaW5zdHJ1Y3Rpb25zIGhhdmUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7dGhpcy5zZXBhcmF0b3JzLnNjb3BlfSR7bmV4dFN0cmluZ2lmaWVkfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYCR7dGhpcy5zZXBhcmF0b3JzLnNjb3BlfSR7dGhpcy5zZXBhcmF0b3JzLnNjb3BlU3RhcnR9JHtuZXh0U3RyaW5naWZpZWR9JHt0aGlzLnNlcGFyYXRvcnMuc2NvcGVFbmR9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5naWZ5U2NvcGVkVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0cnVjdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnlTY29wZWRWaWV3cG9ydEluc3RydWN0aW9ucyhbaW5zdHJ1Y3Rpb25zXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucy5tYXAoKGluc3RydWN0aW9uKSA9PiB0aGlzLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pKS5qb2luKHRoaXMuc2VwYXJhdG9ycy5zY29wZSk7XG4gICAgfVxuICAgIGVuY29kZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSkucmVwbGFjZSgvXFwoL2csICclMjgnKS5yZXBsYWNlKC9cXCkvZywgJyUyOScpO1xuICAgIH1cbiAgICBkZWNvZGVWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWaWV3cG9ydEluc3RydWN0aW9ucyhkZWNvZGVVUklDb21wb25lbnQoaW5zdHJ1Y3Rpb25zKSk7XG4gICAgfVxuICAgIGJ1aWxkU2NvcGVkTGluayhzY29wZUNvbnRleHQsIGhyZWYpIHtcbiAgICAgICAgaWYgKHNjb3BlQ29udGV4dCkge1xuICAgICAgICAgICAgaHJlZiA9IGAvJHtzY29wZUNvbnRleHR9JHt0aGlzLnNlcGFyYXRvcnMuc2NvcGV9JHtocmVmfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHNob3VsZENsZWFyVmlld3BvcnRzKHBhdGgpIHtcbiAgICAgICAgY29uc3QgY2xlYXJWaWV3cG9ydHMgPSAocGF0aCA9PT0gdGhpcy5zZXBhcmF0b3JzLmNsZWFyIHx8IHBhdGguc3RhcnRzV2l0aCh0aGlzLnNlcGFyYXRvcnMuY2xlYXIgKyB0aGlzLnNlcGFyYXRvcnMuYWRkKSk7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBwYXRoLnN0YXJ0c1dpdGgodGhpcy5zZXBhcmF0b3JzLmNsZWFyKSA/IHBhdGguc2xpY2UoMikgOiBwYXRoO1xuICAgICAgICByZXR1cm4geyBjbGVhclZpZXdwb3J0cywgbmV3UGF0aCB9O1xuICAgIH1cbiAgICBtZXJnZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gdGhpcy5wYXJzZVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBtZXJnZWQuZmluZEluZGV4KG1lcmdlID0+IG1lcmdlLnNhbWVWaWV3cG9ydChpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQuc3BsaWNlKGluZGV4LCAxLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgZmxhdHRlblZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykge1xuICAgICAgICBjb25zdCBmbGF0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBmbGF0LnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGZsYXQucHVzaCguLi50aGlzLmZsYXR0ZW5WaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdDtcbiAgICB9XG4gICAgY2xvbmVWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMsIGtlZXBJbnN0YW5jZXMgPSBmYWxzZSwgY29udGV4dCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGNsb25lcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSwgaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lLCBpbnN0cnVjdGlvbi50eXBlZFBhcmFtZXRlcnMgIT09IG51bGwgPyBpbnN0cnVjdGlvbi50eXBlZFBhcmFtZXRlcnMgOiB2b2lkIDApO1xuICAgICAgICAgICAgaWYgKGtlZXBJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBjbG9uZS5zZXRDb21wb25lbnQoaW5zdHJ1Y3Rpb24uY29tcG9uZW50SW5zdGFuY2UgPz8gaW5zdHJ1Y3Rpb24uY29tcG9uZW50VHlwZSA/PyBpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgICAgICBjbG9uZS5zZXRWaWV3cG9ydChpbnN0cnVjdGlvbi52aWV3cG9ydCA/PyBpbnN0cnVjdGlvbi52aWV3cG9ydE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvbmUubmVlZHNWaWV3cG9ydERlc2NyaWJlZCA9IGluc3RydWN0aW9uLm5lZWRzVmlld3BvcnREZXNjcmliZWQ7XG4gICAgICAgICAgICBjbG9uZS5yb3V0ZSA9IGluc3RydWN0aW9uLnJvdXRlO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjbG9uZS5jb250ZXh0ID0gaW5zdHJ1Y3Rpb24uY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb25lLnZpZXdwb3J0U2NvcGUgPSBrZWVwSW5zdGFuY2VzID8gaW5zdHJ1Y3Rpb24udmlld3BvcnRTY29wZSA6IG51bGw7XG4gICAgICAgICAgICBjbG9uZS5zY29wZSA9IGtlZXBJbnN0YW5jZXMgPyBpbnN0cnVjdGlvbi5zY29wZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zID0gdGhpcy5jbG9uZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucywga2VlcEluc3RhbmNlcywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9uZXMucHVzaChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lcztcbiAgICB9XG4gICAgLy8gVE9ETzogRGVhbCB3aXRoIHNlcGFyYXRvcnMgaW4gZGF0YSBhbmQgY29tcGxleCB0eXBlc1xuICAgIHBhcnNlQ29tcG9uZW50UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCB1cmlDb21wb25lbnQgPSBmYWxzZSkge1xuICAgICAgICBpZiAocGFyYW1ldGVycyA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtZXRlcnMgPT09IG51bGwgfHwgcGFyYW1ldGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJhbWV0ZXJzLnNwbGl0KHRoaXMuc2VwYXJhdG9ycy5wYXJhbWV0ZXJTZXBhcmF0b3IpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgICAgICBba2V5LCB2YWx1ZV0gPSBwYXJhbS5zcGxpdCh0aGlzLnNlcGFyYXRvcnMucGFyYW1ldGVyS2V5U2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVyaUNvbXBvbmVudCA/IGRlY29kZVVSSUNvbXBvbmVudChrZXkpIDoga2V5O1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVyaUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goeyBrZXksIHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLm1hcChwYXJhbSA9PiAoeyBrZXk6IHZvaWQgMCwgdmFsdWU6IHBhcmFtIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGFyYW1ldGVycyk7XG4gICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoa2V5ID0+ICh7IGtleSwgdmFsdWU6IHBhcmFtZXRlcnNba2V5XSB9KSk7XG4gICAgfVxuICAgIC8vIFRPRE86IERlYWwgd2l0aCBzZXBhcmF0b3JzIGluIGRhdGEgYW5kIGNvbXBsZXggdHlwZXNcbiAgICBzdHJpbmdpZnlDb21wb25lbnRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHVyaUNvbXBvbmVudCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSB8fCBwYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcHMgPSB0aGlzLnNlcGFyYXRvcnM7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAubWFwKHBhcmFtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhcmFtLmtleSAhPT0gdm9pZCAwICYmIHVyaUNvbXBvbmVudCA/IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbS5rZXkpIDogcGFyYW0ua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cmlDb21wb25lbnQgPyBlbmNvZGVVUklDb21wb25lbnQocGFyYW0udmFsdWUpIDogcGFyYW0udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4ga2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSB2YWx1ZSA/IGtleSArIHNlcHMucGFyYW1ldGVyS2V5U2VwYXJhdG9yICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKHNlcHMucGFyYW1ldGVyU2VwYXJhdG9yKTtcbiAgICB9XG4gICAgbWF0Y2hTY29wZShpbnN0cnVjdGlvbnMsIHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgIG1hdGNoaW5nLnB1c2goLi4uaW5zdHJ1Y3Rpb25zLmZpbHRlcihpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi5zY29wZSA9PT0gc2NvcGUpKTtcbiAgICAgICAgbWF0Y2hpbmcucHVzaCguLi5pbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoaW5zdHIgPT4gaW5zdHIuc2NvcGUgIT09IHNjb3BlKVxuICAgICAgICAgICAgLm1hcChpbnN0ciA9PiBBcnJheS5pc0FycmF5KGluc3RyLm5leHRTY29wZUluc3RydWN0aW9ucykgPyB0aGlzLm1hdGNoU2NvcGUoaW5zdHIubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zLCBzY29wZSkgOiBbXSlcbiAgICAgICAgICAgIC5mbGF0KCkpO1xuICAgICAgICByZXR1cm4gbWF0Y2hpbmc7XG4gICAgfVxuICAgIG1hdGNoQ2hpbGRyZW4oaW5zdHJ1Y3Rpb25zLCBhY3RpdmUpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gYWN0aXZlLmZpbHRlcihpbnN0ciA9PiBpbnN0ci5zYW1lQ29tcG9uZW50KGluc3RydWN0aW9uKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKVxuICAgICAgICAgICAgICAgICYmIGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5tYXRjaENoaWxkcmVuKGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucywgbWF0Y2hpbmcubWFwKGluc3RyID0+IEFycmF5LmlzQXJyYXkoaW5zdHIubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKSA/IGluc3RyLm5leHRTY29wZUluc3RydWN0aW9ucyA6IFtdKS5mbGF0KCkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyc2VWaWV3cG9ydEluc3RydWN0aW9uc1dvcmtlcihpbnN0cnVjdGlvbnMsIGdyb3VwZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdHJ1Y3Rpb25zOiBbXSwgcmVtYWluaW5nOiAnJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMuc3RhcnRzV2l0aCh0aGlzLnNlcGFyYXRvcnMuc2NvcGVTdGFydCkpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGAke3RoaXMuc2VwYXJhdG9ycy5zY29wZX0ke2luc3RydWN0aW9uc31gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGxldCBndWFyZCA9IDEwMDA7XG4gICAgICAgIHdoaWxlIChpbnN0cnVjdGlvbnMubGVuZ3RoICYmIGd1YXJkKSB7XG4gICAgICAgICAgICBndWFyZC0tO1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9ucy5zdGFydHNXaXRoKHRoaXMuc2VwYXJhdG9ycy5zY29wZSkpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuc2xpY2UodGhpcy5zZXBhcmF0b3JzLnNjb3BlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVTdGFydCA9IGluc3RydWN0aW9ucy5zdGFydHNXaXRoKHRoaXMuc2VwYXJhdG9ycy5zY29wZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuc2xpY2UodGhpcy5zZXBhcmF0b3JzLnNjb3BlU3RhcnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbnN0cnVjdGlvbnM6IGZvdW5kLCByZW1haW5pbmcgfSA9IHRoaXMucGFyc2VWaWV3cG9ydEluc3RydWN0aW9uc1dvcmtlcihpbnN0cnVjdGlvbnMsIHNjb3BlU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3cG9ydEluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnNbdmlld3BvcnRJbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV0ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucy5wdXNoKC4uLmZvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb25zLnN0YXJ0c1dpdGgodGhpcy5zZXBhcmF0b3JzLnNjb3BlRW5kKSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5zbGljZSh0aGlzLnNlcGFyYXRvcnMuc2NvcGVFbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5zdHJ1Y3Rpb25zOiB2aWV3cG9ydEluc3RydWN0aW9ucywgcmVtYWluaW5nOiBpbnN0cnVjdGlvbnMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9ucy5zdGFydHNXaXRoKHRoaXMuc2VwYXJhdG9ycy5zaWJsaW5nKSAmJiAhdGhpcy5pc0FkZFZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25zKSkge1xuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpbnN0cnVjdGlvbnM6IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLCByZW1haW5pbmc6IGluc3RydWN0aW9ucyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuc2xpY2UodGhpcy5zZXBhcmF0b3JzLnNpYmxpbmcubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5zdHJ1Y3Rpb246IHZpZXdwb3J0SW5zdHJ1Y3Rpb24sIHJlbWFpbmluZyB9ID0gdGhpcy5wYXJzZUFWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucHVzaCh2aWV3cG9ydEluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSByZW1haW5pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW5zdHJ1Y3Rpb25zOiB2aWV3cG9ydEluc3RydWN0aW9ucywgcmVtYWluaW5nOiBpbnN0cnVjdGlvbnMgfTtcbiAgICB9XG4gICAgZmluZE5leHRUb2tlbihpbnN0cnVjdGlvbiwgdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB7fTtcbiAgICAgICAgLy8gVG9rZW5zIGNhbiBoYXZlIGxlbmd0aCA+IDFcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUG9zID0gaW5zdHJ1Y3Rpb24uaW5kZXhPZih0b2tlbik7XG4gICAgICAgICAgICBpZiAodG9rZW5Qb3MgPiAtMSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXNbdG9rZW5dID0gaW5zdHJ1Y3Rpb24uaW5kZXhPZih0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zID0gTWF0aC5taW4oLi4uT2JqZWN0LnZhbHVlcyhtYXRjaGVzKSk7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gaW4gbWF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNbdG9rZW5dID09PSBwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b2tlbiwgcG9zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9rZW46ICcnLCBwb3M6IC0xIH07XG4gICAgfVxuICAgIHBhcnNlQVZpZXdwb3J0SW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3Qgc2VwcyA9IHRoaXMuc2VwYXJhdG9ycztcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW3NlcHMucGFyYW1ldGVycywgc2Vwcy52aWV3cG9ydCwgc2Vwcy5ub1Njb3BlLCBzZXBzLnNjb3BlRW5kLCBzZXBzLnNjb3BlLCBzZXBzLnNpYmxpbmddO1xuICAgICAgICBsZXQgY29tcG9uZW50ID0gdm9pZCAwO1xuICAgICAgICBsZXQgcGFyYW1ldGVyc1N0cmluZyA9IHZvaWQgMDtcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gdm9pZCAwO1xuICAgICAgICBsZXQgc2NvcGUgPSB0cnVlO1xuICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgIGxldCBwb3M7XG4gICAgICAgIGNvbnN0IHNwZWNpYWxzID0gW3NlcHMuYWRkLCBzZXBzLmNsZWFyXTtcbiAgICAgICAgZm9yIChjb25zdCBzcGVjaWFsIG9mIHNwZWNpYWxzKSB7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24gPT09IHNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpOyAvLyBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KCk7IC8vIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzZXBzLnZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWFsIG9mIHNwZWNpYWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnN0YXJ0c1dpdGgoYCR7c3BlY2lhbH0ke3NlcHMudmlld3BvcnR9YCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gc3BlY2lhbDtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbi5zbGljZShgJHtzcGVjaWFsfSR7c2Vwcy52aWV3cG9ydH1gLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpOyAvLyBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpOyAvLyB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHNlcHMudmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICh7IHRva2VuLCBwb3MgfSA9IHRoaXMuZmluZE5leHRUb2tlbihpbnN0cnVjdGlvbiwgdG9rZW5zKSk7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBwb3MgIT09IC0xID8gaW5zdHJ1Y3Rpb24uc2xpY2UoMCwgcG9zKSA6IGluc3RydWN0aW9uO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBwb3MgIT09IC0xID8gaW5zdHJ1Y3Rpb24uc2xpY2UocG9zICsgdG9rZW4ubGVuZ3RoKSA6ICcnO1xuICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KCk7IC8vIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gc2Vwcy5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgKHsgdG9rZW4sIHBvcyB9ID0gdGhpcy5maW5kTmV4dFRva2VuKGluc3RydWN0aW9uLCBbc2Vwcy5wYXJhbWV0ZXJzRW5kXSkpO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNTdHJpbmcgPSBpbnN0cnVjdGlvbi5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb24uc2xpY2UocG9zICsgdG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAoeyB0b2tlbiB9ID0gdGhpcy5maW5kTmV4dFRva2VuKGluc3RydWN0aW9uLCB0b2tlbnMpKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uLnNsaWNlKHRva2VuLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbnMuc2hpZnQoKTsgLy8gdmlld3BvcnRcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gPT09IHNlcHMudmlld3BvcnQpIHtcbiAgICAgICAgICAgICh7IHRva2VuLCBwb3MgfSA9IHRoaXMuZmluZE5leHRUb2tlbihpbnN0cnVjdGlvbiwgdG9rZW5zKSk7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IHBvcyAhPT0gLTEgPyBpbnN0cnVjdGlvbi5zbGljZSgwLCBwb3MpIDogaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHBvcyAhPT0gLTEgPyBpbnN0cnVjdGlvbi5zbGljZShwb3MgKyB0b2tlbi5sZW5ndGgpIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnNoaWZ0KCk7IC8vIG5vU2NvcGVcbiAgICAgICAgaWYgKHRva2VuID09PSBzZXBzLm5vU2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdG9yZSB0b2tlbiB0aGF0IGJlbG9uZ3MgdG8gbmV4dCBpbnN0cnVjdGlvblxuICAgICAgICBpZiAodG9rZW4gPT09IHNlcHMuc2NvcGVFbmQgfHwgdG9rZW4gPT09IHNlcHMuc2NvcGUgfHwgdG9rZW4gPT09IHNlcHMuc2libGluZykge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBgJHt0b2tlbn0ke2luc3RydWN0aW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3BvcnRJbnN0cnVjdGlvbiA9IHRoaXMuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbihjb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzU3RyaW5nLCBzY29wZSk7XG4gICAgICAgIHJldHVybiB7IGluc3RydWN0aW9uOiB2aWV3cG9ydEluc3RydWN0aW9uLCByZW1haW5pbmc6IGluc3RydWN0aW9uIH07XG4gICAgfVxuICAgIHN0cmluZ2lmeUFWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uLCBleGNsdWRlVmlld3BvcnQgPSBmYWxzZSwgZXhjbHVkZUNvbXBvbmVudCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9uKHRoaXMucGFyc2VWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKSwgZXhjbHVkZVZpZXdwb3J0LCBleGNsdWRlQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpbnN0cnVjdGlvblN0cmluZyA9ICFleGNsdWRlQ29tcG9uZW50ID8gaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSA6ICcnO1xuICAgICAgICAgICAgY29uc3Qgc3BlY2lmaWNhdGlvbiA9IGluc3RydWN0aW9uLmNvbXBvbmVudFR5cGUgPyBpbnN0cnVjdGlvbi5jb21wb25lbnRUeXBlLnBhcmFtZXRlcnMgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRoaXMuc3RyaW5naWZ5Q29tcG9uZW50UGFyYW1ldGVycyhpbnN0cnVjdGlvbi50b1NvcnRlZFBhcmFtZXRlcnMoc3BlY2lmaWNhdGlvbikpO1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uU3RyaW5nICs9ICFleGNsdWRlQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gYCR7dGhpcy5zZXBhcmF0b3JzLnBhcmFtZXRlcnN9JHtwYXJhbWV0ZXJzfSR7dGhpcy5zZXBhcmF0b3JzLnBhcmFtZXRlcnNFbmR9YFxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lICE9PSBudWxsICYmICFleGNsdWRlVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvblN0cmluZyArPSB0aGlzLnNlcGFyYXRvcnMudmlld3BvcnQgKyBpbnN0cnVjdGlvbi52aWV3cG9ydE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluc3RydWN0aW9uLm93bnNTY29wZSkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uU3RyaW5nICs9IHRoaXMuc2VwYXJhdG9ycy5ub1Njb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uU3RyaW5nIHx8ICcnO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdHJ1Y3Rpb24tcmVzb2x2ZXIuanMubWFwIiwiZXhwb3J0IHZhciBSZWVudHJ5QmVoYXZpb3I7XG4oZnVuY3Rpb24gKFJlZW50cnlCZWhhdmlvcikge1xuICAgIFJlZW50cnlCZWhhdmlvcltcImRlZmF1bHRcIl0gPSBcImRlZmF1bHRcIjtcbiAgICBSZWVudHJ5QmVoYXZpb3JbXCJkaXNhbGxvd1wiXSA9IFwiZGlzYWxsb3dcIjtcbiAgICBSZWVudHJ5QmVoYXZpb3JbXCJsb2FkXCJdID0gXCJsb2FkXCI7XG4gICAgUmVlbnRyeUJlaGF2aW9yW1wicmVmcmVzaFwiXSA9IFwicmVmcmVzaFwiO1xufSkoUmVlbnRyeUJlaGF2aW9yIHx8IChSZWVudHJ5QmVoYXZpb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiLCIvKipcbiAqIEBpbnRlcm5hbCAtIFdpbGwgYmUgcmVtb3ZlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlTG9nZ2VyKG5hbWUpIHtcbiAgICBjb25zdCBsaWZlY3ljbGVzID0gW1xuICAgICAgICAnY2FuVW5sb2FkJywgJ3VubG9hZCcsXG4gICAgICAgICdjYW5Mb2FkJywgJ2xvYWQnLFxuICAgICAgICAnY3JlYXRlZCcsXG4gICAgICAgICdiaW5kaW5nJywgJ2JvdW5kJyxcbiAgICAgICAgJ2JlZm9yZUF0dGFjaCcsICdhdHRhY2hpbmcnLFxuICAgICAgICAnZGV0YWNoaW5nJyxcbiAgICAgICAgJ3VuYmluZGluZycsXG4gICAgXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBmb3IgKGNvbnN0IGxpZmVjeWNsZSBvZiBsaWZlY3ljbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRhcmdldC5wcm90b3R5cGVbbGlmZWN5Y2xlXTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZVtsaWZlY3ljbGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7bmFtZX0gJHtsaWZlY3ljbGV9YCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZy5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHJvdG90eXBlW2xpZmVjeWNsZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtuYW1lfSAke2xpZmVjeWNsZX1gLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpZmVjeWNsZS5zdGFydHNXaXRoKCdjYW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBjbGFzcyBMaWZlY3ljbGVDbGFzcyB7XG4gICAgY2FuTG9hZCgpIHsgY29uc29sZS5sb2coYG5hbWUgY2FuTG9hZGApOyByZXR1cm4gdHJ1ZTsgfVxuICAgIGxvYWQocGFyYW1zKSB7IGNvbnNvbGUubG9nKGBuYW1lIGxvYWRgKTsgfVxuICAgIGNyZWF0ZWQoKSB7IGNvbnNvbGUubG9nKGBuYW1lIGNyZWF0ZWRgKTsgfVxuICAgIGJpbmRpbmcoKSB7IGNvbnNvbGUubG9nKGBuYW1lIGJpbmRpbmdgKTsgfVxuICAgIGJvdW5kKCkgeyBjb25zb2xlLmxvZyhgbmFtZSBib3VuZGApOyB9XG4gICAgYmVmb3JlQXR0YWNoKCkgeyBjb25zb2xlLmxvZyhgbmFtZSBiZWZvcmVBdHRhY2hgKTsgfVxuICAgIGF0dGFjaGluZygpIHsgY29uc29sZS5sb2coYG5hbWUgYXR0YWNoaW5nYCk7IH1cbiAgICBjYW5VbmxvYWQoKSB7IGNvbnNvbGUubG9nKGBuYW1lIGNhblVubG9hZGApOyByZXR1cm4gdHJ1ZTsgfVxuICAgIHVubG9hZCgpIHsgY29uc29sZS5sb2coYG5hbWUgdW5sb2FkYCk7IH1cbiAgICBkZXRhY2hpbmcoKSB7IGNvbnNvbGUubG9nKGBuYW1lIGRldGFjaGluZ2ApOyB9XG4gICAgdW5iaW5kaW5nKCkgeyBjb25zb2xlLmxvZyhgbmFtZSB1bmJpbmRpbmdgKTsgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlmZWN5Y2xlLWxvZ2dlci5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IElQbGF0Zm9ybSwgQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIGludGVyYWN0aW9ucyB0aGF0IHNob3VsZCB0cmlnZ2VyIG5hdmlnYXRpb24uXG4gKlxuICogQCBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5LlxuICogVE9ETzogcmVtb3ZlIHRoZSBzcGFjZSBiZXR3ZWVuIEAgYW5kIGkgYWdhaW4gYXQgc29tZSBwb2ludCAodGhpcyBzdHJpcEludGVybmFsIGN1cnJlbnRseSBzY3Jld3MgdXAgdGhlIHR5cGVzIGluIHRoZSBfX3Rlc3RzX18gcGFja2FnZSBmb3Igc29tZSByZWFzb24pXG4gKi9cbmxldCBMaW5rSGFuZGxlciA9IGNsYXNzIExpbmtIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVzZUhyZWY6IHRydWUsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4geyByZXR1cm47IH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IExpbmtIYW5kbGVyLmdldEV2ZW50SW5mbyhlLCB0aGlzLndpbmRvdywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChpbmZvLnNob3VsZEhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWxsYmFjayhpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53aW5kb3cgPSBwLndpbmRvdztcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IHAuZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhyZWYgYW5kIGEgXCJzaG91bGQgaGFuZGxlXCIgcmVjb21tZW5kYXRpb24sIGdpdmVuIGFuIEV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIEV2ZW50IHRvIGluc3BlY3QgZm9yIHRhcmdldCBhbmNob3IgYW5kIGhyZWYuXG4gICAgICovXG4gICAgc3RhdGljIGdldEV2ZW50SW5mbyhldmVudCwgd2luLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgICBzaG91bGRIYW5kbGVFdmVudDogZmFsc2UsXG4gICAgICAgICAgICBpbnN0cnVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGFuY2hvcjogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpbmZvLmFuY2hvciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB0aGlzIGZvciBkZWxlZ2F0aW9uOlxuICAgICAgICAvLyBjb25zdCB0YXJnZXQgPSBpbmZvLmFuY2hvciA9IExpbmtIYW5kbGVyLmNsb3Nlc3RBbmNob3IoZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQpO1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhTGlua0hhbmRsZXIudGFyZ2V0SXNUaGlzV2luZG93KHRhcmdldCwgd2luKSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2V4dGVybmFsJykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnb3RvQXR0ciA9IEN1c3RvbUF0dHJpYnV0ZS5mb3IodGFyZ2V0LCAnZ290bycpO1xuICAgICAgICBjb25zdCBnb3RvID0gZ290b0F0dHIgIT09IHZvaWQgMCA/IGdvdG9BdHRyLnZpZXdNb2RlbC52YWx1ZSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxvYWRBdHRyID0gQ3VzdG9tQXR0cmlidXRlLmZvcih0YXJnZXQsICdsb2FkJyk7XG4gICAgICAgIGNvbnN0IGxvYWQgPSBsb2FkQXR0ciAhPT0gdm9pZCAwID8gbG9hZEF0dHIudmlld01vZGVsLnZhbHVlIDogbnVsbDtcbiAgICAgICAgY29uc3QgaHJlZiA9IG9wdGlvbnMudXNlSHJlZiAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdocmVmJykgPyB0YXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJykgOiBudWxsO1xuICAgICAgICBpZiAoKGdvdG8gPT09IG51bGwgfHwgZ290by5sZW5ndGggPT09IDApICYmIChsb2FkID09PSBudWxsIHx8IGxvYWQubGVuZ3RoID09PSAwKSAmJiAoaHJlZiA9PT0gbnVsbCB8fCBocmVmLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYW5jaG9yID0gdGFyZ2V0O1xuICAgICAgICBpbmZvLmluc3RydWN0aW9uID0gbG9hZCA/PyBnb3RvID8/IGhyZWY7XG4gICAgICAgIGNvbnN0IGxlZnRCdXR0b25DbGlja2VkID0gZXZlbnQuYnV0dG9uID09PSAwO1xuICAgICAgICBpbmZvLnNob3VsZEhhbmRsZUV2ZW50ID0gbGVmdEJ1dHRvbkNsaWNrZWQ7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgY2xvc2VzdCBhbmNlc3RvciB0aGF0J3MgYW4gYW5jaG9yIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCB0byBzZWFyY2ggdXB3YXJkIGZyb20uXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgZWxlbWVudCB0aGF0IGlzIHRoZSBjbG9zZXN0IGFuY2VzdG9yLlxuICAgICAqL1xuICAgIC8vIHByaXZhdGUgc3RhdGljIGNsb3Nlc3RBbmNob3IoZWw6IEVsZW1lbnQpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgLy8gICB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwgIT09IHZvaWQgMCkge1xuICAgIC8vICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgLy8gICAgICAgcmV0dXJuIGVsO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGVsID0gZWwucGFyZW50Tm9kZSBhcyBFbGVtZW50O1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGFuIGFuY2hvciB0YXJnZXRzIHRoZSBjdXJyZW50IHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgYW5jaG9yIGVsZW1lbnQgd2hvc2UgdGFyZ2V0IHNob3VsZCBiZSBpbnNwZWN0ZWQuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGFyZ2V0IG9mIHRoZSBsaW5rIGVsZW1lbnQgaXMgdGhpcyB3aW5kb3c7IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdGFyZ2V0SXNUaGlzV2luZG93KHRhcmdldCwgd2luKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFdpbmRvdyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgICAgICByZXR1cm4gIXRhcmdldFdpbmRvdyB8fFxuICAgICAgICAgICAgdGFyZ2V0V2luZG93ID09PSB3aW4ubmFtZSB8fFxuICAgICAgICAgICAgdGFyZ2V0V2luZG93ID09PSAnX3NlbGYnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGluc3RhbmNlLiBFdmVudCBoYW5kbGVycyBhbmQgb3RoZXIgcmVzb3VyY2VzIHNob3VsZCBiZSBjbGVhbmVkIHVwIGhlcmUuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgaGFuZGxlciBoYXMgbm90IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG59O1xuTGlua0hhbmRsZXIgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElQbGF0Zm9ybSlcbl0sIExpbmtIYW5kbGVyKTtcbmV4cG9ydCB7IExpbmtIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLWhhbmRsZXIuanMubWFwIiwiaW1wb3J0IHsgQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlciwgTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIgfSBmcm9tICcuL3R5cGUtcmVzb2x2ZXJzLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gVXNlZCBieSBhdS1uYXZcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdlJvdXRlIHtcbiAgICBjb25zdHJ1Y3RvcihuYXYsIHJvdXRlKSB7XG4gICAgICAgIHRoaXMubmF2ID0gbmF2O1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmsgPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmtWaXNpYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5rQWN0aXZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wYXJlUGFyYW1ldGVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAnJztcbiAgICAgICAgdGhpcy50aXRsZSA9IHJvdXRlLnRpdGxlO1xuICAgICAgICB0aGlzLm1ldGEgPSByb3V0ZS5tZXRhO1xuICAgICAgICBpZiAocm91dGUucm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdGhpcy5wYXJzZVJvdXRlKHJvdXRlLnJvdXRlKTtcbiAgICAgICAgICAgIHRoaXMubGluayA9IHRoaXMuY29tcHV0ZUxpbmsodGhpcy5pbnN0cnVjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlua0FjdGl2ZSA9IHJvdXRlLmNvbnNpZGVyZWRBY3RpdmUgIT09IG51bGwgJiYgcm91dGUuY29uc2lkZXJlZEFjdGl2ZSAhPT0gdm9pZCAwID8gcm91dGUuY29uc2lkZXJlZEFjdGl2ZSA6IHRoaXMubGluaztcbiAgICAgICAgaWYgKHRoaXMubGlua0FjdGl2ZSAhPT0gbnVsbCAmJiAoISh0aGlzLmxpbmtBY3RpdmUgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc1R5cGUodGhpcy5saW5rQWN0aXZlKSkpIHtcbiAgICAgICAgICAgIHRoaXMubGlua0FjdGl2ZSA9IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyLnRvVmlld3BvcnRJbnN0cnVjdGlvbnModGhpcy5uYXYucm91dGVyLCB0aGlzLmxpbmtBY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0ZSA9IHJvdXRlLmV4ZWN1dGU7XG4gICAgICAgIHRoaXMuY29tcGFyZVBhcmFtZXRlcnMgPSAhIXJvdXRlLmNvbXBhcmVQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLmxpbmtWaXNpYmxlID0gcm91dGUuY29uZGl0aW9uID09PSB1bmRlZmluZWQgPyB0cnVlIDogcm91dGUuY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jaGlsZHJlbiAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA/ICduYXYtaGFzLWNoaWxkcmVuJyA6ICcnKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0aGlzLmNvbXB1dGVWaXNpYmxlKCk7XG4gICAgICAgIGlmICgodGhpcy5saW5rICYmIHRoaXMubGluay5sZW5ndGgpIHx8IHRoaXMuZXhlY3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSB0aGlzLmNvbXB1dGVBY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gKHRoaXMuYWN0aXZlID09PSAnbmF2LWFjdGl2ZScgPyAnbmF2LWFjdGl2ZScgOiAodGhpcy5hY3RpdmVDaGlsZCgpID8gJ25hdi1hY3RpdmUtY2hpbGQnIDogJycpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlQWN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmV4ZWN1dGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgdG9nZ2xlQWN0aXZlKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9ICh0aGlzLmFjdGl2ZS5zdGFydHNXaXRoKCduYXYtYWN0aXZlJykgPyAnJyA6ICduYXYtYWN0aXZlJyk7XG4gICAgfVxuICAgIHBhcnNlUm91dGUocm91dGVzKSB7XG4gICAgICAgIHJldHVybiBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMubmF2LnJvdXRlciwgcm91dGVzKTtcbiAgICB9XG4gICAgY29tcHV0ZVZpc2libGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtWaXNpYmxlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmtWaXNpYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMubGlua1Zpc2libGU7XG4gICAgfVxuICAgIGNvbXB1dGVBY3RpdmUoKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmxpbmtBY3RpdmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5rQWN0aXZlKHRoaXMpID8gJ25hdi1hY3RpdmUnIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMubGlua0FjdGl2ZTtcbiAgICAgICAgY29uc3QgYWN0aXZlQ29tcG9uZW50cyA9IHRoaXMubmF2LnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmZsYXR0ZW5WaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLm5hdi5yb3V0ZXIuYWN0aXZlQ29tcG9uZW50cyk7XG4gICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVDb21wb25lbnRzLmV2ZXJ5KChhY3RpdmUpID0+ICFhY3RpdmUuc2FtZUNvbXBvbmVudChjb21wb25lbnQsIHRoaXMuY29tcGFyZVBhcmFtZXRlcnMgJiYgY29tcG9uZW50LnR5cGVkUGFyYW1ldGVycyAhPT0gbnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbmF2LWFjdGl2ZSc7XG4gICAgfVxuICAgIGNvbXB1dGVMaW5rKGluc3RydWN0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXYucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgYWN0aXZlQ2hpbGQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYWN0aXZlLnN0YXJ0c1dpdGgoJ25hdi1hY3RpdmUnKSB8fCBjaGlsZC5hY3RpdmVDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2LXJvdXRlLmpzLm1hcCIsImltcG9ydCB7IE5hdlJvdXRlIH0gZnJvbSAnLi9uYXYtcm91dGUuanMnO1xuLyoqXG4gKiBQdWJsaWMgQVBJIC0gVXNlZCBieSBhdS1uYXYgYW5kIFJvdXRlciBhZGQvc2V0TmF2XG4gKi9cbmV4cG9ydCBjbGFzcyBOYXYge1xuICAgIGNvbnN0cnVjdG9yKHJvdXRlciwgbmFtZSwgcm91dGVzID0gW10sIGNsYXNzZXMgPSB7fSkge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yb3V0ZXMgPSByb3V0ZXM7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGFkZFJvdXRlcyhyb3V0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkUm91dGUodGhpcy5yb3V0ZXMsIHJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUm91dGVzKHRoaXMucm91dGVzKTtcbiAgICAgICAgdGhpcy5yb3V0ZXMgPSB0aGlzLnJvdXRlcy5zbGljZSgpO1xuICAgIH1cbiAgICBhZGRSb3V0ZShyb3V0ZXMsIHJvdXRlKSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdXRlID0gbmV3IE5hdlJvdXRlKHRoaXMsIHJvdXRlKTtcbiAgICAgICAgcm91dGVzLnB1c2gobmV3Um91dGUpO1xuICAgICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5ld1JvdXRlLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSb3V0ZShuZXdSb3V0ZS5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVJvdXRlcyhyb3V0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpIHtcbiAgICAgICAgICAgIHJvdXRlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUm91dGVzKHJvdXRlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdi5qcy5tYXAiLCJpbXBvcnQgeyBTdGF0ZUNvb3JkaW5hdG9yIH0gZnJvbSAnLi9zdGF0ZS1jb29yZGluYXRvci5qcyc7XG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbkNvb3JkaW5hdG9yT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ05hdmlnYXRpb25Db29yZGluYXRvck9wdGlvbnMgY29uc3RydWN0b3InLCBpbnB1dCk7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlcyA9IGlucHV0LnN5bmNTdGF0ZXMgPz8gW107XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Db29yZGluYXRvciBleHRlbmRzIFN0YXRlQ29vcmRpbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShyb3V0ZXIsIG5hdmlnYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0b3IgPSBuZXcgTmF2aWdhdGlvbkNvb3JkaW5hdG9yKCk7XG4gICAgICAgIGNvb3JkaW5hdG9yLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgY29vcmRpbmF0b3IubmF2aWdhdGlvbiA9IG5hdmlnYXRpb247XG4gICAgICAgIC8vIFRPRE86IFNldCBmbG93IG9wdGlvbnMgZnJvbSByb3V0ZXJcbiAgICAgICAgb3B0aW9ucy5zeW5jU3RhdGVzLmZvckVhY2goKHN0YXRlKSA9PiBjb29yZGluYXRvci5hZGRTeW5jU3RhdGUoc3RhdGUpKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ05hdmlnYXRpb25Db29yZGluYXRvciBjcmVhdGVkJywgY29vcmRpbmF0b3IpO1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0b3I7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBnZXQgaXNSZXN0cmljdGVkTmF2aWdhdGlvbigpOiBib29sZWFuIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLnN5bmNTdGF0ZXMuaGFzKCdndWFyZGVkTG9hZCcpIHx8XG4gICAgLy8gICAgIHRoaXMuc3luY1N0YXRlcy5oYXMoJ3VubG9hZGVkJykgfHxcbiAgICAvLyAgICAgdGhpcy5zeW5jU3RhdGVzLmhhcygnbG9hZGVkJykgfHxcbiAgICAvLyAgICAgdGhpcy5zeW5jU3RhdGVzLmhhcygnZ3VhcmRlZCcpIHx8XG4gICAgLy8gICAgIHRoaXMuc3luY1N0YXRlcy5oYXMoJ3JvdXRlZCcpO1xuICAgIC8vIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTmF2aWdhdGlvbkNvb3JkaW5hdG9yIFJVTicgLyosIHsgLi4udGhpcyB9ICovKTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRpdHkucnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHkucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5lbnRpdHkudHJhbnNpdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xuICAgICAgICBjb25zdCBlbnQgPSBzdXBlci5hZGRFbnRpdHkoZW50aXR5KTtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgZW50LmVudGl0eS50cmFuc2l0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnQ7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICB0aGlzLmVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IGVudGl0eS5lbnRpdHkuZmluYWxpemVDb250ZW50Q2hhbmdlKCkpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIC8vIFRPRE86IFRha2UgY2FyZSBvZiBkaXNhYmxpbmcgdmlld3BvcnRzIHdoZW4gY2FuY2VsbGluZyBhbmQgc3RhdGVmdWwhXG4gICAgICAgIHRoaXMuZW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWJvcnQgPSBlbnRpdHkuZW50aXR5LmFib3J0Q29udGVudENoYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGFib3J0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGFib3J0LmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdG9yLmNhbmNlbCh0aGlzLm5hdmlnYXRpb24pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIucHJvY2Vzc2luZ05hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnJlc29sdmUoKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4geyB0aHJvdyBlcnJvcjsgfSk7XG4gICAgfVxuICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gc2hvdWxkIGNhbmNlbCByZXBsYWNlZCBpbnN0cnVjdGlvbnNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgY2FuY2VsUmVwbGFjZWQobmF2aWdhdGlvbikgeyB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLWNvb3JkaW5hdG9yLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBOYXZpZ2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyeSA9IHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246ICcnLFxuICAgICAgICBmdWxsU3RhdGVJbnN0cnVjdGlvbjogJycsXG4gICAgfSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBlbnRyeS5uYXZpZ2F0aW9uID8/IHtcbiAgICAgICAgICAgIGZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgIG5ldzogZmFsc2UsXG4gICAgICAgICAgICByZWZyZXNoOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcndhcmQ6IGZhbHNlLFxuICAgICAgICAgICAgYmFjazogZmFsc2UsXG4gICAgICAgICAgICByZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXBlYXRpbmcgPSBlbnRyeS5yZXBlYXRpbmc7XG4gICAgICAgIC8vIElOYXZpZ2F0b3JFbnRyeVxuICAgICAgICB0aGlzLmZyb21Ccm93c2VyID0gZW50cnkuZnJvbUJyb3dzZXI7XG4gICAgICAgIHRoaXMub3JpZ2luID0gZW50cnkub3JpZ2luO1xuICAgICAgICB0aGlzLnJlcGxhY2luZyA9IGVudHJ5LnJlcGxhY2luZztcbiAgICAgICAgdGhpcy5yZWZyZXNoaW5nID0gZW50cnkucmVmcmVzaGluZztcbiAgICAgICAgdGhpcy51bnRyYWNrZWQgPSBlbnRyeS51bnRyYWNrZWQ7XG4gICAgICAgIHRoaXMuaGlzdG9yeU1vdmVtZW50ID0gZW50cnkuaGlzdG9yeU1vdmVtZW50O1xuICAgICAgICB0aGlzLnJlc29sdmUgPSBlbnRyeS5yZXNvbHZlO1xuICAgICAgICB0aGlzLnJlamVjdCA9IGVudHJ5LnJlamVjdDtcbiAgICAgICAgLy8gSVN0b3JlZE5hdmlnYXRvckVudHJ5XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24gPSBlbnRyeS5pbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy5mdWxsU3RhdGVJbnN0cnVjdGlvbiA9IGVudHJ5LmZ1bGxTdGF0ZUluc3RydWN0aW9uO1xuICAgICAgICB0aGlzLnNjb3BlID0gZW50cnkuc2NvcGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBlbnRyeS5pbmRleDtcbiAgICAgICAgdGhpcy5maXJzdEVudHJ5ID0gZW50cnkuZmlyc3RFbnRyeTtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IGVudHJ5LnJvdXRlO1xuICAgICAgICB0aGlzLnBhdGggPSBlbnRyeS5wYXRoO1xuICAgICAgICB0aGlzLnRpdGxlID0gZW50cnkudGl0bGU7XG4gICAgICAgIHRoaXMucXVlcnkgPSBlbnRyeS5xdWVyeTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gZW50cnkucGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5kYXRhID0gZW50cnkuZGF0YTtcbiAgICB9XG4gICAgZ2V0IHVzZUZ1bGxTdGF0ZUluc3RydWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubmF2aWdhdGlvbi5iYWNrID8/IGZhbHNlKSB8fCAodGhpcy5uYXZpZ2F0aW9uLmZvcndhcmQgPz8gZmFsc2UpO1xuICAgIH1cbiAgICB0b1N0b3JlZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMubmF2aWdhdGlvbixcbiAgICAgICAgICAgIHJlcGVhdGluZzogdGhpcy5yZXBlYXRpbmcsXG4gICAgICAgICAgICAvLyBJU3RvcmVkTmF2aWdhdG9yRW50cnlcbiAgICAgICAgICAgIGluc3RydWN0aW9uOiB0aGlzLmluc3RydWN0aW9uLFxuICAgICAgICAgICAgZnVsbFN0YXRlSW5zdHJ1Y3Rpb246IHRoaXMuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgZmlyc3RFbnRyeTogdGhpcy5maXJzdEVudHJ5LFxuICAgICAgICAgICAgcm91dGU6IHRoaXMucm91dGUsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgcGFyYW1ldGVyczogdGhpcy5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIiwiaW1wb3J0IHsgUXVldWUgfSBmcm9tICcuL3F1ZXVlLmpzJztcbmltcG9ydCB7IE5hdmlnYXRpb24gfSBmcm9tICcuL25hdmlnYXRpb24uanMnO1xuaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnLi9ydW5uZXIuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuICovXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHN0YXRlZnVsSGlzdG9yeUxlbmd0aDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NOYXZpZ2F0aW9ucyA9IChxRW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gcUVudHJ5O1xuICAgICAgICAgICAgY29uc3QgbmF2aWdhdGlvbkZsYWdzID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlZnJlc2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvcndhcmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJhY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlcGxhY2U6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbnRyeSA9PT0gdGhpcy51bmluaXRpYWxpemVkRW50cnkpIHsgLy8gUmVmcmVzaCBvciBmaXJzdCBlbnRyeVxuICAgICAgICAgICAgICAgIHRoaXMubG9hZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEVudHJ5ICE9PSB0aGlzLnVuaW5pdGlhbGl6ZWRFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRmxhZ3MucmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRmxhZ3MuZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRmxhZ3MubmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgcmVhbGx5IGJlIGNyZWF0ZWQgaGVyZT8gU2hvdWxkbid0IGl0IGJlIGluIHRoZSB2aWV3ZXI/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEVudHJ5ID0gbmV3IE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsU3RhdGVJbnN0cnVjdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50cnkuaW5kZXggIT09IHZvaWQgMCAmJiAhZW50cnkucmVwbGFjaW5nICYmICFlbnRyeS5yZWZyZXNoaW5nKSB7IC8vIEhpc3RvcnkgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIGVudHJ5Lmhpc3RvcnlNb3ZlbWVudCA9IGVudHJ5LmluZGV4IC0gKHRoaXMuY3VycmVudEVudHJ5LmluZGV4ICE9PSB2b2lkIDAgPyB0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCA6IDApO1xuICAgICAgICAgICAgICAgIGVudHJ5Lmluc3RydWN0aW9uID0gdGhpcy5lbnRyaWVzW2VudHJ5LmluZGV4XSAhPT0gdm9pZCAwICYmIHRoaXMuZW50cmllc1tlbnRyeS5pbmRleF0gIT09IG51bGwgPyB0aGlzLmVudHJpZXNbZW50cnkuaW5kZXhdLmZ1bGxTdGF0ZUluc3RydWN0aW9uIDogZW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICAgICAgZW50cnkucmVwbGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaGlzdG9yeU1vdmVtZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRmxhZ3MuZm9yd2FyZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5Lmhpc3RvcnlNb3ZlbWVudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkZsYWdzLmJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LnJlZnJlc2hpbmcgfHwgbmF2aWdhdGlvbkZsYWdzLnJlZnJlc2gpIHsgLy8gUmVmcmVzaGluZ1xuICAgICAgICAgICAgICAgIGVudHJ5LmluZGV4ID0gdGhpcy5jdXJyZW50RW50cnkuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5yZXBsYWNpbmcpIHsgLy8gUmVwbGFjaW5nXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkZsYWdzLnJlcGxhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25GbGFncy5uZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVudHJ5LmluZGV4ID0gdGhpcy5jdXJyZW50RW50cnkuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gTmV3IGVudHJ5XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkZsYWdzLm5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZW50cnkuaW5kZXggPSB0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCAhPT0gdm9pZCAwID8gdGhpcy5jdXJyZW50RW50cnkuaW5kZXggKyAxIDogdGhpcy5lbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW52b2tlQ2FsbGJhY2soZW50cnksIG5hdmlnYXRpb25GbGFncywgdGhpcy5jdXJyZW50RW50cnkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuaW5pdGlhbGl6ZWRFbnRyeSA9IG5ldyBOYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uOiAnTkFWSUdBVE9SIFVOSU5JVElBTElaRUQnLFxuICAgICAgICAgICAgZnVsbFN0YXRlSW5zdHJ1Y3Rpb246ICcnLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdXJyZW50RW50cnkgPSB0aGlzLnVuaW5pdGlhbGl6ZWRFbnRyeTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTmF2aWdhdGlvbnMgPSBuZXcgUXVldWUodGhpcy5wcm9jZXNzTmF2aWdhdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgcXVldWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nTmF2aWdhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgICBzdGFydChyb3V0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF2aWdhdG9yIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXZpZ2F0b3IgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdOYXZpZ2F0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIG5hdmlnYXRlKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdOYXZpZ2F0aW9ucy5lbnF1ZXVlKGVudHJ5KTtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaCgpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmN1cnJlbnRFbnRyeTtcbiAgICAgICAgaWYgKGVudHJ5ID09PSB0aGlzLnVuaW5pdGlhbGl6ZWRFbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnkucmVwbGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgZW50cnkucmVmcmVzaGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlKGVudHJ5KTtcbiAgICB9XG4gICAgYXN5bmMgZ28obW92ZW1lbnQpIHtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSAodGhpcy5jdXJyZW50RW50cnkuaW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuY3VycmVudEVudHJ5LmluZGV4IDogMCkgKyBtb3ZlbWVudDtcbiAgICAgICAgaWYgKG5ld0luZGV4ID49IHRoaXMuZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzW25ld0luZGV4XTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGUoZW50cnkpO1xuICAgIH1cbiAgICBhc3luYyBzZXRFbnRyeVRpdGxlKHRpdGxlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEVudHJ5LnRpdGxlID0gdGl0bGU7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVTdGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgdGl0bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RW50cnkgPT09IHRoaXMudW5pbml0aWFsaXplZEVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCAhPT0gdm9pZCAwID8gdGhpcy5jdXJyZW50RW50cnkuaW5kZXggOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLnNsaWNlKDAsIGluZGV4ICsgMSkuZmlsdGVyKCh2YWx1ZSkgPT4gISF2YWx1ZS50aXRsZSkubWFwKCh2YWx1ZSkgPT4gdmFsdWUudGl0bGUgPyB2YWx1ZS50aXRsZSA6ICcnKTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBzdG9yZWQgbmF2aWdhdG9yIHN0YXRlIChqc29uIG9rYXkpXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5vcHRpb25zLnN0b3JlID8geyAuLi50aGlzLm9wdGlvbnMuc3RvcmUuc3RhdGUgfSA6IHt9O1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gKHN0YXRlLmVudHJpZXMgPz8gW10pO1xuICAgICAgICBjb25zdCBjdXJyZW50RW50cnkgPSAoc3RhdGUuY3VycmVudEVudHJ5ID8/IG51bGwpO1xuICAgICAgICByZXR1cm4geyBzdGF0ZSwgZW50cmllcywgY3VycmVudEVudHJ5IH07XG4gICAgfVxuICAgIC8vIExvYWQgYSBzdG9yZWQgc3RhdGUgaW50byBOYXZpZ2F0aW9uIGVudHJpZXNcbiAgICBsb2FkU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzLm1hcChlbnRyeSA9PiBuZXcgTmF2aWdhdGlvbihlbnRyeSkpO1xuICAgICAgICB0aGlzLmN1cnJlbnRFbnRyeSA9IHN0YXRlLmN1cnJlbnRFbnRyeSAhPT0gbnVsbFxuICAgICAgICAgICAgPyBuZXcgTmF2aWdhdGlvbihzdGF0ZS5jdXJyZW50RW50cnkpXG4gICAgICAgICAgICA6IHRoaXMudW5pbml0aWFsaXplZEVudHJ5O1xuICAgIH1cbiAgICAvLyBTYXZlIHN0b3JlYWJsZSB2ZXJzaW9ucyBvZiBOYXZpZ2F0aW9uIGVudHJpZXNcbiAgICBhc3luYyBzYXZlU3RhdGUocHVzaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbnRyeSA9PT0gdGhpcy51bmluaXRpYWxpemVkRW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdG9yZWRFbnRyeSA9IHRoaXMuY3VycmVudEVudHJ5LnRvU3RvcmVkKCk7XG4gICAgICAgIHRoaXMuZW50cmllc1tzdG9yZWRFbnRyeS5pbmRleCAhPT0gdm9pZCAwID8gc3RvcmVkRW50cnkuaW5kZXggOiAwXSA9IG5ldyBOYXZpZ2F0aW9uKHN0b3JlZEVudHJ5KTtcbiAgICAgICAgLy8gSWYgcHJlc2VydmluZyBoaXN0b3J5LCBzZXJpYWxpemUgZW50cmllcyB0aGF0IGFyZW4ndCBwcmVzZXJ2ZWRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGF0ZWZ1bEhpc3RvcnlMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZW50cmllcy5sZW5ndGggLSB0aGlzLm9wdGlvbnMuc3RhdGVmdWxIaXN0b3J5TGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeS5pbnN0cnVjdGlvbiAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVudHJ5LmZ1bGxTdGF0ZUluc3RydWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlcmlhbGl6ZUVudHJ5KGVudHJ5LCB0aGlzLmVudHJpZXMuc2xpY2UoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RvcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGVudHJpZXM6ICh0aGlzLmVudHJpZXMgPz8gW10pLm1hcCgoZW50cnkpID0+IHRoaXMudG9TdG9yZWFibGVFbnRyeShlbnRyeSkpLFxuICAgICAgICAgICAgY3VycmVudEVudHJ5OiB0aGlzLnRvU3RvcmVhYmxlRW50cnkoc3RvcmVkRW50cnkpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZW50cmllcykge1xuICAgICAgICAvLyAgIHN0YXRlLmVudHJpZXMucHVzaCh0aGlzLnRvU3RvcmVhYmxlRW50cnkoZW50cnkpKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBpZiAoc3RhdGUuY3VycmVudEVudHJ5LnRpdGxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdG9yZS5zZXRUaXRsZShzdGF0ZS5jdXJyZW50RW50cnkudGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0b3JlLnB1c2hOYXZpZ2F0b3JTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0b3JlLnJlcGxhY2VOYXZpZ2F0b3JTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdG9yZWRFbnRyeShlbnRyeSkge1xuICAgICAgICBjb25zdCB7IHByZXZpb3VzLCBmcm9tQnJvd3Nlciwgb3JpZ2luLCByZXBsYWNpbmcsIHJlZnJlc2hpbmcsIHVudHJhY2tlZCwgaGlzdG9yeU1vdmVtZW50LCBuYXZpZ2F0aW9uLCBzY29wZSwgcmVzb2x2ZSwgcmVqZWN0LCAuLi5zdG9yYWJsZUVudHJ5IH0gPSBlbnRyeTtcbiAgICAgICAgcmV0dXJuIHN0b3JhYmxlRW50cnk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmFsaXplKGluc3RydWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEVudHJ5ID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuY3VycmVudEVudHJ5LmluZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbnRyeS51bnRyYWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5mcm9tQnJvd3NlciAmJiB0aGlzLm9wdGlvbnMuc3RvcmUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9wdGlvbnMuc3RvcmUucG9wTmF2aWdhdG9yU3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRFbnRyeS5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzW2luZGV4XSA9IHRoaXMuY3VycmVudEVudHJ5O1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRFbnRyeS5yZXBsYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllc1tpbmRleF0gPSB0aGlzLmN1cnJlbnRFbnRyeTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE5ldyBlbnRyeSAoYWRkIGFuZCBkaXNjYXJkIGxhdGVyIGVudHJpZXMpXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlcmlhbGl6ZUNhbGxiYWNrICE9PSB2b2lkIDAgJiYgdGhpcy5vcHRpb25zLnN0YXRlZnVsSGlzdG9yeUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNsZWFyIHRoZSBpbnN0cnVjdGlvbnMgd2UgZGlzY2FyZCFcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFByZXNlcnZlID0gdGhpcy5lbnRyaWVzLmxlbmd0aCAtIHRoaXMub3B0aW9ucy5zdGF0ZWZ1bEhpc3RvcnlMZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMuc2xpY2UoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkuaW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy5zZXJpYWxpemVDYWxsYmFjayhlbnRyeSwgdGhpcy5lbnRyaWVzLnNsaWNlKGluZGV4UHJlc2VydmUsIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMgPSB0aGlzLmVudHJpZXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnB1c2godGhpcy5jdXJyZW50RW50cnkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlU3RhdGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEVudHJ5LnJlc29sdmUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEVudHJ5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjYW5jZWwoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGluc3RydWN0aW9uLmZyb21Ccm93c2VyICYmIHRoaXMub3B0aW9ucy5zdG9yZSkge1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLm5hdmlnYXRpb24gJiYgaW5zdHJ1Y3Rpb24ubmF2aWdhdGlvbi5uZXcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9wdGlvbnMuc3RvcmUucG9wTmF2aWdhdG9yU3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy5zdG9yZS5nbygtKGluc3RydWN0aW9uLmhpc3RvcnlNb3ZlbWVudCB8fCAwKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEVudHJ5LnJlc29sdmUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEVudHJ5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VDYWxsYmFjayhlbnRyeSwgbmF2aWdhdGlvbkZsYWdzLCBwcmV2aW91c0VudHJ5KSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gbmV3IE5hdmlnYXRpb24oeyAuLi5lbnRyeSB9KTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24ubmF2aWdhdGlvbiA9IG5hdmlnYXRpb25GbGFncztcbiAgICAgICAgaW5zdHJ1Y3Rpb24ucHJldmlvdXMgPSBwcmV2aW91c0VudHJ5O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2FsbGJhY2soaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RvcmVhYmxlRW50cnkoZW50cnkpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVhYmxlID0gZW50cnkgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uID8gZW50cnkudG9TdG9yZWQoKSA6IGVudHJ5O1xuICAgICAgICBzdG9yZWFibGUuaW5zdHJ1Y3Rpb24gPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHN0b3JlYWJsZS5pbnN0cnVjdGlvbik7XG4gICAgICAgIHN0b3JlYWJsZS5mdWxsU3RhdGVJbnN0cnVjdGlvbiA9IHRoaXMucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMoc3RvcmVhYmxlLmZ1bGxTdGF0ZUluc3RydWN0aW9uKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWFibGUuc2NvcGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdG9yZWFibGUuc2NvcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZWFibGU7XG4gICAgfVxuICAgIGFzeW5jIHNlcmlhbGl6ZUVudHJ5KGVudHJ5LCBwcmVzZXJ2ZWRFbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uUmVzb2x2ZXIgPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyO1xuICAgICAgICBsZXQgZXhjbHVkZUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgLy8gQ29tcG9uZW50cyBpbiBwcmVzZXJ2ZWQgZW50cmllcyBzaG91bGQgbm90IGJlIHNlcmlhbGl6ZWQvZnJlZWRcbiAgICAgICAgZm9yIChjb25zdCBwcmVzZXJ2ZWRFbnRyeSBvZiBwcmVzZXJ2ZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXNlcnZlZEVudHJ5Lmluc3RydWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVDb21wb25lbnRzLnB1c2goLi4uaW5zdHJ1Y3Rpb25SZXNvbHZlci5mbGF0dGVuVmlld3BvcnRJbnN0cnVjdGlvbnMocHJlc2VydmVkRW50cnkuaW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udmlld3BvcnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uY29tcG9uZW50SW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlc2VydmVkRW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZUNvbXBvbmVudHMucHVzaCguLi5pbnN0cnVjdGlvblJlc29sdmVyLmZsYXR0ZW5WaWV3cG9ydEluc3RydWN0aW9ucyhwcmVzZXJ2ZWRFbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi52aWV3cG9ydCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgLm1hcChpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi5jb21wb25lbnRJbnN0YW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgdW5pcXVlXG4gICAgICAgIGV4Y2x1ZGVDb21wb25lbnRzID0gZXhjbHVkZUNvbXBvbmVudHMuZmlsdGVyKChjb21wb25lbnQsIGksIGFycikgPT4gY29tcG9uZW50ICE9PSBudWxsICYmIGFyci5pbmRleE9mKGNvbXBvbmVudCkgPT09IGkpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIC8vIFRoZSBpbnN0cnVjdGlvbnMsIG9uZSBvciB0d28sIHdpdGggcG9zc2libGUgY29tcG9uZW50cyB0byBmcmVlXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCguLi5lbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBlbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uUmVzb2x2ZXIuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMoZW50cnkuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkuaW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCguLi5lbnRyeS5pbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBlbnRyeS5pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uUmVzb2x2ZXIuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMoZW50cnkuaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3Mgb25seSB0aG9zZSB3aXRoIGluc3RhbmNlcyBhbmQgbWFrZSB1bmlxdWVcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLmZpbHRlcigoaW5zdHJ1Y3Rpb24sIGksIGFycikgPT4gaW5zdHJ1Y3Rpb24gIT09IG51bGxcbiAgICAgICAgICAgICYmIGluc3RydWN0aW9uLmNvbXBvbmVudEluc3RhbmNlICE9PSBudWxsXG4gICAgICAgICAgICAmJiBhcnIuaW5kZXhPZihpbnN0cnVjdGlvbikgPT09IGkpO1xuICAgICAgICAvLyBBbHJlYWR5IGZyZWVkIGNvbXBvbmVudHMgKHVwZGF0ZWQgd2hlbiBjb21wb25lbnQgaXMgZnJlZWQpXG4gICAgICAgIGNvbnN0IGFscmVhZHlEb25lID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZyZWVJbnN0cnVjdGlvbkNvbXBvbmVudHMoaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVDb21wb25lbnRzLCBhbHJlYWR5RG9uZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJlZUluc3RydWN0aW9uQ29tcG9uZW50cyhpbnN0cnVjdGlvbiwgZXhjbHVkZUNvbXBvbmVudHMsIGFscmVhZHlEb25lKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGluc3RydWN0aW9uLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGluc3RydWN0aW9uLnZpZXdwb3J0O1xuICAgICAgICBpZiAoY29tcG9uZW50ID09PSBudWxsIHx8IHZpZXdwb3J0ID09PSBudWxsIHx8IGFscmVhZHlEb25lLnNvbWUoZG9uZSA9PiBkb25lID09PSBjb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNsdWRlQ29tcG9uZW50cy5zb21lKGV4Y2x1ZGUgPT4gZXhjbHVkZSA9PT0gY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdmlld3BvcnQuZnJlZUNvbnRlbnQoY29tcG9uZW50KSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFscmVhZHlEb25lLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEluc3RydWN0aW9uIG9mIGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHRoaXMuZnJlZUluc3RydWN0aW9uQ29tcG9uZW50cyhuZXh0SW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVDb21wb25lbnRzLCBhbHJlYWR5RG9uZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdG9yLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBPcGVuUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXNQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgICAgIHRoaXMucmVqID0gcmVqO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlcyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJlamVjdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlaih2YWx1ZSk7XG4gICAgICAgIHRoaXMuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3Blbi1wcm9taXNlLmpzLm1hcCIsIi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUXVlcnkocXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5IHx8ICFxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0ge307XG4gICAgLy8gVE9ETzogRGVhbCB3aXRoIGNvbXBsZXggcGFyYW1ldGVycyBzdWNoIGFzIGxpc3RzIGFuZCBvYmplY3RzXG4gICAgY29uc3QgcGFyYW1zID0gcXVlcnkucmVwbGFjZSgnKycsICcgJykuc3BsaXQoJyYnKTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYXJhbS5zcGxpdCgnPScpO1xuICAgICAgICBwYXJhbWV0ZXJzW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1ldGVycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBib3VuZCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG4vKipcbiAqIEEgZmlyc3QtaW4tZmlyc3Qtb3V0IHF1ZXVlIHRoYXQgb25seSBwcm9jZXNzZXMgdGhlIG5leHQgcXVldWVkIGl0ZW1cbiAqIHdoZW4gdGhlIGN1cnJlbnQgb25lIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLiBTZW5kcyBxdWV1ZWQgaXRlbXNcbiAqIG9uZSBhdCBhIHRpbWUgdG8gYSBzcGVjaWZpZWQgY2FsbGJhY2sgZnVuY3Rpb24uIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICogc2hvdWxkIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBxdWV1ZWQgaXRlbSB3aGVuIHByb2Nlc3NpbmcgaXMgZG9uZS5cbiAqIEVucXVldWVkIGl0ZW1zIGNhbiBiZSBhd2FpdGVkLiBFbnF1ZXVlZCBpdGVtcyBjYW4gc3BlY2lmeSBhbiAoYXJiaXRyYXJ5KVxuICogZXhlY3V0aW9uIGNvc3QgYW5kIHRoZSBxdWV1ZSBjYW4gYmUgc2V0IHVwIChzdGFydGVkKSB0byBvbmx5IHByb2Nlc3NcbiAqIGEgc3BlY2lmaWMgYW1vdW50IG9mIGV4ZWN1dGlvbiBjb3N0IHBlciBSQUYvdGljay5cbiAqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseS5cbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IFtdO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudEV4ZWN1dGlvbkNvc3RJbkN1cnJlbnRUaWNrID0gMDtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFzayAhPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZy5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVldWUgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdGlvbnMucGxhdGZvcm07XG4gICAgICAgIHRoaXMuYWxsb3dlZEV4ZWN1dGlvbkNvc3RXaXRoaW5UaWNrID0gb3B0aW9ucy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2s7XG4gICAgICAgIHRoaXMudGFzayA9IHRoaXMucGxhdGZvcm0uZG9tV3JpdGVRdWV1ZS5xdWV1ZVRhc2sodGhpcy5kZXF1ZXVlLCB7IHBlcnNpc3RlbnQ6IHRydWUgfSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWV1ZSBoYXMgbm90IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFzay5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuICAgIGVucXVldWUoaXRlbU9ySXRlbXMsIGNvc3RPckNvc3RzKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KGl0ZW1Pckl0ZW1zKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBsaXN0ID8gaXRlbU9ySXRlbXMgOiBbaXRlbU9ySXRlbXNdO1xuICAgICAgICBjb25zdCBjb3N0cyA9IGl0ZW1zXG4gICAgICAgICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICFBcnJheS5pc0FycmF5KGNvc3RPckNvc3RzKSA/IGNvc3RPckNvc3RzIDogY29zdE9yQ29zdHNbaW5kZXhdKVxuICAgICAgICAgICAgLm1hcCh2YWx1ZSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiAxKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBxSXRlbSA9IHsgLi4uaXRlbSB9O1xuICAgICAgICAgICAgcUl0ZW0uY29zdCA9IGNvc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBxSXRlbS5yZXNvbHZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcUl0ZW0ucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZy5wdXNoKHFJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgcmV0dXJuIGxpc3QgPyBwcm9taXNlcyA6IHByb21pc2VzWzBdO1xuICAgIH1cbiAgICBkZXF1ZXVlKGRlbHRhKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RXhlY3V0aW9uQ29zdEluQ3VycmVudFRpY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayAhPT0gbnVsbCAmJiBkZWx0YSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuY3VycmVudEV4ZWN1dGlvbkNvc3RJbkN1cnJlbnRUaWNrICsgKHRoaXMucGVuZGluZ1swXS5jb3N0IHx8IDApID4gdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSB0aGlzLnBlbmRpbmcuc2hpZnQoKSB8fCBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRFeGVjdXRpb25Db3N0SW5DdXJyZW50VGljayArPSB0aGlzLnByb2Nlc3NpbmcuY29zdCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLnByb2Nlc3NpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnBlbmRpbmcuc3BsaWNlKDAsIHRoaXMucGVuZGluZy5sZW5ndGgpO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIGJvdW5kXG5dLCBRdWV1ZS5wcm90b3R5cGUsIFwiZGVxdWV1ZVwiLCBudWxsKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgY3VzdG9tQXR0cmlidXRlLCBJTm9kZSwgYmluZGFibGUsIEJpbmRpbmdNb2RlLCBJT2JzZXJ2ZXJMb2NhdG9yLCBDdXN0b21BdHRyaWJ1dGUgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlci5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlciB9IGZyb20gJy4uL3R5cGUtcmVzb2x2ZXJzLmpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uV2FybmluZyB9IGZyb20gJy4uL3V0aWxzLmpzJztcbmxldCBHb3RvQ3VzdG9tQXR0cmlidXRlID0gY2xhc3MgR290b0N1c3RvbUF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgcm91dGVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLmhhc0hyZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZUNsYXNzID0gJ2dvdG8tYWN0aXZlJztcbiAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKCdcImdvdG9cIiBjdXN0b20gYXR0cmlidXRlJywgJ1wibG9hZFwiIGN1c3RvbSBhdHRyaWJ1dGUnKTtcbiAgICB9XG4gICAgYmluZGluZygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yb3V0ZXIubGlua0hhbmRsZXIuaGFuZGxlcik7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJMb2NhdG9yID0gdGhpcy5yb3V0ZXIuY29udGFpbmVyLmdldChJT2JzZXJ2ZXJMb2NhdG9yKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyTG9jYXRvci5nZXRPYnNlcnZlcih0aGlzLnJvdXRlciwgJ2FjdGl2ZUNvbXBvbmVudHMnKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5zdWJzY3JpYmUodGhpcyk7XG4gICAgfVxuICAgIHVuYmluZGluZygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yb3V0ZXIubGlua0hhbmRsZXIuaGFuZGxlcik7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgfVxuICAgIHZhbHVlQ2hhbmdlZChuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNIcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0hyZWYgPSB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhc0hyZWYpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgYSBiZXR0ZXIgdmFsdWUgaGVyZSBmb3Igbm9uLXN0cmluZ3MgKHVzaW5nIEluc3RydWN0aW9uUmVzb2x2ZXI/KVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycgPyB0aGlzLnZhbHVlIDogSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IEN1c3RvbUF0dHJpYnV0ZS5mb3IodGhpcy5lbGVtZW50LCAnZ290bycpLnBhcmVudDtcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMucm91dGVyLCB0aGlzLnZhbHVlLCB7IGNvbnRleHQ6IGNvbnRyb2xsZXIgfSk7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyLnRvVmlld3BvcnRJbnN0cnVjdGlvbnModGhpcy5yb3V0ZXIsIGNyZWF0ZWQuaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5zY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnNjb3BlID0gY3JlYXRlZC5zY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVc2Ugcm91dGVyIGNvbmZpZ3VyYXRpb24gZm9yIGNsYXNzIG5hbWUgYW5kIHVwZGF0ZSB0YXJnZXRcbiAgICAgICAgaWYgKHRoaXMucm91dGVyLmNoZWNrQWN0aXZlKGluc3RydWN0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5hY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoeyBtb2RlOiBCaW5kaW5nTW9kZS50b1ZpZXcgfSlcbl0sIEdvdG9DdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5Hb3RvQ3VzdG9tQXR0cmlidXRlID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tQXR0cmlidXRlKCdnb3RvJyksXG4gICAgX19wYXJhbSgwLCBJTm9kZSksXG4gICAgX19wYXJhbSgxLCBJUm91dGVyKVxuXSwgR290b0N1c3RvbUF0dHJpYnV0ZSk7XG5leHBvcnQgeyBHb3RvQ3VzdG9tQXR0cmlidXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb3RvLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgY3VzdG9tQXR0cmlidXRlLCBJTm9kZSwgYmluZGFibGUsIEJpbmRpbmdNb2RlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IElSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXIuanMnO1xuaW1wb3J0IHsgR290b0N1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvbmZpZ3VyYXRpb24uanMnO1xubGV0IEhyZWZDdXN0b21BdHRyaWJ1dGUgPSBjbGFzcyBIcmVmQ3VzdG9tQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCByb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgfVxuICAgIGJpbmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvdXRlci5vcHRpb25zLnVzZUhyZWYgJiYgIXRoaXMuaGFzR290bygpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnJvdXRlci5saW5rSGFuZGxlci5oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgfVxuICAgIHVuYmluZGluZygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yb3V0ZXIubGlua0hhbmRsZXIuaGFuZGxlcik7XG4gICAgfVxuICAgIHZhbHVlQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBoYXNHb3RvKCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiRjb250cm9sbGVyLnBhcmVudDtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIHJldHVybiBzaWJsaW5ncyAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgc2libGluZ3Muc29tZShjID0+IGMudm1LaW5kID09PSAxIC8qIGN1c3RvbUF0dHJpYnV0ZSAqLyAmJiBjLnZpZXdNb2RlbCBpbnN0YW5jZW9mIEdvdG9DdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSh7IG1vZGU6IEJpbmRpbmdNb2RlLnRvVmlldyB9KVxuXSwgSHJlZkN1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbkhyZWZDdXN0b21BdHRyaWJ1dGUgPSBfX2RlY29yYXRlKFtcbiAgICBjdXN0b21BdHRyaWJ1dGUoe1xuICAgICAgICBuYW1lOiAnaHJlZicsXG4gICAgICAgIG5vTXVsdGlCaW5kaW5nczogdHJ1ZVxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMSwgSVJvdXRlcilcbl0sIEhyZWZDdXN0b21BdHRyaWJ1dGUpO1xuZXhwb3J0IHsgSHJlZkN1c3RvbUF0dHJpYnV0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHJlZi5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGN1c3RvbUF0dHJpYnV0ZSwgSU5vZGUsIGJpbmRhYmxlLCBCaW5kaW5nTW9kZSwgSU9ic2VydmVyTG9jYXRvciwgQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IElSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXIuanMnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIgfSBmcm9tICcuLi90eXBlLXJlc29sdmVycy5qcyc7XG5sZXQgTG9hZEN1c3RvbUF0dHJpYnV0ZSA9IGNsYXNzIExvYWRDdXN0b21BdHRyaWJ1dGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHJvdXRlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5oYXNIcmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGFzcyA9ICdsb2FkLWFjdGl2ZSc7XG4gICAgfVxuICAgIGJpbmRpbmcoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucm91dGVyLmxpbmtIYW5kbGVyLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyTG9jYXRvciA9IHRoaXMucm91dGVyLmNvbnRhaW5lci5nZXQoSU9ic2VydmVyTG9jYXRvcik7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlckxvY2F0b3IuZ2V0T2JzZXJ2ZXIodGhpcy5yb3V0ZXIsICdhY3RpdmVDb21wb25lbnRzJyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH1cbiAgICB1bmJpbmRpbmcoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucm91dGVyLmxpbmtIYW5kbGVyLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZWQobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzSHJlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oYXNIcmVmID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNIcmVmKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGEgYmV0dGVyIHZhbHVlIGhlcmUgZm9yIG5vbi1zdHJpbmdzICh1c2luZyBJbnN0cnVjdGlvblJlc29sdmVyPylcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnID8gdGhpcy52YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBDdXN0b21BdHRyaWJ1dGUuZm9yKHRoaXMuZWxlbWVudCwgJ2xvYWQnKS5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9ucyh0aGlzLnJvdXRlciwgdGhpcy52YWx1ZSwgeyBjb250ZXh0OiBjb250cm9sbGVyIH0pO1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMucm91dGVyLCBjcmVhdGVkLmluc3RydWN0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5zY29wZSA9IGNyZWF0ZWQuc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogVXNlIHJvdXRlciBjb25maWd1cmF0aW9uIGZvciBjbGFzcyBuYW1lIGFuZCB1cGRhdGUgdGFyZ2V0XG4gICAgICAgIGlmICh0aGlzLnJvdXRlci5jaGVja0FjdGl2ZShpbnN0cnVjdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKHsgbW9kZTogQmluZGluZ01vZGUudG9WaWV3IH0pXG5dLCBMb2FkQ3VzdG9tQXR0cmlidXRlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuTG9hZEN1c3RvbUF0dHJpYnV0ZSA9IF9fZGVjb3JhdGUoW1xuICAgIGN1c3RvbUF0dHJpYnV0ZSgnbG9hZCcpLFxuICAgIF9fcGFyYW0oMCwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMSwgSVJvdXRlcilcbl0sIExvYWRDdXN0b21BdHRyaWJ1dGUpO1xuZXhwb3J0IHsgTG9hZEN1c3RvbUF0dHJpYnV0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGJpbmRhYmxlLCBjdXN0b21FbGVtZW50IH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IElSb3V0ZXIgfSBmcm9tICcuLi9yb3V0ZXIuanMnO1xubGV0IE5hdkN1c3RvbUVsZW1lbnQgPSBjbGFzcyBOYXZDdXN0b21FbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucm91dGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIH1cbiAgICBnZXQgbmF2Um91dGVzKCkge1xuICAgICAgICBjb25zdCBuYXYgPSB0aGlzLnJvdXRlci5uYXZzW3RoaXMubmFtZV07XG4gICAgICAgIHJldHVybiAobmF2ICE9PSB2b2lkIDAgJiYgbmF2ICE9PSBudWxsID8gbmF2LnJvdXRlcyA6IFtdKTtcbiAgICB9XG4gICAgZ2V0IG5hdkNsYXNzZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hdiA9IHRoaXMucm91dGVyLm5hdnNbdGhpcy5uYW1lXTtcbiAgICAgICAgY29uc3QgbmF2Q2xhc3NlcyA9IChuYXYgIT09IHZvaWQgMCAmJiBuYXYgIT09IG51bGwgPyBuYXYuY2xhc3NlcyA6IHt9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICBuYXY6ICcnLFxuICAgICAgICAgICAgICAgIHVsOiAnJyxcbiAgICAgICAgICAgICAgICBsaTogJycsXG4gICAgICAgICAgICAgICAgYTogJycsXG4gICAgICAgICAgICAgICAgdWxBY3RpdmU6ICcnLFxuICAgICAgICAgICAgICAgIGxpQWN0aXZlOiAnbmF2LWFjdGl2ZScsXG4gICAgICAgICAgICAgICAgYUFjdGl2ZTogJycsXG4gICAgICAgICAgICB9LCAuLi5uYXZDbGFzc2VzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFjdGl2ZShyb3V0ZSkge1xuICAgICAgICByZXR1cm4gJ0FjdGl2ZSc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBOYXZDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgTmF2Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwicm91dGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgTmF2Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibGV2ZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBOYXZDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJjbGFzc2VzXCIsIHZvaWQgMCk7XG5OYXZDdXN0b21FbGVtZW50ID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tRWxlbWVudCh7XG4gICAgICAgIG5hbWU6ICdhdS1uYXYnLCB0ZW1wbGF0ZTogYDx0ZW1wbGF0ZT5cbiAgPG5hdiBpZi5iaW5kPVwibmFtZVwiIGNsYXNzPVwiXFwke25hbWV9IFxcJHtuYXZDbGFzc2VzLm5hdn1cIj5cbiAgICA8YXUtbmF2IHJvdXRlcy5iaW5kPVwibmF2Um91dGVzXCIgY2xhc3Nlcy5iaW5kPVwibmF2Q2xhc3Nlc1wiIGNvbnRhaW5lcmxlc3M+PC9hdS1uYXY+XG4gIDwvbmF2PlxuICA8dWwgaWYuYmluZD1cInJvdXRlc1wiIGNsYXNzPVwibmF2LWxldmVsLVxcJHtsZXZlbH0gXFwke2NsYXNzZXMudWx9XCI+XG4gICAgPGxpIHJlcGVhdC5mb3I9XCJyb3V0ZSBvZiByb3V0ZXNcIiBpZi5iaW5kPVwicm91dGUudmlzaWJsZVwiIGNsYXNzPVwiXFwke3JvdXRlLmFjdGl2ZSA/IGNsYXNzZXMubGlBY3RpdmUgOiAnJ30gXFwke3JvdXRlLmhhc0NoaWxkcmVufSBcXCR7Y2xhc3Nlcy5saX1cIj5cbiAgICAgIDxhIGlmLmJpbmQ9XCJyb3V0ZS5saW5rICYmIHJvdXRlLmxpbmsubGVuZ3RoXCIgbG9hZD1cIlxcJHtyb3V0ZS5saW5rfVwiIGNsYXNzPVwiXFwke3JvdXRlLmFjdGl2ZSA/IGNsYXNzZXMuYUFjdGl2ZSA6ICcnfSBcXCR7Y2xhc3Nlcy5hfVwiIGlubmVyaHRtbC5iaW5kPVwicm91dGUudGl0bGVcIj48L2E+XG4gICAgICA8YSBpZi5iaW5kPVwicm91dGUuZXhlY3V0ZVwiIGNsaWNrLnRyaWdnZXI9XCJyb3V0ZS5leGVjdXRlQWN0aW9uKCRldmVudClcIiBocmVmPVwiXCIgY2xhc3M9XCJcXCR7cm91dGUuYWN0aXZlID8gY2xhc3Nlcy5hQWN0aXZlIDogJyd9IFxcJHtjbGFzc2VzLmF9XCIgaW5uZXJodG1sLmJpbmQ9XCJyb3V0ZS50aXRsZVwiPjwvYT5cbiAgICAgIDxzcGFuIGlmLmJpbmQ9XCIoIXJvdXRlLmxpbmsgfHwgIXJvdXRlLmxpbmsubGVuZ3RoKSAmJiAhcm91dGUuZXhlY3V0ZSAmJiAhcm91dGUuY2hpbGRyZW5cIiBjbGFzcz1cIlxcJHtyb3V0ZS5hY3RpdmUgPyBjbGFzc2VzLmFBY3RpdmUgOiAnJ30gXFwke2NsYXNzZXMuc3Bhbn0gbmF2LXNlcGFyYXRvclwiIGlubmVyaHRtbC5iaW5kPVwicm91dGUudGl0bGVcIj48L3NwYW4+XG4gICAgICA8YSBpZi5iaW5kPVwiKCFyb3V0ZS5saW5rIHx8ICFyb3V0ZS5saW5rLmxlbmd0aCkgJiYgIXJvdXRlLmV4ZWN1dGUgJiYgcm91dGUuY2hpbGRyZW5cIiBjbGljay5kZWxlZ2F0ZT1cInJvdXRlLnRvZ2dsZUFjdGl2ZSgpXCIgaHJlZj1cIlwiIGNsYXNzPVwiXFwke3JvdXRlLmFjdGl2ZSA/IGNsYXNzZXMuYUFjdGl2ZSA6ICcnfSBcXCR7Y2xhc3Nlcy5hfVwiIGlubmVyaHRtbC5iaW5kPVwicm91dGUudGl0bGVcIj48L2E+XG4gICAgICA8YXUtbmF2IGlmLmJpbmQ9XCJyb3V0ZS5jaGlsZHJlblwiIHJvdXRlcy5iaW5kPVwicm91dGUuY2hpbGRyZW5cIiBsZXZlbC5iaW5kPVwibGV2ZWwgKyAxXCIgY2xhc3Nlcy5iaW5kPVwiY2xhc3Nlc1wiIGNvbnRhaW5lcmxlc3M+PC9hdS1uYXY+XG4gICAgPC9saT5cbiAgPC91bD5cbjwvdGVtcGxhdGU+YFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgSVJvdXRlcilcbl0sIE5hdkN1c3RvbUVsZW1lbnQpO1xuZXhwb3J0IHsgTmF2Q3VzdG9tRWxlbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2LmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50XzE7XG5pbXBvcnQgeyBiaW5kYWJsZSwgSU5vZGUsIGN1c3RvbUVsZW1lbnQsIEN1c3RvbUVsZW1lbnQsIElDb250cm9sbGVyLCBpc0N1c3RvbUVsZW1lbnRDb250cm9sbGVyLCBpc0N1c3RvbUVsZW1lbnRWaWV3TW9kZWwsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IElDb250YWluZXIgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlci5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3ZpZXdwb3J0LmpzJztcbmV4cG9ydCBjb25zdCBQYXJlbnRWaWV3cG9ydFNjb3BlID0gQ3VzdG9tRWxlbWVudC5jcmVhdGVJbmplY3RhYmxlKCk7XG5sZXQgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQgPSBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudF8xID0gY2xhc3MgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJvdXRlciwgZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnQsIHBhcmVudENvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5wYXJlbnRDb250cm9sbGVyID0gcGFyZW50Q29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB0aGlzLmNhdGNoZXMgPSAnJztcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3cG9ydFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIE1heWJlIHRoaXMgcmVhbGx5IHNob3VsZCBiZSBoZXJlLiBDaGVjayB3aXRoIEZyZWRcbiAgICAvLyBwdWJsaWMgY3JlYXRlKFxuICAgIC8vICAgY29udHJvbGxlcjogSURyeUN1c3RvbUVsZW1lbnRDb250cm9sbGVyPHRoaXM+LFxuICAgIC8vICAgcGFyZW50Q29udGFpbmVyOiBJQ29udGFpbmVyLFxuICAgIC8vICAgZGVmaW5pdGlvbjogQ3VzdG9tRWxlbWVudERlZmluaXRpb24sXG4gICAgLy8gICBwYXJ0czogUGFydGlhbEN1c3RvbUVsZW1lbnREZWZpbml0aW9uUGFydHMgfCB1bmRlZmluZWQsXG4gICAgLy8gKTogUGFydGlhbEN1c3RvbUVsZW1lbnREZWZpbml0aW9uIHtcbiAgICAvLyAgIC8vIFRPRE8oZmtsZXV2ZXIpOiBkZXNjcmliZSB0aGlzIHNvbWV3aGVyZSBpbiB0aGUgZG9jcyBpbnN0ZWFkXG4gICAgLy8gICAvLyBVbmRlciB0aGUgY29uZGl0aW9uIHRoYXQgdGhlcmUgaXMgbm8gYHJlcGxhY2VgIGF0dHJpYnV0ZSBvbiB0aGlzIGN1c3RvbSBlbGVtZW50J3MgZGVjbGFyYXRpb24sXG4gICAgLy8gICAvLyBhbmQgdGhpcyBjdXN0b20gZWxlbWVudCBpcyBjb250YWluZXJsZXNzLCBpdHMgY29udGVudCB3aWxsIGJlIHBsYWNlZCBpbiBhIHBhcnQgbmFtZWQgJ2RlZmF1bHQnXG4gICAgLy8gICAvLyBTZWUgcGFja2FnZXMvaml0LWh0bWwvc3JjL3RlbXBsYXRlLWJpbmRlci50cyBsaW5lIDQxMSAoYHJlcGxhY2UgPSAnZGVmYXVsdCc7YCkgZm9yIHRoZSBsb2dpYyB0aGF0IGdvdmVybnMgdGhpcy5cbiAgICAvLyAgIC8vIFdlIGNvdWxkIHRpZHkgdGhpcyB1cCBpbnRvIGEgZm9ybWFsIGFwaSBpbiB0aGUgZnV0dXJlLiBGb3Igbm93LCB0aGVyZSBhcmUgdHdvIHdheXMgdG8gZG8gdGhpczpcbiAgICAvLyAgIC8vIDEuIGluamVjdCB0aGUgYEBJSW5zdHJ1Y3Rpb25gIChJSHlkcmF0ZUVsZW1lbnRJbnN0cnVjdGlvbikgYW5kIGdyYWIgLnBhcnRzWydkZWZhdWx0J10gZnJvbSB0aGVyZSwgbWFudWFsbHkgY3JlYXRpbmcgYSB2aWV3IGZhY3RvcnkgZnJvbSB0aGF0LCBldGMuXG4gICAgLy8gICAvLyAyLiB3aGF0IHdlJ3JlIGRvaW5nIHJpZ2h0IGhlcmU6IGdyYWIgdGhlICdkZWZhdWx0JyBwYXJ0IGZyb20gdGhlIGNyZWF0ZSBob29rIGFuZCByZXR1cm4gaXQgYXMgdGhlIGRlZmluaXRpb24sIHRlbGxpbmcgdGhlIHJlbmRlciBjb250ZXh0IHRvIHVzZSB0aGF0IHBhcnQgdG8gY29tcGlsZSB0aGlzIGVsZW1lbnQgaW5zdGVhZFxuICAgIC8vICAgLy8gVGhpcyBlZmZlY3RpdmVseSBjYXVzZXMgdGhpcyBlbGVtZW50IHRvIHJlbmRlciBpdHMgZGVjbGFyZWQgY29udGVudCBhcyBpZiBpdCB3YXMgaXRzIG93biB0ZW1wbGF0ZS5cbiAgICAvLyAgIC8vIFdlIGRvIG5lZWQgdG8gc2V0IGBjb250YWluZXJsZXNzYCB0byB0cnVlIG9uIHRoZSBwYXJ0IGRlZmluaXRpb24gc28gdGhhdCB0aGUgY29ycmVjdCBwcm9qZWN0b3IgaXMgdXNlZCBzaW5jZSBwYXJ0cyBkZWZhdWx0IHRvIG5vbi1jb250YWluZXJsZXNzLlxuICAgIC8vICAgLy8gT3RoZXJ3aXNlLCB0aGUgY29udHJvbGxlciB3aWxsIHRyeSB0byBkbyBgYXBwZW5kQ2hpbGRgIG9uIGEgY29tbWVudCBub2RlIHdoZW4gaXQgaGFzIHRvIGRvIGBpbnNlcnRCZWZvcmVgLlxuICAgIC8vICAgLy8gQWxzbywgaW4gdGhpcyBwYXJ0aWN1bGFyIHNjZW5hcmlvIChzcGVjaWZpYyB0byB2aWV3cG9ydC1zY29wZSkgd2UgbmVlZCB0byBjbG9uZSB0aGUgcGFydCBzbyBhcyB0byBwcmV2ZW50IHRoZSByZXN1bHRpbmcgY29tcGlsZWQgZGVmaW5pdGlvblxuICAgIC8vICAgLy8gZnJvbSBldmVyIGJlaW5nIGNhY2hlZC4gVGhhdCdzIHRoZSBvbmx5IHJlYXNvbiB3aHkgd2UncmUgc3ByZWFkaW5nIHRoZSBwYXJ0IGludG8gYSBuZXcgb2JqZWN0IGZvciBgZ2V0T3JDcmVhdGVgLiBJZiB3ZSBkaWRuJ3QgY2xvbmUgdGhlIG9iamVjdCwgdGhpcyBzcGVjaWZpYyBlbGVtZW50IHdvdWxkbid0IHdvcmsgY29ycmVjdGx5LlxuICAgIC8vICAgY29uc3QgcGFydCA9IHBhcnRzIVsnZGVmYXVsdCddO1xuICAgIC8vICAgcmV0dXJuIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLmdldE9yQ3JlYXRlKHsgLi4ucGFydCwgY29udGFpbmVybGVzczogdHJ1ZSB9KTtcbiAgICAvLyB9XG4gICAgaHlkcmF0ZWQoY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAvLyBEb24ndCB1cGRhdGUgdGhlIGNvbnRhaW5lciBoZXJlIChwcm9iYWJseSBiZWNhdXNlIGl0IHdhbnRzIHRvIGJlIGEgcGFydCBvZiB0aGUgc3RydWN0dXJlKVxuICAgICAgICAvLyB0aGlzLmNvbnRhaW5lciA9IGNvbnRyb2xsZXIuY29udGV4dC5nZXQoSUNvbnRhaW5lcik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdWaWV3cG9ydFNjb3BlIGNyZWF0aW5nJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnLCB0aGlzLm5hbWUpLCB0aGlzLmNvbnRhaW5lciwgdGhpcy5wYXJlbnQsIGNvbnRyb2xsZXIsIHRoaXMpO1xuICAgICAgICAvLyB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgYm91bmQoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJGNvbnRyb2xsZXIuc2NvcGUgPSB0aGlzLnBhcmVudENvbnRyb2xsZXIuc2NvcGU7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydFNjb3BlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0U2NvcGUuYmluZGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnRTY29wZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydFNjb3BlLnVuYmluZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgYWZ0ZXJVbmJpbmQoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGFmdGVyVW5ib3VuZCgpIHtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvdXRlci5yb290U2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnLCB0aGlzLm5hbWUpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjYXRjaGVzJywgdGhpcy5jYXRjaGVzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2F0Y2hlcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbGxlY3Rpb24nLCB0aGlzLmNvbGxlY3Rpb24sIHRydWUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogTmVlZHMgdG8gYmUgYm91bmQ/IEhvdyB0byBzb2x2ZT9cbiAgICAgICAgb3B0aW9ucy5zb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIucm91dGluZ0NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICB0aGlzLnZpZXdwb3J0U2NvcGUgPSB0aGlzLnJvdXRlci5jb25uZWN0Vmlld3BvcnRTY29wZSh0aGlzLnZpZXdwb3J0U2NvcGUsIHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlci5kaXNjb25uZWN0Vmlld3BvcnRTY29wZSh0aGlzLnZpZXdwb3J0U2NvcGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRTY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZShrZXksIHZhbHVlLCBjaGVja0V4aXN0cyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaXNDdXN0b21FbGVtZW50Q29udHJvbGxlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50Q29udHJvbGxlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlzQ3VzdG9tRWxlbWVudFZpZXdNb2RlbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50Vmlld01vZGVsKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0Q2xvc2VzdEN1c3RvbUVsZW1lbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRyb2xsZXIucGFyZW50O1xuICAgICAgICBsZXQgY3VzdG9tRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgY3VzdG9tRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC52aWV3TW9kZWwgaW5zdGFuY2VvZiBWaWV3cG9ydEN1c3RvbUVsZW1lbnQgfHwgcGFyZW50LnZpZXdNb2RlbCBpbnN0YW5jZW9mIFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50XzEpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50ID0gcGFyZW50LnZpZXdNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1c3RvbUVsZW1lbnQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJjYXRjaGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRTY29wZUN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcImNvbGxlY3Rpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwic291cmNlXCIsIHZvaWQgMCk7XG5WaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCA9IFZpZXdwb3J0U2NvcGVDdXN0b21FbGVtZW50XzEgPSBfX2RlY29yYXRlKFtcbiAgICBjdXN0b21FbGVtZW50KHtcbiAgICAgICAgbmFtZTogJ2F1LXZpZXdwb3J0LXNjb3BlJyxcbiAgICAgICAgdGVtcGxhdGU6ICc8dGVtcGxhdGU+PC90ZW1wbGF0ZT4nLFxuICAgICAgICBjb250YWluZXJsZXNzOiBmYWxzZSxcbiAgICAgICAgaW5qZWN0YWJsZTogUGFyZW50Vmlld3BvcnRTY29wZVxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgSVJvdXRlciksXG4gICAgX19wYXJhbSgxLCBJTm9kZSksXG4gICAgX19wYXJhbSgyLCBJQ29udGFpbmVyKSxcbiAgICBfX3BhcmFtKDMsIFBhcmVudFZpZXdwb3J0U2NvcGUpLFxuICAgIF9fcGFyYW0oNCwgSUNvbnRyb2xsZXIpXG5dLCBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCk7XG5leHBvcnQgeyBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3BvcnQtc2NvcGUuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgVmlld3BvcnRDdXN0b21FbGVtZW50XzE7XG5pbXBvcnQgeyBJQ29udGFpbmVyIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IGJpbmRhYmxlLCBJTm9kZSwgY3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudCwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgSVJvdXRlciB9IGZyb20gJy4uL3JvdXRlci5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCB9IGZyb20gJy4vdmlld3BvcnQtc2NvcGUuanMnO1xuaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnLi4vcnVubmVyLmpzJztcbmV4cG9ydCBjb25zdCBQYXJlbnRWaWV3cG9ydCA9IEN1c3RvbUVsZW1lbnQuY3JlYXRlSW5qZWN0YWJsZSgpO1xubGV0IFZpZXdwb3J0Q3VzdG9tRWxlbWVudCA9IFZpZXdwb3J0Q3VzdG9tRWxlbWVudF8xID0gY2xhc3MgVmlld3BvcnRDdXN0b21FbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXIsIGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Vmlld3BvcnQpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnBhcmVudFZpZXdwb3J0ID0gcGFyZW50Vmlld3BvcnQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgdGhpcy51c2VkQnkgPSAnJztcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gJyc7XG4gICAgICAgIHRoaXMuZmFsbGJhY2sgPSAnJztcbiAgICAgICAgdGhpcy5ub1Njb3BlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9MaW5rID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9UaXRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vSGlzdG9yeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlZnVsID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaHlkcmF0ZWQoY29udHJvbGxlcikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaHlkcmF0ZWQnLCB0aGlzLm5hbWUsIHRoaXMucm91dGVyLmlzQWN0aXZlKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250cm9sbGVyLmNvbnRleHQuZ2V0KElDb250YWluZXIpO1xuICAgICAgICAvLyBUaGUgZmlyc3Qgdmlld3BvcnQocykgbWlnaHQgYmUgY29tcGlsZWQgYmVmb3JlIHRoZSByb3V0ZXIgaXMgYWN0aXZlXG4gICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHRoaXMud2FpdEZvclJvdXRlclN0YXJ0KCksICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlci5pc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiaW5kaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLndhaXRGb3JSb3V0ZXJTdGFydCgpLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm91dGVyLmlzUmVzdHJpY3RlZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQgIT09IG51bGwgJiYgKHRoaXMudmlld3BvcnQubmV4dENvbnRlbnQgPz8gbnVsbCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhdHRhY2hpbmcnLCB0aGlzLnZpZXdwb3J0Py50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5hY3RpdmF0ZShpbml0aWF0b3IsIHRoaXMuJGNvbnRyb2xsZXIsIGZsYWdzLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlc3RvcmUgc2Nyb2xsIHN0YXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5iaW5kaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydCAhPT0gbnVsbCAmJiAodGhpcy52aWV3cG9ydC5uZXh0Q29udGVudCA/PyBudWxsKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3VuYmluZGluZycsIHRoaXMudmlld3BvcnQ/LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgLy8gVE9ETzogU2F2ZSB0byBjYWNoZSwgc29tZXRoaW5nIGxpa2VcbiAgICAgICAgICAgIC8vIHRoaXMudmlld3BvcnQuY2FjaGVDb250ZW50KCk7XG4gICAgICAgICAgICAvLyBGcm9tIHZpZXdwb3J0LWNvbnRlbnQ6XG4gICAgICAgICAgICAvLyBwdWJsaWMgdW5sb2FkQ29tcG9uZW50KGNhY2hlOiBWaWV3cG9ydENvbnRlbnRbXSwgc3RhdGVmdWw6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgLy8gICAvLyBUT0RPOiBXZSBtaWdodCB3YW50IHRvIGRvIHNvbWV0aGluZyBoZXJlIGV2ZW50dWFsbHksIHdobyBrbm93cz9cbiAgICAgICAgICAgIC8vICAgaWYgKHRoaXMuY29udGVudFN0YXR1cyAhPT0gQ29udGVudFN0YXR1cy5sb2FkZWQpIHtcbiAgICAgICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vICAgLy8gRG9uJ3QgdW5sb2FkIGNvbXBvbmVudHMgd2hlbiBzdGF0ZWZ1bFxuICAgICAgICAgICAgLy8gICBpZiAoIXN0YXRlZnVsKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5jb250ZW50U3RhdHVzID0gQ29udGVudFN0YXR1cy5jcmVhdGVkO1xuICAgICAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIGNhY2hlLnB1c2godGhpcyk7XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIFRPRE86IFNhdmUgc2Nyb2xsIHN0YXRlIGJlZm9yZSBkZXRhY2hcbiAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHRoaXMudmlld3BvcnQuZGVhY3RpdmF0ZShpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydC5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdGhpcy52aWV3cG9ydC5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhpcy52aWV3cG9ydC5kZWFjdGl2YXRlKGluaXRpYXRvciwgcGFyZW50LCBmbGFncyk7XG4gICAgICAgICAgICAvLyAvLyB0aGlzLnZpZXdwb3J0LmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwdWJsaWMgZGV0YWNoaW5nKGluaXRpYXRvcjogSUh5ZHJhdGVkQ29udHJvbGxlciwgcGFyZW50OiBJU3ludGhldGljVmlldyB8IElDdXN0b21FbGVtZW50Q29udHJvbGxlcjxJQ3VzdG9tRWxlbWVudFZpZXdNb2RlbD4gfCBudWxsLCBmbGFnczogTGlmZWN5Y2xlRmxhZ3MpOiB2b2lkIHwgUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gICBpZiAodGhpcy52aWV3cG9ydCAhPT0gbnVsbCAmJiAodGhpcy52aWV3cG9ydC5uZXh0Q29udGVudCA/PyBudWxsKSA9PT0gbnVsbCkge1xuICAgIC8vICAgICBjb25zb2xlLmxvZygnZGV0YWNoaW5nJywgdGhpcy52aWV3cG9ydD8udG9TdHJpbmcoKSk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiAodGhpcy52aWV3cG9ydD8ubmV4dENvbnRlbnQgPz8gbnVsbCkgPT09IG51bGwgPyB0aGlzLnZpZXdwb3J0Py5kaXNwb3NlKCkgOiB2b2lkIDAsICgpID0+IHRoaXMuZGlzY29ubmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXIucm9vdFNjb3BlID09PSBudWxsIHx8ICh0aGlzLnZpZXdwb3J0ICE9PSBudWxsICYmIHRoaXMucm91dGVyLmlzUmVzdHJpY3RlZE5hdmlnYXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGV0IGNvbnRyb2xsZXJDb250YWluZXIgPSAodGhpcy5jb250cm9sbGVyLmNvbnRleHQgYXMgYW55KS5jb250YWluZXI7XG4gICAgICAgIC8vIGxldCBvdXRwdXQgPSAnJztcbiAgICAgICAgLy8gZG8ge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKG91dHB1dCwgJzonLCBjb250cm9sbGVyQ29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lciwgdGhpcy5jb250cm9sbGVyLCBjb250cm9sbGVyQ29udGFpbmVyLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIC8vICAgaWYgKGNvbnRyb2xsZXJDb250YWluZXIgPT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgIC8vICAgICBicmVhaztcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vICAgY29udHJvbGxlckNvbnRhaW5lciA9IGNvbnRyb2xsZXJDb250YWluZXIucGFyZW50O1xuICAgICAgICAvLyAgIG91dHB1dCArPSAnLnBhcmVudCc7XG4gICAgICAgIC8vIH0gd2hpbGUgKGNvbnRyb2xsZXJDb250YWluZXIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnLCB0aGlzLm5hbWUpO1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbm8tc2NvcGUnLCB0aGlzLm5vU2NvcGUpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0geyBzY29wZTogdmFsdWUgPT09IHZvaWQgMCB8fCAhdmFsdWUgPyB0cnVlIDogZmFsc2UgfTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgndXNlZC1ieScsIHRoaXMudXNlZEJ5KTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMudXNlZEJ5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGVmYXVsdCcsIHRoaXMuZGVmYXVsdCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmYWxsYmFjaycsIHRoaXMuZmFsbGJhY2spO1xuICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0aW9ucy5mYWxsYmFjayA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25vLWxpbmsnLCB0aGlzLm5vTGluaywgdHJ1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm5vTGluayA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25vLXRpdGxlJywgdGhpcy5ub1RpdGxlLCB0cnVlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMubm9UaXRsZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25vLWhpc3RvcnknLCB0aGlzLm5vSGlzdG9yeSwgdHJ1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm5vSGlzdG9yeSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0YXRlZnVsJywgdGhpcy5zdGF0ZWZ1bCwgdHJ1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0YXRlZnVsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnJvdXRpbmdDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMucm91dGVyLmNvbm5lY3RWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB0aGlzLCBuYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMucm91dGVyLmRpc2Nvbm5lY3RWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0QXR0cmlidXRlKGtleSwgdmFsdWUsIGNoZWNrRXhpc3RzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGlmICh0aGlzLmlzQm91bmQgJiYgIWNoZWNrRXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBnZXRDbG9zZXN0Q3VzdG9tRWxlbWVudCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuY29udHJvbGxlci5wYXJlbnQ7XG4gICAgICAgIGxldCBjdXN0b21FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBjdXN0b21FbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnZpZXdNb2RlbCBpbnN0YW5jZW9mIFZpZXdwb3J0Q3VzdG9tRWxlbWVudF8xIHx8IHBhcmVudC52aWV3TW9kZWwgaW5zdGFuY2VvZiBWaWV3cG9ydFNjb3BlQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnQgPSBwYXJlbnQudmlld01vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VzdG9tRWxlbWVudDtcbiAgICB9XG4gICAgLy8gVE9ETzogU3dpdGNoIHRoaXMgdG8gdXNlIChwcm9iYWJseSkgYW4gZXZlbnQgaW5zdGVhZFxuICAgIHdhaXRGb3JSb3V0ZXJTdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlci5zdGFydGVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwidXNlZEJ5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJkZWZhdWx0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJmYWxsYmFja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibm9TY29wZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFZpZXdwb3J0Q3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIFwibm9MaW5rXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJub1RpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgVmlld3BvcnRDdXN0b21FbGVtZW50LnByb3RvdHlwZSwgXCJub0hpc3RvcnlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBWaWV3cG9ydEN1c3RvbUVsZW1lbnQucHJvdG90eXBlLCBcInN0YXRlZnVsXCIsIHZvaWQgMCk7XG5WaWV3cG9ydEN1c3RvbUVsZW1lbnQgPSBWaWV3cG9ydEN1c3RvbUVsZW1lbnRfMSA9IF9fZGVjb3JhdGUoW1xuICAgIGN1c3RvbUVsZW1lbnQoe1xuICAgICAgICBuYW1lOiAnYXUtdmlld3BvcnQnLFxuICAgICAgICBpbmplY3RhYmxlOiBQYXJlbnRWaWV3cG9ydFxuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgSVJvdXRlciksXG4gICAgX19wYXJhbSgxLCBJTm9kZSksXG4gICAgX19wYXJhbSgyLCBJQ29udGFpbmVyKSxcbiAgICBfX3BhcmFtKDMsIFBhcmVudFZpZXdwb3J0KVxuXSwgVmlld3BvcnRDdXN0b21FbGVtZW50KTtcbmV4cG9ydCB7IFZpZXdwb3J0Q3VzdG9tRWxlbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3BvcnQuanMubWFwIiwiaW1wb3J0IHsgUm91dGVSZWNvZ25pemVyIGFzICRSb3V0ZVJlY29nbml6ZXIsIENvbmZpZ3VyYWJsZVJvdXRlIGFzICRDb25maWd1cmFibGVSb3V0ZSwgUmVjb2duaXplZFJvdXRlIGFzICRSZWNvZ25pemVkUm91dGUsIEVuZHBvaW50IGFzICRFbmRwb2ludCwgfSBmcm9tICdAYXVyZWxpYS9yb3V0ZS1yZWNvZ25pemVyJztcbmV4cG9ydCBjb25zdCBSb3V0ZVJlY29nbml6ZXIgPSAkUm91dGVSZWNvZ25pemVyO1xuZXhwb3J0IGNvbnN0IENvbmZpZ3VyYWJsZVJvdXRlID0gJENvbmZpZ3VyYWJsZVJvdXRlO1xuZXhwb3J0IGNvbnN0IFJlY29nbml6ZWRSb3V0ZSA9ICRSZWNvZ25pemVkUm91dGU7XG5leHBvcnQgY29uc3QgRW5kcG9pbnQgPSAkRW5kcG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1yZWNvZ25pemVyLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBSb3V0ZXJPcHRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXBhcmF0b3JzID0ge1xuICAgICAgICAgICAgdmlld3BvcnQ6ICdAJyxcbiAgICAgICAgICAgIHNpYmxpbmc6ICcrJyxcbiAgICAgICAgICAgIHNjb3BlOiAnLycsXG4gICAgICAgICAgICBzY29wZVN0YXJ0OiAnKCcsXG4gICAgICAgICAgICBzY29wZUVuZDogJyknLFxuICAgICAgICAgICAgbm9TY29wZTogJyEnLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogJygnLFxuICAgICAgICAgICAgcGFyYW1ldGVyc0VuZDogJyknLFxuICAgICAgICAgICAgcGFyYW1ldGVyU2VwYXJhdG9yOiAnLCcsXG4gICAgICAgICAgICBwYXJhbWV0ZXJLZXlTZXBhcmF0b3I6ICc9JyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogJyYnLFxuICAgICAgICAgICAgYWRkOiAnKycsXG4gICAgICAgICAgICBjbGVhcjogJy0nLFxuICAgICAgICAgICAgYWN0aW9uOiAnLicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXNlVXJsRnJhZ21lbnRIYXNoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51c2VIcmVmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZWZ1bEhpc3RvcnlMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnVzZURpcmVjdFJvdXRlcyA9IHRydWU7XG4gICAgICAgIHRoaXMudXNlQ29uZmlndXJlZFJvdXRlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkaXRpdmVJbnN0cnVjdGlvbkRlZmF1bHQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRpdGxlID0ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgICAgICBhcHBUaXRsZTogXCIke2NvbXBvbmVudFRpdGxlc31cXCR7YXBwVGl0bGVTZXBhcmF0b3J9QXVyZWxpYVwiLFxuICAgICAgICAgICAgYXBwVGl0bGVTZXBhcmF0b3I6ICcgfCAnLFxuICAgICAgICAgICAgY29tcG9uZW50VGl0bGVPcmRlcjogJ3RvcC1kb3duJyxcbiAgICAgICAgICAgIGNvbXBvbmVudFRpdGxlU2VwYXJhdG9yOiAnID4gJyxcbiAgICAgICAgICAgIHVzZUNvbXBvbmVudE5hbWVzOiB0cnVlLFxuICAgICAgICAgICAgY29tcG9uZW50UHJlZml4OiAnYXBwLScsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblN5bmNTdGF0ZXMgPSBbJ2d1YXJkZWRVbmxvYWQnLCAnc3dhcHBlZCcsICdjb21wbGV0ZWQnXTtcbiAgICAgICAgdGhpcy5zd2FwU3RyYXRlZ3kgPSAnYWRkLWZpcnN0LXNlcXVlbnRpYWwnO1xuICAgICAgICB0aGlzLnJvdXRpbmdIb29rSW50ZWdyYXRpb24gPSAnaW50ZWdyYXRlZCc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLW9wdGlvbnMuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdGVtcGxhdGUtY3VybHktaW4tc3RyaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItdGVtcGxhdGUgKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcy1wZXItZnVuY3Rpb24gKi9cbmltcG9ydCB7IERJLCBJQ29udGFpbmVyLCBSZWdpc3RyYXRpb24sIE1ldGFkYXRhIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQsIElBcHBSb290LCBpc1JlbmRlckNvbnRleHQsIGdldEVmZmVjdGl2ZVBhcmVudE5vZGUgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgSW5zdHJ1Y3Rpb25SZXNvbHZlciB9IGZyb20gJy4vaW5zdHJ1Y3Rpb24tcmVzb2x2ZXIuanMnO1xuaW1wb3J0IHsgTGlua0hhbmRsZXIgfSBmcm9tICcuL2xpbmstaGFuZGxlci5qcyc7XG5pbXBvcnQgeyBOYXYgfSBmcm9tICcuL25hdi5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0b3IgfSBmcm9tICcuL25hdmlnYXRvci5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlciB9IGZyb20gJy4vdHlwZS1yZXNvbHZlcnMuanMnO1xuaW1wb3J0IHsgYXJyYXlSZW1vdmUsIGRlcHJlY2F0aW9uV2FybmluZyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgVmlld3BvcnQgfSBmcm9tICcuL3ZpZXdwb3J0LmpzJztcbmltcG9ydCB7IFZpZXdwb3J0SW5zdHJ1Y3Rpb24gfSBmcm9tICcuL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzJztcbmltcG9ydCB7IEZvdW5kUm91dGUgfSBmcm9tICcuL2ZvdW5kLXJvdXRlLmpzJztcbmltcG9ydCB7IEhvb2tNYW5hZ2VyIH0gZnJvbSAnLi9ob29rLW1hbmFnZXIuanMnO1xuaW1wb3J0IHsgU2NvcGUgfSBmcm9tICcuL3Njb3BlLmpzJztcbmltcG9ydCB7IFZpZXdwb3J0U2NvcGUgfSBmcm9tICcuL3ZpZXdwb3J0LXNjb3BlLmpzJztcbmltcG9ydCB7IEJyb3dzZXJWaWV3ZXJTdG9yZSB9IGZyb20gJy4vYnJvd3Nlci12aWV3ZXItc3RvcmUuanMnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbiB9IGZyb20gJy4vbmF2aWdhdGlvbi5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uQ29vcmRpbmF0b3IgfSBmcm9tICcuL25hdmlnYXRpb24tY29vcmRpbmF0b3IuanMnO1xuaW1wb3J0IHsgUm91dGVyT3B0aW9ucyB9IGZyb20gJy4vcm91dGVyLW9wdGlvbnMuanMnO1xuaW1wb3J0IHsgT3BlblByb21pc2UgfSBmcm9tICcuL29wZW4tcHJvbWlzZS5qcyc7XG4vLyBleHBvcnQgdHlwZSBTd2FwU3RyYXRlZ3kgPSAnYWRkLWZpcnN0LXNlcXVlbnRpYWwnIHwgJ2FkZC1maXJzdC1wYXJhbGxlbCcgfCAncmVtb3ZlLWZpcnN0LXNlcXVlbnRpYWwnIHwgJ3JlbW92ZS1maXJzdC1wYXJhbGxlbCc7XG4vLyBleHBvcnQgdHlwZSBSb3V0aW5nSG9va0ludGVncmF0aW9uID0gJ2ludGVncmF0ZWQnIHwgJ3NlcGFyYXRlJztcbi8vIC8qKlxuLy8gICogUHVibGljIEFQSVxuLy8gICovXG4vLyBleHBvcnQgaW50ZXJmYWNlIElSb3V0ZXJBY3RpdmF0ZU9wdGlvbnMgZXh0ZW5kcyBPbWl0PFBhcnRpYWw8SVJvdXRlck9wdGlvbnM+LCAndGl0bGUnPiB7XG4vLyAgIHRpdGxlPzogc3RyaW5nIHwgSVJvdXRlclRpdGxlO1xuLy8gfVxuLy8gLyoqXG4vLyAgKiBQdWJsaWMgQVBJXG4vLyAgKi9cbi8vIGV4cG9ydCBpbnRlcmZhY2UgSVJvdXRlck9wdGlvbnMgZXh0ZW5kcyBJTmF2aWdhdG9yT3B0aW9ucyB7XG4vLyAgIHNlcGFyYXRvcnM/OiBJUm91dGVTZXBhcmF0b3JzO1xuLy8gICB1c2VVcmxGcmFnbWVudEhhc2g6IGJvb2xlYW47XG4vLyAgIHVzZUhyZWY6IGJvb2xlYW47XG4vLyAgIHN0YXRlZnVsSGlzdG9yeUxlbmd0aDogbnVtYmVyO1xuLy8gICB1c2VEaXJlY3RSb3V0ZXM6IGJvb2xlYW47XG4vLyAgIHVzZUNvbmZpZ3VyZWRSb3V0ZXM6IGJvb2xlYW47XG4vLyAgIGFkZGl0aXZlSW5zdHJ1Y3Rpb25EZWZhdWx0OiBib29sZWFuO1xuLy8gICB0aXRsZTogSVRpdGxlQ29uZmlndXJhdGlvbjtcbi8vICAgaG9va3M/OiBJSG9va0RlZmluaXRpb25bXTtcbi8vICAgcmVwb3J0Q2FsbGJhY2s/KGluc3RydWN0aW9uOiBOYXZpZ2F0aW9uKTogdm9pZDtcbi8vICAgbmF2aWdhdGlvblN5bmNTdGF0ZXM6IE5hdmlnYXRpb25TdGF0ZVtdO1xuLy8gICBzd2FwU3RyYXRlZ3k6IFN3YXBTdHJhdGVneTtcbi8vICAgcm91dGluZ0hvb2tJbnRlZ3JhdGlvbjogUm91dGluZ0hvb2tJbnRlZ3JhdGlvbjtcbi8vIH1cbi8vIC8qKlxuLy8gICogUHVibGljIEFQSVxuLy8gICovXG4vLyBleHBvcnQgaW50ZXJmYWNlIElSb3V0ZXJUaXRsZSBleHRlbmRzIFBhcnRpYWw8SVRpdGxlQ29uZmlndXJhdGlvbj4geyB9XG4vLyAvKipcbi8vICAqIFB1YmxpYyBBUElcbi8vICAqL1xuLy8gZXhwb3J0IGludGVyZmFjZSBJVGl0bGVDb25maWd1cmF0aW9uIHtcbi8vICAgYXBwVGl0bGU6IHN0cmluZztcbi8vICAgYXBwVGl0bGVTZXBhcmF0b3I6IHN0cmluZztcbi8vICAgY29tcG9uZW50VGl0bGVPcmRlcjogJ3RvcC1kb3duJyB8ICdib3R0b20tdXAnO1xuLy8gICBjb21wb25lbnRUaXRsZVNlcGFyYXRvcjogc3RyaW5nO1xuLy8gICB1c2VDb21wb25lbnROYW1lczogYm9vbGVhbjtcbi8vICAgY29tcG9uZW50UHJlZml4OiBzdHJpbmc7XG4vLyAgIHRyYW5zZm9ybVRpdGxlPzogKHRpdGxlOiBzdHJpbmcsIGluc3RydWN0aW9uOiBzdHJpbmcgfCBWaWV3cG9ydEluc3RydWN0aW9uIHwgRm91bmRSb3V0ZSkgPT4gc3RyaW5nO1xuLy8gfVxuLyoqXG4gKiBQdWJsaWMgQVBJXG4gKi9cbmV4cG9ydCBjb25zdCBJUm91dGVyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJUm91dGVyJywgeCA9PiB4LnNpbmdsZXRvbihSb3V0ZXIpKTtcbmNsYXNzIENsb3Nlc3RWaWV3cG9ydEN1c3RvbUVsZW1lbnQge1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ2xvc2VzdFNjb3BlIHtcbn1cbmV4cG9ydCBjbGFzcyBSb3V0ZXIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGNvbnRhaW5lciwgXG4gICAgLyoqXG4gICAgICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICovXG4gICAgbmF2aWdhdG9yLCBuYXZpZ2F0aW9uLCBcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBsaW5rSGFuZGxlciwgXG4gICAgLyoqXG4gICAgICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHkuIFByb2JhYmx5LlxuICAgICAqL1xuICAgIGluc3RydWN0aW9uUmVzb2x2ZXIsIFxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5LiBQcm9iYWJseS5cbiAgICAgKi9cbiAgICBob29rTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5hdmlnYXRpb247XG4gICAgICAgIHRoaXMubGlua0hhbmRsZXIgPSBsaW5rSGFuZGxlcjtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyID0gaW5zdHJ1Y3Rpb25SZXNvbHZlcjtcbiAgICAgICAgdGhpcy5ob29rTWFuYWdlciA9IGhvb2tNYW5hZ2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJvb3RTY29wZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBob29rTWFuYWdlcjogSG9va01hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF2cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHVibGljIEFQSVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVDb21wb25lbnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwZW5kZWRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgLy8gLyoqXG4gICAgICAgIC8vICAqIEBpbnRlcm5hbFxuICAgICAgICAvLyAgKi9cbiAgICAgICAgLy8gcHVibGljIG9wdGlvbnM6IElSb3V0ZXJPcHRpb25zID0ge1xuICAgICAgICAvLyAgIHVzZVVybEZyYWdtZW50SGFzaDogdHJ1ZSxcbiAgICAgICAgLy8gICB1c2VIcmVmOiB0cnVlLFxuICAgICAgICAvLyAgIHN0YXRlZnVsSGlzdG9yeUxlbmd0aDogMCxcbiAgICAgICAgLy8gICB1c2VEaXJlY3RSb3V0ZXM6IHRydWUsXG4gICAgICAgIC8vICAgdXNlQ29uZmlndXJlZFJvdXRlczogdHJ1ZSxcbiAgICAgICAgLy8gICBhZGRpdGl2ZUluc3RydWN0aW9uRGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgLy8gICB0aXRsZToge1xuICAgICAgICAvLyAgICAgYXBwVGl0bGU6IFwiJHtjb21wb25lbnRUaXRsZXN9XFwke2FwcFRpdGxlU2VwYXJhdG9yfUF1cmVsaWFcIixcbiAgICAgICAgLy8gICAgIGFwcFRpdGxlU2VwYXJhdG9yOiAnIHwgJyxcbiAgICAgICAgLy8gICAgIGNvbXBvbmVudFRpdGxlT3JkZXI6ICd0b3AtZG93bicsXG4gICAgICAgIC8vICAgICBjb21wb25lbnRUaXRsZVNlcGFyYXRvcjogJyA+ICcsXG4gICAgICAgIC8vICAgICB1c2VDb21wb25lbnROYW1lczogdHJ1ZSxcbiAgICAgICAgLy8gICAgIGNvbXBvbmVudFByZWZpeDogJ2FwcC0nLFxuICAgICAgICAvLyAgIH0sXG4gICAgICAgIC8vICAgc3dhcFN0cmF0ZWd5OiAnYWRkLWZpcnN0LXNlcXVlbnRpYWwnLFxuICAgICAgICAvLyAgIHJvdXRpbmdIb29rSW50ZWdyYXRpb246ICdpbnRlZ3JhdGVkJyxcbiAgICAgICAgLy8gICBuYXZpZ2F0aW9uU3luY1N0YXRlczogWydndWFyZGVkVW5sb2FkJywgJ3N3YXBwZWQnLCAnY29tcGxldGVkJ10sXG4gICAgICAgIC8vIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ05hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxvYWRlZEZpcnN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdE5hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWxlQ2hlY2tzID0ge307XG4gICAgICAgIC8vIFRPRE86IFN3aXRjaCB0aGlzIHRvIHVzZSAocHJvYmFibHkpIGFuIGV2ZW50IGluc3RlYWRcbiAgICAgICAgdGhpcy5zdGFydGVycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPOiB1c2UgQGJvdW5kIGFuZCBpbXByb3ZlIG5hbWUgKGVzbGludC1kaXNhYmxlIGlzIHRlbXApXG4gICAgICAgIHRoaXMubGlua0NhbGxiYWNrID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgIGxldCBpbnN0cnVjdGlvbiA9IGluZm8uaW5zdHJ1Y3Rpb24gfHwgJyc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnc3RyaW5nJyAmJiBpbnN0cnVjdGlvbi5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIC8vICcjJyA9PT0gJy8nID09PSAnIy8nXG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0cnVjdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBcIi9cIiArIGluc3RydWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZHMgdG8gTmF2aWdhdG9yJ3MgUXVldWUsIHdoaWNoIG1ha2VzIHN1cmUgaXQncyBzZXJpYWxcbiAgICAgICAgICAgIHRoaXMubG9hZChpbnN0cnVjdGlvbiwgeyBvcmlnaW46IGluZm8uYW5jaG9yIH0pLmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPOiB1c2UgQGJvdW5kIGFuZCBpbXByb3ZlIG5hbWUgKGVzbGludC1kaXNhYmxlIGlzIHRlbXApXG4gICAgICAgIHRoaXMubmF2aWdhdG9yQ2FsbGJhY2sgPSAoaW5zdHJ1Y3Rpb24pID0+IHtcbiAgICAgICAgICAgIC8vIEluc3RydWN0aW9ucyBleHRyYWN0ZWQgZnJvbSBxdWV1ZSwgb25lIGF0IGEgdGltZVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTmF2aWdhdGlvbnMoaW5zdHJ1Y3Rpb24pLmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPOiB1c2UgQGJvdW5kIGFuZCBpbXByb3ZlIG5hbWUgKGVzbGludC1kaXNhYmxlIGlzIHRlbXApXG4gICAgICAgIHRoaXMubmF2aWdhdG9yU2VyaWFsaXplQ2FsbGJhY2sgPSBhc3luYyAoZW50cnksIHByZXNlcnZlZEVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBleGNsdWRlQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVzZXJ2ZWRFbnRyeSBvZiBwcmVzZXJ2ZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVzZXJ2ZWRFbnRyeS5pbnN0cnVjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUNvbXBvbmVudHMucHVzaCguLi50aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuZmxhdHRlblZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHByZXNlcnZlZEVudHJ5Lmluc3RydWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi52aWV3cG9ydCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uY29tcG9uZW50SW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVzZXJ2ZWRFbnRyeS5mdWxsU3RhdGVJbnN0cnVjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUNvbXBvbmVudHMucHVzaCguLi50aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuZmxhdHRlblZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHByZXNlcnZlZEVudHJ5LmZ1bGxTdGF0ZUluc3RydWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi52aWV3cG9ydCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uY29tcG9uZW50SW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGNsdWRlQ29tcG9uZW50cyA9IGV4Y2x1ZGVDb21wb25lbnRzLmZpbHRlcigoY29tcG9uZW50LCBpLCBhcnIpID0+IGNvbXBvbmVudCAhPT0gbnVsbCAmJiBhcnIuaW5kZXhPZihjb21wb25lbnQpID09PSBpKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7IC4uLmVudHJ5IH07XG4gICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZC5mdWxsU3RhdGVJbnN0cnVjdGlvbiAmJiB0eXBlb2Ygc2VyaWFsaXplZC5mdWxsU3RhdGVJbnN0cnVjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCguLi5zZXJpYWxpemVkLmZ1bGxTdGF0ZUluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLmZ1bGxTdGF0ZUluc3RydWN0aW9uID0gdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHNlcmlhbGl6ZWQuZnVsbFN0YXRlSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWQuaW5zdHJ1Y3Rpb24gJiYgdHlwZW9mIHNlcmlhbGl6ZWQuaW5zdHJ1Y3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goLi4uc2VyaWFsaXplZC5pbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5pbnN0cnVjdGlvbiA9IHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9ucyhzZXJpYWxpemVkLmluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5maWx0ZXIoKGluc3RydWN0aW9uLCBpLCBhcnIpID0+IGluc3RydWN0aW9uICE9PSBudWxsXG4gICAgICAgICAgICAgICAgJiYgaW5zdHJ1Y3Rpb24uY29tcG9uZW50SW5zdGFuY2UgIT09IG51bGxcbiAgICAgICAgICAgICAgICAmJiBhcnIuaW5kZXhPZihpbnN0cnVjdGlvbikgPT09IGkpO1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeURvbmUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mcmVlQ29tcG9uZW50cyhpbnN0cnVjdGlvbiwgZXhjbHVkZUNvbXBvbmVudHMsIGFscmVhZHlEb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPOiB1c2UgQGJvdW5kIGFuZCBpbXByb3ZlIG5hbWUgKGVzbGludC1kaXNhYmxlIGlzIHRlbXApXG4gICAgICAgIHRoaXMuYnJvd3Nlck5hdmlnYXRvckNhbGxiYWNrID0gKGJyb3dzZXJOYXZpZ2F0aW9uRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IE5hdmlnYXRpb24oYnJvd3Nlck5hdmlnYXRpb25FdmVudC5zdGF0ZT8uY3VycmVudEVudHJ5KTtcbiAgICAgICAgICAgIGVudHJ5Lmluc3RydWN0aW9uID0gYnJvd3Nlck5hdmlnYXRpb25FdmVudC5pbnN0cnVjdGlvbjtcbiAgICAgICAgICAgIGVudHJ5LmZyb21Ccm93c2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yLm5hdmlnYXRlKGVudHJ5KS5jYXRjaChlcnJvciA9PiB7IHRocm93IGVycm9yOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogdXNlIEBib3VuZCBhbmQgaW1wcm92ZSBuYW1lIChlc2xpbnQtZGlzYWJsZSBpcyB0ZW1wKVxuICAgICAgICB0aGlzLnByb2Nlc3NOYXZpZ2F0aW9ucyA9IGFzeW5jIChxSW5zdHJ1Y3Rpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gdGhpcy5wcm9jZXNzaW5nTmF2aWdhdGlvbiA9IHFJbnN0cnVjdGlvbjtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwZW5kaW5nQ29ubmVjdHMnLCBbLi4udGhpcy5wZW5kaW5nQ29ubmVjdHNdKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3RzLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlcG9ydENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlcG9ydENhbGxiYWNrKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxldCB7XG4gICAgICAgICAgICAvLyAgIGZ1bGxTdGF0ZUluc3RydWN0aW9uLFxuICAgICAgICAgICAgLy8gICBpbnN0cnVjdGlvbk5hdmlnYXRpb24sXG4gICAgICAgICAgICAvLyAgIGNvbmZpZ3VyZWRSb3V0ZSxcbiAgICAgICAgICAgIC8vICAgY29uZmlndXJlZFJvdXRlUGF0aCxcbiAgICAgICAgICAgIC8vICAgaW5zdHJ1Y3Rpb25zLFxuICAgICAgICAgICAgLy8gICBjbGVhclNjb3BlT3duZXJzLFxuICAgICAgICAgICAgLy8gICBjbGVhclZpZXdwb3J0U2NvcGVzLFxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0b3IgPSBOYXZpZ2F0aW9uQ29vcmRpbmF0b3IuY3JlYXRlKHRoaXMsIGluc3RydWN0aW9uLCB7IHN5bmNTdGF0ZXM6IHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uU3luY1N0YXRlcyB9KTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHN0ZXBzID0gW1xuICAgICAgICAgICAgLy8gICAoKSA9PiBjb29yZGluYXRvci5zeW5jU3RhdGUoJ2xvYWRlZCcpLFxuICAgICAgICAgICAgLy8gICAoKSA9PiB7IGNvbnNvbGUubG9nKCdTeW5jU3RhdGUgbG9hZGVkIHJlc29sdmVkIScsIHN0ZXBzKTsgfSxcbiAgICAgICAgICAgIC8vICAgKCkgPT4gY29vcmRpbmF0b3Iuc3luY1N0YXRlKCdzd2FwcGVkJyksXG4gICAgICAgICAgICAvLyAgICgpID0+IHsgY29uc29sZS5sb2coJ1N5bmNTdGF0ZSBzd2FwcGVkIHJlc29sdmVkIScsIHN0ZXBzKTsgfSxcbiAgICAgICAgICAgIC8vICAgKCkgPT4gY29vcmRpbmF0b3Iuc3luY1N0YXRlKCdsZWZ0JyksXG4gICAgICAgICAgICAvLyAgICgpID0+IHsgY29uc29sZS5sb2coJ1N5bmNTdGF0ZSBsZWZ0IHJlc29sdmVkIScsIHN0ZXBzKTsgfSxcbiAgICAgICAgICAgIC8vIF07XG4gICAgICAgICAgICAvLyBydW4oLi4uc3RlcHMpO1xuICAgICAgICAgICAgLy8gY29uc3QgbG9hZGVkUHJvbWlzZSA9IDtcbiAgICAgICAgICAgIC8vIGlmIChsb2FkZWRQcm9taXNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIC8vICAgbG9hZGVkUHJvbWlzZS50aGVuKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1N5bmNTdGF0ZSBsb2FkZWQgcmVzb2x2ZWQhJywgdmFsdWUpO1xuICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGluc3RydWN0aW9uLmluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucm9vdFNjb3BlPy5zY29wZS50b1N0cmluZyh0cnVlKSk7XG4gICAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRJbnN0cnVjdGlvbiA9IHR5cGVvZiBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbiA9PT0gJ3N0cmluZycgJiYgIWluc3RydWN0aW9uLnVzZUZ1bGxTdGF0ZUluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgPyBhd2FpdCB0aGlzLmhvb2tNYW5hZ2VyLmludm9rZVRyYW5zZm9ybUZyb21VcmwoaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24sIHRoaXMucHJvY2Vzc2luZ05hdmlnYXRpb24pXG4gICAgICAgICAgICAgICAgOiBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbjtcbiAgICAgICAgICAgIC8vIFRPRE86IFJldmlldyB0aGlzXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZWRJbnN0cnVjdGlvbiA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRJbnN0cnVjdGlvbiA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uc2NvcGUgPSBpbnN0cnVjdGlvbi5zY29wZSA/PyB0aGlzLnJvb3RTY29wZS5zY29wZTtcbiAgICAgICAgICAgIGxldCBjb25maWd1cmVkUm91dGUgPSBpbnN0cnVjdGlvbi5zY29wZS5maW5kSW5zdHJ1Y3Rpb25zKHRyYW5zZm9ybWVkSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgbGV0IGNvbmZpZ3VyZWRSb3V0ZVBhdGggPSBudWxsO1xuICAgICAgICAgICAgLy8gbGV0IGNvbmZpZ3VyZWRSb3V0ZSA9IGF3YWl0IHRoaXMuZmluZEluc3RydWN0aW9ucyhcbiAgICAgICAgICAgIC8vICAgdGhpcy5yb290U2NvcGUhLnNjb3BlLFxuICAgICAgICAgICAgLy8gICBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbixcbiAgICAgICAgICAgIC8vICAgaW5zdHJ1Y3Rpb24uc2NvcGUgPz8gdGhpcy5yb290U2NvcGUhLnNjb3BlLFxuICAgICAgICAgICAgLy8gICAhaW5zdHJ1Y3Rpb24udXNlRnVsbFN0YXRlSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmluc3RydWN0aW9uLmxlbmd0aCA+IDAgJiYgIWNvbmZpZ3VyZWRSb3V0ZS5mb3VuZENvbmZpZ3VyYXRpb24gJiYgIWNvbmZpZ3VyZWRSb3V0ZS5mb3VuZEluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IERvIHNvbWV0aGluZyBoZXJlIVxuICAgICAgICAgICAgICAgIHRoaXMudW5rbm93blJvdXRlKGNvbmZpZ3VyZWRSb3V0ZS5yZW1haW5pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IGNvbmZpZ3VyZWRSb3V0ZS5pbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJlZFJvdXRlLmZvdW5kQ29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnBhdGggPSBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbi5zdGFydHNXaXRoKCcvJylcbiAgICAgICAgICAgICAgICAgICAgPyBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbi5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICA6IGluc3RydWN0aW9uLmluc3RydWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRSb3V0ZVBhdGggPSAoY29uZmlndXJlZFJvdXRlUGF0aCA/PyAnJykgKyBjb25maWd1cmVkUm91dGUubWF0Y2hpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290U2NvcGUucGF0aCA9IGNvbmZpZ3VyZWRSb3V0ZVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBVc2VkIHRvIGhhdmUgYW4gZWFybHkgZXhpdCBpZiBubyBpbnN0cnVjdGlvbnMuIFJlc3RvcmUgaXQ/XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hZGRpdGl2ZUluc3RydWN0aW9uRGVmYXVsdCAmJlxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0FkZEFsbFZpZXdwb3J0c0luc3RydWN0aW9uKGluc3RydWN0aW9uc1swXSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmlzQ2xlYXJBbGxWaWV3cG9ydHNJbnN0cnVjdGlvbihpbnN0cnVjdGlvbnNbMF0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdHIgPSB0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24odGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgaW5zdHIuc2NvcGUgPSBpbnN0cnVjdGlvbnNbMF0uc2NvcGU7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnVuc2hpZnQoaW5zdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xlYXJTY29wZU93bmVycyA9IFtdO1xuICAgICAgICAgICAgbGV0IGNsZWFyVmlld3BvcnRTY29wZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2xlYXJJbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMuZmlsdGVyKGluc3RyID0+IHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0NsZWFyQWxsVmlld3BvcnRzSW5zdHJ1Y3Rpb24oaW5zdHIpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gY2xlYXJJbnN0cnVjdGlvbi5zY29wZSB8fCB0aGlzLnJvb3RTY29wZS5zY29wZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29wZXMgPSBzY29wZS5hbGxTY29wZXMoKS5maWx0ZXIoc2NvcGUgPT4gIXNjb3BlLm93bmVyLmlzRW1wdHkpLm1hcChzY29wZSA9PiBzY29wZS5vd25lcik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGVsbCBGcmVkIGFib3V0IHRoZSBuZWVkIGZvciByZXZlcnNlXG4gICAgICAgICAgICAgICAgLy8gc2NvcGVzLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBjbGVhclNjb3BlT3duZXJzLnB1c2goLi4uc2NvcGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUudmlld3BvcnRTY29wZSAhPT0gbnVsbCAmJiBzY29wZS52aWV3cG9ydFNjb3BlICE9PSB0aGlzLnJvb3RTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclZpZXdwb3J0U2NvcGVzLnB1c2goc2NvcGUudmlld3BvcnRTY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLmZpbHRlcihpbnN0ciA9PiAhdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmlzQ2xlYXJBbGxWaWV3cG9ydHNJbnN0cnVjdGlvbihpbnN0cikpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRJbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMuZmlsdGVyKGluc3RyID0+IHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5pc0FkZEFsbFZpZXdwb3J0c0luc3RydWN0aW9uKGluc3RyKSkpIHtcbiAgICAgICAgICAgICAgICBhZGRJbnN0cnVjdGlvbi5zZXRWaWV3cG9ydCgoYWRkSW5zdHJ1Y3Rpb24uc2NvcGUgfHwgdGhpcy5yb290U2NvcGUuc2NvcGUpLnZpZXdwb3J0U2NvcGUubmFtZSk7XG4gICAgICAgICAgICAgICAgYWRkSW5zdHJ1Y3Rpb24uc2NvcGUgPSBhZGRJbnN0cnVjdGlvbi5zY29wZS5vd25pbmdTY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdHIgb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5zdHIudG9wSW5zdHJ1Y3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNjb3BlT3duZXJzID0gW107XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5Rm91bmRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIC8vIFRPRE86IFRha2UgY2FyZSBvZiBjYW5jZWxsYXRpb25zIGRvd24gaW4gc3Vic2V0cy9pdGVyYXRpb25zXG4gICAgICAgICAgICBsZXQgeyBmb3VuZDogdmlld3BvcnRJbnN0cnVjdGlvbnMsIHJlbWFpbmluZzogcmVtYWluaW5nSW5zdHJ1Y3Rpb25zIH0gPSB0aGlzLmZpbmRWaWV3cG9ydHMoaW5zdHJ1Y3Rpb25zLCBhbHJlYWR5Rm91bmRJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgbGV0IGd1YXJkID0gMTAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmICghZ3VhcmQtLSkgeyAvLyBHdWFyZCBhZ2FpbnN0IGVuZGxlc3MgbG9vcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IocmVtYWluaW5nSW5zdHJ1Y3Rpb25zLmxlbmd0aCArICcgcmVtYWluaW5nIGluc3RydWN0aW9ucyBhZnRlciAxMDAgaXRlcmF0aW9uczsgdGhlcmUgaXMgbGlrZWx5IGFuIGluZmluaXRlIGxvb3AuJyk7XG4gICAgICAgICAgICAgICAgICAgIGVyclsncmVtYWluaW5nSW5zdHJ1Y3Rpb25zJ10gPSByZW1haW5pbmdJbnN0cnVjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZW1haW5pbmdJbnN0cnVjdGlvbnMnLCByZW1haW5pbmdJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRTY29wZU93bmVycyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJldmlldyB3aGV0aGVyIHRoaXMgYXdhaXQgcG9zZXMgYSBwcm9ibGVtIChpdCdzIGN1cnJlbnRseSBuZWNlc3NhcnkgZm9yIG5ldyB2aWV3cG9ydHMgdG8gbG9hZClcbiAgICAgICAgICAgICAgICBjb25zdCBob29rZWQgPSBhd2FpdCB0aGlzLmhvb2tNYW5hZ2VyLmludm9rZUJlZm9yZU5hdmlnYXRpb24odmlld3BvcnRJbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoaG9va2VkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5jYW5jZWxOYXZpZ2F0aW9uKFsuLi5jaGFuZ2VkU2NvcGVPd25lcnMsIC4uLnVwZGF0ZWRTY29wZU93bmVyc10sIGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zID0gaG9va2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZpZXdwb3J0SW5zdHJ1Y3Rpb24gb2Ygdmlld3BvcnRJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVPd25lciA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb24ub3duZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZU93bmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZU93bmVyLnBhdGggPSBjb25maWd1cmVkUm91dGVQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gc2NvcGVPd25lci5zZXROZXh0Q29udGVudCh2aWV3cG9ydEluc3RydWN0aW9uLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnc2tpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkU2NvcGVPd25lcnMucHVzaChzY29wZU93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRvci5hZGRFbnRpdHkoc2NvcGVPd25lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb250Q2xlYXIgPSBbc2NvcGVPd25lcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnc3dhcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb250Q2xlYXIucHVzaCguLi5zY29wZU93bmVyLnNjb3BlLmFsbFNjb3Blcyh0cnVlLCB0cnVlKS5tYXAoc2NvcGUgPT4gc2NvcGUub3duZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5UmVtb3ZlKGNsZWFyU2NvcGVPd25lcnMsIHZhbHVlID0+IGRvbnRDbGVhci5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXlSZW1vdmUoY2xlYXJTY29wZU93bmVycywgdmFsdWUgPT4gdmFsdWUgPT09IHNjb3BlT3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuaXNDbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb24odmlld3BvcnRJbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2aWV3cG9ydEluc3RydWN0aW9uLnNjb3BlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdmlld3BvcnRJbnN0cnVjdGlvbi5zY29wZS5wYXJlbnQgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2aWV3cG9ydEluc3RydWN0aW9uLnNjb3BlLnBhcmVudC5pc1ZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVJlbW92ZShjbGVhclZpZXdwb3J0U2NvcGVzLCB2YWx1ZSA9PiB2YWx1ZSA9PT0gdmlld3BvcnRJbnN0cnVjdGlvbi5zY29wZS5wYXJlbnQudmlld3BvcnRTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVzdHJpY3RlZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0b3IuZmluYWxFbnRpdHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0b3IucnVuKCk7XG4gICAgICAgICAgICAgICAgLy8gYXdhaXQgY29vcmRpbmF0b3Iuc3luY1N0YXRlKCdyb3V0ZWQnKTtcbiAgICAgICAgICAgICAgICAvLyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgICAgIC8vIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2hhbmdlZFNjb3BlT3duZXJzLm1hcCgoc2NvcGVPd25lcikgPT4gc2NvcGVPd25lci5jYW5VbmxvYWQoKSkpO1xuICAgICAgICAgICAgICAgIC8vIGlmIChyZXN1bHRzLnNvbWUocmVzdWx0ID0+IHJlc3VsdCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gICByZXR1cm4gdGhpcy5jYW5jZWxOYXZpZ2F0aW9uKFsuLi5jaGFuZ2VkU2NvcGVPd25lcnMsIC4uLnVwZGF0ZWRTY29wZU93bmVyc10sIGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICAvLyByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2hhbmdlZFNjb3BlT3duZXJzLm1hcChhc3luYyAoc2NvcGVPd25lcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgY29uc3QgY2FuTG9hZCA9IGF3YWl0IHNjb3BlT3duZXIuY2FuTG9hZCgpO1xuICAgICAgICAgICAgICAgIC8vICAgaWYgKHR5cGVvZiBjYW5Mb2FkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGNhbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZShzY29wZU93bmVyLCAnbG9hZGVkJyk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgcmV0dXJuIHNjb3BlT3duZXIubG9hZCgpO1xuICAgICAgICAgICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgIC8vICAgYXdhaXQgdGhpcy5sb2FkKGNhbkxvYWQsIHsgYXBwZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIC8vICAgYXdhaXQgc2NvcGVPd25lci5hYm9ydENvbnRlbnRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAvLyAgIC8vIFRPRE86IEFib3J0IGNvbnRlbnQgY2hhbmdlIGluIHRoZSB2aWV3cG9ydHNcbiAgICAgICAgICAgICAgICAvLyAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBpZiAocmVzdWx0cy5zb21lKHJlc3VsdCA9PiByZXN1bHQgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vICAgcmV0dXJuIHRoaXMuY2FuY2VsTmF2aWdhdGlvbihbLi4uY2hhbmdlZFNjb3BlT3duZXJzLCAuLi51cGRhdGVkU2NvcGVPd25lcnNdLCBxSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZpZXdwb3J0IG9mIGNoYW5nZWRTY29wZU93bmVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFNjb3BlT3duZXJzLmV2ZXJ5KHNjb3BlT3duZXIgPT4gc2NvcGVPd25lciAhPT0gdmlld3BvcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkU2NvcGVPd25lcnMucHVzaCh2aWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRml4IG11bHRpIGxldmVsIHJlY3Vyc2l2ZW5lc3MhXG4gICAgICAgICAgICAgICAgYWxyZWFkeUZvdW5kSW5zdHJ1Y3Rpb25zLnB1c2goLi4udmlld3BvcnRJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgICh7IGZvdW5kOiB2aWV3cG9ydEluc3RydWN0aW9ucywgcmVtYWluaW5nOiByZW1haW5pbmdJbnN0cnVjdGlvbnMgfSA9IHRoaXMuZmluZFZpZXdwb3J0cyhyZW1haW5pbmdJbnN0cnVjdGlvbnMsIGFscmVhZHlGb3VuZEluc3RydWN0aW9ucykpO1xuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGNvbmZpZ3VyZWQgY2hpbGQgcm91dGVzIChvbmNlIHdlJ3ZlIGxvYWRlZCBldmVyeXRoaW5nIHNvIGZhcj8pXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyZWRSb3V0ZS5oYXNSZW1haW5pbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpZ3VyZWQgPSBuZXcgRm91bmRSb3V0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVNjb3BlT3duZXJzID0gYWxyZWFkeUZvdW5kSW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGluc3RyID0+IGluc3RyLm93bmVyICE9PSBudWxsICYmIGluc3RyLm93bmVyLnBhdGggPT09IGNvbmZpZ3VyZWRSb3V0ZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGluc3RyID0+IGluc3RyLm93bmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsdWUsIGluZGV4LCBhcnIpID0+IGFyci5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGF3YWl0IG5ldyB2aWV3cG9ydHMgYmVpbmcgYm91bmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVzdHJpY3RlZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0F3YWl0aW5nIHN3YXBwZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgnc3dhcHBlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0F3YWl0ZWQgc3dhcHBlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3BlbmRpbmdDb25uZWN0cyBiZWZvcmUgZmluZCBuZXcnLCBbLi4udGhpcy5wZW5kaW5nQ29ubmVjdHNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHBlbmRpbmcgPSBbLi4udGhpcy5wZW5kaW5nQ29ubmVjdHMudmFsdWVzKCldLmZpbHRlcihjb25uZWN0ID0+IGNvbm5lY3QuaXNQZW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChwZW5kaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ0JlZ2lubmluZyBhd2FpdCBmb3IgJywgcGVuZGluZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhd2FpdCBQcm9taXNlLmFsbChwZW5kaW5nLm1hcChjb25uZWN0ID0+IGNvbm5lY3QucHJvbWlzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZygnQXdhaXQgZG9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3duZXIgb2Ygcm91dGVTY29wZU93bmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJlZCA9IG93bmVyLnNjb3BlLmZpbmRJbnN0cnVjdGlvbnMoY29uZmlndXJlZFJvdXRlLnJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25maWd1cmVkID0gYXdhaXQgdGhpcy5maW5kSW5zdHJ1Y3Rpb25zKG93bmVyLnNjb3BlLCBjb25maWd1cmVkUm91dGUucmVtYWluaW5nLCBvd25lci5zY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJlZC5mb3VuZENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJlZC5mb3VuZEluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJlZFJvdXRlID0gY29uZmlndXJlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRSb3V0ZVBhdGggPSAoY29uZmlndXJlZFJvdXRlUGF0aCA/PyAnJykgKyBcIi9cIiArIGNvbmZpZ3VyZWRSb3V0ZS5tYXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERvIHNvbWV0aGluZyBoZXJlIVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmtub3duUm91dGUoY29uZmlndXJlZC5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kSW5zdHJ1Y3Rpb25zKGNvbmZpZ3VyZWQuaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIGRlZmF1bHRzIHdoZW4gaXQncyBhIGZ1bGwgc3RhdGUgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi51c2VGdWxsU3RhdGVJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5hcHBlbmRlZEluc3RydWN0aW9ucy5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gIWluc3RydWN0aW9uLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIG5vbi1kZWZhdWx0cyBmaXJzdFxuICAgICAgICAgICAgICAgIGxldCBhcHBlbmRlZEluc3RydWN0aW9ucyA9IHRoaXMuYXBwZW5kZWRJbnN0cnVjdGlvbnMuZmlsdGVyKGluc3RydWN0aW9uID0+ICFpbnN0cnVjdGlvbi5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5hcHBlbmRlZEluc3RydWN0aW9ucy5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uZGVmYXVsdCk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGVuZGVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYXBwZW5kZWRJbnN0cnVjdGlvbnMuZmluZEluZGV4KGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kZWRJbnN0cnVjdGlvbnMgPSB0aGlzLmFwcGVuZGVkSW5zdHJ1Y3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGFwcGVuZGVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBwZW5kZWRJbnN0cnVjdGlvbiA9IGFwcGVuZGVkSW5zdHJ1Y3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQWxyZWFkeUZvdW5kID0gYWxyZWFkeUZvdW5kSW5zdHJ1Y3Rpb25zLnNvbWUoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uc2FtZVZpZXdwb3J0KGFwcGVuZGVkSW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdGb3VuZCA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLmZpbmQodmFsdWUgPT4gdmFsdWUuc2FtZVZpZXdwb3J0KGFwcGVuZGVkSW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZW1haW5pbmcgPSByZW1haW5pbmdJbnN0cnVjdGlvbnMuZmluZCh2YWx1ZSA9PiB2YWx1ZS5zYW1lVmlld3BvcnQoYXBwZW5kZWRJbnN0cnVjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwZW5kZWRJbnN0cnVjdGlvbi5kZWZhdWx0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXhpc3RpbmdBbHJlYWR5Rm91bmQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhpc3RpbmdGb3VuZCAhPT0gdm9pZCAwICYmICFleGlzdGluZ0ZvdW5kLmRlZmF1bHQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV4aXN0aW5nUmVtYWluaW5nICE9PSB2b2lkIDAgJiYgIWV4aXN0aW5nUmVtYWluaW5nLmRlZmF1bHQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRm91bmQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlSZW1vdmUodmlld3BvcnRJbnN0cnVjdGlvbnMsIHZhbHVlID0+IHZhbHVlID09PSBleGlzdGluZ0ZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdSZW1haW5pbmcgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlSZW1vdmUocmVtYWluaW5nSW5zdHJ1Y3Rpb25zLCB2YWx1ZSA9PiB2YWx1ZSA9PT0gZXhpc3RpbmdSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHBlbmRlZEluc3RydWN0aW9uLnZpZXdwb3J0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucy5wdXNoKGFwcGVuZGVkSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLnB1c2goYXBwZW5kZWRJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMCAmJiByZW1haW5pbmdJbnN0cnVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zID0gY2xlYXJTY29wZU93bmVycy5tYXAob3duZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24odGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbiwgb3duZXIuaXNWaWV3cG9ydCA/IG93bmVyIDogdm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lci5pc1ZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlID0gb3duZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucy5wdXNoKC4uLmNsZWFyVmlld3BvcnRTY29wZXMubWFwKHZpZXdwb3J0U2NvcGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdHIgPSB0aGlzLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb24odGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmNsZWFyVmlld3BvcnRJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0ci52aWV3cG9ydFNjb3BlID0gdmlld3BvcnRTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cjtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclZpZXdwb3J0U2NvcGVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwKSk7XG4gICAgICAgICAgICB9IHdoaWxlICh2aWV3cG9ydEluc3RydWN0aW9ucy5sZW5ndGggPiAwIHx8IHJlbWFpbmluZ0luc3RydWN0aW9ucy5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdG9yLmZpbmFsRW50aXR5KCk7XG4gICAgICAgICAgICAvLyBhd2FpdCBQcm9taXNlLmFsbCh1cGRhdGVkU2NvcGVPd25lcnMubWFwKCh2YWx1ZSkgPT4gdmFsdWUubG9hZENvbnRlbnQoKSkpO1xuICAgICAgICAgICAgYXdhaXQgY29vcmRpbmF0b3Iuc3luY1N0YXRlKCdjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdG9yLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAvLyB1cGRhdGVkU2NvcGVPd25lcnMuZm9yRWFjaCgodmlld3BvcnQpID0+IHtcbiAgICAgICAgICAgIC8vICAgdmlld3BvcnQuZmluYWxpemVDb250ZW50Q2hhbmdlKCk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVwbGFjZVBhdGhzKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIC8vIHRoaXMudXBkYXRlTmF2KCk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgaGlzdG9yeSBlbnRyeSBpZiBubyBoaXN0b3J5IHZpZXdwb3J0cyB1cGRhdGVkXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubmF2aWdhdGlvbi5uZXcgJiYgIWluc3RydWN0aW9uLm5hdmlnYXRpb24uZmlyc3QgJiYgIWluc3RydWN0aW9uLnJlcGVhdGluZyAmJiB1cGRhdGVkU2NvcGVPd25lcnMuZXZlcnkodmlld3BvcnQgPT4gdmlld3BvcnQub3B0aW9ucy5ub0hpc3RvcnkpKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24udW50cmFja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZWRTY29wZU93bmVycy5mb3JFYWNoKCh2aWV3cG9ydCkgPT4ge1xuICAgICAgICAgICAgLy8gICB2aWV3cG9ydC5maW5hbGl6ZUNvbnRlbnRDaGFuZ2UoKTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0TmF2aWdhdGlvbiA9IHRoaXMucHJvY2Vzc2luZ05hdmlnYXRpb247XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0TmF2aWdhdGlvbj8ucmVwZWF0aW5nID8/IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0TmF2aWdhdGlvbi5yZXBlYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ05hdmlnYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0b3IuZmluYWxpemUoaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0aGlzLmhvb2tNYW5hZ2VyID0gbmV3IEhvb2tNYW5hZ2VyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBnZXQgaXNOYXZpZ2F0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nTmF2aWdhdGlvbiAhPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzUmVzdHJpY3RlZE5hdmlnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHN5bmNTdGF0ZXMgPSB0aGlzLm9wdGlvbnMubmF2aWdhdGlvblN5bmNTdGF0ZXM7XG4gICAgICAgIHJldHVybiBzeW5jU3RhdGVzLmluY2x1ZGVzKCdndWFyZGVkTG9hZCcpIHx8XG4gICAgICAgICAgICBzeW5jU3RhdGVzLmluY2x1ZGVzKCd1bmxvYWRlZCcpIHx8XG4gICAgICAgICAgICBzeW5jU3RhdGVzLmluY2x1ZGVzKCdsb2FkZWQnKSB8fFxuICAgICAgICAgICAgc3luY1N0YXRlcy5pbmNsdWRlcygnZ3VhcmRlZCcpIHx8XG4gICAgICAgICAgICBzeW5jU3RhdGVzLmluY2x1ZGVzKCdyb3V0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IHN0YXRlZnVsSGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdGF0ZWZ1bEhpc3RvcnlMZW5ndGggIT09IHZvaWQgMCAmJiB0aGlzLm9wdGlvbnMuc3RhdGVmdWxIaXN0b3J5TGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm91dGVyIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcbiAgICAgICAgY29uc3QgdGl0bGVPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgLi4uKHR5cGVvZiBvcHRpb25zLnRpdGxlID09PSAnc3RyaW5nJyA/IHsgYXBwVGl0bGU6IG9wdGlvbnMudGl0bGUgfSA6IG9wdGlvbnMudGl0bGUpLFxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnRpdGxlID0gdGl0bGVPcHRpb25zO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLnNlcGFyYXRvcnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLnNlcGFyYXRvcnMgPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMuc2VwYXJhdG9ycyA9IHNlcGFyYXRvck9wdGlvbnM7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob29rcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhvb2tzKHRoaXMub3B0aW9ucy5ob29rcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLnN0YXJ0KHsgc2VwYXJhdG9yczogdGhpcy5vcHRpb25zLnNlcGFyYXRvcnMgfSk7XG4gICAgICAgIHRoaXMubmF2aWdhdG9yLnN0YXJ0KHRoaXMsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLm5hdmlnYXRvckNhbGxiYWNrLFxuICAgICAgICAgICAgc3RvcmU6IHRoaXMubmF2aWdhdGlvbixcbiAgICAgICAgICAgIHN0YXRlZnVsSGlzdG9yeUxlbmd0aDogdGhpcy5vcHRpb25zLnN0YXRlZnVsSGlzdG9yeUxlbmd0aCxcbiAgICAgICAgICAgIHNlcmlhbGl6ZUNhbGxiYWNrOiB0aGlzLnN0YXRlZnVsSGlzdG9yeSA/IHRoaXMubmF2aWdhdG9yU2VyaWFsaXplQ2FsbGJhY2sgOiB2b2lkIDAsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxpbmtIYW5kbGVyLnN0YXJ0KHsgY2FsbGJhY2s6IHRoaXMubGlua0NhbGxiYWNrLCB1c2VIcmVmOiB0aGlzLm9wdGlvbnMudXNlSHJlZiB9KTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnN0YXJ0KHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLmJyb3dzZXJOYXZpZ2F0b3JDYWxsYmFjayxcbiAgICAgICAgICAgIHVzZVVybEZyYWdtZW50SGFzaDogdGhpcy5vcHRpb25zLnVzZVVybEZyYWdtZW50SGFzaFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbnN1cmVSb290U2NvcGUoKTtcbiAgICAgICAgLy8gVE9ETzogU3dpdGNoIHRoaXMgdG8gdXNlIChwcm9iYWJseSkgYW4gZXZlbnQgaW5zdGVhZFxuICAgICAgICBmb3IgKGNvbnN0IHN0YXJ0ZXIgb2YgdGhpcy5zdGFydGVycykge1xuICAgICAgICAgICAgc3RhcnRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkVXJsKCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG5ldyBOYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMubmF2aWdhdGlvbi52aWV3ZXJTdGF0ZSxcbiAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICBmdWxsU3RhdGVJbnN0cnVjdGlvbjogJycsXG4gICAgICAgICAgICAgICAgcmVwbGFjaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZyb21Ccm93c2VyOiBmYWxzZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMubmF2aWdhdG9yLm5hdmlnYXRlKGVudHJ5KTtcbiAgICAgICAgdGhpcy5sb2FkZWRGaXJzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm91dGVyIGhhcyBub3QgYmVlbiBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rSGFuZGxlci5zdG9wKCk7XG4gICAgICAgIHRoaXMubmF2aWdhdG9yLnN0b3AoKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnN0b3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZmluZFNjb3BlKG9yaWdpbikge1xuICAgICAgICAvLyB0aGlzLmVuc3VyZVJvb3RTY29wZSgpO1xuICAgICAgICBpZiAob3JpZ2luID09PSB2b2lkIDAgfHwgb3JpZ2luID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbiBpbnN0YW5jZW9mIFNjb3BlIHx8IG9yaWdpbiBpbnN0YW5jZW9mIFZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luLnNjb3BlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldENsb3Nlc3RTY29wZShvcmlnaW4pIHx8IHRoaXMucm9vdFNjb3BlLnNjb3BlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmaW5kUGFyZW50U2NvcGUoY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3RTY29wZS5zY29wZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHJlYWR5IChwcmVtYXR1cmVseSkgc2V0IG9uIHRoaXMgdmlldyBtb2RlbCBzbyBnZXQgaXQgZnJvbSBjb250YWluZXIncyBwYXJlbnQgaW5zdGVhZFxuICAgICAgICBpZiAoY29udGFpbmVyLmhhcyhDbG9zZXN0U2NvcGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5oYXMoQ2xvc2VzdFNjb3BlLCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5nZXQoQ2xvc2VzdFNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb290U2NvcGUuc2NvcGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUEkgLSBHZXQgdmlld3BvcnQgYnkgbmFtZVxuICAgICAqL1xuICAgIGdldFZpZXdwb3J0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsVmlld3BvcnRzKCkuZmluZCh2aWV3cG9ydCA9PiB2aWV3cG9ydC5uYW1lID09PSBuYW1lKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIChub3QgeWV0IGltcGxlbWVudGVkKVxuICAgICAqL1xuICAgIGFkZFZpZXdwb3J0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSSAobm90IHlldCBpbXBsZW1lbnRlZClcbiAgICAgKi9cbiAgICBmaW5kVmlld3BvcnRTY29wZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUEkgKG5vdCB5ZXQgaW1wbGVtZW50ZWQpXG4gICAgICovXG4gICAgYWRkVmlld3BvcnRTY29wZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCAtIENhbGxlZCBmcm9tIHRoZSB2aWV3cG9ydCBzY29wZSBjdXN0b20gZWxlbWVudCBpbiBjcmVhdGVkKClcbiAgICAgKi9cbiAgICBzZXRDbG9zZXN0U2NvcGUodmlld01vZGVsT3JDb250YWluZXIsIHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKHZpZXdNb2RlbE9yQ29udGFpbmVyKTtcbiAgICAgICAgUmVnaXN0cmF0aW9uLmluc3RhbmNlKENsb3Nlc3RTY29wZSwgc2NvcGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldENsb3Nlc3RTY29wZSh2aWV3TW9kZWxPckVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gJ3Jlc291cmNlUmVzb2x2ZXJzJyBpbiB2aWV3TW9kZWxPckVsZW1lbnRcbiAgICAgICAgICAgID8gdmlld01vZGVsT3JFbGVtZW50XG4gICAgICAgICAgICA6IHRoaXMuZ2V0Q2xvc2VzdENvbnRhaW5lcih2aWV3TW9kZWxPckVsZW1lbnQpO1xuICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRhaW5lci5oYXMoQ2xvc2VzdFNjb3BlLCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5nZXQoQ2xvc2VzdFNjb3BlKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bnNldENsb3Nlc3RTY29wZSh2aWV3TW9kZWxPckNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcih2aWV3TW9kZWxPckNvbnRhaW5lcik7XG4gICAgICAgIC8vIFRPRE86IEdldCBhbiAndW5yZWdpc3Rlcicgb24gY29udGFpbmVyXG4gICAgICAgIGNvbnRhaW5lci5yZXNvbHZlcnMuZGVsZXRlKENsb3Nlc3RTY29wZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCAtIENhbGxlZCBmcm9tIHRoZSB2aWV3cG9ydCBjdXN0b20gZWxlbWVudFxuICAgICAqL1xuICAgIGNvbm5lY3RWaWV3cG9ydCh2aWV3cG9ydCwgY29ubmVjdGVkQ0UsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50U2NvcGUgPSB0aGlzLmZpbmRQYXJlbnRTY29wZShjb25uZWN0ZWRDRS5jb250YWluZXIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVmlld3BvcnQgcGFyZW50U2NvcGUnLCBwYXJlbnRTY29wZS50b1N0cmluZygpLCAoY29ubmVjdGVkQ0UgYXMgYW55KS5nZXRDbG9zZXN0Q3VzdG9tRWxlbWVudCgpKTtcbiAgICAgICAgY29uc3QgcGFyZW50Vmlld3BvcnRTY29wZSA9IChjb25uZWN0ZWRDRS5wYXJlbnRWaWV3cG9ydD8udmlld3BvcnQgPz8gdGhpcy5yb290U2NvcGUpLnNjb3BlO1xuICAgICAgICBpZiAocGFyZW50U2NvcGUgIT09IHBhcmVudFZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1ZpZXdwb3J0IHBhcmVudFNjb3BlICE9PSBwYXJlbnRWaWV3cG9ydFNjb3BlJywgcGFyZW50U2NvcGUudG9TdHJpbmcodHJ1ZSksIHBhcmVudFZpZXdwb3J0U2NvcGUudG9TdHJpbmcodHJ1ZSksIGNvbm5lY3RlZENFLmdldENsb3Nlc3RDdXN0b21FbGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3cG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld3BvcnQgPSBwYXJlbnRTY29wZS5hZGRWaWV3cG9ydChuYW1lLCBjb25uZWN0ZWRDRSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNldENsb3Nlc3RTY29wZShjb25uZWN0ZWRDRS5jb250YWluZXIsIHZpZXdwb3J0LmNvbm5lY3RlZFNjb3BlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Jlc3RyaWN0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdHMuc2V0KGNvbm5lY3RlZENFLCBuZXcgT3BlblByb21pc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0cy5nZXQoY29ubmVjdGVkQ0UpPy5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBDYWxsZWQgZnJvbSB0aGUgdmlld3BvcnQgY3VzdG9tIGVsZW1lbnRcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0Vmlld3BvcnQodmlld3BvcnQsIGNvbm5lY3RlZENFKSB7XG4gICAgICAgIGlmICghdmlld3BvcnQuY29ubmVjdGVkU2NvcGUucGFyZW50LnJlbW92ZVZpZXdwb3J0KHZpZXdwb3J0LCBjb25uZWN0ZWRDRSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZW1vdmUgdmlld3BvcnQ6IFwiICsgdmlld3BvcnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnNldENsb3Nlc3RTY29wZShjb25uZWN0ZWRDRS5jb250YWluZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBDYWxsZWQgZnJvbSB0aGUgdmlld3BvcnQgc2NvcGUgY3VzdG9tIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25uZWN0Vmlld3BvcnRTY29wZSh2aWV3cG9ydFNjb3BlLCBjb25uZWN0ZWRDRSwgbmFtZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJlbnRTY29wZSA9IHRoaXMuZmluZFBhcmVudFNjb3BlKGNvbm5lY3RlZENFLmNvbnRhaW5lcik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdWaWV3cG9ydFNjb3BlIHBhcmVudFNjb3BlJywgcGFyZW50U2NvcGUudG9TdHJpbmcoKSwgKGNvbm5lY3RlZENFIGFzIGFueSkuZ2V0Q2xvc2VzdEN1c3RvbUVsZW1lbnQoKSk7XG4gICAgICAgIGlmICh2aWV3cG9ydFNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3cG9ydFNjb3BlID0gcGFyZW50U2NvcGUuYWRkVmlld3BvcnRTY29wZShuYW1lLCBjb25uZWN0ZWRDRSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNldENsb3Nlc3RTY29wZShjb25uZWN0ZWRDRS5jb250YWluZXIsIHZpZXdwb3J0U2NvcGUuY29ubmVjdGVkU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cG9ydFNjb3BlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgLSBDYWxsZWQgZnJvbSB0aGUgdmlld3BvcnQgc2NvcGUgY3VzdG9tIGVsZW1lbnRcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0Vmlld3BvcnRTY29wZSh2aWV3cG9ydFNjb3BlLCBjb25uZWN0ZWRDRSkge1xuICAgICAgICBpZiAoIXZpZXdwb3J0U2NvcGUuY29ubmVjdGVkU2NvcGUucGFyZW50LnJlbW92ZVZpZXdwb3J0U2NvcGUodmlld3BvcnRTY29wZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZW1vdmUgdmlld3BvcnQgc2NvcGU6IFwiICsgdmlld3BvcnRTY29wZS5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuc2V0Q2xvc2VzdFNjb3BlKGNvbm5lY3RlZENFLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGFsbFZpZXdwb3J0cyhpbmNsdWRlRGlzYWJsZWQgPSBmYWxzZSwgaW5jbHVkZVJlcGxhY2VkID0gZmFsc2UpIHtcbiAgICAgICAgLy8gdGhpcy5lbnN1cmVSb290U2NvcGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdFNjb3BlLnNjb3BlLmFsbFZpZXdwb3J0cyhpbmNsdWRlRGlzYWJsZWQsIGluY2x1ZGVSZXBsYWNlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUEkgLSBUSEUgbmF2aWdhdGlvbiBBUElcbiAgICAgKi9cbiAgICBhc3luYyBnb3RvKGluc3RydWN0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoJ1wiZ290b1wiIG1ldGhvZCcsICdcImxvYWRcIiBtZXRob2QnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZChpbnN0cnVjdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBsb2FkKGluc3RydWN0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy8gVE9ETzogUmV2aWV3IHF1ZXJ5IGV4dHJhY3Rpb247IGRpZmZlcmVudCBwb3MgZm9yIHBhdGggYW5kIGZyYWdtZW50IVxuICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9ucyA9PT0gJ3N0cmluZycgJiYgIW9wdGlvbnMucXVlcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtwYXRoLCBzZWFyY2hdID0gaW5zdHJ1Y3Rpb25zLnNwbGl0KCc/Jyk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBwYXRoO1xuICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHNlYXJjaDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b09wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luKSB7XG4gICAgICAgICAgICB0b09wdGlvbnMuY29udGV4dCA9IG9wdGlvbnMub3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY29wZSA9IG51bGw7XG4gICAgICAgICh7IGluc3RydWN0aW9ucywgc2NvcGUgfSA9IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyLmNyZWF0ZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMsIGluc3RydWN0aW9ucywgdG9PcHRpb25zKSk7XG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZCAmJiB0aGlzLnByb2Nlc3NpbmdOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMsIGluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMsIHNjb3BlKTtcbiAgICAgICAgICAgIC8vIENhbid0IHJldHVybiBjdXJyZW50IG5hdmlnYXRpb24gcHJvbWlzZSBzaW5jZSBpdCBjYW4gbGVhZCB0byBkZWFkbG9jayBpbiBsb2FkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSBuZXcgTmF2aWdhdGlvbih7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbjogaW5zdHJ1Y3Rpb25zLFxuICAgICAgICAgICAgZnVsbFN0YXRlSW5zdHJ1Y3Rpb246ICcnLFxuICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgdGl0bGU6IG9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgICBxdWVyeTogb3B0aW9ucy5xdWVyeSxcbiAgICAgICAgICAgIHJlcGxhY2luZzogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICAgICAgcmVwZWF0aW5nOiBvcHRpb25zLmFwcGVuZCxcbiAgICAgICAgICAgIGZyb21Ccm93c2VyOiBmYWxzZSxcbiAgICAgICAgICAgIG9yaWdpbjogb3B0aW9ucy5vcmlnaW4sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IubmF2aWdhdGUoZW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLnJlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5nbygtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBmb3J3YXJkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuZ28oMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBnbyhkZWx0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuZ28oZGVsdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgY2hlY2tBY3RpdmUoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBzY29wZUluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5tYXRjaFNjb3BlKHRoaXMuYWN0aXZlQ29tcG9uZW50cywgaW5zdHJ1Y3Rpb24uc2NvcGUpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBzY29wZUluc3RydWN0aW9ucy5maWx0ZXIoaW5zdHIgPT4gaW5zdHIuc2FtZUNvbXBvbmVudChpbnN0cnVjdGlvbiwgdHJ1ZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucylcbiAgICAgICAgICAgICAgICAmJiBpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICYmIHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5tYXRjaENoaWxkcmVuKGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucywgbWF0Y2hpbmcubWFwKGluc3RyID0+IEFycmF5LmlzQXJyYXkoaW5zdHIubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKSA/IGluc3RyLm5leHRTY29wZUluc3RydWN0aW9ucyA6IFtdKS5mbGF0KCkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIHNldE5hdihuYW1lLCByb3V0ZXMsIGNsYXNzZXMpIHtcbiAgICAgICAgY29uc3QgbmF2ID0gdGhpcy5maW5kTmF2KG5hbWUpO1xuICAgICAgICBpZiAobmF2ICE9PSB2b2lkIDAgJiYgbmF2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBuYXYucm91dGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGROYXYobmFtZSwgcm91dGVzLCBjbGFzc2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqL1xuICAgIGFkZE5hdihuYW1lLCByb3V0ZXMsIGNsYXNzZXMpIHtcbiAgICAgICAgbGV0IG5hdiA9IHRoaXMubmF2c1tuYW1lXTtcbiAgICAgICAgaWYgKG5hdiA9PT0gdm9pZCAwIHx8IG5hdiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmF2ID0gdGhpcy5uYXZzW25hbWVdID0gbmV3IE5hdih0aGlzLCBuYW1lLCBbXSwgY2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICAgICAgbmF2LmFkZFJvdXRlcyhyb3V0ZXMpO1xuICAgICAgICBuYXYudXBkYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICB1cGRhdGVOYXYobmFtZSkge1xuICAgICAgICBjb25zdCBuYXZzID0gbmFtZVxuICAgICAgICAgICAgPyBbbmFtZV1cbiAgICAgICAgICAgIDogT2JqZWN0LmtleXModGhpcy5uYXZzKTtcbiAgICAgICAgZm9yIChjb25zdCBuYXYgb2YgbmF2cykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2c1tuYXZdICE9PSB2b2lkIDAgJiYgdGhpcy5uYXZzW25hdl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdnNbbmF2XS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgZmluZE5hdihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdnNbbmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBhZGRSb3V0ZXMocm91dGVzLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGFkZCB0byB0aGUgY29udGV4dCBpbnN0ZWFkXG4gICAgICAgIC8vIFRPRE86IEFkZCByb3V0ZXMgd2l0aG91dCBjb250ZXh0IHRvIHJvb3RTY29wZSBjb250ZW50ICh3aGljaCBuZWVkcyB0byBiZSBjcmVhdGVkKT9cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAvLyBjb25zdCB2aWV3cG9ydCA9IChjb250ZXh0ICE9PSB2b2lkIDAgPyB0aGlzLmNsb3Nlc3RWaWV3cG9ydChjb250ZXh0KSA6IHRoaXMucm9vdFNjb3BlKSB8fCB0aGlzLnJvb3RTY29wZSBhcyBWaWV3cG9ydDtcbiAgICAgICAgLy8gcmV0dXJuIHZpZXdwb3J0LmFkZFJvdXRlcyhyb3V0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgcmVtb3ZlUm91dGVzKHJvdXRlcywgY29udGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZW1vdmUgZnJvbSB0aGUgY29udGV4dCBpbnN0ZWFkXG4gICAgICAgIC8vIGNvbnN0IHZpZXdwb3J0ID0gKGNvbnRleHQgIT09IHZvaWQgMCA/IHRoaXMuY2xvc2VzdFZpZXdwb3J0KGNvbnRleHQpIDogdGhpcy5yb290U2NvcGUpIHx8IHRoaXMucm9vdFNjb3BlIGFzIFZpZXdwb3J0O1xuICAgICAgICAvLyByZXR1cm4gdmlld3BvcnQucmVtb3ZlUm91dGVzKHJvdXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUElcbiAgICAgKi9cbiAgICBhZGRIb29rcyhob29rcykge1xuICAgICAgICByZXR1cm4gaG9va3MubWFwKGhvb2sgPT4gdGhpcy5hZGRIb29rKGhvb2suaG9vaywgaG9vay5vcHRpb25zKSk7XG4gICAgfVxuICAgIGFkZEhvb2soaG9vaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5ob29rTWFuYWdlci5hZGRIb29rKGhvb2ssIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJXG4gICAgICovXG4gICAgcmVtb3ZlSG9va3MoaG9va3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgQVBJIC0gVGhlIHJpZ2h0IHdheSB0byBjcmVhdGUgVmlld3BvcnRJbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKGNvbXBvbmVudCwgdmlld3BvcnQsIHBhcmFtZXRlcnMsIG93bnNTY29wZSA9IHRydWUsIG5leHRTY29wZUluc3RydWN0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKGNvbXBvbmVudCwgdmlld3BvcnQsIHBhcmFtZXRlcnMsIG93bnNTY29wZSwgbmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgaGFzU2libGluZ0luc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgaWYgKGluc3RydWN0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucy5zb21lKGluc3RydWN0aW9uID0+IHRoaXMuaGFzU2libGluZ0luc3RydWN0aW9ucyhpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMpKTtcbiAgICB9XG4gICAgYXBwZW5kSW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucywgc2NvcGUgPSBudWxsKSB7XG4gICAgICAgIGlmIChzY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2NvcGUgPSB0aGlzLnJvb3RTY29wZS5zY29wZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZGVkSW5zdHJ1Y3Rpb25zLnB1c2goLi4uaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgY2hlY2tTdGFsZShuYW1lLCBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RhbGVDaGVjayA9IHRoaXMuc3RhbGVDaGVja3NbbmFtZV07XG4gICAgICAgIGlmIChzdGFsZUNoZWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhbGVDaGVja3NbbmFtZV0gPSBpbnN0cnVjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhbGVDaGVjay5sZW5ndGggIT09IGluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhbGVDaGVja3NbbmFtZV0gPSBpbnN0cnVjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWxlQ2hlY2tbaV0gIT09IGluc3RydWN0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhbGVDaGVja3NbbmFtZV0gPSBpbnN0cnVjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVua25vd25Sb3V0ZShyb3V0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJvdXRlICE9PSAnc3RyaW5nJyB8fCByb3V0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUNvbmZpZ3VyZWRSb3V0ZXMgJiYgdGhpcy5vcHRpb25zLnVzZURpcmVjdFJvdXRlcykge1xuICAgICAgICAgICAgLy8gVE9ETzogQWRkIG1pc3NpbmcvdW5rbm93biByb3V0ZSBoYW5kbGluZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWF0Y2hpbmcgY29uZmlndXJlZCByb3V0ZSBvciBjb21wb25lbnQgZm91bmQgZm9yICdcIiArIHJvdXRlICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy51c2VDb25maWd1cmVkUm91dGVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBZGQgbWlzc2luZy91bmtub3duIHJvdXRlIGhhbmRsaW5nXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtYXRjaGluZyBjb25maWd1cmVkIHJvdXRlIGZvdW5kIGZvciAnXCIgKyByb3V0ZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBtaXNzaW5nL3Vua25vd24gcm91dGUgaGFuZGxpbmdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1hdGNoaW5nIHJvdXRlL2NvbXBvbmVudCBmb3VuZCBmb3IgJ1wiICsgcm91dGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFZpZXdwb3J0cyhpbnN0cnVjdGlvbnMsIGFscmVhZHlGb3VuZCwgd2l0aG91dFZpZXdwb3J0cyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uc1swXS5zY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc1swXS5zY29wZSA9IHRoaXMucm9vdFNjb3BlLnNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSBpbnN0cnVjdGlvbnNbMF0uc2NvcGU7XG4gICAgICAgICAgICBjb25zdCB7IGZvdW5kVmlld3BvcnRzLCByZW1haW5pbmdJbnN0cnVjdGlvbnMgfSA9IHNjb3BlLmZpbmRWaWV3cG9ydHMoaW5zdHJ1Y3Rpb25zLmZpbHRlcihpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi5zY29wZSA9PT0gc2NvcGUpLCBhbHJlYWR5Rm91bmQsIHdpdGhvdXRWaWV3cG9ydHMpO1xuICAgICAgICAgICAgZm91bmQucHVzaCguLi5mb3VuZFZpZXdwb3J0cyk7XG4gICAgICAgICAgICByZW1haW5pbmcucHVzaCguLi5yZW1haW5pbmdJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLmZpbHRlcihpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi5zY29wZSAhPT0gc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvdW5kOiBmb3VuZC5zbGljZSgpLCByZW1haW5pbmcgfTtcbiAgICB9XG4gICAgYXN5bmMgY2FuY2VsTmF2aWdhdGlvbih1cGRhdGVkU2NvcGVPd25lcnMsIHFJbnN0cnVjdGlvbikge1xuICAgICAgICAvLyBUT0RPOiBUYWtlIGNhcmUgb2YgZGlzYWJsaW5nIHZpZXdwb3J0cyB3aGVuIGNhbmNlbGxpbmcgYW5kIHN0YXRlZnVsIVxuICAgICAgICB1cGRhdGVkU2NvcGVPd25lcnMuZm9yRWFjaCgodmlld3BvcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0ID0gdmlld3BvcnQuYWJvcnRDb250ZW50Q2hhbmdlKCk7XG4gICAgICAgICAgICBpZiAoYWJvcnQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQuY2F0Y2goZXJyb3IgPT4geyB0aHJvdyBlcnJvcjsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRvci5jYW5jZWwocUluc3RydWN0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTmF2aWdhdGlvbiA9IG51bGw7XG4gICAgICAgIHFJbnN0cnVjdGlvbi5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGVuc3VyZVJvb3RTY29wZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb3RTY29wZSkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuY29udGFpbmVyLmdldChJQXBwUm9vdCk7XG4gICAgICAgICAgICAvLyByb290LmNvbmZpZy5jb21wb25lbnQgc2hvdWxkbid0IGJlIHVzZWQgaW4gdGhlIGVuZC4gTWV0YWRhdGEgd2lsbCBwcm9iYWJseSBlbGltaW5hdGUgaXRcbiAgICAgICAgICAgIHRoaXMucm9vdFNjb3BlID0gbmV3IFZpZXdwb3J0U2NvcGUoJ3Jvb3RTY29wZScsIHRoaXMsIHJvb3QuY29udHJvbGxlci52aWV3TW9kZWwsIG51bGwsIHRydWUsIHJvb3QuY29uZmlnLmNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdFNjb3BlO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlUGF0aHMoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdGhpcy5yb290U2NvcGUuc2NvcGUucmVwYXJlbnRWaWV3cG9ydEluc3RydWN0aW9ucygpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gdGhpcy5yb290U2NvcGUuc2NvcGUuaG9pc3RlZENoaWxkcmVuXG4gICAgICAgICAgICAuZmlsdGVyKHNjb3BlID0+IHNjb3BlLnZpZXdwb3J0SW5zdHJ1Y3Rpb24gIT09IG51bGwgJiYgIXNjb3BlLnZpZXdwb3J0SW5zdHJ1Y3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgLm1hcChzY29wZSA9PiBzY29wZS52aWV3cG9ydEluc3RydWN0aW9uKTtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLmNsb25lVmlld3BvcnRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zLCB0cnVlKTtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBtYWtlcyBzdXJlIHJpZ2h0IHZpZXdwb3J0L3ZpZXdwb3J0IHNjb3BlcyBhcmUgc2V0IGFuZCB1cGRhdGVcbiAgICAgICAgLy8gd2hldGhlciB2aWV3cG9ydCBuYW1lIGlzIG5lY2Vzc2FyeSBvciBub3RcbiAgICAgICAgY29uc3QgYWxyZWFkeUZvdW5kID0gW107XG4gICAgICAgIGxldCB7IGZvdW5kLCByZW1haW5pbmcgfSA9IHRoaXMuZmluZFZpZXdwb3J0cyhpbnN0cnVjdGlvbnMsIGFscmVhZHlGb3VuZCwgdHJ1ZSk7XG4gICAgICAgIGxldCBndWFyZCA9IDEwMDtcbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IGVuZGxlc3MgbG9vcFxuICAgICAgICAgICAgaWYgKGd1YXJkLS0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIHZpZXdwb3J0IHdoZW4gdXBkYXRpbmcgdmlld2VyIHBhdGhzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeUZvdW5kLnB1c2goLi4uZm91bmQpO1xuICAgICAgICAgICAgKHsgZm91bmQsIHJlbWFpbmluZyB9ID0gdGhpcy5maW5kVmlld3BvcnRzKHJlbWFpbmluZywgYWxyZWFkeUZvdW5kLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVDb21wb25lbnRzID0gaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLmFjdGl2ZVJvdXRlID0gaW5zdHJ1Y3Rpb24ucm91dGU7XG4gICAgICAgIC8vIEZpcnN0IGludm9rZSB3aXRoIHZpZXdwb3J0IGluc3RydWN0aW9ucyAoc2hvdWxkIGl0IHBlcmhhcHMgZ2V0IGZ1bGwgc3RhdGU/KVxuICAgICAgICBsZXQgc3RhdGUgPSBhd2FpdCB0aGlzLmhvb2tNYW5hZ2VyLmludm9rZVRyYW5zZm9ybVRvVXJsKGluc3RydWN0aW9ucywgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5zdHJpbmdpZnlWaWV3cG9ydEluc3RydWN0aW9ucyhzdGF0ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludm9rZSBhZ2FpbiB3aXRoIHN0cmluZ1xuICAgICAgICBzdGF0ZSA9IGF3YWl0IHRoaXMuaG9va01hbmFnZXIuaW52b2tlVHJhbnNmb3JtVG9Vcmwoc3RhdGUsIGluc3RydWN0aW9uKTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSAoaW5zdHJ1Y3Rpb24ucXVlcnkgJiYgaW5zdHJ1Y3Rpb24ucXVlcnkubGVuZ3RoID8gXCI/XCIgKyBpbnN0cnVjdGlvbi5xdWVyeSA6ICcnKTtcbiAgICAgICAgLy8gaWYgKGluc3RydWN0aW9uLnBhdGggPT09IHZvaWQgMCB8fCBpbnN0cnVjdGlvbi5wYXRoLmxlbmd0aCA9PT0gMCB8fCBpbnN0cnVjdGlvbi5wYXRoID09PSAnLycpIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb24ucGF0aCA9IHN0YXRlICsgcXVlcnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3QgZnVsbFZpZXdwb3J0U3RhdGVzID0gW3RoaXMuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbih0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIuY2xlYXJWaWV3cG9ydEluc3RydWN0aW9uKV07XG4gICAgICAgIGZ1bGxWaWV3cG9ydFN0YXRlcy5wdXNoKC4uLnRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jbG9uZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucywgdGhpcy5zdGF0ZWZ1bEhpc3RvcnkpKTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24uZnVsbFN0YXRlSW5zdHJ1Y3Rpb24gPSBmdWxsVmlld3BvcnRTdGF0ZXM7XG4gICAgICAgIGlmICgoaW5zdHJ1Y3Rpb24udGl0bGUgPz8gbnVsbCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gYXdhaXQgdGhpcy5nZXRUaXRsZShpbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnRpdGxlID0gdGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUaXRsZShpbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIC8vIEZpcnN0IGludm9rZSB3aXRoIHZpZXdwb3J0IGluc3RydWN0aW9uc1xuICAgICAgICBsZXQgdGl0bGUgPSBhd2FpdCB0aGlzLmhvb2tNYW5hZ2VyLmludm9rZVNldFRpdGxlKGluc3RydWN0aW9ucywgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICBpZiAodHlwZW9mIHRpdGxlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gSG9vayBkaWRuJ3QgcmV0dXJuIGEgdGl0bGUsIHNvIHJ1biB0aXRsZSBsb2dpY1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50VGl0bGVzID0gdGhpcy5zdHJpbmdpZnlUaXRsZXModGl0bGUsIGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlLmFwcFRpdGxlO1xuICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKFwiJHtjb21wb25lbnRUaXRsZXN9XCIsIGNvbXBvbmVudFRpdGxlcyk7XG4gICAgICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UoXCIke2FwcFRpdGxlU2VwYXJhdG9yfVwiLCBjb21wb25lbnRUaXRsZXMgIT09ICcnXG4gICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMudGl0bGUuYXBwVGl0bGVTZXBhcmF0b3JcbiAgICAgICAgICAgICAgICA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnZva2UgYWdhaW4gd2l0aCBjb21wbGV0ZSBzdHJpbmdcbiAgICAgICAgdGl0bGUgPSBhd2FpdCB0aGlzLmhvb2tNYW5hZ2VyLmludm9rZVNldFRpdGxlKHRpdGxlLCBpbnN0cnVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gICAgc3RyaW5naWZ5VGl0bGVzKGluc3RydWN0aW9ucywgbmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlcyA9IGluc3RydWN0aW9uc1xuICAgICAgICAgICAgLm1hcChpbnN0cnVjdGlvbiA9PiB0aGlzLnN0cmluZ2lmeVRpdGxlKGluc3RydWN0aW9uLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pKVxuICAgICAgICAgICAgLmZpbHRlcihpbnN0cnVjdGlvbiA9PiAoaW5zdHJ1Y3Rpb24/Lmxlbmd0aCA/PyAwKSA+IDApO1xuICAgICAgICByZXR1cm4gdGl0bGVzLmpvaW4oJyArICcpO1xuICAgIH1cbiAgICBzdHJpbmdpZnlUaXRsZShpbnN0cnVjdGlvbiwgbmF2aWdhdGlvbkluc3RydWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlVGl0bGUoaW5zdHJ1Y3Rpb24sIG5hdmlnYXRpb25JbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSBpbnN0cnVjdGlvbi5yb3V0ZSA/PyBudWxsO1xuICAgICAgICBjb25zdCBuZXh0SW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zO1xuICAgICAgICBsZXQgc3RyaW5naWZpZWQgPSAnJztcbiAgICAgICAgLy8gSXQncyBhIGNvbmZpZ3VyZWQgcm91dGVcbiAgICAgICAgaWYgKHJvdXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGFkZGVkIGFzIHBhcnQgb2YgYSBjb25maWd1cmF0aW9uLCBza2lwIHRvIG5leHQgc2NvcGVcbiAgICAgICAgICAgIGlmIChyb3V0ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuZXh0SW5zdHJ1Y3Rpb25zKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc3RyaW5naWZ5VGl0bGVzKG5leHRJbnN0cnVjdGlvbnMsIG5hdmlnYXRpb25JbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkICs9IHRoaXMucmVzb2x2ZVRpdGxlKHJvdXRlLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyaW5naWZpZWQgKz0gdGhpcy5yZXNvbHZlVGl0bGUoaW5zdHJ1Y3Rpb24sIG5hdmlnYXRpb25JbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dEluc3RydWN0aW9ucykgJiYgbmV4dEluc3RydWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFN0cmluZ2lmaWVkID0gdGhpcy5zdHJpbmdpZnlUaXRsZXMobmV4dEluc3RydWN0aW9ucywgbmF2aWdhdGlvbkluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChuZXh0U3RyaW5naWZpZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0SW5zdHJ1Y3Rpb25zLmxlbmd0aCAhPT0gMSkgeyAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYWxzbyBjaGVjayB0aGF0IHRoZSBpbnN0cnVjdGlvbnMgaGF2ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RyaW5naWZpZWQgPSBcIlsgXCIgKyBuZXh0U3RyaW5naWZpZWQgKyBcIiBdXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdpZmllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkID0gdGhpcy5vcHRpb25zLnRpdGxlLmNvbXBvbmVudFRpdGxlT3JkZXIgPT09ICd0b3AtZG93bidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RyaW5naWZpZWQgKyB0aGlzLm9wdGlvbnMudGl0bGUuY29tcG9uZW50VGl0bGVTZXBhcmF0b3IgKyBuZXh0U3RyaW5naWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFN0cmluZ2lmaWVkICsgdGhpcy5vcHRpb25zLnRpdGxlLmNvbXBvbmVudFRpdGxlU2VwYXJhdG9yICsgc3RyaW5naWZpZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZCA9IG5leHRTdHJpbmdpZmllZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgICByZXNvbHZlVGl0bGUoaW5zdHJ1Y3Rpb24sIG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRpdGxlID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBWaWV3cG9ydEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24udmlld3BvcnQuZ2V0VGl0bGUobmF2aWdhdGlvbkluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbiBpbnN0YW5jZW9mIEZvdW5kUm91dGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlVGl0bGUgPSBpbnN0cnVjdGlvbi5tYXRjaD8udGl0bGU7XG4gICAgICAgICAgICBpZiAocm91dGVUaXRsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByb3V0ZVRpdGxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHJvdXRlVGl0bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHJvdXRlVGl0bGUuY2FsbChpbnN0cnVjdGlvbiwgaW5zdHJ1Y3Rpb24sIG5hdmlnYXRpb25JbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGl0bGUudHJhbnNmb3JtVGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGUudHJhbnNmb3JtVGl0bGUuY2FsbCh0aGlzLCB0aXRsZSwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gICAgYXN5bmMgZnJlZUNvbXBvbmVudHMoaW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVDb21wb25lbnRzLCBhbHJlYWR5RG9uZSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBpbnN0cnVjdGlvbi5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBpbnN0cnVjdGlvbi52aWV3cG9ydDtcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gbnVsbCB8fCB2aWV3cG9ydCA9PT0gbnVsbCB8fCBhbHJlYWR5RG9uZS5zb21lKGRvbmUgPT4gZG9uZSA9PT0gY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjbHVkZUNvbXBvbmVudHMuc29tZShleGNsdWRlID0+IGV4Y2x1ZGUgPT09IGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHZpZXdwb3J0LmZyZWVDb250ZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICBhbHJlYWR5RG9uZS5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0SW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb24ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mcmVlQ29tcG9uZW50cyhuZXh0SW5zdHJ1Y3Rpb24sIGV4Y2x1ZGVDb21wb25lbnRzLCBhbHJlYWR5RG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2xvc2VzdENvbnRhaW5lcih2aWV3TW9kZWxPckVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCdjb250ZXh0JyBpbiB2aWV3TW9kZWxPckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3TW9kZWxPckVsZW1lbnQuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJyRjb250cm9sbGVyJyBpbiB2aWV3TW9kZWxPckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3TW9kZWxPckVsZW1lbnQuJGNvbnRyb2xsZXIuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5DdXN0b21FbGVtZW50Rm9yKHZpZXdNb2RlbE9yRWxlbWVudCk7XG4gICAgICAgIGlmIChjb250cm9sbGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmNvbnRleHQ7XG4gICAgfVxuICAgIGdldENvbnRhaW5lcih2aWV3TW9kZWxPckNvbnRhaW5lcikge1xuICAgICAgICBpZiAoJ3Jlc291cmNlUmVzb2x2ZXJzJyBpbiB2aWV3TW9kZWxPckNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdNb2RlbE9yQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlbmRlckNvbnRleHQodmlld01vZGVsT3JDb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld01vZGVsT3JDb250YWluZXIuZ2V0KElDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnJGNvbnRyb2xsZXInIGluIHZpZXdNb2RlbE9yQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld01vZGVsT3JDb250YWluZXIuJGNvbnRyb2xsZXIuY29udGV4dC5nZXQoSUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRPRE86IFRoaXMgaXMgcHJvYmFibHkgd3Jvbmcgc2luY2UgaXQgY2F1c2VkIHRlc3QgZmFpbHMgd2hlbiBpbiBDdXN0b21FbGVtZW50LmZvclxuICAgIC8vIEZyZWQgcHJvYmFibHkga25vd3MgYW5kIHdpbGwgbmVlZCB0byBsb29rIGF0IGl0XG4gICAgLy8gVGhpcyBjYW4gbW9zdCBsaWtlbHkgYWxzbyBiZSBjaGFuZ2VkIHNvIHRoYXQgdGhlIG5vZGUgdHJhdmVyc2FsIGlzbid0IG5lY2Vzc2FyeVxuICAgIEN1c3RvbUVsZW1lbnRGb3Iobm9kZSkge1xuICAgICAgICBsZXQgY3VyID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKGN1ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVJlc291cmNlTmFtZSA9IGN1ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE1ldGFkYXRhLmdldE93bihDdXN0b21FbGVtZW50Lm5hbWUgKyBcIjpcIiArIG5vZGVSZXNvdXJjZU5hbWUsIGN1cilcbiAgICAgICAgICAgICAgICB8fCBNZXRhZGF0YS5nZXRPd24oQ3VzdG9tRWxlbWVudC5uYW1lLCBjdXIpO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gZ2V0RWZmZWN0aXZlUGFyZW50Tm9kZShjdXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodm9pZCAwKTtcbiAgICB9XG59XG5Sb3V0ZXIuaW5qZWN0ID0gW0lDb250YWluZXIsIE5hdmlnYXRvciwgQnJvd3NlclZpZXdlclN0b3JlLCBMaW5rSGFuZGxlciwgSW5zdHJ1Y3Rpb25SZXNvbHZlciwgSG9va01hbmFnZXIsIFJvdXRlck9wdGlvbnNdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCIsIi8qKlxuICogQ2xhc3MgZm9yIHJ1bm5pbmcgYSBzZXF1ZW5jZSBvZiBzdGVwcyB3aXRoIHZhbHVlcyxcbiAqIGZ1bmN0aW9ucyBhbmQgcHJvbWlzZXMuIFN0YXlzIHN5bmMgaWYgcG9zc2libGUuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHByb21pc2UgPSBSdW5uZXIucnVuKFxuICogICAnb25lJyxcbiAqICAgcHJldiA9PiBgJHtwcmV2aW91c30sIHR3b2AsXG4gKiAgIHByZXYgPT4gY3JlYXRlUHJvbWlzZShwcmV2KSwgLy8gY3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBgJHtwcmV2fSwgdGhyZWVgXG4gKiApO1xuICpcbiAqIC8vIFJ1biBjYW4gYmUgY2FuY2VsbGVkIHdpdGggUnVubmVyLmNhbmNlbChwcm9taXNlKTtcbiAqXG4gKiBjb25zdCBzdGVwc1J1bm5lciA9IFJ1bm5lci5ydW5uZXIocHJvbWlzZSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICogaWYgKHN0ZXBzUnVubmVyPy5pc1Jlc29sdmVkKSB7IC8vIE1ha2Ugc3VyZSBwcm9taXNlIHdhc24ndCByZWplY3RlZFxuICogICAvLyByZXN1bHQgPT09ICdvbmUsIHR3bywgdGhyZWUnXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5lciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXNEb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHN0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ2FuY2VsbGVkIHx8IHRoaXMuaXNSZWplY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBhIHNldCBvZiBzdGVwcyBhbmQgcmV0dW5zIHRoZSBsYXN0IHZhbHVlXG4gICAgICpcbiAgICAgKiBTdGVwcyBhcmUgcHJvY2Vzc2VkIGluIHNlcXVlbmNlIGFuZCBjYW4gYmUgZWl0aGVyIGFcbiAgICAgKlxuICAgICAqIC0gdmFsdWUgLSB3aGljaCBpcyB0aGVuIHByb3BhZ2F0ZWQgYXMgaW5wdXQgaW50byB0aGUgbmV4dCBzdGVwXG4gICAgICogLSBmdW5jdGlvbiAtIHdoaWNoIGlzIGV4ZWN1dGVkIGluIHRpbWUuIFRoZSByZXN1bHQgaXMgcmVwbGFjaW5nIHRoZSBzdGVwIHdoaWNoIGlzIHRoZW4gcmVwcm9jZXNzZWRcbiAgICAgKiAtIHByb21pc2UgLSB3aGljaCBpcyBhd2FpdGVkXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHJlc3VsdCA9IGF3YWl0IFJ1bm5lci5ydW4oXG4gICAgICogICAnb25lJyxcbiAgICAgKiAgIHByZXYgPT4gYCR7cHJldmlvdXN9LCB0d29gLFxuICAgICAqICAgcHJldiA9PiBjcmVhdGVQcm9taXNlKHByZXYpLCAvLyBjcmVhdGVzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGAke3ByZXZ9LCB0aHJlZWBcbiAgICAgKiApOyAvLyByZXN1bHQgPT09ICdvbmUsIHR3bywgdGhyZWUnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcnVuKC4uLnN0ZXBzKSB7XG4gICAgICAgIC8vIGRlYnVnZ2VyOyAvLyBGSVggQVJSQVkgQ0hFQ0shXG4gICAgICAgIGNvbnN0ICRydW5uZXIgPSBuZXcgUnVubmVyKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gUnVubmVyLiRydW4oJHJ1bm5lciwgLi4uc3RlcHMpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bm5lcnMuc2V0KHZhbHVlLCAkcnVubmVyKTtcbiAgICAgICAgICAgIHZhbHVlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICRydW5uZXIuaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoJHJ1bm5lci5pc0FzeW5jICYmICEkcnVubmVyLnN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgJHJ1bm5lci5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uZXJzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyRydW5uZXIgZG9uZScsICRydW5uZXIsIHRoaXMucnVubmVycyk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4geyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcnVubmVyIGZvciBhIHByb21pc2UgcmV0dXJuZWQgYnkgUnVubmVyLnJ1blxuICAgICAqXG4gICAgICogVGhlIHJ1bm5lciBjYW4gYmUgdXNlZCB0byBjaGVjayBzdGF0dXMgYW5kIG91dGNvbWUgb2ZcbiAgICAgKiB0aGUgcnVuIGFzIHdlbGwgYXMgY2FuY2VsIGl0XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcnVubmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVubmVycy5nZXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgdGhlIHJ1bm5lciBmb3IgYSBwcm9taXNlIHJldHVybmVkIGJ5IFJ1bm5lci5ydW5cbiAgICAgKlxuICAgICAqIE9uY2UgYSBydW5uZXIgaGFzIGJlZW4gY2FuY2VsbGVkLCBpdCdzIG5vIGxvbmdlciBwb3NzaWJsZVxuICAgICAqIHRvIHJldHJpZXZlIGl0IGZyb20gdGhlIHByb21pc2VcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBjYW5jZWwodmFsdWUpIHtcbiAgICAgICAgY29uc3QgJHJ1bm5lciA9IFJ1bm5lci5ydW5uZXIodmFsdWUpO1xuICAgICAgICBpZiAoJHJ1bm5lciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAkcnVubmVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBydW5BbGwoc3RlcHMpIHtcbiAgICAgICAgY29uc3QgJHJ1bm5lciA9IG5ldyBSdW5uZXIoKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gUnVubmVyLiRydW5BbGwoJHJ1bm5lciwgc3RlcHMpO1xuICAgICAgICBpZiAoJHJ1bm5lci5pc0FzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5hbGwodmFsdWVzKTtcbiAgICAgICAgICAgIHRoaXMucnVubmVycy5zZXQocHJvbWlzZSwgJHJ1bm5lcik7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICRydW5uZXIuaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoJHJ1bm5lci5pc0FzeW5jICYmICEkcnVubmVyLnN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgJHJ1bm5lci5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uZXJzLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnJHJ1bm5lciBkb25lJywgJHJ1bm5lciwgdGhpcy5ydW5uZXJzKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBzdGF0aWMgcnVuT25lKHN0ZXApIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAvLyBJdGVyYXRpdmVseSByZXNvbHZlIEZ1bmN0aW9ucyAodW50aWwgdmFsdWUgb3IgUHJvbWlzZSlcbiAgICAgICAgd2hpbGUgKHN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgc3RlcCA9IHN0ZXAodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBQcm9taXNlKSkgeyAvLyA9PT0gaXNWYWx1ZShzdGVwKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIHdhc24ndCBhIEZ1bmN0aW9uIGJlZm9yZSB0aGUgdmFsdWVcbiAgICAgICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBQcm9taXNlKSkgeyAvLyA9PT0gaXNWYWx1ZShzdGVwKVxuICAgICAgICAgICAgdmFsdWUgPSBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvdCBhIFByb21pc2UsIHJ1biB0aGUgcmVtYWluaW5nXG4gICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAudGhlbigocmVzb2x2ZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuT25lKHJlc29sdmVkVmFsdWUpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4geyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljICRydW4oJHJ1bm5lciwgLi4uc3RlcHMpIHtcbiAgICAgICAgbGV0IHN0ZXA7XG4gICAgICAgIHdoaWxlIChzdGVwcy5sZW5ndGggPiAwICYmICEkcnVubmVyLnN0b3ApIHtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwcy5zaGlmdCgpO1xuICAgICAgICAgICAgLy8gSXRlcmF0aXZlbHkgcmVzb2x2ZSBGdW5jdGlvbnMgKHVudGlsIHZhbHVlIG9yIFByb21pc2UpXG4gICAgICAgICAgICB3aGlsZSAoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmICEkcnVubmVyLnN0b3ApIHtcbiAgICAgICAgICAgICAgICBzdGVwID0gc3RlcCgkcnVubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24pICYmICEoc3RlcCBpbnN0YW5jZW9mIFByb21pc2UpKSB7IC8vID09PSBpc1ZhbHVlKHN0ZXApXG4gICAgICAgICAgICAgICAgICAgICRydW5uZXIudmFsdWUgPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlcmUgd2Fzbid0IGEgRnVuY3Rpb24gYmVmb3JlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBQcm9taXNlKSkgeyAvLyA9PT0gaXNWYWx1ZShzdGVwKVxuICAgICAgICAgICAgICAgICRydW5uZXIudmFsdWUgPSBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIHN0ZXBzIHVudGlsIGRvbmUgb3Igd2UgZ2V0IGEgUHJvbWlzZVxuICAgICAgICAgICAgaWYgKHN0ZXAgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UndmUgZ290IGEgUHJvbWlzZSwgcnVuIHRoZSByZW1haW5pbmdcbiAgICAgICAgaWYgKHN0ZXAgaW5zdGFuY2VvZiBQcm9taXNlICYmICEkcnVubmVyLnN0b3ApIHtcbiAgICAgICAgICAgICRydW5uZXIuaXNBc3luYyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gc3RlcC50aGVuKChyZXNvbHZlZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci4kcnVuKCRydW5uZXIsIHJlc29sdmVkVmFsdWUsIC4uLnN0ZXBzKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAkcnVubmVyLmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcnVubmVyLnZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgJHJ1bkFsbCgkcnVubmVyLCBzdGVwcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KHN0ZXBzLmxlbmd0aCk7XG4gICAgICAgIHN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBJdGVyYXRpdmVseSByZXNvbHZlIEZ1bmN0aW9ucyAodW50aWwgdmFsdWUgb3IgUHJvbWlzZSlcbiAgICAgICAgICAgIHdoaWxlIChzdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzdGVwID0gc3RlcChyZXN1bHRzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBQcm9taXNlKSkgeyAvLyA9PT0gaXNWYWx1ZShzdGVwKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSB3YXNuJ3QgYSBGdW5jdGlvbiBiZWZvcmUgdGhlIHZhbHVlXG4gICAgICAgICAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7IC8vID09PSBpc1ZhbHVlKHN0ZXApXG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UndmUgZ290IGEgUHJvbWlzZSwgcnVuIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICRydW5uZXIuaXNBc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59XG5SdW5uZXIucnVubmVycyA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW5uZXIuanMubWFwIiwiaW1wb3J0IHsgVmlld3BvcnRTY29wZSB9IGZyb20gJy4vdmlld3BvcnQtc2NvcGUuanMnO1xuaW1wb3J0IHsgRm91bmRSb3V0ZSB9IGZyb20gJy4vZm91bmQtcm91dGUuanMnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIgfSBmcm9tICcuL3R5cGUtcmVzb2x2ZXJzLmpzJztcbmltcG9ydCB7IFZpZXdwb3J0IH0gZnJvbSAnLi92aWV3cG9ydC5qcyc7XG5pbXBvcnQgeyBhcnJheVJlbW92ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBSb3V0ZVJlY29nbml6ZXIgfSBmcm9tICcuL3JvdXRlLXJlY29nbml6ZXIuanMnO1xuaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnLi9ydW5uZXIuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuICovXG5leHBvcnQgY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHJvdXRlciwgaGFzU2NvcGUsIG93bmluZ1Njb3BlLCB2aWV3cG9ydCA9IG51bGwsIHZpZXdwb3J0U2NvcGUgPSBudWxsLCByb290Q29tcG9uZW50VHlwZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMuaGFzU2NvcGUgPSBoYXNTY29wZTtcbiAgICAgICAgdGhpcy5vd25pbmdTY29wZSA9IG93bmluZ1Njb3BlO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMudmlld3BvcnRTY29wZSA9IHZpZXdwb3J0U2NvcGU7XG4gICAgICAgIHRoaXMucm9vdENvbXBvbmVudFR5cGUgPSByb290Q29tcG9uZW50VHlwZTtcbiAgICAgICAgdGhpcy5pZCA9ICcuJztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMucmVwbGFjZWRDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvLyBTdXBwb3J0IGNvbGxlY3Rpb24gZmVhdHVyZSBpbiB2aWV3cG9ydCBzY29wZXNcbiAgICAgICAgdGhpcy5jaGlsZENvbGxlY3Rpb25zID0ge307XG4gICAgICAgIHRoaXMub3duaW5nU2NvcGUgPSBvd25pbmdTY29wZSA/PyB0aGlzO1xuICAgICAgICB0aGlzLnNjb3BlID0gdGhpcy5oYXNTY29wZSA/IHRoaXMgOiB0aGlzLm93bmluZ1Njb3BlLnNjb3BlO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3JlYXRlZCBzY29wZScsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHJlY3Vyc2UgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vd25pbmdTY29wZSAhPT0gdGhpcyA/IHRoaXMub3duaW5nU2NvcGUudG9TdHJpbmcoKSA6ICcnfS8ke3RoaXMub3duZXIudG9TdHJpbmcoKX1gICtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgICAgIGAke3JlY3Vyc2UgPyBgXFxuYCArIHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnRvU3RyaW5nKHRydWUpKS5qb2luKCcnKSA6ICcnfWA7XG4gICAgfVxuICAgIGdldCBpc1ZpZXdwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydCAhPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzVmlld3BvcnRTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRTY29wZSAhPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhc3NUaHJvdWdoU2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmlld3BvcnRTY29wZSAmJiB0aGlzLnZpZXdwb3J0U2NvcGUucGFzc1Rocm91Z2hTY29wZTtcbiAgICB9XG4gICAgZ2V0IG93bmVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1ZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0U2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBlbmFibGVkQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmZpbHRlcihzY29wZSA9PiBzY29wZS5lbmFibGVkKTtcbiAgICB9XG4gICAgZ2V0IGhvaXN0ZWRDaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gdGhpcy5lbmFibGVkQ2hpbGRyZW47XG4gICAgICAgIHdoaWxlIChzY29wZXMuc29tZShzY29wZSA9PiBzY29wZS5wYXNzVGhyb3VnaFNjb3BlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMuc2xpY2UoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5wYXNzVGhyb3VnaFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2NvcGVzLmluZGV4T2Yoc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZXMuc3BsaWNlKGluZGV4LCAxLCAuLi5zY29wZS5lbmFibGVkQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlZFZpZXdwb3J0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoc2NvcGUgPT4gc2NvcGUuaXNWaWV3cG9ydCAmJiBzY29wZS5lbmFibGVkKVxuICAgICAgICAgICAgLm1hcChzY29wZSA9PiBzY29wZS52aWV3cG9ydCk7XG4gICAgfVxuICAgIGdldCB2aWV3cG9ydEluc3RydWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdwb3J0U2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0U2NvcGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1ZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5jb250ZW50LmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJlbnROZXh0Q29udGVudEFjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50QWN0aW9uID0gdGhpcy5wYXJlbnQub3duZXIubmV4dENvbnRlbnRBY3Rpb247XG4gICAgICAgIGlmIChwYXJlbnRBY3Rpb24gPT09ICdzd2FwJyB8fCBwYXJlbnRBY3Rpb24gPT09ICdza2lwJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudEFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50TmV4dENvbnRlbnRBY3Rpb247XG4gICAgfVxuICAgIGdldEVuYWJsZWRWaWV3cG9ydHModmlld3BvcnRTY29wZXMpIHtcbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0U2NvcGVzXG4gICAgICAgICAgICAuZmlsdGVyKHNjb3BlID0+ICFzY29wZS5pc1ZpZXdwb3J0U2NvcGUpXG4gICAgICAgICAgICAubWFwKHNjb3BlID0+IHNjb3BlLnZpZXdwb3J0KVxuICAgICAgICAgICAgLnJlZHVjZSgodmlld3BvcnRzLCB2aWV3cG9ydCkgPT4ge1xuICAgICAgICAgICAgdmlld3BvcnRzW3ZpZXdwb3J0Lm5hbWVdID0gdmlld3BvcnQ7XG4gICAgICAgICAgICByZXR1cm4gdmlld3BvcnRzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGdldE93bmVkVmlld3BvcnRzKGluY2x1ZGVEaXNhYmxlZCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFZpZXdwb3J0cyhpbmNsdWRlRGlzYWJsZWQpLmZpbHRlcih2aWV3cG9ydCA9PiB2aWV3cG9ydC5vd25pbmdTY29wZSA9PT0gdGhpcyk7XG4gICAgfVxuICAgIGdldE93bmVkU2NvcGVzKGluY2x1ZGVEaXNhYmxlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuYWxsU2NvcGVzKGluY2x1ZGVEaXNhYmxlZCkuZmlsdGVyKHNjb3BlID0+IHNjb3BlLm93bmluZ1Njb3BlID09PSB0aGlzKTtcbiAgICAgICAgLy8gSG9pc3QgY2hpbGRyZW4gdG8gcGFzcyB0aHJvdWdoIHNjb3Blc1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcy5zbGljZSgpKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUucGFzc1Rocm91Z2hTY29wZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2NvcGVzLmluZGV4T2Yoc2NvcGUpO1xuICAgICAgICAgICAgICAgIHNjb3Blcy5zcGxpY2UoaW5kZXgsIDEsIC4uLnNjb3BlLmdldE93bmVkU2NvcGVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZXM7XG4gICAgfVxuICAgIGZpbmRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgbGV0IHJvdXRlID0gbmV3IEZvdW5kUm91dGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIucGFyc2VWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3V0ZXIub3B0aW9ucy51c2VDb25maWd1cmVkUm91dGVzICYmICF0aGlzLnJvdXRlci5oYXNTaWJsaW5nSW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZFJvdXRlID0gdGhpcy5maW5kTWF0Y2hpbmdSb3V0ZShpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kUm91dGU/LmZvdW5kQ29uZmlndXJhdGlvbiA/PyBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IGZvdW5kUm91dGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3V0ZXIub3B0aW9ucy51c2VEaXJlY3RSb3V0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZS5pbnN0cnVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbnN0cnVjdGlvbnMgPSByb3V0ZS5pbnN0cnVjdGlvbnNbMF0ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlLnJlbWFpbmluZyA9IHRoaXMucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIuc3RyaW5naWZ5Vmlld3BvcnRJbnN0cnVjdGlvbnMobmV4dEluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVmVyaWZ5IHRoYXQgaXQncyBva2F5IHRvIGxlYXZlIHRoaXMgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZS5pbnN0cnVjdGlvbnNbMF0ubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucm91dGVyLm9wdGlvbnMudXNlRGlyZWN0Um91dGVzKSB7XG4gICAgICAgICAgICAgICAgcm91dGUuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm91dGUuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbnN0ciBvZiByb3V0ZS5pbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpbnN0ci5zY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluc3RyLnNjb3BlID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfVxuICAgIC8vIE5vdGU6IFRoaXMgY2FuJ3QgY2hhbmdlIHN0YXRlIG90aGVyIHRoYW4gdGhlIGluc3RydWN0aW9ucyFcbiAgICBmaW5kVmlld3BvcnRzKGluc3RydWN0aW9ucywgYWxyZWFkeUZvdW5kLCBkaXNyZWdhcmRWaWV3cG9ydHMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBmb3VuZFZpZXdwb3J0cyA9IFtdO1xuICAgICAgICBsZXQgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGNvbnN0IG93bmVkU2NvcGVzID0gdGhpcy5nZXRPd25lZFNjb3BlcygpO1xuICAgICAgICAvLyBHZXQgYSBzaGFsbG93IGNvcHkgb2YgYWxsIGF2YWlsYWJsZSBtYW51YWwgdmlld3BvcnQgc2NvcGVzXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0U2NvcGVzID0gb3duZWRTY29wZXMuZmlsdGVyKHNjb3BlID0+IHNjb3BlLmlzVmlld3BvcnRTY29wZSkubWFwKHNjb3BlID0+IHNjb3BlLnZpZXdwb3J0U2NvcGUpO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVWaWV3cG9ydFNjb3BlcyA9IHZpZXdwb3J0U2NvcGVzLmZpbHRlcih2aWV3cG9ydFNjb3BlID0+IGFscmVhZHlGb3VuZC5ldmVyeShmb3VuZCA9PiBmb3VuZC52aWV3cG9ydFNjb3BlICE9PSB2aWV3cG9ydFNjb3BlKSk7XG4gICAgICAgIC8vIEdldCBhIHNoYWxsb3cgY29weSBvZiBhbGwgYXZhaWxhYmxlIHZpZXdwb3J0c1xuICAgICAgICBjb25zdCBhdmFpbGFibGVWaWV3cG9ydHMgPSB7IC4uLnRoaXMuZ2V0RW5hYmxlZFZpZXdwb3J0cyhvd25lZFNjb3BlcykgfTtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBhbHJlYWR5Rm91bmQuZmlsdGVyKGZvdW5kID0+IGZvdW5kLnNjb3BlID09PSB0aGlzKSkge1xuICAgICAgICAgICAgYXZhaWxhYmxlVmlld3BvcnRzW2luc3RydWN0aW9uLnZpZXdwb3J0TmFtZV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zID0gbmV3IENvbGxlY3Rpb24oLi4uaW5zdHJ1Y3Rpb25zLnNsaWNlKCkpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgICAgICAvLyBUaGUgdmlld3BvcnQgc2NvcGUgaXMgYWxyZWFkeSBrbm93blxuICAgICAgICB3aGlsZSAoKGluc3RydWN0aW9uID0gdmlld3BvcnRJbnN0cnVjdGlvbnMubmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnZpZXdwb3J0U2NvcGUgIT09IG51bGwgJiYgIXRoaXMucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIuaXNBZGRWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5wdXNoKC4uLnRoaXMuZm91bmRWaWV3cG9ydFNjb3BlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlKSk7XG4gICAgICAgICAgICAgICAgZm91bmRWaWV3cG9ydHMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgYXJyYXlSZW1vdmUoYXZhaWxhYmxlVmlld3BvcnRTY29wZXMsIGF2YWlsYWJsZSA9PiBhdmFpbGFibGUgPT09IGluc3RydWN0aW9uLnZpZXdwb3J0U2NvcGUpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdmlld3BvcnQgaXMgYWxyZWFkeSBrbm93blxuICAgICAgICBpZiAoIWRpc3JlZ2FyZFZpZXdwb3J0cykge1xuICAgICAgICAgICAgd2hpbGUgKChpbnN0cnVjdGlvbiA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLm5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24udmlld3BvcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLnB1c2goLi4udGhpcy5mb3VuZFZpZXdwb3J0KGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbi52aWV3cG9ydCwgZGlzcmVnYXJkVmlld3BvcnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kVmlld3BvcnRzLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVWaWV3cG9ydHNbaW5zdHJ1Y3Rpb24udmlld3BvcnQubmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9ucy5yZW1vdmVDdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFZpZXdwb3J0IHNjb3BlcyBoYXZlIHByaW9yaXR5XG4gICAgICAgIHdoaWxlICgoaW5zdHJ1Y3Rpb24gPSB2aWV3cG9ydEluc3RydWN0aW9ucy5uZXh0KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3cG9ydFNjb3BlIG9mIHZpZXdwb3J0U2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0U2NvcGUuYWNjZXB0U2VnbWVudChpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2aWV3cG9ydFNjb3BlLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhdmFpbGFibGUnLCB2aWV3cG9ydFNjb3BlLmF2YWlsYWJsZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhdmFpbGFibGUgPSBhdmFpbGFibGVWaWV3cG9ydFNjb3Blcy5maW5kKGF2YWlsYWJsZSA9PiBhdmFpbGFibGUubmFtZSA9PT0gdmlld3BvcnRTY29wZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGUgPT09IHZvaWQgMCB8fCB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmlzQWRkVmlld3BvcnRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmlld3BvcnRTY29wZS5hZGRTb3VyY2VJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlID0gdGhpcy5nZXRPd25lZFNjb3BlcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoc2NvcGUgPT4gc2NvcGUuaXNWaWV3cG9ydFNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHNjb3BlID0+IHNjb3BlLnZpZXdwb3J0U2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHZpZXdwb3J0U2NvcGUgPT4gdmlld3BvcnRTY29wZS5zb3VyY2VJdGVtID09PSBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0U2NvcGUgPSBhdmFpbGFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLnB1c2goLi4udGhpcy5mb3VuZFZpZXdwb3J0U2NvcGUoaW5zdHJ1Y3Rpb24sIHZpZXdwb3J0U2NvcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRWaWV3cG9ydHMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5UmVtb3ZlKGF2YWlsYWJsZVZpZXdwb3J0U2NvcGVzLCBhdmFpbGFibGUgPT4gYXZhaWxhYmxlID09PSBpbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uZmlndXJlZCB2aWV3cG9ydCBpcyBydWxpbmdcbiAgICAgICAgd2hpbGUgKChpbnN0cnVjdGlvbiA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLm5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLm5lZWRzVmlld3BvcnREZXNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGF2YWlsYWJsZVZpZXdwb3J0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gYXZhaWxhYmxlVmlld3BvcnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFsc28gY2hlY2sgaWYgKHJlc29sdmVkKSBjb21wb25lbnQgd2FudHMgYSBzcGVjaWZpYyB2aWV3cG9ydFxuICAgICAgICAgICAgICAgIGlmICh2aWV3cG9ydD8ud2FudENvbXBvbmVudChpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmZvdW5kVmlld3BvcnQoaW5zdHJ1Y3Rpb24sIHZpZXdwb3J0LCBkaXNyZWdhcmRWaWV3cG9ydHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFZpZXdwb3J0cy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLnB1c2goLi4ucmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlVmlld3BvcnRzW25hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV4dCBpbiBsaW5lIGlzIHNwZWNpZmllZCB2aWV3cG9ydCAoYnV0IG5vdCBpZiB3ZSdyZSBkaXNyZWdhcmRpbmcgdmlld3BvcnRzKVxuICAgICAgICBpZiAoIWRpc3JlZ2FyZFZpZXdwb3J0cykge1xuICAgICAgICAgICAgd2hpbGUgKChpbnN0cnVjdGlvbiA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLm5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZSB8fCAhbmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3BlID0gaW5zdHJ1Y3Rpb24ub3duc1Njb3BlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRFbmFibGVkVmlld3BvcnRzKG93bmVkU2NvcGVzKVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTm8gbG9uZ2VyIHByZS1jcmVhdGluZyB2aWV3cG9ydHMuIEV2YWx1YXRlIVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZpZXdwb3J0KG5hbWUsIG51bGwsIHsgc2NvcGU6IG5ld1Njb3BlLCBmb3JjZURlc2NyaXB0aW9uOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVWaWV3cG9ydHNbbmFtZV0gPSB0aGlzLmdldEVuYWJsZWRWaWV3cG9ydHMob3duZWRTY29wZXMpW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGF2YWlsYWJsZVZpZXdwb3J0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnQ/LmFjY2VwdENvbXBvbmVudChpbnN0cnVjdGlvbi5jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmZvdW5kVmlld3BvcnQoaW5zdHJ1Y3Rpb24sIHZpZXdwb3J0LCBkaXNyZWdhcmRWaWV3cG9ydHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFZpZXdwb3J0cy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zLnB1c2goLi4ucmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlVmlld3BvcnRzW25hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBvbmx5IG9uZSBhY2NlcHRpbmcgdmlld3BvcnQgbGVmdD9cbiAgICAgICAgd2hpbGUgKChpbnN0cnVjdGlvbiA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLm5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1ZpZXdwb3J0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGF2YWlsYWJsZVZpZXdwb3J0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gYXZhaWxhYmxlVmlld3BvcnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3cG9ydD8uYWNjZXB0Q29tcG9uZW50KGluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ1ZpZXdwb3J0cy5wdXNoKHZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nVmlld3BvcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gcmVtYWluaW5nVmlld3BvcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5mb3VuZFZpZXdwb3J0KGluc3RydWN0aW9uLCB2aWV3cG9ydCwgZGlzcmVnYXJkVmlld3BvcnRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmb3VuZFZpZXdwb3J0cy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdJbnN0cnVjdGlvbnMucHVzaCguLi5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVZpZXdwb3J0c1t2aWV3cG9ydC5uYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbnMucmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGlnbm9yaW5nIHZpZXdwb3J0cywgd2Ugbm93IG1hdGNoIHRoZW0gYW55d2F5XG4gICAgICAgIGlmIChkaXNyZWdhcmRWaWV3cG9ydHMpIHtcbiAgICAgICAgICAgIHdoaWxlICgoaW5zdHJ1Y3Rpb24gPSB2aWV3cG9ydEluc3RydWN0aW9ucy5uZXh0KCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdwb3J0ID0gaW5zdHJ1Y3Rpb24udmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gaW5zdHJ1Y3Rpb24udmlld3BvcnROYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG5hbWU/Lmxlbmd0aCA/PyAwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBpbnN0cnVjdGlvbi5vd25zU2NvcGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRFbmFibGVkVmlld3BvcnRzKG93bmVkU2NvcGVzKVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBObyBsb25nZXIgcHJlLWNyZWF0aW5nIHZpZXdwb3J0cy4gRXZhbHVhdGUhXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZpZXdwb3J0KG5hbWUsIG51bGwsIHsgc2NvcGU6IG5ld1Njb3BlLCBmb3JjZURlc2NyaXB0aW9uOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlVmlld3BvcnRzW25hbWVdID0gdGhpcy5nZXRFbmFibGVkVmlld3BvcnRzKG93bmVkU2NvcGVzKVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IGF2YWlsYWJsZVZpZXdwb3J0c1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdwb3J0Py5hY2NlcHRDb21wb25lbnQoaW5zdHJ1Y3Rpb24uY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5mb3VuZFZpZXdwb3J0KGluc3RydWN0aW9uLCB2aWV3cG9ydCwgZGlzcmVnYXJkVmlld3BvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRWaWV3cG9ydHMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0luc3RydWN0aW9ucy5wdXNoKC4uLnJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVZpZXdwb3J0c1t2aWV3cG9ydC5uYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb25zLnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtYWluaW5nSW5zdHJ1Y3Rpb25zID0gWy4uLnZpZXdwb3J0SW5zdHJ1Y3Rpb25zLCAuLi5yZW1haW5pbmdJbnN0cnVjdGlvbnNdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm91bmRWaWV3cG9ydHMsXG4gICAgICAgICAgICByZW1haW5pbmdJbnN0cnVjdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvdW5kVmlld3BvcnRTY29wZShpbnN0cnVjdGlvbiwgdmlld3BvcnRTY29wZSkge1xuICAgICAgICBpbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlID0gdmlld3BvcnRTY29wZTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24ubmVlZHNWaWV3cG9ydERlc2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBpbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnM/LnNsaWNlKCkgPz8gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVtIG9mIHJlbWFpbmluZykge1xuICAgICAgICAgICAgaWYgKHJlbS5zY29wZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbS5zY29wZSA9IHZpZXdwb3J0U2NvcGUuc2NvcGUuc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICB9XG4gICAgZm91bmRWaWV3cG9ydChpbnN0cnVjdGlvbiwgdmlld3BvcnQsIHdpdGhvdXRWaWV3cG9ydHMsIGRvZXNudE5lZWRWaWV3cG9ydERlc2NyaWJlZCA9IGZhbHNlKSB7XG4gICAgICAgIGluc3RydWN0aW9uLnNldFZpZXdwb3J0KHZpZXdwb3J0KTtcbiAgICAgICAgaWYgKGRvZXNudE5lZWRWaWV3cG9ydERlc2NyaWJlZCkge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ubmVlZHNWaWV3cG9ydERlc2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucz8uc2xpY2UoKSA/PyBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZW0gb2YgcmVtYWluaW5nKSB7XG4gICAgICAgICAgICBpZiAocmVtLnNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVtLnNjb3BlID0gdmlld3BvcnQuc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICB9XG4gICAgYWRkVmlld3BvcnQobmFtZSwgY29ubmVjdGVkQ0UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdmlld3BvcnQgPSB0aGlzLmdldEVuYWJsZWRWaWV3cG9ydHModGhpcy5nZXRPd25lZFNjb3BlcygpKVtuYW1lXTtcbiAgICAgICAgLy8gRWFjaCBhdS12aWV3cG9ydCBlbGVtZW50IGhhcyBpdHMgb3duIFZpZXdwb3J0XG4gICAgICAgIGlmICgoKGNvbm5lY3RlZENFID8/IG51bGwpICE9PSBudWxsKSAmJlxuICAgICAgICAgICAgKCh2aWV3cG9ydD8uY29ubmVjdGVkQ0UgPz8gbnVsbCkgIT09IG51bGwpICYmXG4gICAgICAgICAgICB2aWV3cG9ydC5jb25uZWN0ZWRDRSAhPT0gY29ubmVjdGVkQ0UpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0LmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5nZXRPd25lZFZpZXdwb3J0cyh0cnVlKS5maW5kKGNoaWxkID0+IGNoaWxkLm5hbWUgPT09IG5hbWUgJiYgY2hpbGQuY29ubmVjdGVkQ0UgPT09IGNvbm5lY3RlZENFKSA/PyBudWxsO1xuICAgICAgICAgICAgaWYgKCh2aWV3cG9ydCA/PyBudWxsKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgodmlld3BvcnQgPz8gbnVsbCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KHRoaXMucm91dGVyLCBuYW1lLCBjb25uZWN0ZWRDRSwgdGhpcy5zY29wZSwgISFvcHRpb25zLnNjb3BlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodmlld3BvcnQuY29ubmVjdGVkU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY29ubmVjdGVkQ0UgPz8gbnVsbCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0LnNldENvbm5lY3RlZENFKGNvbm5lY3RlZENFLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIHJlbW92ZVZpZXdwb3J0KHZpZXdwb3J0LCBjb25uZWN0ZWRDRSkge1xuICAgICAgICBpZiAoKChjb25uZWN0ZWRDRSA/PyBudWxsKSAhPT0gbnVsbCkgfHwgdmlld3BvcnQucmVtb3ZlKGNvbm5lY3RlZENFKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh2aWV3cG9ydC5jb25uZWN0ZWRTY29wZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFkZFZpZXdwb3J0U2NvcGUobmFtZSwgY29ubmVjdGVkQ0UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB2aWV3cG9ydFNjb3BlID0gbmV3IFZpZXdwb3J0U2NvcGUobmFtZSwgdGhpcy5yb3V0ZXIsIGNvbm5lY3RlZENFLCB0aGlzLnNjb3BlLCB0cnVlLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh2aWV3cG9ydFNjb3BlLmNvbm5lY3RlZFNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0U2NvcGU7XG4gICAgfVxuICAgIHJlbW92ZVZpZXdwb3J0U2NvcGUodmlld3BvcnRTY29wZSkge1xuICAgICAgICAvLyB2aWV3cG9ydFNjb3BlLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHZpZXdwb3J0U2NvcGUuY29ubmVjdGVkU2NvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWRkQ2hpbGQoc2NvcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLnNvbWUodnAgPT4gdnAgPT09IHNjb3BlKSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLnBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNjb3BlLnBhcmVudC5yZW1vdmVDaGlsZChzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goc2NvcGUpO1xuICAgICAgICAgICAgc2NvcGUucGFyZW50ID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDaGlsZChzY29wZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihzY29wZSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBzY29wZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyUmVwbGFjZWRDaGlsZHJlbigpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlZENoaWxkcmVuID0gW107XG4gICAgfVxuICAgIGRpc2FibGVSZXBsYWNlZENoaWxkcmVuKCkge1xuICAgICAgICB0aGlzLnJlcGxhY2VkQ2hpbGRyZW4gPSB0aGlzLmVuYWJsZWRDaGlsZHJlbjtcbiAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiB0aGlzLnJlcGxhY2VkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHNjb3BlLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWVuYWJsZVJlcGxhY2VkQ2hpbGRyZW4oKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgdGhpcy5yZXBsYWNlZENoaWxkcmVuKSB7XG4gICAgICAgICAgICBzY29wZS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGxWaWV3cG9ydHMoaW5jbHVkZURpc2FibGVkID0gZmFsc2UsIGluY2x1ZGVSZXBsYWNlZCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFNjb3BlcyhpbmNsdWRlRGlzYWJsZWQsIGluY2x1ZGVSZXBsYWNlZCkuZmlsdGVyKHNjb3BlID0+IHNjb3BlLmlzVmlld3BvcnQpLm1hcChzY29wZSA9PiBzY29wZS52aWV3cG9ydCk7XG4gICAgfVxuICAgIGFsbFNjb3BlcyhpbmNsdWRlRGlzYWJsZWQgPSBmYWxzZSwgaW5jbHVkZVJlcGxhY2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gaW5jbHVkZURpc2FibGVkID8gdGhpcy5jaGlsZHJlbi5zbGljZSgpIDogdGhpcy5lbmFibGVkQ2hpbGRyZW47XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzLnNsaWNlKCkpIHtcbiAgICAgICAgICAgIHNjb3Blcy5wdXNoKC4uLnNjb3BlLmFsbFNjb3BlcyhpbmNsdWRlRGlzYWJsZWQsIGluY2x1ZGVSZXBsYWNlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZXM7XG4gICAgfVxuICAgIHJlcGFyZW50Vmlld3BvcnRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuaG9pc3RlZENoaWxkcmVuXG4gICAgICAgICAgICAuZmlsdGVyKHNjb3BlID0+IHNjb3BlLnZpZXdwb3J0SW5zdHJ1Y3Rpb24gIT09IG51bGwgJiYgc2NvcGUudmlld3BvcnRJbnN0cnVjdGlvbi5jb21wb25lbnROYW1lKTtcbiAgICAgICAgaWYgKCFzY29wZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRJbnN0cnVjdGlvbnMgPSBzY29wZS5yZXBhcmVudFZpZXdwb3J0SW5zdHJ1Y3Rpb25zKCk7XG4gICAgICAgICAgICBzY29wZS52aWV3cG9ydEluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucyA9XG4gICAgICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbnMgIT09IG51bGwgJiYgY2hpbGRJbnN0cnVjdGlvbnMubGVuZ3RoID4gMCA/IGNoaWxkSW5zdHJ1Y3Rpb25zIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVzLm1hcChzY29wZSA9PiBzY29wZS52aWV3cG9ydEluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgZmluZE1hdGNoaW5nUm91dGUocGF0aCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdwb3J0U2NvcGUgJiYgIXRoaXMucGFzc1Rocm91Z2hTY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZE1hdGNoaW5nUm91dGVJblJvdXRlcyhwYXRoLCB0aGlzLnZpZXdwb3J0U2NvcGUuZ2V0Um91dGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVmlld3BvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRNYXRjaGluZ1JvdXRlSW5Sb3V0ZXMocGF0aCwgdGhpcy52aWV3cG9ydC5nZXRSb3V0ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogTWF0Y2ggc3BlY2lmaWVkIG5hbWVzIGhlcmVcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVuYWJsZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgZm91bmQgPSBjaGlsZC5maW5kTWF0Y2hpbmdSb3V0ZShwYXRoKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2FuTG9hZChyZWN1cnNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBSdW5uZXIucnVuQWxsKHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpZXdwb3J0ICE9PSBudWxsXG4gICAgICAgICAgICA/IGNoaWxkLnZpZXdwb3J0LmNhbkxvYWQocmVjdXJzZSlcbiAgICAgICAgICAgIDogY2hpbGQuY2FuTG9hZChyZWN1cnNlKSkpO1xuICAgICAgICBpZiAocmVzdWx0cyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLnRoZW4ocmVzb2x2ZWRSZXN1bHRzID0+IHJlc29sdmVkUmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHMuZXZlcnkocmVzdWx0ID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIGNhblVubG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFJ1bm5lci5ydW5BbGwodGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlld3BvcnQgIT09IG51bGxcbiAgICAgICAgICAgID8gY2hpbGQudmlld3BvcnQuY2FuVW5sb2FkKClcbiAgICAgICAgICAgIDogY2hpbGQuY2FuVW5sb2FkKCkpKTtcbiAgICAgICAgaWYgKHJlc3VsdHMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cy50aGVuKHJlc29sdmVkUmVzdWx0cyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkUmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBsb2FkKHJlY3Vyc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFJ1bm5lci5ydW5BbGwodGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlld3BvcnQgIT09IG51bGxcbiAgICAgICAgICAgID8gY2hpbGQudmlld3BvcnQubG9hZChyZWN1cnNlKVxuICAgICAgICAgICAgOiBjaGlsZC5sb2FkKHJlY3Vyc2UpKSk7XG4gICAgICAgIGlmIChyZXN1bHRzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5sb2FkKHJlY3Vyc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFJ1bm5lci5ydW5BbGwodGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlld3BvcnQgIT09IG51bGxcbiAgICAgICAgICAgID8gY2hpbGQudmlld3BvcnQudW5sb2FkKHJlY3Vyc2UpXG4gICAgICAgICAgICA6IGNoaWxkLnVubG9hZChyZWN1cnNlKSkpO1xuICAgICAgICBpZiAocmVzdWx0cyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNvbnRlbnQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBSdW5uZXIucnVuQWxsKHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpZXdwb3J0ICE9PSBudWxsXG4gICAgICAgICAgICA/IGNoaWxkLnZpZXdwb3J0LnJlbW92ZUNvbnRlbnQoKVxuICAgICAgICAgICAgOiBjaGlsZC5yZW1vdmVDb250ZW50KCkpKTtcbiAgICAgICAgaWYgKHJlc3VsdHMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTWF0Y2hpbmdSb3V0ZUluUm91dGVzKHBhdGgsIHJvdXRlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcm91dGVzID0gcm91dGVzLm1hcChyb3V0ZSA9PiB0aGlzLmVuc3VyZVByb3BlclJvdXRlKHJvdXRlKSk7XG4gICAgICAgIGNvbnN0IGNSb3V0ZXMgPSByb3V0ZXMubWFwKHJvdXRlID0+ICh7XG4gICAgICAgICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgICAgICAgaGFuZGxlcjogcm91dGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY1JvdXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjUm91dGUgPSBjUm91dGVzW2ldO1xuICAgICAgICAgICAgY1JvdXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5jUm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aDogYCR7Y1JvdXRlLnBhdGh9LypyZW1haW5pbmdQYXRoYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvdW5kID0gbmV3IEZvdW5kUm91dGUoKTtcbiAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWNvZ25pemVyID0gbmV3IFJvdXRlUmVjb2duaXplcigpO1xuICAgICAgICByZWNvZ25pemVyLmFkZChjUm91dGVzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVjb2duaXplci5yZWNvZ25pemUocGF0aCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvdW5kLm1hdGNoID0gcmVzdWx0LmVuZHBvaW50LnJvdXRlLmhhbmRsZXI7XG4gICAgICAgICAgICBmb3VuZC5tYXRjaGluZyA9IHBhdGg7XG4gICAgICAgICAgICBjb25zdCAkcGFyYW1zID0geyAuLi5yZXN1bHQucGFyYW1zIH07XG4gICAgICAgICAgICBpZiAoJHBhcmFtcy5yZW1haW5pbmdQYXRoICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBmb3VuZC5yZW1haW5pbmcgPSAkcGFyYW1zLnJlbWFpbmluZ1BhdGg7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSgkcGFyYW1zLCAncmVtYWluaW5nUGF0aCcpO1xuICAgICAgICAgICAgICAgIGZvdW5kLm1hdGNoaW5nID0gZm91bmQubWF0Y2hpbmcuc2xpY2UoMCwgZm91bmQubWF0Y2hpbmcuaW5kZXhPZihmb3VuZC5yZW1haW5pbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kLnBhcmFtcyA9ICRwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kLmZvdW5kQ29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgLy8gY2xvbmUgaXQgc28gY29uZmlnIGRvZXNuJ3QgZ2V0IG1vZGlmaWVkXG4gICAgICAgICAgICBmb3VuZC5pbnN0cnVjdGlvbnMgPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmNsb25lVmlld3BvcnRJbnN0cnVjdGlvbnMoZm91bmQubWF0Y2guaW5zdHJ1Y3Rpb25zLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBmb3VuZC5pbnN0cnVjdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHdoaWxlIChpbnN0cnVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYWRkUGFyYW1ldGVycyhmb3VuZC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnJvdXRlID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMudW5zaGlmdCguLi5pbnN0cnVjdGlvbi5uZXh0U2NvcGVJbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZC5pbnN0cnVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvdW5kLmluc3RydWN0aW9uc1swXS5yb3V0ZSA9IGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgZW5zdXJlUHJvcGVyUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKHJvdXRlLmlkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJvdXRlLmlkID0gcm91dGUucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUuaW5zdHJ1Y3Rpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJvdXRlLmluc3RydWN0aW9ucyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogcm91dGUuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydDogcm91dGUudmlld3BvcnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHJvdXRlLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICByb3V0ZS5pbnN0cnVjdGlvbnMgPSBOYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25SZXNvbHZlci50b1ZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMucm91dGVyLCByb3V0ZS5pbnN0cnVjdGlvbnMpO1xuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiaW1wb3J0IHsgT3BlblByb21pc2UgfSBmcm9tICcuL29wZW4tcHJvbWlzZS5qcyc7XG5leHBvcnQgY2xhc3MgRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHkpIHtcbiAgICAgICAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoZWNrZWRTdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNQcm9taXNlID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RhdGVDb29yZGluYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW50aXRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oYXNBbGxFbnRpdGllcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2hlY2tlZFN5bmNTdGF0ZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihASUxvZ2dlciBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlcjogSUxvZ2dlcikge1xuICAgIC8vICAgdGhpcy5sb2dnZXIgPSBsb2dnZXIucm9vdC5zY29wZVRvKCdTdGF0ZUNvb3JkaW5hdG9yJyk7XG4gICAgLy8gICB0aGlzLmxvZ2dlci50cmFjZSgnY29uc3RydWN0b3IoKScpO1xuICAgIC8vIH1cbiAgICBhZGRTeW5jU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgb3BlblByb21pc2UgPSBuZXcgT3BlblByb21pc2UoKTtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVzLnNldChzdGF0ZSwgb3BlblByb21pc2UpO1xuICAgIH1cbiAgICBhZGRFbnRpdHkoZW50aXR5KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdFbnRpdHkgcmVjZWl2ZWQnLCBlbnRpdHkpO1xuICAgICAgICBjb25zdCBlbnQgPSBuZXcgRW50aXR5KGVudGl0eSk7XG4gICAgICAgIHRoaXMuZW50aXRpZXMucHVzaChlbnQpO1xuICAgICAgICB0aGlzLnJlc2V0U3luY1N0YXRlcygpO1xuICAgICAgICByZXR1cm4gZW50O1xuICAgIH1cbiAgICBhZGRFbnRpdHlTdGF0ZShlbnRpdHksIHN0YXRlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAjIyMjIEVudGl0eVN0YXRlIHJlY2VpdmVkICR7c3RhdGV9YCwgKGVudGl0eSBhcyBhbnkpLm5hbWUpO1xuICAgICAgICBsZXQgZW50ID0gdGhpcy5lbnRpdGllcy5maW5kKGUgPT4gZS5lbnRpdHkgPT09IGVudGl0eSk7XG4gICAgICAgIGlmIChlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZW50ID0gdGhpcy5hZGRFbnRpdHkoZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbnQuc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgICB0aGlzLmNoZWNrU3luY1N0YXRlKHN0YXRlKTtcbiAgICB9XG4gICAgc3luY1N0YXRlKHN0YXRlLCBlbnRpdHkgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gdGhpcy5zeW5jU3RhdGVzLmdldChzdGF0ZSk7XG4gICAgICAgIGlmIChvcGVuUHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZW50ID0gdGhpcy5lbnRpdGllcy5maW5kKGUgPT4gZS5lbnRpdHkgPT09IGVudGl0eSk7XG4gICAgICAgICAgICBpZiAoZW50Py5zeW5jUHJvbWlzZSA9PT0gbnVsbCAmJiBvcGVuUHJvbWlzZS5pc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBlbnQuc3luY1N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgZW50LnN5bmNQcm9taXNlID0gbmV3IE9wZW5Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgZW50LmNoZWNrZWRTdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkU3luY1N0YXRlcy5hZGQoc3RhdGUpO1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4geyB0aGlzLmNoZWNrU3luY1N0YXRlKHN0YXRlKTsgfSkuY2F0Y2goZXJyID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50LnN5bmNQcm9taXNlLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5jaGVja1N5bmNTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBvcGVuUHJvbWlzZS5wcm9taXNlO1xuICAgIH1cbiAgICBjaGVja2luZ1N5bmNTdGF0ZShzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jU3RhdGVzLmhhcyhzdGF0ZSk7XG4gICAgfVxuICAgIGZpbmFsRW50aXR5KCkge1xuICAgICAgICB0aGlzLmhhc0FsbEVudGl0aWVzID0gdHJ1ZTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZpbmFsIGVudGl0eSByZWNlaXZlZCcsIHRoaXMuZW50aXRpZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVzLmZvckVhY2goKF9wcm9taXNlLCBzdGF0ZSkgPT4gdGhpcy5jaGVja1N5bmNTdGF0ZShzdGF0ZSkpO1xuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHsgfVxuICAgIGNhbmNlbCgpIHsgfVxuICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gc2hvdWxkIGNhbmNlbCByZXBsYWNlZCBpbnN0cnVjdGlvbnNcbiAgICBjYW5jZWxSZXBsYWNlZChuYXZpZ2F0aW9uKSB7IH1cbiAgICBjaGVja1N5bmNTdGF0ZShzdGF0ZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnU3RhdGVDb29yZGluYXRvciBjaGVjayBzdGF0ZScsIHN0YXRlLCB0aGlzKTtcbiAgICAgICAgY29uc3Qgb3BlblByb21pc2UgPSB0aGlzLnN5bmNTdGF0ZXMuZ2V0KHN0YXRlKTtcbiAgICAgICAgaWYgKG9wZW5Qcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNBbGxFbnRpdGllcyAmJlxuICAgICAgICAgICAgb3BlblByb21pc2UuaXNQZW5kaW5nICYmXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgc3RhdGUgaGFzIGJlZW4gZG9uZSBieSBhbGwgc3RhdGUgZW50aXRpZXMgYW5kIGlmIHNvIHJlc29sdmUgdGhlIHByb21pc2VcbiAgICAgICAgICAgIHRoaXMuZW50aXRpZXMuZXZlcnkoZW50ID0+IGVudC5zdGF0ZXMuaW5jbHVkZXMoc3RhdGUpKSAmJlxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIHN0YXRlIGhhcyBiZWVuIGNoZWNrZWQgKHJlYWNoZWQpIGJ5IGFsbCBzdGF0ZSBlbnRpdGllcyBhbmQgaWYgc28gcmVzb2x2ZSB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgKCF0aGlzLmNoZWNrZWRTeW5jU3RhdGVzLmhhcyhzdGF0ZSkgfHwgdGhpcy5lbnRpdGllcy5ldmVyeShlbnQgPT4gZW50LmNoZWNrZWRTdGF0ZXMuaW5jbHVkZXMoc3RhdGUpKSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5LnN5bmNTdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1Jlc29sdmluZyBlbnRpdHkgcHJvbWlzZSBmb3IgJywgc3RhdGUsIChlbnRpdHkuZW50aXR5IGFzIGFueSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5zeW5jUHJvbWlzZT8ucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuc3luY1Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuc3luY1N0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnIyMjIyBTdGF0ZUNvb3JkaW5hdG9yIHN0YXRlIHJlc29sdmVkJywgc3RhdGUgLyosIHRoaXMgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0U3luY1N0YXRlcygpIHtcbiAgICAgICAgdGhpcy5zeW5jU3RhdGVzLmZvckVhY2goKHByb21pc2UsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXByb21pc2UuaXNQZW5kaW5nICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuZW50aXRpZXMuZXZlcnkoZW50aXR5ID0+IGVudGl0eS5zdGF0ZXMuaW5jbHVkZXMoc3RhdGUpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3luY1N0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUtY29vcmRpbmF0b3IuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgYm91bmQgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuLyoqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuICovXG5leHBvcnQgY2xhc3MgUXVldWVUYXNrIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXNrUXVldWUsIGl0ZW0sIGNvc3QgPSAwKSB7XG4gICAgICAgIHRoaXMudGFza1F1ZXVlID0gdGFza1F1ZXVlO1xuICAgICAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgICAgICB0aGlzLmNvc3QgPSBjb3N0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLnJlc29sdmUodGhpcywgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXNrUXVldWUucmVqZWN0KHRoaXMsIHJlamVjdCwgcmVhc29uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlKCkge1xuICAgICAgICBpZiAoJ2V4ZWN1dGUnIGluIHRoaXMuaXRlbSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pdGVtLmV4ZWN1dGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLml0ZW0odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FpdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG59XG4vKipcbiAqIEEgZmlyc3QtaW4tZmlyc3Qtb3V0IHRhc2sgcXVldWUgdGhhdCBvbmx5IHByb2Nlc3NlcyB0aGUgbmV4dCBxdWV1ZWQgaXRlbVxuICogd2hlbiB0aGUgY3VycmVudCBvbmUgaGFzIGJlZW4gcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuIElmIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIGlzIHNwZWNpZmllZCwgaXQgcmVjZWl2ZXMgdGhlIHF1ZXVlZCBpdGVtcyBhcyB0YXNrcyBvbmUgYXQgYSB0aW1lLiBJZiBub1xuICogY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCB0aGUgdGFza3MgdGhlbXNlbHZlcyBhcmUgZWl0aGVyIGV4ZWN1dGVkIChpZiBhXG4gKiBmdW5jdGlvbikgb3IgdGhlIGV4ZWN1dGUgbWV0aG9kIGluIHRoZW0gYXJlIHJ1bi4gVGhlIGV4ZWN1dGVkIGZ1bmN0aW9uXG4gKiBzaG91bGQgcmVzb2x2ZSBvciByZWplY3QgdGhlIHRhc2sgd2hlbiBwcm9jZXNzaW5nIGlzIGRvbmUuXG4gKiBFbnF1ZXVlZCBpdGVtcycgdGFza3MgY2FuIGJlIGF3YWl0ZWQuIEVucXVldWVkIGl0ZW1zIGNhbiBzcGVjaWZ5IGFuXG4gKiAoYXJiaXRyYXJ5KSBleGVjdXRpb24gY29zdCBhbmQgdGhlIHF1ZXVlIGNhbiBiZSBzZXQgdXAgKHN0YXJ0ZWQpIHRvXG4gKiBvbmx5IHByb2Nlc3MgYSBzcGVjaWZpYyBhbW91bnQgb2YgZXhlY3V0aW9uIGNvc3QgcGVyIFJBRi90aWNrLlxuICpcbiAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5LlxuICovXG5leHBvcnQgY2xhc3MgVGFza1F1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IFtdO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudEV4ZWN1dGlvbkNvc3RJbkN1cnJlbnRUaWNrID0gMDtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFzayAhPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZy5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFza1F1ZXVlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBvcHRpb25zLnBsYXRmb3JtO1xuICAgICAgICB0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayA9IG9wdGlvbnMuYWxsb3dlZEV4ZWN1dGlvbkNvc3RXaXRoaW5UaWNrO1xuICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLnBsYXRmb3JtLmRvbVdyaXRlUXVldWUucXVldWVUYXNrKHRoaXMuZGVxdWV1ZSwgeyBwZXJzaXN0ZW50OiB0cnVlIH0pO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFza1F1ZXVlIGhhcyBub3QgYmVlbiBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXNrLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG4gICAgZW5xdWV1ZShpdGVtT3JJdGVtcywgY29zdE9yQ29zdHMpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkoaXRlbU9ySXRlbXMpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IChsaXN0ID8gaXRlbU9ySXRlbXMgOiBbaXRlbU9ySXRlbXNdKTtcbiAgICAgICAgY29uc3QgY29zdHMgPSBpdGVtc1xuICAgICAgICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiAhQXJyYXkuaXNBcnJheShjb3N0T3JDb3N0cykgPyBjb3N0T3JDb3N0cyA6IGNvc3RPckNvc3RzW2luZGV4XSlcbiAgICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiAxKTtcbiAgICAgICAgY29uc3QgdGFza3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICB0YXNrcy5wdXNoKGl0ZW0gaW5zdGFuY2VvZiBRdWV1ZVRhc2tcbiAgICAgICAgICAgICAgICA/IGl0ZW1cbiAgICAgICAgICAgICAgICA6IHRoaXMuY3JlYXRlUXVldWVUYXNrKGl0ZW0sIGNvc3RzLnNoaWZ0KCkpKTsgLy8gVE9ETzogR2V0IGNhbmNlbGxhYmxlIGluIGFzIHdlbGxcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmcucHVzaCguLi50YXNrcyk7XG4gICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICByZXR1cm4gbGlzdCA/IHRhc2tzIDogdGFza3NbMF07XG4gICAgfVxuICAgIGNyZWF0ZVF1ZXVlVGFzayhpdGVtLCBjb3N0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVldWVUYXNrKHRoaXMsIGl0ZW0sIGNvc3QpO1xuICAgIH1cbiAgICBkZXF1ZXVlKGRlbHRhKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RXhlY3V0aW9uQ29zdEluQ3VycmVudFRpY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRFeGVjdXRpb25Db3N0V2l0aGluVGljayAhPT0gbnVsbCAmJiBkZWx0YSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuY3VycmVudEV4ZWN1dGlvbkNvc3RJbkN1cnJlbnRUaWNrICsgKHRoaXMucGVuZGluZ1swXS5jb3N0IHx8IDApID4gdGhpcy5hbGxvd2VkRXhlY3V0aW9uQ29zdFdpdGhpblRpY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSB0aGlzLnBlbmRpbmcuc2hpZnQoKSB8fCBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRFeGVjdXRpb25Db3N0SW5DdXJyZW50VGljayArPSB0aGlzLnByb2Nlc3NpbmcuY29zdCA/PyAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5wcm9jZXNzaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IG5lZWQgdG8gYXdhaXQgdGhpcyBzaW5jZSBuZXh0IHRhc2sgd29uJ3QgYmUgZGVxdWV1ZWQgdW50aWxcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlZCBmdW5jdGlvbiBpcyByZXNvbHZlZFxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5leGVjdXRlKCkuY2F0Y2goZXJyb3IgPT4geyB0aHJvdyBlcnJvcjsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZy5zcGxpY2UoMCwgdGhpcy5wZW5kaW5nLmxlbmd0aCk7XG4gICAgfVxuICAgIHJlc29sdmUodGFzaywgcmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH1cbiAgICByZWplY3QodGFzaywgcmVqZWN0LCByZWFzb24pIHtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIGJvdW5kXG5dLCBUYXNrUXVldWUucHJvdG90eXBlLCBcImRlcXVldWVcIiwgbnVsbCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXNrLXF1ZXVlLmpzLm1hcCIsImltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgVmlld3BvcnQgfSBmcm9tICcuL3ZpZXdwb3J0LmpzJztcbmltcG9ydCB7IFZpZXdwb3J0SW5zdHJ1Y3Rpb24gfSBmcm9tICcuL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzJztcbmV4cG9ydCBjb25zdCBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyID0ge1xuICAgIGlzTmFtZShjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnO1xuICAgIH0sXG4gICAgaXNUeXBlKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gQ3VzdG9tRWxlbWVudC5pc1R5cGUoY29tcG9uZW50KTtcbiAgICB9LFxuICAgIGlzSW5zdGFuY2UoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAhQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc05hbWUoY29tcG9uZW50KSAmJiAhQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc1R5cGUoY29tcG9uZW50KTtcbiAgICB9LFxuICAgIGdldE5hbWUoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmlzTmFtZShjb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNUeXBlKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBDdXN0b21FbGVtZW50LmdldERlZmluaXRpb24oY29tcG9uZW50KS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0TmFtZShjb21wb25lbnQuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRUeXBlKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc05hbWUoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc1R5cGUoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQuY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEluc3RhbmNlKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5pc05hbWUoY29tcG9uZW50KSB8fCBDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmlzVHlwZShjb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBWaWV3cG9ydEhhbmRsZVJlc29sdmVyID0ge1xuICAgIGlzTmFtZSh2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZpZXdwb3J0ID09PSAnc3RyaW5nJztcbiAgICB9LFxuICAgIGlzSW5zdGFuY2Uodmlld3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQ7XG4gICAgfSxcbiAgICBnZXROYW1lKHZpZXdwb3J0KSB7XG4gICAgICAgIGlmIChWaWV3cG9ydEhhbmRsZVJlc29sdmVyLmlzTmFtZSh2aWV3cG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3cG9ydCA/ICh2aWV3cG9ydCkubmFtZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEluc3RhbmNlKHZpZXdwb3J0KSB7XG4gICAgICAgIGlmIChWaWV3cG9ydEhhbmRsZVJlc29sdmVyLmlzTmFtZSh2aWV3cG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgTmF2aWdhdGlvbkluc3RydWN0aW9uUmVzb2x2ZXIgPSB7XG4gICAgY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbnMocm91dGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgc2NvcGUgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgICBzY29wZSA9IHJvdXRlci5maW5kU2NvcGUob3B0aW9ucy5jb250ZXh0KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdGlvbkluc3RydWN0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCBmcm9tIHNjb3BlIHJvb3QsIGZpZ3VyZSBvdXQgd2hpY2ggc2NvcGVcbiAgICAgICAgICAgICAgICBpZiAoIW5hdmlnYXRpb25JbnN0cnVjdGlvbnMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjb3BlIG1vZGlmaWNhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25JbnN0cnVjdGlvbnMuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2FtZSBhcyBubyBzY29wZSBtb2RpZmljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zID0gbmF2aWdhdGlvbkluc3RydWN0aW9ucy5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgb3V0IGhvdyBtYW55IHNjb3BlcyB1cHdhcmRzIHdlIHNob3VsZCBtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmF2aWdhdGlvbkluc3RydWN0aW9ucy5zdGFydHNXaXRoKCcuLi8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50IHx8IHNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JbnN0cnVjdGlvbnMgPSBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zLnNsaWNlKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5wYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zID0gYCR7c2NvcGUucGF0aH0vJHtuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHJvdXRlci5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIFNwZWNpZmllZCByb290IHNjb3BlIHdpdGggL1xuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHJvdXRlci5yb290U2NvcGUuc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkluc3RydWN0aW9ucyA9IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyLnRvVmlld3BvcnRJbnN0cnVjdGlvbnMocm91dGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIG5hdmlnYXRpb25JbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnNjb3BlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnM6IG5hdmlnYXRpb25JbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvVmlld3BvcnRJbnN0cnVjdGlvbnMocm91dGVyLCBuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShuYXZpZ2F0aW9uSW5zdHJ1Y3Rpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyLnRvVmlld3BvcnRJbnN0cnVjdGlvbnMocm91dGVyLCBbbmF2aWdhdGlvbkluc3RydWN0aW9uc10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIG5hdmlnYXRpb25JbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goLi4ucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIucGFyc2VWaWV3cG9ydEluc3RydWN0aW9ucyhpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gaW5zdGFuY2VvZiBWaWV3cG9ydEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRDb21wb25lbnQgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbnN0cnVjdGlvbiA9IHJvdXRlci5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKHZpZXdwb3J0Q29tcG9uZW50LmNvbXBvbmVudCwgdmlld3BvcnRDb21wb25lbnQudmlld3BvcnQsIHZpZXdwb3J0Q29tcG9uZW50LnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3cG9ydENvbXBvbmVudC5jaGlsZHJlbiAhPT0gdm9pZCAwICYmIHZpZXdwb3J0Q29tcG9uZW50LmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0luc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucyA9IE5hdmlnYXRpb25JbnN0cnVjdGlvblJlc29sdmVyLnRvVmlld3BvcnRJbnN0cnVjdGlvbnMocm91dGVyLCB2aWV3cG9ydENvbXBvbmVudC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKG5ld0luc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKHJvdXRlci5jcmVhdGVWaWV3cG9ydEluc3RydWN0aW9uKGluc3RydWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGUtcmVzb2x2ZXJzLmpzLm1hcCIsIi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5UmVtb3ZlKGFyciwgZnVuYykge1xuICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICBsZXQgYXJySW5kZXggPSBhcnIuZmluZEluZGV4KGZ1bmMpO1xuICAgIHdoaWxlIChhcnJJbmRleCA+PSAwKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaChhcnIuc3BsaWNlKGFyckluZGV4LCAxKVswXSk7XG4gICAgICAgIGFyckluZGV4ID0gYXJyLmZpbmRJbmRleChmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBvc3NpYmxlUHJvbWlzZSh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAvLyBJZiB3ZSd2ZSBnb3QgYSBQcm9taXNlLCB3YWl0IGZvciBpdCdzIHJlc29sdmVcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50aGVuKChyZXNvbHZlZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc29sdmVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGlvbldhcm5pbmcob2xkRmVhdHVyZSwgbmV3RmVhdHVyZSkge1xuICAgIGNvbnNvbGUud2FybihgW0RlcHJlY2F0ZWRdIFRoZSAke29sZEZlYXR1cmV9IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlICR7bmV3RmVhdHVyZX0gaW5zdGVhZC5gKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgcGFyc2VRdWVyeSB9IGZyb20gJy4vcGFyc2VyLmpzJztcbmltcG9ydCB7IFZpZXdwb3J0SW5zdHJ1Y3Rpb24gfSBmcm9tICcuL3ZpZXdwb3J0LWluc3RydWN0aW9uLmpzJztcbmltcG9ydCB7IE5hdmlnYXRpb24gfSBmcm9tICcuL25hdmlnYXRpb24uanMnO1xuaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnLi9ydW5uZXIuanMnO1xuaW1wb3J0IHsgQXdhaXRhYmxlTWFwIH0gZnJvbSAnLi9hd2FpdGFibGUtbWFwLmpzJztcbi8qKlxuICogQGludGVybmFsIC0gU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcbiAqL1xuZXhwb3J0IHZhciBDb250ZW50U3RhdHVzO1xuKGZ1bmN0aW9uIChDb250ZW50U3RhdHVzKSB7XG4gICAgQ29udGVudFN0YXR1c1tDb250ZW50U3RhdHVzW1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgQ29udGVudFN0YXR1c1tDb250ZW50U3RhdHVzW1wiY3JlYXRlZFwiXSA9IDFdID0gXCJjcmVhdGVkXCI7XG4gICAgQ29udGVudFN0YXR1c1tDb250ZW50U3RhdHVzW1wiYWN0aXZhdGVkXCJdID0gM10gPSBcImFjdGl2YXRlZFwiO1xufSkoQ29udGVudFN0YXR1cyB8fCAoQ29udGVudFN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbCAtIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG4gKi9cbmV4cG9ydCBjbGFzcyBWaWV3cG9ydENvbnRlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIENhbiAoYW5kIHdhbnRzKSBiZSBhIChyZXNvbHZlZCkgdHlwZSBvciBhIHN0cmluZyAodG8gYmUgcmVzb2x2ZWQgbGF0ZXIpXG4gICAgLy8gcHVibGljIGNvbnRlbnQ6IFZpZXdwb3J0SW5zdHJ1Y3Rpb24gPSBuZXcgVmlld3BvcnRJbnN0cnVjdGlvbignJyksXG4gICAgY29udGVudCA9IFZpZXdwb3J0SW5zdHJ1Y3Rpb24uY3JlYXRlKG51bGwsICcnKSwgaW5zdHJ1Y3Rpb24gPSBuZXcgTmF2aWdhdGlvbih7XG4gICAgICAgIGluc3RydWN0aW9uOiAnJyxcbiAgICAgICAgZnVsbFN0YXRlSW5zdHJ1Y3Rpb246ICcnLFxuICAgIH0pLCBjb25uZWN0ZWRDRSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAvLyBwdWJsaWMgY29udGVudFN0YXR1czogQ29udGVudFN0YXR1cyA9IENvbnRlbnRTdGF0dXMubm9uZTtcbiAgICAgICAgdGhpcy5jb250ZW50U3RhdGVzID0gbmV3IEF3YWl0YWJsZU1hcCgpO1xuICAgICAgICAvLyBwdWJsaWMgY29udGVudFN0YXRlczogTWFwPENvbnRlbnRTdGF0ZSwgdW5kZWZpbmVkPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcm9tSGlzdG9yeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgd2UndmUgZ290IGEgY29udGFpbmVyLCB3ZSdyZSBnb29kIHRvIHJlc29sdmUgdHlwZVxuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5pc0NvbXBvbmVudFR5cGUoKSAmJiAoY29ubmVjdGVkQ0U/LmNvbnRhaW5lciA/PyBudWxsKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LmNvbXBvbmVudFR5cGUgPSB0aGlzLnRvQ29tcG9uZW50VHlwZShjb25uZWN0ZWRDRS5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb21wb25lbnRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9XG4gICAgZ2V0IHZpZXdwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnZpZXdwb3J0O1xuICAgIH1cbiAgICBlcXVhbENvbXBvbmVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNhbWVDb21wb25lbnQob3RoZXIuY29udGVudCk7XG4gICAgfVxuICAgIGVxdWFsUGFyYW1ldGVycyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNhbWVDb21wb25lbnQob3RoZXIuY29udGVudCwgdHJ1ZSkgJiZcbiAgICAgICAgICAgIC8vIFRPRE86IFJldmlldyB3aGV0aGVyIHF1ZXJ5IGlzIHJlbGV2YW50XG4gICAgICAgICAgICB0aGlzLmluc3RydWN0aW9uLnF1ZXJ5ID09PSBvdGhlci5pbnN0cnVjdGlvbi5xdWVyeTtcbiAgICB9XG4gICAgcmVlbnRyeUJlaGF2aW9yKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgJ3JlZW50cnlCZWhhdmlvcicgaW4gdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UucmVlbnRyeUJlaGF2aW9yICE9PSB2b2lkIDApXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5yZWVudHJ5QmVoYXZpb3JcbiAgICAgICAgICAgIDogXCJkZWZhdWx0XCIgLyogZGVmYXVsdCAqLztcbiAgICB9XG4gICAgaXNDYWNoZUVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc2FtZUNvbXBvbmVudChvdGhlci5jb250ZW50LCB0cnVlKTtcbiAgICB9XG4gICAgY29udGVudENvbnRyb2xsZXIoY29ubmVjdGVkQ0UpIHtcbiAgICAgICAgcmV0dXJuIENvbnRyb2xsZXIuZm9yQ3VzdG9tRWxlbWVudChudWxsLCBjb25uZWN0ZWRDRS5jb250YWluZXIsIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSwgY29ubmVjdGVkQ0UuZWxlbWVudCwgbnVsbCwgdm9pZCAwKTtcbiAgICB9XG4gICAgY3JlYXRlQ29tcG9uZW50KGNvbm5lY3RlZENFLCBmYWxsYmFjaykge1xuICAgICAgICAvLyBpZiAodGhpcy5jb250ZW50U3RhdHVzICE9PSBDb250ZW50U3RhdHVzLm5vbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2NyZWF0ZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGxvYWQgY2FjaGVkIGNvbnRlbnQgb3IgaW5zdGFudGlhdGVkIGhpc3RvcnkgY29udGVudFxuICAgICAgICBpZiAoIXRoaXMuZnJvbUNhY2hlICYmICF0aGlzLmZyb21IaXN0b3J5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMudG9Db21wb25lbnRJbnN0YW5jZShjb25uZWN0ZWRDRS5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc2V0UGFyYW1ldGVycyh7IGlkOiB0aGlzLmNvbnRlbnQuY29tcG9uZW50TmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnNldENvbXBvbmVudChmYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLnRvQ29tcG9uZW50SW5zdGFuY2UoY29ubmVjdGVkQ0UuY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGVudFN0YXRlcy5zZXQoJ2NyZWF0ZWQnLCB2b2lkIDApO1xuICAgICAgICAvLyB0aGlzLmNvbnRlbnRTdGF0dXMgPSBDb250ZW50U3RhdHVzLmNyZWF0ZWQ7XG4gICAgICAgIC8vIGlmICh0aGlzLmNvbnRlbnRTdGF0dXMgIT09IENvbnRlbnRTdGF0dXMuY3JlYXRlZCB8fCAhdGhpcy5sb2FkZWQgfHwgIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAvLyBpZiAodGhpcy5jb250ZW50U3RhdHVzICE9PSBDb250ZW50U3RhdHVzLmNyZWF0ZWQgfHwgdGhpcy5sb2FkZWQgfHwgIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50U3RhdGVzLmhhcygnbG9hZGVkJykgfHwgIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuY29udGVudFN0YXR1cyA9IENvbnRlbnRTdGF0dXMubG9hZGVkO1xuICAgICAgICAvLyBEb24ndCBsb2FkIGNhY2hlZCBjb250ZW50IG9yIGluc3RhbnRpYXRlZCBoaXN0b3J5IGNvbnRlbnRcbiAgICAgICAgaWYgKCF0aGlzLmZyb21DYWNoZSB8fCAhdGhpcy5mcm9tSGlzdG9yeSkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udGVudENvbnRyb2xsZXIoY29ubmVjdGVkQ0UpO1xuICAgICAgICAgICAgY29udHJvbGxlci5wYXJlbnQgPSBjb25uZWN0ZWRDRS5jb250cm9sbGVyOyAvLyBDdXN0b21FbGVtZW50LmZvcihjb25uZWN0ZWRDRS5lbGVtZW50KSE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVibGljIGRlc3Ryb3lDb21wb25lbnQoKTogdm9pZCB7XG4gICAgLy8gICAvLyBUT0RPOiBXZSBtaWdodCB3YW50IHRvIGRvIHNvbWV0aGluZyBoZXJlIGV2ZW50dWFsbHksIHdobyBrbm93cz9cbiAgICAvLyAgIC8vIGlmICh0aGlzLmNvbnRlbnRTdGF0dXMgIT09IENvbnRlbnRTdGF0dXMuY3JlYXRlZCkge1xuICAgIC8vICAgaWYgKCF0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdjcmVhdGVkJykpIHtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vICAgfVxuICAgIC8vICAgLy8gRG9uJ3QgZGVzdHJveSBjb21wb25lbnRzIHdoZW4gc3RhdGVmdWxcbiAgICAvLyAgIC8vIHRoaXMuY29udGVudFN0YXR1cyA9IENvbnRlbnRTdGF0dXMubm9uZTtcbiAgICAvLyAgIHRoaXMuY29udGVudFN0YXRlcy5kZWxldGUoJ2NyZWF0ZWQnKTtcbiAgICAvLyB9XG4gICAgY2FuTG9hZCh2aWV3cG9ydCwgcHJldmlvdXNJbnN0cnVjdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2NyZWF0ZWQnKSB8fCAodGhpcy5jb250ZW50U3RhdGVzLmhhcygnZ3VhcmRlZCcpICYmICF0aGlzLnJlZW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRlbnRTdGF0ZXMuc2V0KCdndWFyZGVkJywgdm9pZCAwKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5jYW5Mb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMuY29udGVudC5jb21wb25lbnRUeXBlID8gdGhpcy5jb250ZW50LmNvbXBvbmVudFR5cGUucGFyYW1ldGVycyA6IG51bGw7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24ucGFyYW1ldGVycyA9IHRoaXMuY29udGVudC50b1NwZWNpZmllZFBhcmFtZXRlcnModHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSB7IC4uLnBhcnNlUXVlcnkodGhpcy5pbnN0cnVjdGlvbi5xdWVyeSksIC4uLnRoaXMuaW5zdHJ1Y3Rpb24ucGFyYW1ldGVycyB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UuY2FuTG9hZChtZXJnZWQsIHRoaXMuaW5zdHJ1Y3Rpb24sIHByZXZpb3VzSW5zdHJ1Y3Rpb24pO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFt2aWV3cG9ydC5yb3V0ZXIuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbihyZXN1bHQsIHZpZXdwb3J0KV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2FuVW5sb2FkKG5leHRJbnN0cnVjdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSB8fCAhdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlLmNhblVubG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdsb2FkZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5jYW5VbmxvYWQobmV4dEluc3RydWN0aW9uLCB0aGlzLmluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgLy8gcHVibGljIGFzeW5jIGNhblVubG9hZChuZXh0SW5zdHJ1Y3Rpb246IE5hdmlnYXRpb24gfCBudWxsKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gICBpZiAoIXRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSB8fCAhdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlLmNhblVubG9hZCkge1xuICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5jYW5VbmxvYWQobmV4dEluc3RydWN0aW9uLCB0aGlzLmluc3RydWN0aW9uKTtcbiAgICAvLyAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiByZXN1bHQ7XG4gICAgLy8gfVxuICAgIGxvYWQocHJldmlvdXNJbnN0cnVjdGlvbikge1xuICAgICAgICAvLyBpZiAoIXRoaXMucmVlbnRyeSAmJiAodGhpcy5jb250ZW50U3RhdHVzICE9PSBDb250ZW50U3RhdHVzLmNyZWF0ZWQgfHwgdGhpcy5sb2FkZWQpKSB7XG4gICAgICAgIC8vIGlmICghdGhpcy5yZWVudHJ5ICYmIHRoaXMubG9hZGVkKSB7XG4gICAgICAgIC8vIGlmICghdGhpcy5jb250ZW50U3RhdGVzLmhhcygnY3JlYXRlZCcpIHx8ICh0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdsb2FkZWQnKSAmJiAhdGhpcy5yZWVudHJ5KSkge1xuICAgICAgICAvLyAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB0aGlzLnJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy5jb250ZW50U3RhdGVzLmF3YWl0KCdndWFyZGVkJyksICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50U3RhdGVzLmhhcygnY3JlYXRlZCcpIHx8ICh0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdsb2FkZWQnKSAmJiAhdGhpcy5yZWVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVlbnRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xvYWRlZCcsIHRoaXMuY29udGVudC5jb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudFN0YXRlcy5zZXQoJ2xvYWRlZCcsIHZvaWQgMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlICYmIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5sb2FkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLmNvbnRlbnQuY29tcG9uZW50VHlwZSA/IHRoaXMuY29udGVudC5jb21wb25lbnRUeXBlLnBhcmFtZXRlcnMgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24ucGFyYW1ldGVycyA9IHRoaXMuY29udGVudC50b1NwZWNpZmllZFBhcmFtZXRlcnModHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4ucGFyc2VRdWVyeSh0aGlzLmluc3RydWN0aW9uLnF1ZXJ5KSwgLi4udGhpcy5pbnN0cnVjdGlvbi5wYXJhbWV0ZXJzIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS5sb2FkKG1lcmdlZCwgdGhpcy5pbnN0cnVjdGlvbiwgcHJldmlvdXNJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bmxvYWQobmV4dEluc3RydWN0aW9uKSB7XG4gICAgICAgIC8vIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdsb2FkZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsb2FkZWQnLCB0aGlzLmNvbnRlbnQuY29tcG9uZW50TmFtZSwgJ2RlbGV0ZWQnKTtcbiAgICAgICAgdGhpcy5jb250ZW50U3RhdGVzLmRlbGV0ZSgnbG9hZGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgJiYgdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlLnVubG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZS51bmxvYWQobmV4dEluc3RydWN0aW9uLCB0aGlzLmluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwdWJsaWMgdW5sb2FkQ29tcG9uZW50KGNhY2hlOiBWaWV3cG9ydENvbnRlbnRbXSwgc3RhdGVmdWw6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIC8vICAgLy8gVE9ETzogV2UgbWlnaHQgd2FudCB0byBkbyBzb21ldGhpbmcgaGVyZSBldmVudHVhbGx5LCB3aG8ga25vd3M/XG4gICAgLy8gICAvLyBpZiAodGhpcy5jb250ZW50U3RhdHVzICE9PSBDb250ZW50U3RhdHVzLmFjdGl2YXRlZCkge1xuICAgIC8vICAgaWYgKCF0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdjcmVhdGVkJykpIHtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vICAgfVxuICAgIC8vICAgLy8gRG9uJ3QgdW5sb2FkIGNvbXBvbmVudHMgd2hlbiBzdGF0ZWZ1bFxuICAgIC8vICAgLy8gVE9ETzogV2UncmUgbWlzc2luZyBzdHVmZiBoZXJlXG4gICAgLy8gICBpZiAoIXN0YXRlZnVsKSB7XG4gICAgLy8gICAgIC8vIHRoaXMuY29udGVudFN0YXR1cyA9IENvbnRlbnRTdGF0dXMuY3JlYXRlZDtcbiAgICAvLyAgICAgdGhpcy5jb250ZW50U3RhdGVzLmRlbGV0ZSgnY3JlYXRlZCcpO1xuICAgIC8vICAgfSBlbHNlIHtcbiAgICAvLyAgICAgY2FjaGUucHVzaCh0aGlzKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgYWN0aXZhdGVDb21wb25lbnQoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzLCBjb25uZWN0ZWRDRSwgcGFyZW50QWN0aXZhdGVkKSB7XG4gICAgICAgIC8vIGlmICh0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdhY3RpdmF0ZWQnKSB8fCAhdGhpcy5jb250ZW50U3RhdGVzLmhhcygnY3JlYXRlZCcpKSB7XG4gICAgICAgIC8vIGlmICh0aGlzLmNvbnRlbnRTdGF0ZXMuaGFzKCdhY3RpdmF0ZWQnKSkge1xuICAgICAgICAvLyAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB0aGlzLmNvbnRlbnRTdGF0ZXMuc2V0KCdhY3RpdmF0ZWQnLCB2b2lkIDApO1xuICAgICAgICAvLyAvLyBpZiAocGFyZW50QWN0aXZhdGVkKSB7IC8vIFBhcmVudCBpcyBhbHJlYWR5IHBhcnQgb2YgYW4gYWN0aXZhdGlvblxuICAgICAgICAvLyAvLyAgIHJldHVybiA7XG4gICAgICAgIC8vIC8vIH1cbiAgICAgICAgLy8gY29uc3QgY29udGVudENvbnRyb2xsZXIgPSB0aGlzLmNvbnRlbnRDb250cm9sbGVyKGNvbm5lY3RlZENFKTtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gdGhpcy5jb250ZW50U3RhdGVzLmF3YWl0KCdsb2FkZWQnKSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2FjdGl2YXRlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250ZW50U3RhdGVzLnNldCgnYWN0aXZhdGVkJywgdm9pZCAwKTtcbiAgICAgICAgICAgIC8vIGlmIChwYXJlbnRBY3RpdmF0ZWQpIHsgLy8gUGFyZW50IGlzIGFscmVhZHkgcGFydCBvZiBhbiBhY3RpdmF0aW9uXG4gICAgICAgICAgICAvLyAgIHJldHVybiA7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q29udHJvbGxlciA9IHRoaXMuY29udGVudENvbnRyb2xsZXIoY29ubmVjdGVkQ0UpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRDb250cm9sbGVyLmFjdGl2YXRlKGluaXRpYXRvciA/PyBjb250ZW50Q29udHJvbGxlciwgbnVsbCAvKiBUT0RPOiB0YWtlIGJhY2s6IHBhcmVudCEgKi8sIGZsYWdzKTtcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJvbUNhY2hlIHx8IHRoaXMuZnJvbUhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmZyb20oY29ubmVjdGVkQ0UuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUoJ2F1LWVsZW1lbnQtc2Nyb2xsJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbdG9wLCBsZWZ0XSA9IGF0dHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXUtZWxlbWVudC1zY3JvbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNjcm9sbFRvKCtsZWZ0LCArdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBhc3luYyBhY3RpdmF0ZUNvbXBvbmVudChpbml0aWF0b3I6IElIeWRyYXRlZENvbnRyb2xsZXIgfCBudWxsLCBwYXJlbnQ6IElDdXN0b21FbGVtZW50Q29udHJvbGxlcjxJQ3VzdG9tRWxlbWVudFZpZXdNb2RlbD4gfCBudWxsLCBmbGFnczogTGlmZWN5Y2xlRmxhZ3MsIGNvbm5lY3RlZENFOiBJQ29ubmVjdGVkQ3VzdG9tRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vICAgLy8gaWYgKHRoaXMuY29udGVudFN0YXR1cyAhPT0gQ29udGVudFN0YXR1cy5jcmVhdGVkKSB7XG4gICAgLy8gICBpZiAoIXRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2NyZWF0ZWQnKSkge1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gICB9XG4gICAgLy8gICAvLyB0aGlzLmNvbnRlbnRTdGF0dXMgPSBDb250ZW50U3RhdHVzLmFjdGl2YXRlZDtcbiAgICAvLyAgIHRoaXMuY29udGVudFN0YXRlcy5hZGQoJ2FjdGl2YXRlZCcpO1xuICAgIC8vICAgY29uc3QgY29udGVudENvbnRyb2xsZXIgPSB0aGlzLmNvbnRlbnRDb250cm9sbGVyKGNvbm5lY3RlZENFKTtcbiAgICAvLyAgIGF3YWl0IGNvbnRlbnRDb250cm9sbGVyLmFjdGl2YXRlKGluaXRpYXRvciA/PyBjb250ZW50Q29udHJvbGxlciwgcGFyZW50ISwgZmxhZ3MpO1xuICAgIC8vICAgaWYgKHRoaXMuZnJvbUNhY2hlIHx8IHRoaXMuZnJvbUhpc3RvcnkpIHtcbiAgICAvLyAgICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5mcm9tKGNvbm5lY3RlZENFLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSk7XG4gICAgLy8gICAgIGZvciAoY29uc3QgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAvLyAgICAgICBjb25zdCBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKCdhdS1lbGVtZW50LXNjcm9sbCcpO1xuICAgIC8vICAgICAgIGlmIChhdHRyKSB7XG4gICAgLy8gICAgICAgICBjb25zdCBbdG9wLCBsZWZ0XSA9IGF0dHIuc3BsaXQoJywnKTtcbiAgICAvLyAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXUtZWxlbWVudC1zY3JvbGwnKTtcbiAgICAvLyAgICAgICAgIGVsLnNjcm9sbFRvKCtsZWZ0LCArdG9wKTtcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgZGVhY3RpdmF0ZUNvbXBvbmVudChpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MsIGNvbm5lY3RlZENFLCBzdGF0ZWZ1bCA9IGZhbHNlKSB7XG4gICAgICAgIC8vIGlmICh0aGlzLmNvbnRlbnRTdGF0dXMgIT09IENvbnRlbnRTdGF0dXMuYWN0aXZhdGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50U3RhdGVzLmhhcygnYWN0aXZhdGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmNvbnRlbnRTdGF0dXMgPSBDb250ZW50U3RhdHVzLmNyZWF0ZWQ7XG4gICAgICAgIHRoaXMuY29udGVudFN0YXRlcy5kZWxldGUoJ2FjdGl2YXRlZCcpO1xuICAgICAgICBpZiAoc3RhdGVmdWwgJiYgY29ubmVjdGVkQ0UuZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY29uc3QgY29udGVudENvbnRyb2xsZXIgPSB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UhLiRjb250cm9sbGVyITtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShjb25uZWN0ZWRDRS5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbC5zY3JvbGxUb3AgPiAwIHx8IGVsLnNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhdS1lbGVtZW50LXNjcm9sbCcsIGAke2VsLnNjcm9sbFRvcH0sJHtlbC5zY3JvbGxMZWZ0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50Q29udHJvbGxlciA9IHRoaXMuY29udGVudENvbnRyb2xsZXIoY29ubmVjdGVkQ0UpO1xuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiBjb250ZW50Q29udHJvbGxlci5kZWFjdGl2YXRlKGluaXRpYXRvciA/PyBjb250ZW50Q29udHJvbGxlciwgcGFyZW50LCBmbGFncykpO1xuICAgIH1cbiAgICBkaXNwb3NlQ29tcG9uZW50KGNvbm5lY3RlZENFLCBjYWNoZSwgc3RhdGVmdWwgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudFN0YXRlcy5oYXMoJ2NyZWF0ZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHVubG9hZCBjb21wb25lbnRzIHdoZW4gc3RhdGVmdWxcbiAgICAgICAgLy8gVE9ETzogV2UncmUgbWlzc2luZyBzdHVmZiBoZXJlXG4gICAgICAgIGlmICghc3RhdGVmdWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudFN0YXRlcy5kZWxldGUoJ2NyZWF0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDb250cm9sbGVyID0gdGhpcy5jb250ZW50Q29udHJvbGxlcihjb25uZWN0ZWRDRSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudENvbnRyb2xsZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FjaGUucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcmVlQ29udGVudChjb25uZWN0ZWRDRSwgbmV4dEluc3RydWN0aW9uLCBjYWNoZSwgc3RhdGVmdWwgPSBmYWxzZSkge1xuICAgICAgICAvLyBzd2l0Y2ggKHRoaXMuY29udGVudFN0YXR1cykge1xuICAgICAgICAvLyAgIGNhc2UgQ29udGVudFN0YXR1cy5hY3RpdmF0ZWQ6XG4gICAgICAgIC8vICAgICBhd2FpdCB0aGlzLnVubG9hZChuZXh0SW5zdHJ1Y3Rpb24pO1xuICAgICAgICAvLyAgICAgYXdhaXQgdGhpcy5kZWFjdGl2YXRlQ29tcG9uZW50KG51bGwsIGNvbm5lY3RlZENFIS5jb250cm9sbGVyLCBMaWZlY3ljbGVGbGFncy5ub25lLCBjb25uZWN0ZWRDRSEsIHN0YXRlZnVsKTtcbiAgICAgICAgLy8gICAgIHRoaXMudW5sb2FkQ29tcG9uZW50KGNhY2hlLCBzdGF0ZWZ1bCk7IC8vIFRPRE86IEhvb2sgdXAgdG8gbmV3IGRpc3Bvc2VcbiAgICAgICAgLy8gICBjYXNlIENvbnRlbnRTdGF0dXMuY3JlYXRlZDpcbiAgICAgICAgLy8gICAgIHRoaXMuZGVzdHJveUNvbXBvbmVudCgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIFRPRE86IEZpeCBleGVjdXRpb24gb3JkZXIgb24gdGhlc2VcbiAgICAgICAgLy8gVGhlc2UgYXJlIGFsbCBzYWZlIHRvIHJ1blxuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLnVubG9hZChuZXh0SW5zdHJ1Y3Rpb24pLCAoKSA9PiB0aGlzLmRlYWN0aXZhdGVDb21wb25lbnQobnVsbCwgY29ubmVjdGVkQ0UuY29udHJvbGxlciwgMCAvKiBub25lICovLCBjb25uZWN0ZWRDRSwgc3RhdGVmdWwpLCBcbiAgICAgICAgLy8gKCkgPT4gdGhpcy51bmxvYWRDb21wb25lbnQoY2FjaGUsIHN0YXRlZnVsKSwgLy8gVE9ETzogSG9vayB1cCB0byBuZXcgZGlzcG9zZVxuICAgICAgICAvLyAoKSA9PiB0aGlzLmRlc3Ryb3lDb21wb25lbnQoKSxcbiAgICAgICAgKCkgPT4gdGhpcy5kaXNwb3NlQ29tcG9uZW50KGNvbm5lY3RlZENFLCBjYWNoZSwgc3RhdGVmdWwpKTtcbiAgICB9XG4gICAgdG9Db21wb25lbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmNvbXBvbmVudE5hbWU7XG4gICAgfVxuICAgIHRvQ29tcG9uZW50VHlwZShjb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudG9Db21wb25lbnRUeXBlKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHRvQ29tcG9uZW50SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRvQ29tcG9uZW50SW5zdGFuY2UoY29udGFpbmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3cG9ydC1jb250ZW50LmpzLm1hcCIsImltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lLWh0bWwnO1xuaW1wb3J0IHsgQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlciB9IGZyb20gJy4vdHlwZS1yZXNvbHZlcnMuanMnO1xuaW1wb3J0IHsgUm91dGVyT3B0aW9ucyB9IGZyb20gJy4vcm91dGVyLW9wdGlvbnMuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWwgLSBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuICovXG5leHBvcnQgdmFyIFBhcmFtZXRlcnNUeXBlO1xuKGZ1bmN0aW9uIChQYXJhbWV0ZXJzVHlwZSkge1xuICAgIFBhcmFtZXRlcnNUeXBlW1wibm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIFBhcmFtZXRlcnNUeXBlW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBQYXJhbWV0ZXJzVHlwZVtcImFycmF5XCJdID0gXCJhcnJheVwiO1xuICAgIFBhcmFtZXRlcnNUeXBlW1wib2JqZWN0XCJdID0gXCJvYmplY3RcIjtcbn0pKFBhcmFtZXRlcnNUeXBlIHx8IChQYXJhbWV0ZXJzVHlwZSA9IHt9KSk7XG4vKipcbiAqIFB1YmxpYyBBUEkgLSBUaGUgdmlld3BvcnQgaW5zdHJ1Y3Rpb25zIGFyZSB0aGUgY29yZSBvZiB0aGUgcm91dGVyJ3MgbmF2aWdhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZXdwb3J0SW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3cG9ydE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzUmVjb3JkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyc1R5cGUgPSBcIm5vbmVcIiAvKiBub25lICovO1xuICAgICAgICB0aGlzLm93bnNTY29wZSA9IHRydWU7XG4gICAgICAgIHRoaXMubmV4dFNjb3BlSW5zdHJ1Y3Rpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9ICcnO1xuICAgICAgICB0aGlzLnZpZXdwb3J0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5lZWRzVmlld3BvcnREZXNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcEluc3RydWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlciA9IG51bGw7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICAvLyAgIGNvbXBvbmVudDogQ29tcG9uZW50QXBwZWxsYXRpb24sXG4gICAgLy8gICB2aWV3cG9ydD86IFZpZXdwb3J0SGFuZGxlLFxuICAgIC8vICAgcGFyYW1ldGVycz86IENvbXBvbmVudFBhcmFtZXRlcnMsXG4gICAgLy8gICBwdWJsaWMgb3duc1Njb3BlOiBib29sZWFuID0gdHJ1ZSxcbiAgICAvLyAgIHB1YmxpYyBuZXh0U2NvcGVJbnN0cnVjdGlvbnM6IFZpZXdwb3J0SW5zdHJ1Y3Rpb25bXSB8IG51bGwgPSBudWxsLFxuICAgIC8vICkge1xuICAgIC8vICAgdGhpcy5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAvLyAgIHRoaXMuc2V0Vmlld3BvcnQodmlld3BvcnQpO1xuICAgIC8vICAgdGhpcy5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIC8vIH1cbiAgICBzdGF0aWMgY3JlYXRlKGluc3RydWN0aW9uUmVzb2x2ZXIsIGNvbXBvbmVudCwgdmlld3BvcnQsIHBhcmFtZXRlcnMsIG93bnNTY29wZSA9IHRydWUsIG5leHRTY29wZUluc3RydWN0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgLy8gaWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgLy8gICByZXR1cm4gY29tcG9uZW50LnRoZW4oKHJlc29sdmVkQ29tcG9uZW50KSA9PiB7XG4gICAgICAgIC8vICAgICByZXR1cm4gVmlld3BvcnRJbnN0cnVjdGlvbi5jcmVhdGUoaW5zdHJ1Y3Rpb25SZXNvbHZlciwgcmVzb2x2ZWRDb21wb25lbnQsIHZpZXdwb3J0LCBwYXJhbWV0ZXJzLCBvd25zU2NvcGUsIG5leHRTY29wZUluc3RydWN0aW9ucyk7XG4gICAgICAgIC8vICAgfSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBuZXcgVmlld3BvcnRJbnN0cnVjdGlvbigpO1xuICAgICAgICBpbnN0cnVjdGlvbi5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24uc2V0Vmlld3BvcnQodmlld3BvcnQpO1xuICAgICAgICBpbnN0cnVjdGlvbi5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICBpbnN0cnVjdGlvbi5vd25zU2NvcGUgPSBvd25zU2NvcGU7XG4gICAgICAgIGluc3RydWN0aW9uLm5leHRTY29wZUluc3RydWN0aW9ucyA9IG5leHRTY29wZUluc3RydWN0aW9ucztcbiAgICAgICAgaW5zdHJ1Y3Rpb24uc2V0SW5zdHJ1Y3Rpb25SZXNvbHZlcihpbnN0cnVjdGlvblJlc29sdmVyKTtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgIH1cbiAgICBnZXQgb3duZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0ID8/IHRoaXMudmlld3BvcnRTY29wZSA/PyBudWxsO1xuICAgIH1cbiAgICBnZXQgdHlwZWRQYXJhbWV0ZXJzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGFyYW1ldGVyc1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIiAvKiBzdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyc1N0cmluZztcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiIC8qIGFycmF5ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnNMaXN0O1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiIC8qIG9iamVjdCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzUmVjb3JkO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25SZXNvbHZlci5wYXJzZUNvbXBvbmVudFBhcmFtZXRlcnModGhpcy50eXBlZFBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0IG5vcm1hbGl6ZWRQYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0cnVjdGlvblJlc29sdmVyICE9PSBudWxsICYmIHRoaXMudHlwZWRQYXJhbWV0ZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvblJlc29sdmVyLnN0cmluZ2lmeUNvbXBvbmVudFBhcmFtZXRlcnModGhpcy5wYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHNldENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNOYW1lKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TmFtZSA9IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0TmFtZShjb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuaXNUeXBlKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0TmV3TmFtZShjb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gQ29tcG9uZW50QXBwZWxsYXRpb25SZXNvbHZlci5nZXRUeXBlKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21wb25lbnRBcHBlbGxhdGlvblJlc29sdmVyLmlzSW5zdGFuY2UoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnROYW1lID0gdGhpcy5nZXROZXdOYW1lKENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0VHlwZShjb21wb25lbnQpKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0VHlwZShjb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0SW5zdGFuY2UoY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAodmlld3BvcnQgPT09IHVuZGVmaW5lZCB8fCB2aWV3cG9ydCA9PT0gJycpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpZXdwb3J0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydE5hbWUgPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydE5hbWUgPSB2aWV3cG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUgPSB2aWV3cG9ydC5vd25pbmdTY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbWV0ZXJzID09PSBudWxsIHx8IHBhcmFtZXRlcnMgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnNUeXBlID0gXCJub25lXCIgLyogbm9uZSAqLztcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzVHlwZSA9IFwic3RyaW5nXCIgLyogc3RyaW5nICovO1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzU3RyaW5nID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnNUeXBlID0gXCJhcnJheVwiIC8qIGFycmF5ICovO1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzTGlzdCA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnNUeXBlID0gXCJvYmplY3RcIiAvKiBvYmplY3QgKi87XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnNSZWNvcmQgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgb25seSB3b3JrcyB3aXRoIG9iamVjdHMgYWRkZWQgdG8gb2JqZWN0cyFcbiAgICBhZGRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1R5cGUgPT09IFwibm9uZVwiIC8qIG5vbmUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1R5cGUgIT09IFwib2JqZWN0XCIgLyogb2JqZWN0ICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgYWRkIG9iamVjdCBwYXJhbWV0ZXJzIHRvIGV4aXN0aW5nIG5vbi1vYmplY3QgcGFyYW1ldGVycyEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnMoeyAuLi50aGlzLnBhcmFtZXRlcnNSZWNvcmQsIC4uLnBhcmFtZXRlcnMgfSk7XG4gICAgfVxuICAgIHNldEluc3RydWN0aW9uUmVzb2x2ZXIoaW5zdHJ1Y3Rpb25SZXNvbHZlcikge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uUmVzb2x2ZXIgPSBpbnN0cnVjdGlvblJlc29sdmVyO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNDb21wb25lbnROYW1lKCkgJiYgIXRoaXMuaXNDb21wb25lbnRUeXBlKCkgJiYgIXRoaXMuaXNDb21wb25lbnRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICBpc0NvbXBvbmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY29tcG9uZW50TmFtZSAmJiAhdGhpcy5pc0NvbXBvbmVudFR5cGUoKSAmJiAhdGhpcy5pc0NvbXBvbmVudEluc3RhbmNlKCk7XG4gICAgfVxuICAgIGlzQ29tcG9uZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50VHlwZSAhPT0gbnVsbCAmJiAhdGhpcy5pc0NvbXBvbmVudEluc3RhbmNlKCk7XG4gICAgfVxuICAgIGlzQ29tcG9uZW50SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlICE9PSBudWxsO1xuICAgIH1cbiAgICB0b0NvbXBvbmVudFR5cGUoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50TmFtZSAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaXMuY29tcG9uZW50TmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIGNvbnRhaW5lciAhPT0gbnVsbFxuICAgICAgICAgICAgJiYgY29udGFpbmVyLmhhcyhDdXN0b21FbGVtZW50LmtleUZyb20odGhpcy5jb21wb25lbnROYW1lKSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gY29udGFpbmVyLmdldFJlc29sdmVyKEN1c3RvbUVsZW1lbnQua2V5RnJvbSh0aGlzLmNvbXBvbmVudE5hbWUpKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlciAhPT0gbnVsbCAmJiByZXNvbHZlci5nZXRGYWN0b3J5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gcmVzb2x2ZXIuZ2V0RmFjdG9yeShjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmIChmYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5LlR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0NvbXBvbmVudEluc3RhbmNlKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lciAhPT0gdm9pZCAwICYmIGNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmlzQ29tcG9uZW50VHlwZSgpXG4gICAgICAgICAgICAgICAgPyBjb250YWluZXIuZ2V0KHRoaXMuY29tcG9uZW50VHlwZSlcbiAgICAgICAgICAgICAgICA6IGNvbnRhaW5lci5nZXQoQ3VzdG9tRWxlbWVudC5rZXlGcm9tKHRoaXMuY29tcG9uZW50TmFtZSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wb25lbnRUeXBlKCkgJiZcbiAgICAgICAgICAgICAgICAhKGluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy5jb21wb25lbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGluc3RhbnRpYXRlJywgdGhpcy5jb21wb25lbnRUeXBlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9WaWV3cG9ydEluc3RhbmNlKHJvdXRlcikge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlci5nZXRWaWV3cG9ydCh0aGlzLnZpZXdwb3J0TmFtZSk7XG4gICAgfVxuICAgIHRvU3BlY2lmaWVkUGFyYW1ldGVycyhzcGVjaWZpY2F0aW9ucykge1xuICAgICAgICBzcGVjaWZpY2F0aW9ucyA9IHNwZWNpZmljYXRpb25zIHx8IFtdO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBzcGVjaWZpZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBzcGVjIG9mIHNwZWNpZmljYXRpb25zKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBnZXQgbmFtZWQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJhbWV0ZXJzLmZpbmRJbmRleChwYXJhbSA9PiBwYXJhbS5rZXkgPT09IHNwZWMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcGFyYW1ldGVyXSA9IHBhcmFtZXRlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZWRbc3BlY10gPSBwYXJhbWV0ZXIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgZ2V0IGZpcnN0IHVubmFtZWRcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcmFtZXRlcnMuZmluZEluZGV4KHBhcmFtID0+IHBhcmFtLmtleSA9PT0gdm9pZCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbcGFyYW1ldGVyXSA9IHBhcmFtZXRlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkW3NwZWNdID0gcGFyYW1ldGVyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYWxsIHJlbWFpbmluZyBuYW1lZFxuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtZXRlciBvZiBwYXJhbWV0ZXJzLmZpbHRlcihwYXJhbSA9PiBwYXJhbS5rZXkgIT09IHZvaWQgMCkpIHtcbiAgICAgICAgICAgIHNwZWNpZmllZFtwYXJhbWV0ZXIua2V5XSA9IHBhcmFtZXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSBzcGVjaWZpY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgIC8vIEFkZCBhbGwgcmVtYWluaW5nIHVubmFtZWQuLi5cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2YgcGFyYW1ldGVycy5maWx0ZXIocGFyYW0gPT4gcGFyYW0ua2V5ID09PSB2b2lkIDApKSB7XG4gICAgICAgICAgICAvLyAuLndpdGggYW4gaW5kZXhcbiAgICAgICAgICAgIHNwZWNpZmllZFtpbmRleCsrXSA9IHBhcmFtZXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BlY2lmaWVkO1xuICAgIH1cbiAgICB0b1NvcnRlZFBhcmFtZXRlcnMoc3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgc3BlY2lmaWNhdGlvbnMgPSBzcGVjaWZpY2F0aW9ucyB8fCBbXTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgc29ydGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3BlYyBvZiBzcGVjaWZpY2F0aW9ucykge1xuICAgICAgICAgICAgLy8gRmlyc3QgZ2V0IG5hbWVkIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFyYW1ldGVycy5maW5kSW5kZXgocGFyYW0gPT4gcGFyYW0ua2V5ID09PSBzcGVjKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0geyAuLi5wYXJhbWV0ZXJzLnNwbGljZShpbmRleCwgMSlbMF0gfTtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXIua2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHNvcnRlZC5wdXNoKHBhcmFtZXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgZ2V0IGZpcnN0IHVubmFtZWRcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcmFtZXRlcnMuZmluZEluZGV4KHBhcmFtID0+IHBhcmFtLmtleSA9PT0gdm9pZCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXIgPSB7IC4uLnBhcmFtZXRlcnMuc3BsaWNlKGluZGV4LCAxKVswXSB9O1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3IgYW4gZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkLnB1c2goeyB2YWx1ZTogdm9pZCAwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYWxsIHJlbWFpbmluZyBuYW1lZFxuICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJhbWV0ZXJzLmZpbHRlcihwYXJhbSA9PiBwYXJhbS5rZXkgIT09IHZvaWQgMCk7XG4gICAgICAgIHBhcmFtcy5zb3J0KChhLCBiKSA9PiAoYS5rZXkgfHwgJycpIDwgKGIua2V5IHx8ICcnKSA/IDEgOiAoYi5rZXkgfHwgJycpIDwgKGEua2V5IHx8ICcnKSA/IC0xIDogMCk7XG4gICAgICAgIHNvcnRlZC5wdXNoKC4uLnBhcmFtcyk7XG4gICAgICAgIC8vIEFkZCBhbGwgcmVtYWluaW5nIHVubmFtZWQuLi5cbiAgICAgICAgc29ydGVkLnB1c2goLi4ucGFyYW1ldGVycy5maWx0ZXIocGFyYW0gPT4gcGFyYW0ua2V5ID09PSB2b2lkIDApKTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICB9XG4gICAgc2FtZUNvbXBvbmVudChvdGhlciwgY29tcGFyZVBhcmFtZXRlcnMgPSBmYWxzZSwgY29tcGFyZVR5cGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoY29tcGFyZVBhcmFtZXRlcnMgJiYgIXRoaXMuc2FtZVBhcmFtZXRlcnMob3RoZXIsIGNvbXBhcmVUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlVHlwZSA/IHRoaXMuY29tcG9uZW50VHlwZSA9PT0gb3RoZXIuY29tcG9uZW50VHlwZSA6IHRoaXMuY29tcG9uZW50TmFtZSA9PT0gb3RoZXIuY29tcG9uZW50TmFtZTtcbiAgICB9XG4gICAgLy8gVE9ETzogU29tZXdoZXJlIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGZvcm1hdCBzdWNoIGFzIHNwYWNlcyBldGNcbiAgICBzYW1lUGFyYW1ldGVycyhvdGhlciwgY29tcGFyZVR5cGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2FtZUNvbXBvbmVudChvdGhlciwgZmFsc2UsIGNvbXBhcmVUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5jb21wb25lbnRUeXBlID8gdGhpcy5jb21wb25lbnRUeXBlLnBhcmFtZXRlcnMgOiBbXTtcbiAgICAgICAgY29uc3QgbWluZSA9IHRoaXMudG9TcGVjaWZpZWRQYXJhbWV0ZXJzKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gb3RoZXIudG9TcGVjaWZpZWRQYXJhbWV0ZXJzKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1pbmUpLmV2ZXJ5KGtleSA9PiBtaW5lW2tleV0gPT09IG90aGVyc1trZXldKVxuICAgICAgICAgICAgJiYgT2JqZWN0LmtleXMob3RoZXJzKS5ldmVyeShrZXkgPT4gb3RoZXJzW2tleV0gPT09IG1pbmVba2V5XSk7XG4gICAgfVxuICAgIHNhbWVWaWV3cG9ydChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydCAhPT0gbnVsbCAmJiBvdGhlci52aWV3cG9ydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQgPT09IG90aGVyLnZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlID09PSBvdGhlci5zY29wZSAmJlxuICAgICAgICAgICAgKHRoaXMudmlld3BvcnQgPyB0aGlzLnZpZXdwb3J0Lm5hbWUgOiB0aGlzLnZpZXdwb3J0TmFtZSkgPT09IChvdGhlci52aWV3cG9ydCA/IG90aGVyLnZpZXdwb3J0Lm5hbWUgOiBvdGhlci52aWV3cG9ydE5hbWUpO1xuICAgIH1cbiAgICBnZXROZXdOYW1lKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50TmFtZSA9PT0gbnVsbFxuICAgICAgICAvLyB8fCAhdHlwZS5hbGlhc2VzPy5pbmNsdWRlcyh0aGlzLmNvbXBvbmVudE5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudEFwcGVsbGF0aW9uUmVzb2x2ZXIuZ2V0TmFtZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnROYW1lO1xuICAgIH1cbn1cblZpZXdwb3J0SW5zdHJ1Y3Rpb24uaW5qZWN0ID0gW1JvdXRlck9wdGlvbnNdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3BvcnQtaW5zdHJ1Y3Rpb24uanMubWFwIiwiaW1wb3J0IHsgU2NvcGUgfSBmcm9tICcuL3Njb3BlLmpzJztcbmltcG9ydCB7IGFycmF5UmVtb3ZlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBSdW5uZXIgfSBmcm9tICcuL3J1bm5lci5qcyc7XG5leHBvcnQgY2xhc3MgVmlld3BvcnRTY29wZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcm91dGVyLCBjb25uZWN0ZWRDRSwgb3duaW5nU2NvcGUsIHNjb3BlLCByb290Q29tcG9uZW50VHlwZSA9IG51bGwsIC8vIHRlbXBvcmFyeS4gTWV0YWRhdGEgd2lsbCBwcm9iYWJseSBlbGltaW5hdGUgaXRcbiAgICBvcHRpb25zID0ge1xuICAgICAgICBjYXRjaGVzOiBbXSxcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQ0UgPSBjb25uZWN0ZWRDRTtcbiAgICAgICAgdGhpcy5yb290Q29tcG9uZW50VHlwZSA9IHJvb3RDb21wb25lbnRUeXBlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNvdXJjZUl0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZUl0ZW1JbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnJlbW92ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZFNjb3BlID0gbmV3IFNjb3BlKHJvdXRlciwgc2NvcGUsIG93bmluZ1Njb3BlLCBudWxsLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSByb3V0ZXIuY3JlYXRlVmlld3BvcnRJbnN0cnVjdGlvbih0aGlzLmNhdGNoZXNbMF0sIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRTY29wZS5zY29wZTtcbiAgICB9XG4gICAgZ2V0IG93bmluZ1Njb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRTY29wZS5vd25pbmdTY29wZTtcbiAgICB9XG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZFNjb3BlLmVuYWJsZWQ7XG4gICAgfVxuICAgIHNldCBlbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZS5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB9XG4gICAgZ2V0IGlzVmlld3BvcnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGlzVmlld3BvcnRTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50ID09PSBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFzc1Rocm91Z2hTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdENvbXBvbmVudFR5cGUgPT09IG51bGwgJiYgdGhpcy5jYXRjaGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0IHNpYmxpbmdzKCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmNvbm5lY3RlZFNjb3BlLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50LmVuYWJsZWRDaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5pc1ZpZXdwb3J0U2NvcGUgJiYgY2hpbGQudmlld3BvcnRTY29wZS5uYW1lID09PSB0aGlzLm5hbWUpXG4gICAgICAgICAgICAubWFwKGNoaWxkID0+IGNoaWxkLnZpZXdwb3J0U2NvcGUpO1xuICAgIH1cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgY2F0Y2hlcygpIHtcbiAgICAgICAgbGV0IGNhdGNoZXMgPSB0aGlzLm9wdGlvbnMuY2F0Y2hlcyB8fCBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYXRjaGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2F0Y2hlcyA9IGNhdGNoZXMuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2F0Y2hlcztcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2F0Y2hlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmV4dENvbnRlbnRBY3RpdmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnBhcmVudD8ub3duZXI/Lm5leHRDb250ZW50QWN0aXZhdGVkID8/IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcGFyZW50TmV4dENvbnRlbnRBY3RpdmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnBhcmVudD8ub3duZXI/Lm5leHRDb250ZW50QWN0aXZhdGVkID8/IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmV4dENvbnRlbnRBY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lID0gdGhpcy5jb250ZW50Py5jb21wb25lbnROYW1lID8/ICcnO1xuICAgICAgICBjb25zdCBuZXh0Q29udGVudE5hbWUgPSB0aGlzLm5leHRDb250ZW50Py5jb21wb25lbnROYW1lID8/ICcnO1xuICAgICAgICByZXR1cm4gYHZzOiR7dGhpcy5uYW1lfVske2NvbnRlbnROYW1lfS0+JHtuZXh0Q29udGVudE5hbWV9XWA7XG4gICAgfVxuICAgIHNldE5leHRDb250ZW50KHZpZXdwb3J0SW5zdHJ1Y3Rpb24sIG5hdmlnYXRpb24pIHtcbiAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbi52aWV3cG9ydFNjb3BlID0gdGhpcztcbiAgICAgICAgdGhpcy5yZW1vdmUgPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmlzQ2xlYXJWaWV3cG9ydEluc3RydWN0aW9uKHZpZXdwb3J0SW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICB8fCB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmlzQ2xlYXJBbGxWaWV3cG9ydHNJbnN0cnVjdGlvbih2aWV3cG9ydEluc3RydWN0aW9uKTtcbiAgICAgICAgdGhpcy5hZGQgPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmlzQWRkVmlld3BvcnRJbnN0cnVjdGlvbih2aWV3cG9ydEluc3RydWN0aW9uKVxuICAgICAgICAgICAgJiYgQXJyYXkuaXNBcnJheSh0aGlzLnNvdXJjZSk7XG4gICAgICAgIGlmICh0aGlzLmFkZCkge1xuICAgICAgICAgICAgdmlld3BvcnRJbnN0cnVjdGlvbi5jb21wb25lbnROYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0ICE9PSB2b2lkIDAgJiYgdmlld3BvcnRJbnN0cnVjdGlvbi5jb21wb25lbnROYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3cG9ydEluc3RydWN0aW9uLmNvbXBvbmVudE5hbWUgPSB0aGlzLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0Q29udGVudCA9IHZpZXdwb3J0SW5zdHJ1Y3Rpb247XG4gICAgICAgIHJldHVybiAnc3dhcCc7XG4gICAgfVxuICAgIHRyYW5zaXRpb24oY29vcmRpbmF0b3IpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZpZXdwb3J0U2NvcGUgc3dhcCcvKiwgdGhpcywgY29vcmRpbmF0b3IqLyk7XG4gICAgICAgIFJ1bm5lci5ydW4oKCkgPT4gY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ2d1YXJkZWRVbmxvYWQnKSwgKCkgPT4gY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ2d1YXJkZWRMb2FkJyksICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdndWFyZGVkJyksICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdsb2FkZWQnKSwgKCkgPT4gY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ3VubG9hZGVkJyksICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdyb3V0ZWQnKSwgKCkgPT4gY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ3N3YXBwZWQnKSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gIXRoaXMucmVtb3ZlID8gdGhpcy5uZXh0Q29udGVudCA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdjb21wbGV0ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhblVubG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhbkxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1bmxvYWQoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgbG9hZENvbnRlbnQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gICB0aGlzLmNvbnRlbnQgPSAhdGhpcy5yZW1vdmUgPyB0aGlzLm5leHRDb250ZW50IDogbnVsbDtcbiAgICAvLyAgIHRoaXMubmV4dENvbnRlbnQgPSBudWxsO1xuICAgIC8vICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAvLyB9XG4gICAgZmluYWxpemVDb250ZW50Q2hhbmdlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVmlld3BvcnRTY29wZSBmaW5hbGl6aW5nJywgdGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlICYmIEFycmF5LmlzQXJyYXkodGhpcy5zb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNvdXJjZUl0ZW0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhYm9ydENvbnRlbnRDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMubmV4dENvbnRlbnQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5hZGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zb3VyY2UuaW5kZXhPZih0aGlzLnNvdXJjZUl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlSXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhY2NlcHRTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQgPT09IG51bGwgJiYgc2VnbWVudCA9PT0gdm9pZCAwIHx8IHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudCA9PT0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5jbGVhclZpZXdwb3J0SW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIHx8IHNlZ21lbnQgPT09IHRoaXMucm91dGVyLmluc3RydWN0aW9uUmVzb2x2ZXIuYWRkVmlld3BvcnRJbnN0cnVjdGlvblxuICAgICAgICAgICAgfHwgc2VnbWVudCA9PT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2F0Y2hlcy5pbmNsdWRlcyhzZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2F0Y2hlcy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZS5pbmNsdWRlcygnKicpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYmluZGluZygpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UgfHwgW107XG4gICAgICAgIGlmIChzb3VyY2UubGVuZ3RoID4gMCAmJiB0aGlzLnNvdXJjZUl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlSXRlbSA9IHRoaXMuZ2V0QXZhaWxhYmxlU291cmNlSXRlbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlSXRlbSAhPT0gbnVsbCAmJiB0aGlzLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlSZW1vdmUodGhpcy5zb3VyY2UsIChpdGVtKSA9PiBpdGVtID09PSB0aGlzLnNvdXJjZUl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlSXRlbSA9IG51bGw7XG4gICAgfVxuICAgIGdldEF2YWlsYWJsZVNvdXJjZUl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLnNpYmxpbmdzO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzaWJsaW5ncy5ldmVyeShzaWJsaW5nID0+IHNpYmxpbmcuc291cmNlSXRlbSAhPT0gaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWRkU291cmNlSXRlbSgpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHt9O1xuICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKGl0ZW0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgcmVtb3ZlU291cmNlSXRlbSgpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJdGVtSW5kZXggPSB0aGlzLnNvdXJjZS5pbmRleE9mKHRoaXMuc291cmNlSXRlbSk7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUl0ZW1JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5zcGxpY2UodGhpcy5zb3VyY2VJdGVtSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJvdXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdENvbXBvbmVudFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3RDb21wb25lbnRUeXBlLnJvdXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3cG9ydC1zY29wZS5qcy5tYXAiLCJpbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IGFycmF5UmVtb3ZlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBWaWV3cG9ydENvbnRlbnQgfSBmcm9tICcuL3ZpZXdwb3J0LWNvbnRlbnQuanMnO1xuaW1wb3J0IHsgU2NvcGUgfSBmcm9tICcuL3Njb3BlLmpzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJy4vcnVubmVyLmpzJztcbmV4cG9ydCBjbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3Iocm91dGVyLCBuYW1lLCBjb25uZWN0ZWRDRSwgb3duaW5nU2NvcGUsIHNjb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQ0UgPSBjb25uZWN0ZWRDRTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5uZXh0Q29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dENvbnRlbnRBY3Rpb24gPSAnJztcbiAgICAgICAgdGhpcy5mb3JjZVJlbW92ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLmNsZWFyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblJlc29sdmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzVmlld3BvcnRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbmV3IFZpZXdwb3J0Q29udGVudCgpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZFNjb3BlID0gbmV3IFNjb3BlKHJvdXRlciwgc2NvcGUsIG93bmluZ1Njb3BlLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRTY29wZS5zY29wZTtcbiAgICB9XG4gICAgZ2V0IG93bmluZ1Njb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRTY29wZS5vd25pbmdTY29wZTtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RlZENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZENFPy4kY29udHJvbGxlciA/PyBudWxsO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkU2NvcGUuZW5hYmxlZDtcbiAgICB9XG4gICAgc2V0IGVuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZFNjb3BlLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH1cbiAgICBnZXQgaXNWaWV3cG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBpc1ZpZXdwb3J0U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgPT09IG51bGw7XG4gICAgfVxuICAgIGdldCBkb0ZvcmNlUmVtb3ZlKCkge1xuICAgICAgICBsZXQgc2NvcGUgPSB0aGlzLmNvbm5lY3RlZFNjb3BlO1xuICAgICAgICB3aGlsZSAoc2NvcGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS52aWV3cG9ydCAhPT0gbnVsbCAmJiBzY29wZS52aWV3cG9ydC5mb3JjZVJlbW92ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENvbnRlbnQgPz8gdGhpcy5jb250ZW50O1xuICAgIH1cbiAgICBnZXQgbmV4dENvbnRlbnRBY3RpdmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50Py5jb250ZW50U3RhdGVzLmhhcygnYWN0aXZhdGVkJykgPz8gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwYXJlbnROZXh0Q29udGVudEFjdGl2YXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUucGFyZW50Py5vd25lcj8ubmV4dENvbnRlbnRBY3RpdmF0ZWQgPz8gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwZXJmb3JtTG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uICE9PSAnc2tpcCcgJiYgdGhpcy5jb25uZWN0ZWRTY29wZS5wYXJlbnROZXh0Q29udGVudEFjdGlvbiAhPT0gJ3N3YXAnO1xuICAgICAgICAvLyAvLyByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiAhPT0gJ3NraXAnICYmICgodGhpcy5uZXh0Q29udGVudD8uY29udGVudC50b3BJbnN0cnVjdGlvbiA/PyBmYWxzZSkgfHwgdGhpcy5jbGVhcik7XG4gICAgfVxuICAgIGdldCBwZXJmb3JtU3dhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uICE9PSAnc2tpcCcgJiYgdGhpcy5jb25uZWN0ZWRTY29wZS5wYXJlbnROZXh0Q29udGVudEFjdGlvbiAhPT0gJ3N3YXAnO1xuICAgICAgICAvLyAvLyByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiAhPT0gJ3NraXAnICYmICgodGhpcy5uZXh0Q29udGVudD8uY29udGVudC50b3BJbnN0cnVjdGlvbiA/PyBmYWxzZSkgfHwgdGhpcy5jbGVhcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBjb250ZW50TmFtZSA9IHRoaXMuY29udGVudD8uY29udGVudC5jb21wb25lbnROYW1lID8/ICcnO1xuICAgICAgICBjb25zdCBuZXh0Q29udGVudE5hbWUgPSB0aGlzLm5leHRDb250ZW50Py5jb250ZW50LmNvbXBvbmVudE5hbWUgPz8gJyc7XG4gICAgICAgIHJldHVybiBgdjoke3RoaXMubmFtZX1bJHtjb250ZW50TmFtZX0tPiR7bmV4dENvbnRlbnROYW1lfV1gO1xuICAgIH1cbiAgICBzZXROZXh0Q29udGVudCh2aWV3cG9ydEluc3RydWN0aW9uLCBuYXZpZ2F0aW9uKSB7XG4gICAgICAgIHZpZXdwb3J0SW5zdHJ1Y3Rpb24uc2V0Vmlld3BvcnQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXIgPSB0aGlzLnJvdXRlci5pbnN0cnVjdGlvblJlc29sdmVyLmlzQ2xlYXJWaWV3cG9ydEluc3RydWN0aW9uKHZpZXdwb3J0SW5zdHJ1Y3Rpb24pO1xuICAgICAgICAvLyBDYW4gaGF2ZSBhIChyZXNvbHZlZCkgdHlwZSBvciBhIHN0cmluZyAodG8gYmUgcmVzb2x2ZWQgbGF0ZXIpXG4gICAgICAgIHRoaXMubmV4dENvbnRlbnQgPSBuZXcgVmlld3BvcnRDb250ZW50KCF0aGlzLmNsZWFyID8gdmlld3BvcnRJbnN0cnVjdGlvbiA6IHZvaWQgMCwgbmF2aWdhdGlvbiwgdGhpcy5jb25uZWN0ZWRDRSA/PyBudWxsKTtcbiAgICAgICAgdGhpcy5uZXh0Q29udGVudC5mcm9tSGlzdG9yeSA9IHRoaXMubmV4dENvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgJiYgbmF2aWdhdGlvbi5uYXZpZ2F0aW9uXG4gICAgICAgICAgICA/ICEhbmF2aWdhdGlvbi5uYXZpZ2F0aW9uLmJhY2sgfHwgISFuYXZpZ2F0aW9uLm5hdmlnYXRpb24uZm9yd2FyZFxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGF0ZWZ1bCkge1xuICAgICAgICAgICAgLy8gVE9ETzogQWRkIGEgcGFyYW1ldGVyIGhlcmUgdG8gZGVjaWRlIHJlcXVpcmVkIGVxdWFsaXR5XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmNhY2hlLmZpbmQoKGl0ZW0pID0+IHRoaXMubmV4dENvbnRlbnQuaXNDYWNoZUVxdWFsKGl0ZW0pKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gY2FjaGVkO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENvbnRlbnQuZnJvbUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUucHVzaCh0aGlzLm5leHRDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGlsZHJlbiB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgKHVubGVzcyBhZGRlZCBhZ2FpbikgYnkgbmV4dCBjb250ZW50LiBXaWxsXG4gICAgICAgIC8vIGJlIHJlLWVuYWJsZWQgb24gY2FuY2VsXG4gICAgICAgIHRoaXMuY29ubmVjdGVkU2NvcGUuY2xlYXJSZXBsYWNlZENoaWxkcmVuKCk7XG4gICAgICAgIC8vIElmIHdlIGdldCB0aGUgc2FtZSBfaW5zdGFuY2VfLCBkb24ndCBkbyBhbnl0aGluZyAoaGFwcGVucyB3aXRoIGNhY2hlZCBhbmQgaGlzdG9yeSlcbiAgICAgICAgaWYgKHRoaXMubmV4dENvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgIT09IG51bGwgJiYgdGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlID09PSB0aGlzLm5leHRDb250ZW50LmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJ3NraXAnOyAvLyBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5lcXVhbENvbXBvbmVudCh0aGlzLm5leHRDb250ZW50KSB8fFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZS5wYXJlbnROZXh0Q29udGVudEFjdGlvbiA9PT0gJ3N3YXAnIHx8IC8vIFNvbWUgcGFyZW50IGhhcyBiZWVuIHN3YXBwZWQsIG5lZWQgdG8gYmUgbmV3IGNvbXBvbmVudFxuICAgICAgICAgICAgbmF2aWdhdGlvbi5uYXZpZ2F0aW9uLnJlZnJlc2ggfHwgLy8gTmF2aWdhdGlvbiAncmVmcmVzaCcgcGVyZm9ybWVkXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucmVlbnRyeUJlaGF2aW9yKCkgPT09IFwicmVmcmVzaFwiIC8qIHJlZnJlc2ggKi8gLy8gUmVlbnRyeUJlaGF2aW9yICdyZWZyZXNoJyB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZS5kaXNhYmxlUmVwbGFjZWRDaGlsZHJlbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dENvbnRlbnRBY3Rpb24gPSAnc3dhcCc7IC8vIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcG9uZW50IGlzIHRoZSBzYW1lIG5hbWUvdHlwZVxuICAgICAgICAvLyBFeHBsaWNpdGx5IGRvbid0IGFsbG93IG5hdmlnYXRpb24gYmFjayB0byB0aGUgc2FtZSBjb21wb25lbnQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5yZWVudHJ5QmVoYXZpb3IoKSA9PT0gXCJkaXNhbGxvd1wiIC8qIGRpc2FsbG93ICovKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJ3NraXAnOyAvLyBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHBsaWNpdGx5IHJlLWxvYWQgc2FtZSBjb21wb25lbnQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5yZWVudHJ5QmVoYXZpb3IoKSA9PT0gXCJsb2FkXCIgLyogbG9hZCAqLykge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnJlZW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudC5jb250ZW50LnNldENvbXBvbmVudCh0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgLy8gdGhpcy5uZXh0Q29udGVudC5jb250ZW50U3RhdHVzID0gdGhpcy5jb250ZW50LmNvbnRlbnRTdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm5leHRDb250ZW50LmNvbnRlbnRTdGF0ZXMgPSB0aGlzLmNvbnRlbnQuY29udGVudFN0YXRlcy5jbG9uZSgpO1xuICAgICAgICAgICAgLy8gdGhpcy5uZXh0Q29udGVudC5jb250ZW50U3RhdGVzID0gbmV3IE1hcCh0aGlzLmNvbnRlbnQuY29udGVudFN0YXRlcyk7XG4gICAgICAgICAgICB0aGlzLm5leHRDb250ZW50LnJlZW50cnkgPSB0aGlzLmNvbnRlbnQucmVlbnRyeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJ3JlbG9hZCc7IC8vIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVlbnRyeUJlaGF2aW9yIGlzIG5vdyAnZGVmYXVsdCdcbiAgICAgICAgLy8gUmVxdWlyZXMgdXBkYXRlZCBwYXJhbWV0ZXJzIGlmIHZpZXdwb3J0IHN0YXRlZnVsXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhdGVmdWwgJiZcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5lcXVhbFBhcmFtZXRlcnModGhpcy5uZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dENvbnRlbnRBY3Rpb24gPSAnc2tpcCc7IC8vIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LmVxdWFsUGFyYW1ldGVycyh0aGlzLm5leHRDb250ZW50KSkge1xuICAgICAgICAgICAgLy8gVE9ETzogRml4IGEgY29uZmlnIG9wdGlvbiBmb3IgdGhpc1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKGZhbHNlKSB7IC8vIFJlLXVzZSBjb21wb25lbnQsIG9ubHkgcmVsb2FkIHdpdGggbmV3IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucmVlbnRyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudC5jb250ZW50LnNldENvbXBvbmVudCh0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENvbnRlbnQuY29udGVudFN0YXRlcyA9IHRoaXMuY29udGVudC5jb250ZW50U3RhdGVzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudC5yZWVudHJ5ID0gdGhpcy5jb250ZW50LnJlZW50cnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dENvbnRlbnRBY3Rpb24gPSAncmVsb2FkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBQZXJmb3JtIGEgZnVsbCBzd2FwXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZS5kaXNhYmxlUmVwbGFjZWRDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJ3N3YXAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgaXMgdG8gZG8gbm90aGluZ1xuICAgICAgICByZXR1cm4gJ3NraXAnO1xuICAgICAgICAvLyAvLyBEZWZhdWx0IGlzIHRvIHRyaWdnZXIgYSByZWZyZXNoICh3aXRob3V0IGEgY2hlY2sgb2YgcGFyYW1ldGVycylcbiAgICAgICAgLy8gdGhpcy5jb25uZWN0ZWRTY29wZS5kaXNhYmxlUmVwbGFjZWRDaGlsZHJlbigpO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5uZXh0Q29udGVudEFjdGlvbiA9ICdyZWxvYWQnOyAvLyB0cnVlO1xuICAgIH1cbiAgICBzZXRDb25uZWN0ZWRDRShjb25uZWN0ZWRDRSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkQ0UgIT09IGNvbm5lY3RlZENFKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXN0b3JlIHRoaXMgc3RhdGUgb24gbmF2aWdhdGlvbiBjYW5jZWxcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWaWV3cG9ydFN0YXRlID0geyAuLi50aGlzIH07XG4gICAgICAgICAgICB0aGlzLmNsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkQ0UgPSBjb25uZWN0ZWRDRTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZWRCeSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy51c2VkQnkgPSBvcHRpb25zLnVzZWRCeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGVmYXVsdCA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZhbGxiYWNrID0gb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5vTGluaykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ub0xpbmsgPSBvcHRpb25zLm5vTGluaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5vVGl0bGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubm9UaXRsZSA9IG9wdGlvbnMubm9UaXRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5vSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ub0hpc3RvcnkgPSBvcHRpb25zLm5vSGlzdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXRlZnVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0YXRlZnVsID0gb3B0aW9ucy5zdGF0ZWZ1bDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25SZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IE1pZ2h0IG5vdCBuZWVkIHRoaXM/IEZpZ3VyZSBpdCBvdXRcbiAgICAgICAgLy8gaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAvLyAgIGNvbnRhaW5lclsndmlld3BvcnROYW1lJ10gPSB0aGlzLm5hbWU7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF0aGlzLm5leHRDb250ZW50IHx8ICF0aGlzLm5leHRDb250ZW50LmNvbXBvbmVudEluc3RhbmNlKSAmJiB0aGlzLm9wdGlvbnMuZGVmYXVsdCkge1xuICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGhpcy5yb3V0ZXIuaW5zdHJ1Y3Rpb25SZXNvbHZlci5wYXJzZVZpZXdwb3J0SW5zdHJ1Y3Rpb25zKHRoaXMub3B0aW9ucy5kZWZhdWx0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRvIG5hbWUgdG8gYmUgZGVsYXllZCBvbmUgdHVyblxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLnNldFZpZXdwb3J0KHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uc2NvcGUgPSB0aGlzLm93bmluZ1Njb3BlO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmRlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb3V0ZXIubG9hZChpbnN0cnVjdGlvbnMsIHsgYXBwZW5kOiB0cnVlIH0pLmNhdGNoKGVycm9yID0+IHsgdGhyb3cgZXJyb3I7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjb25uZWN0ZWRDRSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRDRSA9PT0gY29ubmVjdGVkQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZnJlZUNvbnRlbnQodGhpcy5jb25uZWN0ZWRDRSwgKHRoaXMubmV4dENvbnRlbnQgPyB0aGlzLm5leHRDb250ZW50Lmluc3RydWN0aW9uIDogbnVsbCksIHRoaXMuaGlzdG9yeUNhY2hlLCB0aGlzLmRvRm9yY2VSZW1vdmUgPyBmYWxzZSA6IHRoaXMucm91dGVyLnN0YXRlZnVsSGlzdG9yeSB8fCB0aGlzLm9wdGlvbnMuc3RhdGVmdWwpOyAvLyAuY2F0Y2goZXJyb3IgPT4geyB0aHJvdyBlcnJvcjsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvRm9yY2VSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgdGhpcy5oaXN0b3J5Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaCgoKSA9PiBjb250ZW50LmZyZWVDb250ZW50KG51bGwsIG51bGwsIHRoaXMuaGlzdG9yeUNhY2hlLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaCgoKSA9PiB7IHRoaXMuaGlzdG9yeUNhY2hlID0gW107IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1biguLi5yZW1vdmVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuaGlzdG9yeUNhY2hlLm1hcChjb250ZW50ID0+IGNvbnRlbnQuZnJlZUNvbnRlbnQoXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHRoaXMuaGlzdG9yeUNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAvLyApKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuaGlzdG9yeUNhY2hlID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cmFuc2l0aW9uKGNvb3JkaW5hdG9yKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdWaWV3cG9ydCB0cmFuc2l0aW9uJywgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgLy8gbGV0IHJ1bjogdW5rbm93bjtcbiAgICAgICAgY29uc3QgZ3VhcmRlZCA9IGNvb3JkaW5hdG9yLmNoZWNraW5nU3luY1N0YXRlKCdndWFyZGVkJyk7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1Mb2FkID0gdGhpcy5wZXJmb3JtTG9hZCB8fCAhZ3VhcmRlZDtcbiAgICAgICAgY29uc3QgcGVyZm9ybVN3YXAgPSB0aGlzLnBlcmZvcm1Td2FwIHx8ICFndWFyZGVkO1xuICAgICAgICAvLyBjb25zdCBwZXJmb3JtU3dhcCA9IHRoaXMucGVyZm9ybVN3YXAgfHwgIXRoaXMucm91dGVyLmlzUmVzdHJpY3RlZE5hdmlnYXRpb24gfHwgdGhpcy5jbGVhcjtcbiAgICAgICAgY29uc3QgZ3VhcmRTdGVwcyA9IFtcbiAgICAgICAgICAgICgpID0+IHBlcmZvcm1Mb2FkID8gdGhpcy5jYW5VbmxvYWQoKSA6IHRydWUsXG4gICAgICAgICAgICAoY2FuVW5sb2FkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5VbmxvYWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgUnVubmVyLmNhbmNlbCh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3V0ZXIuaXNSZXN0cmljdGVkTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRDb250ZW50LmNyZWF0ZUNvbXBvbmVudCh0aGlzLmNvbm5lY3RlZENFLCB0aGlzLm9wdGlvbnMuZmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnZ3VhcmRlZFVubG9hZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgnZ3VhcmRlZFVubG9hZCcsIHRoaXMpLFxuICAgICAgICAgICAgKCkgPT4gcGVyZm9ybUxvYWQgPyB0aGlzLmNhbkxvYWQoZ3VhcmRlZCkgOiB0cnVlLFxuICAgICAgICAgICAgKGNhbkxvYWRSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbkxvYWRSZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbkxvYWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJ1bm5lci5jYW5jZWwodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdG9yLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdndWFyZGVkTG9hZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnZ3VhcmRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gRGVuaWVkIGFuZCAocHJvYmFibHkpIHJlZGlyZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgUnVubmVyLnJ1bigoKSA9PiB0aGlzLnJvdXRlci5sb2FkKGNhbkxvYWRSZXN1bHQsIHsgYXBwZW5kOiB0cnVlIH0pLCAoKSA9PiB0aGlzLmFib3J0Q29udGVudENoYW5nZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCByb3V0aW5nU3RlcHMgPSBbXG4gICAgICAgICAgICAvLyAoKSA9PiB7IGNvbnNvbGUubG9nKFwiSSdtIHdhaXRpbmcgZm9yIGd1YXJkZWRcIiwgdGhpcy50b1N0cmluZygpKTsgfSxcbiAgICAgICAgICAgICgpID0+IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgnZ3VhcmRlZCcsIHRoaXMpLFxuICAgICAgICAgICAgLy8gKCkgPT4geyBjb25zb2xlLmxvZyhcIkknbSBndWFyZGVkXCIsIHRoaXMudG9TdHJpbmcoKSk7IH0sXG4gICAgICAgICAgICAvLyBUT0RPOiBGb3IgY29uc2lzdGVuY3kgaXQgc2hvdWxkIHByb2JhYmx5IGJlIHRoaXMgb3B0aW9uIHdpdGggJ3JvdXRlZCdcbiAgICAgICAgICAgIC8vICgpID0+IHBlcmZvcm1Td2FwID8gdGhpcy51bmxvYWQoY29vcmRpbmF0b3IuY2hlY2tpbmdTeW5jU3RhdGUoJ3JvdXRlZCcpKSA6IHRydWUsXG4gICAgICAgICAgICAoKSA9PiBwZXJmb3JtTG9hZCA/IHRoaXMudW5sb2FkKHRydWUpIDogdHJ1ZSxcbiAgICAgICAgICAgICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICd1bmxvYWRlZCcpLFxuICAgICAgICAgICAgLy8gKCkgPT4geyBjb25zb2xlLmxvZyhcIkknbSB3YWl0aW5nIGZvciB1bmxvYWRlZFwiLCB0aGlzLnRvU3RyaW5nKCkpOyB9LFxuICAgICAgICAgICAgKCkgPT4gY29vcmRpbmF0b3Iuc3luY1N0YXRlKCd1bmxvYWRlZCcsIHRoaXMpLFxuICAgICAgICAgICAgLy8gKCkgPT4geyBjb25zb2xlLmxvZyhcIkknbSBkb25lIHdhaXRpbmcgZm9yIHVubG9hZGVkXCIsIHRoaXMudG9TdHJpbmcoKSk7IH0sXG4gICAgICAgICAgICAoKSA9PiBwZXJmb3JtTG9hZCA/IHRoaXMubG9hZChjb29yZGluYXRvci5jaGVja2luZ1N5bmNTdGF0ZSgncm91dGVkJykpIDogdHJ1ZSxcbiAgICAgICAgICAgICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdsb2FkZWQnKSxcbiAgICAgICAgICAgICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdyb3V0ZWQnKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlU3RlcHMgPSBbXG4gICAgICAgICAgICAoKSA9PiBjb29yZGluYXRvci5zeW5jU3RhdGUoJ3JvdXRlZCcsIHRoaXMpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAocGVyZm9ybVN3YXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlci5vcHRpb25zLnN3YXBTdHJhdGVneS5pbmNsdWRlcygncGFyYWxsZWwnKSkge1xuICAgICAgICAgICAgICAgIGxpZmVjeWNsZVN0ZXBzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3V0ZXIub3B0aW9ucy5zd2FwU3RyYXRlZ3kuaW5jbHVkZXMoJ2FkZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bih0aGlzLmFkZENvbnRlbnQoKSwgdGhpcy5yZW1vdmVDb250ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4odGhpcy5yZW1vdmVDb250ZW50KCksIHRoaXMuYWRkQ29udGVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlU3RlcHMucHVzaCgoKSA9PiBwZXJmb3JtU3dhcCA/ICh0aGlzLnJvdXRlci5vcHRpb25zLnN3YXBTdHJhdGVneS5pbmNsdWRlcygnYWRkJykgPyB0aGlzLmFkZENvbnRlbnQoKSA6IHRoaXMucmVtb3ZlQ29udGVudCgpKSA6IHZvaWQgMCwgKCkgPT4gcGVyZm9ybVN3YXAgPyAodGhpcy5yb3V0ZXIub3B0aW9ucy5zd2FwU3RyYXRlZ3kuaW5jbHVkZXMoJ2FkZCcpID8gdGhpcy5yZW1vdmVDb250ZW50KCkgOiB0aGlzLmFkZENvbnRlbnQoKSkgOiB2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpZmVjeWNsZVN0ZXBzLnB1c2goKCkgPT4gY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ3N3YXBwZWQnKSk7XG4gICAgICAgIC8vIGNvbnN0IGxpZmVjeWNsZVN0ZXBzID0gW1xuICAgICAgICAvLyAgICgpID0+IGNvb3JkaW5hdG9yLnN5bmNTdGF0ZSgncm91dGVkJyksXG4gICAgICAgIC8vICAgLy8gKCkgPT4gY29vcmRpbmF0b3IuYWRkRW50aXR5U3RhdGUodGhpcywgJ2JvdW5kJyksXG4gICAgICAgIC8vICAgKCkgPT4gcGVyZm9ybVN3YXAgPyAodGhpcy5yb3V0ZXIub3B0aW9ucy5zd2FwU3RyYXRlZ3kuaW5jbHVkZXMoJ2FkZCcpID8gdGhpcy5hZGRDb250ZW50KCkgOiB0aGlzLnJlbW92ZUNvbnRlbnQoKSkgOiB0cnVlLFxuICAgICAgICAvLyAgICgpID0+IHBlcmZvcm1Td2FwID8gKHRoaXMucm91dGVyLm9wdGlvbnMuc3dhcFN0cmF0ZWd5LmluY2x1ZGVzKCdhZGQnKSA/IHRoaXMucmVtb3ZlQ29udGVudCgpIDogdGhpcy5hZGRDb250ZW50KCkpIDogdHJ1ZSxcbiAgICAgICAgLy8gICAoKSA9PiBjb29yZGluYXRvci5hZGRFbnRpdHlTdGF0ZSh0aGlzLCAnc3dhcHBlZCcpLFxuICAgICAgICAvLyBdO1xuICAgICAgICAvLyBydW4gPVxuICAgICAgICBSdW5uZXIucnVuKC4uLmd1YXJkU3RlcHMsIC4uLnJvdXRpbmdTdGVwcywgLi4ubGlmZWN5Y2xlU3RlcHMsICgpID0+IGNvb3JkaW5hdG9yLmFkZEVudGl0eVN0YXRlKHRoaXMsICdjb21wbGV0ZWQnKSk7XG4gICAgfVxuICAgIGNhblVubG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZpZXdwb3J0IGNhblVubG9hZCBydW4nLCB0aGlzLm5hbWUsICdiZWZvcmUnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY29ubmVjdGVkU2NvcGUuY2FuVW5sb2FkKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndmlld3BvcnQgY2FuVW5sb2FkIHJ1bicsIHRoaXMubmFtZSwgJ2FmdGVyJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCAoY2FuVW5sb2FkQ2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd2aWV3cG9ydCBjYW5VbmxvYWQgcmVzdWx0JywgdGhpcy5uYW1lLCBjYW5VbmxvYWRDaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAoIWNhblVubG9hZENoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuXG4gICAgICAgICAgICAvLyAvLyBEb24ndCBzdG9wIGl0IGJlY2F1c2Ugd2UncmUgbm90IGdvaW5nIHRvIGFjdHVhbGx5IGRvIGFueXRoaW5nXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlID09PSB0aGlzLm5leHRDb250ZW50Py5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY2FuVW5sb2FkKHRoaXMubmV4dENvbnRlbnQ/Lmluc3RydWN0aW9uID8/IG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuTG9hZChyZWN1cnNlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY29ubmVjdGVkU2NvcGUudG9TdHJpbmcoKSwgJ3ZpZXdwb3J0IGNvbnRlbnQgY2FuTG9hZCcsIHRoaXMubmV4dENvbnRlbnQ/LmNvbnRlbnQ/LmNvbXBvbmVudE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5jbGVhcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLm5leHRDb250ZW50Py5jb250ZW50ID8/IG51bGwpID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLndhaXRGb3JDb25uZWN0ZWQoKSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q29udGVudC5jcmVhdGVDb21wb25lbnQodGhpcy5jb25uZWN0ZWRDRSwgdGhpcy5vcHRpb25zLmZhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAgICAgLy8gLy8gRG9uJ3Qgc3RvcCBpdCBiZWNhdXNlIHdlJ3JlIG5vdCBnb2luZyB0byBhY3R1YWxseSBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSA9PT0gdGhpcy5uZXh0Q29udGVudCEuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q29udGVudC5jYW5Mb2FkKHRoaXMsIHRoaXMuY29udGVudC5pbnN0cnVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkKHJlY3Vyc2UpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jb25uZWN0ZWRTY29wZS50b1N0cmluZygpLCAndmlld3BvcnQgY29udGVudCBsb2FkJywgdGhpcy5uZXh0Q29udGVudD8uY29udGVudD8uY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmNsZWFyIHx8ICh0aGlzLm5leHRDb250ZW50Py5jb21wb25lbnRJbnN0YW5jZSA/PyBudWxsKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlblxuICAgICAgICAvLyAvLyBUT0RPOiBWZXJpZnkgdGhpc1xuICAgICAgICAvLyBpZiAodGhpcy5uZXh0Q29udGVudCA9PT0gdGhpcy5jb250ZW50KSB7XG4gICAgICAgIC8vICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHRoaXMubmV4dENvbnRlbnQ/LmxvYWQodGhpcy5jb250ZW50Lmluc3RydWN0aW9uKSk7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLm5leHRDb250ZW50Py5sb2FkKHRoaXMuY29udGVudC5pbnN0cnVjdGlvbik7XG4gICAgICAgIC8vIGF3YWl0IHRoaXMubmV4dENvbnRlbnQuYWN0aXZhdGVDb21wb25lbnQobnVsbCwgdGhpcy5jb25uZWN0ZWRDRSEuJGNvbnRyb2xsZXIgYXMgSUN1c3RvbUVsZW1lbnRDb250cm9sbGVyPElDdXN0b21FbGVtZW50Vmlld01vZGVsPiwgTGlmZWN5Y2xlRmxhZ3Mubm9uZSwgdGhpcy5jb25uZWN0ZWRDRSEpO1xuICAgICAgICAvLyByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWRkQ29udGVudCgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkZENvbnRlbnQnLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLmFjdGl2YXRlKG51bGwsIHRoaXMuY29ubmVjdGVkQ29udHJvbGxlciwgMCAvKiBub25lICovLCB0aGlzLnBhcmVudE5leHRDb250ZW50QWN0aXZhdGVkKSk7XG4gICAgfVxuICAgIHJlbW92ZUNvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlQ29udGVudCcsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBSdW5uZXIucnVuKCgpID0+IHRoaXMuY29ubmVjdGVkU2NvcGUucmVtb3ZlQ29udGVudCgpLCAoKSA9PiB0aGlzLmRlYWN0aXZhdGUobnVsbCwgbnVsbCAvKiBUT0RPOiB2ZXJpZnkgdGhpcy5jb25uZWN0ZWRDb250cm9sbGVyICovLCAwIC8qIG5vbmUgKi8pLCAoKSA9PiB0aGlzLmRpc3Bvc2UoKSk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQ29udGVudCgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5uYW1lLCAncmVtb3ZlQ29udGVudCcsIHRoaXMuY29udGVudC5jb250ZW50KTtcbiAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4gIXRoaXMuaXNFbXB0eSA/IHRoaXMuY29ubmVjdGVkU2NvcGUucmVtb3ZlQ29udGVudCgpIDogdm9pZCAwKTtcbiAgICB9XG4gICAgYWN0aXZhdGUoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzLCBmcm9tUGFyZW50KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdhY3RpdmF0ZScgLyogLCB7IC4uLnRoaXMgfSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkU2NvcGUucmVlbmFibGVSZXBsYWNlZENoaWxkcmVuKCk7XG4gICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLmFjdGl2ZUNvbnRlbnQubG9hZCh0aGlzLmFjdGl2ZUNvbnRlbnQuaW5zdHJ1Y3Rpb24pLCAvLyBPbmx5IGFjdHMgaWYgbm90IGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAoKSA9PiB0aGlzLmFjdGl2ZUNvbnRlbnQuYWN0aXZhdGVDb21wb25lbnQoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzLCB0aGlzLmNvbm5lY3RlZENFLCBmcm9tUGFyZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZShpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgIXRoaXMuY29udGVudC5yZWVudHJ5ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuY29tcG9uZW50SW5zdGFuY2UgIT09IHRoaXMubmV4dENvbnRlbnQ/LmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLmNvbnRlbnQ/LnVubG9hZCh0aGlzLmNvbnRlbnQuaW5zdHJ1Y3Rpb24pLCAvLyBPbmx5IGFjdHMgaWYgbm90IGFscmVhZHkgdW5sb2FkZWRcbiAgICAgICAgICAgICgpID0+IHRoaXMuY29udGVudD8uZGVhY3RpdmF0ZUNvbXBvbmVudChpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MsIHRoaXMuY29ubmVjdGVkQ0UsIHRoaXMucm91dGVyLnN0YXRlZnVsSGlzdG9yeSB8fCB0aGlzLm9wdGlvbnMuc3RhdGVmdWwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmxvYWQocmVjdXJzZSkge1xuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiByZWN1cnNlID8gdGhpcy5jb25uZWN0ZWRTY29wZS51bmxvYWQocmVjdXJzZSkgOiB0cnVlLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvbm5lY3RlZFNjb3BlLnRvU3RyaW5nKCksICd2aWV3cG9ydCBjb250ZW50IHVubG9hZCcsIHRoaXMuY29udGVudC5jb250ZW50LmNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuXG4gICAgICAgICAgICAvLyAvLyBUT0RPOiBWZXJpZnkgdGhpc1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMubmV4dENvbnRlbnQgPT09IHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgLy8gICByZXR1cm47XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC51bmxvYWQodGhpcy5uZXh0Q29udGVudD8uaW5zdHJ1Y3Rpb24gPz8gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAhdGhpcy5jb250ZW50LnJlZW50cnkgJiZcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5jb21wb25lbnRJbnN0YW5jZSAhPT0gdGhpcy5uZXh0Q29udGVudD8uY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBSdW5uZXIucnVuKFxuICAgICAgICAgICAgLy8gKCkgPT4gdGhpcy5jb250ZW50IS51bmxvYWRDb21wb25lbnQoXG4gICAgICAgICAgICAvLyAgIHRoaXMuaGlzdG9yeUNhY2hlLFxuICAgICAgICAgICAgLy8gICB0aGlzLnJvdXRlci5zdGF0ZWZ1bEhpc3RvcnkgfHwgdGhpcy5vcHRpb25zLnN0YXRlZnVsKSxcbiAgICAgICAgICAgIC8vICgpID0+IHRoaXMuY29udGVudCEuZGVzdHJveUNvbXBvbmVudCgpLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5jb250ZW50LmRpc3Bvc2VDb21wb25lbnQodGhpcy5jb25uZWN0ZWRDRSwgdGhpcy5oaXN0b3J5Q2FjaGUsIHRoaXMucm91dGVyLnN0YXRlZnVsSGlzdG9yeSB8fCB0aGlzLm9wdGlvbnMuc3RhdGVmdWwpKTtcbiAgICAgICAgICAgIC8vIGF3YWl0IHRoaXMuY29udGVudCEuZnJlZUNvbnRlbnQoXG4gICAgICAgICAgICAvLyAgIHRoaXMuY29ubmVjdGVkQ0UsXG4gICAgICAgICAgICAvLyAgIHRoaXMubmV4dENvbnRlbnQhLmluc3RydWN0aW9uLFxuICAgICAgICAgICAgLy8gICB0aGlzLmhpc3RvcnlDYWNoZSxcbiAgICAgICAgICAgIC8vICAgdGhpcy5yb3V0ZXIuc3RhdGVmdWxIaXN0b3J5IHx8IHRoaXMub3B0aW9ucy5zdGF0ZWZ1bCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxpemVDb250ZW50Q2hhbmdlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZmluYWxpemVDb250ZW50JywgdGhpcy5uZXh0Q29udGVudCEuY29udGVudD8uY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGlmICh0aGlzLm5leHRDb250ZW50LmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLm5leHRDb250ZW50O1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbGVhcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gbmV3IFZpZXdwb3J0Q29udGVudCh2b2lkIDAsIHRoaXMubmV4dENvbnRlbnQuaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dENvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJyc7XG4gICAgICAgIHRoaXMucHJldmlvdXNWaWV3cG9ydFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRTY29wZS5jbGVhclJlcGxhY2VkQ2hpbGRyZW4oKTtcbiAgICB9XG4gICAgYWJvcnRDb250ZW50Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZFNjb3BlLnJlZW5hYmxlUmVwbGFjZWRDaGlsZHJlbigpO1xuICAgICAgICByZXR1cm4gUnVubmVyLnJ1bigoKSA9PiB0aGlzLm5leHRDb250ZW50LmZyZWVDb250ZW50KHRoaXMuY29ubmVjdGVkQ0UsIHRoaXMubmV4dENvbnRlbnQuaW5zdHJ1Y3Rpb24sIHRoaXMuaGlzdG9yeUNhY2hlLCB0aGlzLnJvdXRlci5zdGF0ZWZ1bEhpc3RvcnkgfHwgdGhpcy5vcHRpb25zLnN0YXRlZnVsKSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNWaWV3cG9ydFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB0aGlzLnByZXZpb3VzVmlld3BvcnRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHRDb250ZW50QWN0aW9uID0gJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBEZWFsIHdpdGggbm9uLXN0cmluZyBjb21wb25lbnRzXG4gICAgd2FudENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IHVzZWRCeSA9IHRoaXMub3B0aW9ucy51c2VkQnkgfHwgW107XG4gICAgICAgIGlmICh0eXBlb2YgdXNlZEJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdXNlZEJ5ID0gdXNlZEJ5LnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZWRCeS5pbmNsdWRlcyhjb21wb25lbnQpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBEZWFsIHdpdGggbm9uLXN0cmluZyBjb21wb25lbnRzXG4gICAgYWNjZXB0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50ID09PSAnLScgfHwgY29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXNlZEJ5ID0gdGhpcy5vcHRpb25zLnVzZWRCeTtcbiAgICAgICAgaWYgKCF1c2VkQnkgfHwgIXVzZWRCeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXNlZEJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdXNlZEJ5ID0gdXNlZEJ5LnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZWRCeS5pbmNsdWRlcyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlZEJ5LmZpbHRlcigodmFsdWUpID0+IHZhbHVlLmluY2x1ZGVzKCcqJykpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmcmVlQ29udGVudChjb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuaGlzdG9yeUNhY2hlLmZpbmQoY2FjaGVkID0+IGNhY2hlZC5jb21wb25lbnRJbnN0YW5jZSA9PT0gY29tcG9uZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIFJ1bm5lci5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50LmZyZWVDb250ZW50KG51bGwsIG51bGwsIHRoaXMuaGlzdG9yeUNhY2hlLCBmYWxzZSk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlbW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFycmF5UmVtb3ZlKHRoaXMuaGlzdG9yeUNhY2hlLCAoY2FjaGVkID0+IGNhY2hlZCA9PT0gY29udGVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Um91dGVzKCkge1xuICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gdGhpcy5nZXRDb21wb25lbnRUeXBlKCk7XG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZXMgPSBjb21wb25lbnRUeXBlLnJvdXRlcztcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocm91dGVzKSA/IHJvdXRlcyA6IG51bGw7XG4gICAgfVxuICAgIGdldFRpdGxlKG5hdmlnYXRpb25JbnN0cnVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vVGl0bGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gdGhpcy5nZXRDb21wb25lbnRUeXBlKCk7XG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpdGxlID0gJyc7XG4gICAgICAgIGNvbnN0IHR5cGVUaXRsZSA9IGNvbXBvbmVudFR5cGUudGl0bGU7XG4gICAgICAgIGlmICh0eXBlVGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlVGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSB0eXBlVGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSB0eXBlVGl0bGUuY2FsbChjb21wb25lbnQsIGNvbXBvbmVudCwgbmF2aWdhdGlvbkluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJvdXRlci5vcHRpb25zLnRpdGxlLnVzZUNvbXBvbmVudE5hbWVzKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHRoaXMuZ2V0Q29udGVudEluc3RydWN0aW9uKCkuY29tcG9uZW50TmFtZSA/PyAnJztcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMucm91dGVyLm9wdGlvbnMudGl0bGUuY29tcG9uZW50UHJlZml4ID8/ICcnO1xuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKCctJywgJyAnKTtcbiAgICAgICAgICAgIHRpdGxlID0gbmFtZS5zbGljZSgwLCAxKS50b0xvY2FsZVVwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3V0ZXIub3B0aW9ucy50aXRsZS50cmFuc2Zvcm1UaXRsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aXRsZSA9IHRoaXMucm91dGVyLm9wdGlvbnMudGl0bGUudHJhbnNmb3JtVGl0bGUuY2FsbCh0aGlzLCB0aXRsZSwgdGhpcy5nZXRDb250ZW50SW5zdHJ1Y3Rpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH1cbiAgICBnZXRDb21wb25lbnRUeXBlKCkge1xuICAgICAgICBsZXQgY29tcG9uZW50VHlwZSA9IHRoaXMuZ2V0Q29udGVudEluc3RydWN0aW9uKCkuY29tcG9uZW50VHlwZSA/PyBudWxsO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGdvaW5nIGF3YXkgb25jZSBNZXRhZGF0YSBpcyBpbiFcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBDdXN0b21FbGVtZW50LmZvcih0aGlzLmNvbm5lY3RlZENFLmVsZW1lbnQpO1xuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IGNvbnRyb2xsZXIuY29udGV4dFxuICAgICAgICAgICAgICAgIC5jb21wb25lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRUeXBlID8/IG51bGw7XG4gICAgfVxuICAgIGdldENvbXBvbmVudEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50SW5zdHJ1Y3Rpb24oKS5jb21wb25lbnRJbnN0YW5jZSA/PyBudWxsO1xuICAgIH1cbiAgICBnZXRDb250ZW50SW5zdHJ1Y3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDb250ZW50Py5jb250ZW50ID8/IHRoaXMuY29udGVudC5jb250ZW50ID8/IG51bGw7XG4gICAgfVxuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBuZXcgVmlld3BvcnRDb250ZW50KCk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBbXTtcbiAgICB9XG4gICAgd2FpdEZvckNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkQ0UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3cG9ydC5qcy5tYXAiLCJpbXBvcnQgeyBESSwgUmVnaXN0cmF0aW9uLCBvblJlc29sdmUsIHJlc29sdmVBbGwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSU5vZGUgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBJQXBwVGFzayB9IGZyb20gJy4vYXBwLXRhc2suanMnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudCB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50LmpzJztcbmltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICcuL3RlbXBsYXRpbmcvY29udHJvbGxlci5qcyc7XG5leHBvcnQgY29uc3QgSUFwcFJvb3QgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lBcHBSb290Jyk7XG5leHBvcnQgY2xhc3MgQXBwUm9vdCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBwbGF0Zm9ybSwgY29udGFpbmVyLCByb290UHJvdmlkZXIsIGVuaGFuY2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gKHZvaWQgMCk7XG4gICAgICAgIHRoaXMuaHlkcmF0ZVByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuaG9zdCA9IGNvbmZpZy5ob3N0O1xuICAgICAgICByb290UHJvdmlkZXIucHJlcGFyZSh0aGlzKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5oYXMoSU5vZGUsIGZhbHNlKSAmJiBjb250YWluZXIuZ2V0KElOb2RlKSAhPT0gY29uZmlnLmhvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZUNoaWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKElOb2RlLCBjb25maWcuaG9zdCkpO1xuICAgICAgICBpZiAoZW5oYW5jZSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29uZmlnLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHRoaXMuZW5oYW5jZURlZmluaXRpb24gPSBDdXN0b21FbGVtZW50LmdldERlZmluaXRpb24oQ3VzdG9tRWxlbWVudC5pc1R5cGUoY29tcG9uZW50KVxuICAgICAgICAgICAgICAgID8gQ3VzdG9tRWxlbWVudC5kZWZpbmUoeyAuLi5DdXN0b21FbGVtZW50LmdldERlZmluaXRpb24oY29tcG9uZW50KSwgdGVtcGxhdGU6IHRoaXMuaG9zdCwgZW5oYW5jZTogdHJ1ZSB9LCBjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgOiBDdXN0b21FbGVtZW50LmRlZmluZSh7IG5hbWU6ICh2b2lkIDApLCB0ZW1wbGF0ZTogdGhpcy5ob3N0LCBlbmhhbmNlOiB0cnVlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmh5ZHJhdGVQcm9taXNlID0gb25SZXNvbHZlKHRoaXMucnVuQXBwVGFza3MoJ2JlZm9yZUNyZWF0ZScpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IEN1c3RvbUVsZW1lbnQuaXNUeXBlKGNvbmZpZy5jb21wb25lbnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbnRhaW5lci5nZXQoY29uZmlnLmNvbXBvbmVudClcbiAgICAgICAgICAgICAgICA6IGNvbmZpZy5jb21wb25lbnQ7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gKHRoaXMuY29udHJvbGxlciA9IENvbnRyb2xsZXIuZm9yQ3VzdG9tRWxlbWVudCh0aGlzLCBjb250YWluZXIsIGluc3RhbmNlLCB0aGlzLmhvc3QsIG51bGwsIDAgLyogbm9uZSAqLywgZmFsc2UsIHRoaXMuZW5oYW5jZURlZmluaXRpb24pKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuaHlkcmF0ZUN1c3RvbUVsZW1lbnQoY29udGFpbmVyLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5ydW5BcHBUYXNrcygnaHlkcmF0aW5nJyksICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmh5ZHJhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSh0aGlzLnJ1bkFwcFRhc2tzKCdoeWRyYXRlZCcpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuaHlkcmF0ZUNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHlkcmF0ZVByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICByZXR1cm4gb25SZXNvbHZlKHRoaXMuaHlkcmF0ZVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5ydW5BcHBUYXNrcygnYmVmb3JlQWN0aXZhdGUnKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5jb250cm9sbGVyLmFjdGl2YXRlKHRoaXMuY29udHJvbGxlciwgbnVsbCwgMzIgLyogZnJvbUJpbmQgKi8sIHZvaWQgMCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuQXBwVGFza3MoJ2FmdGVyQWN0aXZhdGUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSh0aGlzLnJ1bkFwcFRhc2tzKCdiZWZvcmVEZWFjdGl2YXRlJyksICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5jb250cm9sbGVyLmRlYWN0aXZhdGUodGhpcy5jb250cm9sbGVyLCBudWxsLCAwIC8qIG5vbmUgKi8pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuQXBwVGFza3MoJ2FmdGVyRGVhY3RpdmF0ZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgcnVuQXBwVGFza3Moc2xvdCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFsbCguLi50aGlzLmNvbnRhaW5lci5nZXRBbGwoSUFwcFRhc2spLnJlZHVjZSgocmVzdWx0cywgdGFzaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhc2suc2xvdCA9PT0gc2xvdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0YXNrLnJ1bigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9LCBbXSkpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXI/LmRpc3Bvc2UoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm9vdC5qcy5tYXAiLCJpbXBvcnQgeyBESSwgUmVnaXN0cmF0aW9uLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgY29uc3QgSUFwcFRhc2sgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lBcHBUYXNrJyk7XG5jbGFzcyAkQXBwVGFzayB7XG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnNsb3QgPSAodm9pZCAwKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9ICh2b2lkIDApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9ICh2b2lkIDApO1xuICAgIH1cbiAgICBzdGF0aWMgd2l0aChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkQXBwVGFzayhrZXkpO1xuICAgIH1cbiAgICBiZWZvcmVDcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0KCdiZWZvcmVDcmVhdGUnKTtcbiAgICB9XG4gICAgaHlkcmF0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdCgnaHlkcmF0aW5nJyk7XG4gICAgfVxuICAgIGh5ZHJhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdCgnaHlkcmF0ZWQnKTtcbiAgICB9XG4gICAgYmVmb3JlQWN0aXZhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0KCdiZWZvcmVBY3RpdmF0ZScpO1xuICAgIH1cbiAgICBhZnRlckFjdGl2YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdCgnYWZ0ZXJBY3RpdmF0ZScpO1xuICAgIH1cbiAgICBiZWZvcmVEZWFjdGl2YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdCgnYmVmb3JlRGVhY3RpdmF0ZScpO1xuICAgIH1cbiAgICBhZnRlckRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0KCdhZnRlckRlYWN0aXZhdGUnKTtcbiAgICB9XG4gICAgYXQoc2xvdCkge1xuICAgICAgICB0aGlzLnNsb3QgPSBzbG90O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FsbChmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyLnJlZ2lzdGVyKFJlZ2lzdHJhdGlvbi5pbnN0YW5jZShJQXBwVGFzaywgdGhpcykpO1xuICAgIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5jYWxsYmFjaztcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmNvbnRhaW5lci5nZXQodGhpcy5rZXkpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBBcHBUYXNrID0gJEFwcFRhc2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtdGFzay5qcy5tYXAiLCJpbXBvcnQgeyBESSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgY29uc3QgSUF0dHJTeW50YXhUcmFuc2Zvcm1lciA9IERJXG4gICAgLmNyZWF0ZUludGVyZmFjZSgnSUF0dHJTeW50YXhUcmFuc2Zvcm1lcicsIHggPT4geC5zaW5nbGV0b24oQXR0clN5bnRheFRyYW5zZm9ybWVyKSk7XG5leHBvcnQgY2xhc3MgQXR0clN5bnRheFRyYW5zZm9ybWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgZ2l2ZW4gZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGZucyB0aGF0IHdpbGwgYmUgdXNlZFxuICAgICAqIHRvIGNoZWNrIGlmIGAnYmluZCdgIGNvbW1hbmQgY2FuIGJlIHRyYW5zZm9ybWVkIHRvIGAndHdvLXdheSdgIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBJZiBvbmUgb2YgdGhvc2UgZnVuY3Rpb25zIGluIHRoaXMgbGlzdHMgcmV0dXJucyB0cnVlLCB0aGUgYCdiaW5kJ2AgY29tbWFuZFxuICAgICAqIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50byBgJ3R3by13YXknYCBjb21tYW5kLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggMiBwYXJhbWV0ZXJzOlxuICAgICAqIC0gZWxlbWVudDogdGhlIGVsZW1lbnQgdGhhdCB0aGUgdGVtcGxhdGUgY29tcGlsZXIgaXMgY3VycmVudGx5IHdvcmtpbmcgd2l0aFxuICAgICAqIC0gcHJvcGVydHk6IHRoZSB0YXJnZXQgcHJvcGVydHkgbmFtZVxuICAgICAqL1xuICAgIHVzZVR3b1dheShmbikge1xuICAgICAgICB0aGlzLmZucy5wdXNoKGZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdHJhbnNmb3JtKG5vZGUsIGF0dHJTeW50YXgpIHtcbiAgICAgICAgaWYgKGF0dHJTeW50YXguY29tbWFuZCA9PT0gJ2JpbmQnICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAvLyBub3RlOiBldmVuIHRob3VnaCB0YXJnZXQgY291bGQgcG9zc2libHkgYmUgbWFwcGVkIHRvIGEgZGlmZmVyZW50IG5hbWVcbiAgICAgICAgICAgIC8vIHRoZSBmaW5hbCBwcm9wZXJ0eSBuYW1lIHNob3VsZG4ndCBhZmZlY3QgdGhlIHR3byB3YXkgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGFzIHRoZXkgYm90aCBzaG91bGQgd29yayB3aXRoIG9yaWdpbmFsIHNvdXJjZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgc2hvdWxkRGVmYXVsdFRvVHdvV2F5KG5vZGUsIGF0dHJTeW50YXgudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZm5zLmxlbmd0aCA+IDAgJiYgdGhpcy5mbnMuc29tZShmbiA9PiBmbihub2RlLCBhdHRyU3ludGF4LnRhcmdldCkpKSkge1xuICAgICAgICAgICAgYXR0clN5bnRheC5jb21tYW5kID0gJ3R3by13YXknO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJTeW50YXgudGFyZ2V0ID0gdGhpcy5tYXAobm9kZS50YWdOYW1lLCBhdHRyU3ludGF4LnRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRvZG86IHRoaXMgc2hvdWxkIGJlIGluIHRoZSBmb3JtIG9mIGEgbG9va3VwLiB0aGUgZm9sbG93aW5nIGlzIG5vdCBleHRlbnNpYmxlXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtYXAodGFnTmFtZSwgYXR0cikge1xuICAgICAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0xBQkVMJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaHRtbEZvcic7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdJTUcnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1c2VtYXAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd1c2VNYXAnO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXhsZW5ndGgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtYXhMZW5ndGgnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaW5sZW5ndGgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtaW5MZW5ndGgnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3JtYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZm9ybUFjdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zvcm1lbmN0eXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZm9ybUVuY1R5cGUnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3JtbWV0aG9kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZm9ybU1ldGhvZCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zvcm1ub3ZhbGlkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZm9ybU5vVmFsaWRhdGUnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3JtdGFyZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZm9ybVRhcmdldCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lucHV0bW9kZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2lucHV0TW9kZSc7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdURVhUQVJFQSc6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21heGxlbmd0aCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21heExlbmd0aCc7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdURCc6XG4gICAgICAgICAgICBjYXNlICdUSCc6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Jvd3NwYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyb3dTcGFuJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29sc3Bhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbFNwYW4nO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWNjZXNza2V5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWNjZXNzS2V5JztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udGVudGVkaXRhYmxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnY29udGVudEVkaXRhYmxlJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGFiaW5kZXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0YWJJbmRleCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRjb250ZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndGV4dENvbnRlbnQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbm5lcmh0bWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdpbm5lckhUTUwnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzY3JvbGx0b3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdzY3JvbGxUb3AnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzY3JvbGxsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnc2Nyb2xsTGVmdCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlYWRvbmx5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncmVhZE9ubHknO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkRGVmYXVsdFRvVHdvV2F5KGVsZW1lbnQsIGF0dHIpIHtcbiAgICBzd2l0Y2ggKGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICBjYXNlICdJTlBVVCc6XG4gICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyID09PSAnY2hlY2tlZCc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHIgPT09ICd2YWx1ZScgfHwgYXR0ciA9PT0gJ2ZpbGVzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxuICAgICAgICBjYXNlICdTRUxFQ1QnOlxuICAgICAgICAgICAgcmV0dXJuIGF0dHIgPT09ICd2YWx1ZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Y29udGVudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5uZXJodG1sJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAgICAgICAgICAgICBjYXNlICdzY3JvbGx0b3AnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Njcm9sbGxlZnQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0cmlidXRlLXN5bnRheC10cmFuc2Zvcm1lci5qcy5tYXAiLCJpbXBvcnQgeyBESSwgUmVnaXN0cmF0aW9uLCBJbnN0YW5jZVByb3ZpZGVyLCBvblJlc29sdmUgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQnJvd3NlclBsYXRmb3JtIH0gZnJvbSAnQGF1cmVsaWEvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBBcHBSb290LCBJQXBwUm9vdCB9IGZyb20gJy4vYXBwLXJvb3QuanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5leHBvcnQgY29uc3QgSUF1cmVsaWEgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lBdXJlbGlhJyk7XG5leHBvcnQgY2xhc3MgQXVyZWxpYSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyID0gREkuY3JlYXRlQ29udGFpbmVyKCkpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1N0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU3RvcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnN0YXJ0UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5zdG9wUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5oYXMoSUF1cmVsaWEsIHRydWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGluc3RhbmNlIG9mIEF1cmVsaWEgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggdGhlIGNvbnRhaW5lciBvciBhbiBhbmNlc3RvciBvZiBpdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKElBdXJlbGlhLCB0aGlzKSk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKElBcHBSb290LCB0aGlzLnJvb3RQcm92aWRlciA9IG5ldyBJbnN0YW5jZVByb3ZpZGVyKCdJQXBwUm9vdCcpKTtcbiAgICB9XG4gICAgZ2V0IGlzUnVubmluZygpIHsgcmV0dXJuIHRoaXMuX2lzUnVubmluZzsgfVxuICAgIGdldCBpc1N0YXJ0aW5nKCkgeyByZXR1cm4gdGhpcy5faXNTdGFydGluZzsgfVxuICAgIGdldCBpc1N0b3BwaW5nKCkgeyByZXR1cm4gdGhpcy5faXNTdG9wcGluZzsgfVxuICAgIGdldCByb290KCkge1xuICAgICAgICBpZiAodGhpcy5fcm9vdCA9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQgPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByb290IGlzIG5vdCBkZWZpbmVkYCk7IC8vIFRPRE86IGNyZWF0ZSBlcnJvciBjb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH1cbiAgICByZWdpc3RlciguLi5wYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVnaXN0ZXIoLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFwcChjb25maWcpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV3IEFwcFJvb3QoY29uZmlnLCB0aGlzLmluaXRQbGF0Zm9ybShjb25maWcuaG9zdCksIHRoaXMuY29udGFpbmVyLCB0aGlzLnJvb3RQcm92aWRlciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW5oYW5jZShjb25maWcpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV3IEFwcFJvb3QoY29uZmlnLCB0aGlzLmluaXRQbGF0Zm9ybShjb25maWcuaG9zdCksIHRoaXMuY29udGFpbmVyLCB0aGlzLnJvb3RQcm92aWRlciwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9ySWRsZSgpIHtcbiAgICAgICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnJvb3QucGxhdGZvcm07XG4gICAgICAgIGF3YWl0IHBsYXRmb3JtLmRvbVdyaXRlUXVldWUueWllbGQoKTtcbiAgICAgICAgYXdhaXQgcGxhdGZvcm0uZG9tUmVhZFF1ZXVlLnlpZWxkKCk7XG4gICAgICAgIGF3YWl0IHBsYXRmb3JtLm1hY3JvVGFza1F1ZXVlLnlpZWxkKCk7XG4gICAgfVxuICAgIGluaXRQbGF0Zm9ybShob3N0KSB7XG4gICAgICAgIGxldCBwO1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyLmhhcyhJUGxhdGZvcm0sIGZhbHNlKSkge1xuICAgICAgICAgICAgaWYgKGhvc3Qub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgdGhlIHBsYXRmb3JtIG9iamVjdC4gVGhlIGhvc3QgZWxlbWVudCdzIG93bmVyRG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHRWaWV3YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gbmV3IEJyb3dzZXJQbGF0Zm9ybShob3N0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKElQbGF0Zm9ybSwgcCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCA9IHRoaXMuY29udGFpbmVyLmdldChJUGxhdGZvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzdGFydChyb290ID0gdGhpcy5uZXh0KSB7XG4gICAgICAgIGlmIChyb290ID09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBjb21wb3NpdGlvbiByb290YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UHJvbWlzZSA9IG9uUmVzb2x2ZSh0aGlzLnN0b3AoKSwgKCkgPT4ge1xuICAgICAgICAgICAgUmVmbGVjdC5zZXQocm9vdC5ob3N0LCAnJGF1cmVsaWEnLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucm9vdFByb3ZpZGVyLnByZXBhcmUodGhpcy5fcm9vdCA9IHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5faXNTdGFydGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gb25SZXNvbHZlKHJvb3QuYWN0aXZhdGUoKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChyb290LCAnYXUtc3RhcnRlZCcsIHJvb3QuaG9zdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3AoZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU3RvcHBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcFByb21pc2UgPSBvblJlc29sdmUocm9vdC5kZWFjdGl2YXRlKCksICgpID0+IHtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHJvb3QuaG9zdCwgJyRhdXJlbGlhJyk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290UHJvdmlkZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU3RvcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocm9vdCwgJ2F1LXN0b3BwZWQnLCByb290Lmhvc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZyB8fCB0aGlzLl9pc1N0b3BwaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBhdXJlbGlhIGluc3RhbmNlIG11c3QgYmUgZnVsbHkgc3RvcHBlZCBiZWZvcmUgaXQgY2FuIGJlIGRpc3Bvc2VkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBkaXNwYXRjaEV2ZW50KHJvb3QsIG5hbWUsIHRhcmdldCkge1xuICAgICAgICBjb25zdCBldiA9IG5ldyByb290LnBsYXRmb3JtLndpbmRvdy5DdXN0b21FdmVudChuYW1lLCB7IGRldGFpbDogdGhpcywgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1cmVsaWEuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsga2ViYWJDYXNlLCBNZXRhZGF0YSwgUHJvdG9jb2wsIGZpcnN0RGVmaW5lZCwgZ2V0UHJvdG90eXBlQ2hhaW4sIG5vb3AsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdNb2RlLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRhYmxlKGNvbmZpZ09yVGFyZ2V0LCBwcm9wKSB7XG4gICAgbGV0IGNvbmZpZztcbiAgICBmdW5jdGlvbiBkZWNvcmF0b3IoJHRhcmdldCwgJHByb3ApIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBOb24gaW52b2NhdGlvbjpcbiAgICAgICAgICAgIC8vIC0gQGJpbmRhYmxlXG4gICAgICAgICAgICAvLyBJbnZvY2F0aW9uIHdpdGggb3Igdy9vIG9wdHM6XG4gICAgICAgICAgICAvLyAtIEBiaW5kYWJsZSgpXG4gICAgICAgICAgICAvLyAtIEBiaW5kYWJsZSh7Li4ub3B0c30pXG4gICAgICAgICAgICBjb25maWcucHJvcGVydHkgPSAkcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQmluZGFibGUubmFtZSwgQmluZGFibGVEZWZpbml0aW9uLmNyZWF0ZSgkcHJvcCwgY29uZmlnKSwgJHRhcmdldC5jb25zdHJ1Y3RvciwgJHByb3ApO1xuICAgICAgICBQcm90b2NvbC5hbm5vdGF0aW9uLmFwcGVuZFRvKCR0YXJnZXQuY29uc3RydWN0b3IsIEJpbmRhYmxlLmtleUZyb20oJHByb3ApKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIE5vbiBpbnZvY2F0aW9uOlxuICAgICAgICAvLyAtIEBiaW5kYWJsZVxuICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgZGVjb3JhdG9yKGNvbmZpZ09yVGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnT3JUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIENsYXNzRGVjb3JhdG9yXG4gICAgICAgIC8vIC0gQGJpbmRhYmxlKCdiYXInKVxuICAgICAgICAvLyBEaXJlY3QgY2FsbDpcbiAgICAgICAgLy8gLSBAYmluZGFibGUoJ2JhcicpKEZvbylcbiAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgfVxuICAgIC8vIEludm9jYXRpb24gd2l0aCBvciB3L28gb3B0czpcbiAgICAvLyAtIEBiaW5kYWJsZSgpXG4gICAgLy8gLSBAYmluZGFibGUoey4uLm9wdHN9KVxuICAgIGNvbmZpZyA9IGNvbmZpZ09yVGFyZ2V0ID09PSB2b2lkIDAgPyB7fSA6IGNvbmZpZ09yVGFyZ2V0O1xuICAgIHJldHVybiBkZWNvcmF0b3I7XG59XG5mdW5jdGlvbiBpc0JpbmRhYmxlQW5ub3RhdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoQmluZGFibGUubmFtZSk7XG59XG5leHBvcnQgY29uc3QgQmluZGFibGUgPSB7XG4gICAgbmFtZTogUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IoJ2JpbmRhYmxlJyksXG4gICAga2V5RnJvbShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtCaW5kYWJsZS5uYW1lfToke25hbWV9YDtcbiAgICB9LFxuICAgIGZyb20oLi4uYmluZGFibGVMaXN0cykge1xuICAgICAgICBjb25zdCBiaW5kYWJsZXMgPSB7fTtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgICAgIGZ1bmN0aW9uIGFkZE5hbWUobmFtZSkge1xuICAgICAgICAgICAgYmluZGFibGVzW25hbWVdID0gQmluZGFibGVEZWZpbml0aW9uLmNyZWF0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGREZXNjcmlwdGlvbihuYW1lLCBkZWYpIHtcbiAgICAgICAgICAgIGJpbmRhYmxlc1tuYW1lXSA9IGRlZiBpbnN0YW5jZW9mIEJpbmRhYmxlRGVmaW5pdGlvbiA/IGRlZiA6IEJpbmRhYmxlRGVmaW5pdGlvbi5jcmVhdGUobmFtZSwgZGVmKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRMaXN0KG1heWJlTGlzdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkobWF5YmVMaXN0KSkge1xuICAgICAgICAgICAgICAgIG1heWJlTGlzdC5mb3JFYWNoKGFkZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF5YmVMaXN0IGluc3RhbmNlb2YgQmluZGFibGVEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmluZGFibGVzW21heWJlTGlzdC5wcm9wZXJ0eV0gPSBtYXliZUxpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXliZUxpc3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1heWJlTGlzdCkuZm9yRWFjaChuYW1lID0+IGFkZERlc2NyaXB0aW9uKG5hbWUsIG1heWJlTGlzdFtuYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJpbmRhYmxlTGlzdHMuZm9yRWFjaChhZGRMaXN0KTtcbiAgICAgICAgcmV0dXJuIGJpbmRhYmxlcztcbiAgICB9LFxuICAgIGZvcihUeXBlKSB7XG4gICAgICAgIGxldCBkZWY7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSB7XG4gICAgICAgICAgICBhZGQoY29uZmlnT3JQcm9wKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3A7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ09yUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ09yUHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0geyBwcm9wZXJ0eTogcHJvcCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ09yUHJvcC5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnT3JQcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWYgPSBCaW5kYWJsZURlZmluaXRpb24uY3JlYXRlKHByb3AsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKCFNZXRhZGF0YS5oYXNPd24oQmluZGFibGUubmFtZSwgVHlwZSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgUHJvdG9jb2wuYW5ub3RhdGlvbi5hcHBlbmRUbyhUeXBlLCBCaW5kYWJsZS5rZXlGcm9tKHByb3ApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEJpbmRhYmxlLm5hbWUsIGRlZiwgVHlwZSwgcHJvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZShtb2RlKSB7XG4gICAgICAgICAgICAgICAgZGVmLm1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZGVmLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIGRlZi5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpbWFyeSgpIHtcbiAgICAgICAgICAgICAgICBkZWYucHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHNldEludGVycHJldGVyKSB7XG4gICAgICAgICAgICAgICAgZGVmLnNldCA9IHNldEludGVycHJldGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGdldEFsbChUeXBlKSB7XG4gICAgICAgIGNvbnN0IHByb3BTdGFydCA9IEJpbmRhYmxlLm5hbWUubGVuZ3RoICsgMTtcbiAgICAgICAgY29uc3QgZGVmcyA9IFtdO1xuICAgICAgICBjb25zdCBwcm90b3R5cGVDaGFpbiA9IGdldFByb3RvdHlwZUNoYWluKFR5cGUpO1xuICAgICAgICBsZXQgaVByb3RvID0gcHJvdG90eXBlQ2hhaW4ubGVuZ3RoO1xuICAgICAgICBsZXQgaURlZnMgPSAwO1xuICAgICAgICBsZXQga2V5cztcbiAgICAgICAgbGV0IGtleXNMZW47XG4gICAgICAgIGxldCBDbGFzcztcbiAgICAgICAgd2hpbGUgKC0taVByb3RvID49IDApIHtcbiAgICAgICAgICAgIENsYXNzID0gcHJvdG90eXBlQ2hhaW5baVByb3RvXTtcbiAgICAgICAgICAgIGtleXMgPSBQcm90b2NvbC5hbm5vdGF0aW9uLmdldEtleXMoQ2xhc3MpLmZpbHRlcihpc0JpbmRhYmxlQW5ub3RhdGlvbik7XG4gICAgICAgICAgICBrZXlzTGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGRlZnNbaURlZnMrK10gPSBNZXRhZGF0YS5nZXRPd24oQmluZGFibGUubmFtZSwgQ2xhc3MsIGtleXNbaV0uc2xpY2UocHJvcFN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZnM7XG4gICAgfSxcbn07XG5leHBvcnQgY2xhc3MgQmluZGFibGVEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGUsIGNhbGxiYWNrLCBtb2RlLCBwcmltYXJ5LCBwcm9wZXJ0eSwgc2V0KSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMucHJpbWFyeSA9IHByaW1hcnk7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocHJvcCwgZGVmID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kYWJsZURlZmluaXRpb24oZmlyc3REZWZpbmVkKGRlZi5hdHRyaWJ1dGUsIGtlYmFiQ2FzZShwcm9wKSksIGZpcnN0RGVmaW5lZChkZWYuY2FsbGJhY2ssIGAke3Byb3B9Q2hhbmdlZGApLCBmaXJzdERlZmluZWQoZGVmLm1vZGUsIEJpbmRpbmdNb2RlLnRvVmlldyksIGZpcnN0RGVmaW5lZChkZWYucHJpbWFyeSwgZmFsc2UpLCBmaXJzdERlZmluZWQoZGVmLnByb3BlcnR5LCBwcm9wKSwgZmlyc3REZWZpbmVkKGRlZi5zZXQsIG5vb3ApKTtcbiAgICB9XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMsc3BhY2VkLWNvbW1lbnQgKi9cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzZXJ2ZXMgdHdvIHB1cnBvc2VzOlxuICogLSBBIHBsYXlncm91bmQgZm9yIGNvbnRyaWJ1dG9ycyB0byB0cnkgdGhlaXIgY2hhbmdlcyB0byB0aGUgQVBJcy5cbiAqIC0gQ2F1c2UgdGhlIEFQSSBzdXJmYWNlIHRvIGJlIHByb3Blcmx5IHR5cGUtY2hlY2tlZCBhbmQgcHJvdGVjdGVkIGFnYWluc3QgYWNjaWRlbnRhbCB0eXBlIHJlZ3Jlc3Npb25zLlxuICpcbiAqIEl0IHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGJ5IGRlYWQgY29kZSBlbGltaW5hdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXBpVHlwZUNoZWNrKCkge1xuICAgIGxldCBGb28gPSBcbiAgICAvLyA+IGV4cGVjdGVkIGVycm9yIC0gY2xhc3MgZGVjb3JhdG9yIG9ubHkgYWNjZXB0cyBhIHN0cmluZ1xuICAgIC8vQGJpbmRhYmxlKHt9KVxuICAgIGNsYXNzIEZvbyB7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgYmluZGFibGUsXG4gICAgICAgIGJpbmRhYmxlKCksXG4gICAgICAgIGJpbmRhYmxlKHt9KVxuICAgICAgICAvLyA+IGV4cGVjdGVkIGVycm9yIC0gJ3Byb3BlcnR5JyBkb2VzIG5vdCBleGlzdCBvbiBkZWNvcmF0b3IgaW5wdXQgb2JqZWN0XG4gICAgICAgIC8vQGJpbmRhYmxlKHsgcHJvcGVydHk6ICdwcm9wJyB9KVxuICAgICAgICAsXG4gICAgICAgIGJpbmRhYmxlKHsgbW9kZTogQmluZGluZ01vZGUudHdvV2F5IH0pLFxuICAgICAgICBiaW5kYWJsZSh7IGNhbGxiYWNrOiAncHJvcENoYW5nZWQnIH0pLFxuICAgICAgICBiaW5kYWJsZSh7IGF0dHJpYnV0ZTogJ3Byb3AnIH0pLFxuICAgICAgICBiaW5kYWJsZSh7IHByaW1hcnk6IHRydWUgfSksXG4gICAgICAgIGJpbmRhYmxlKHsgc2V0OiB2YWx1ZSA9PiBTdHJpbmcodmFsdWUpIH0pLFxuICAgICAgICBiaW5kYWJsZSh7IHNldDogdmFsdWUgPT4gTnVtYmVyKHZhbHVlKSB9KSxcbiAgICAgICAgYmluZGFibGUoe1xuICAgICAgICAgICAgbW9kZTogQmluZGluZ01vZGUudHdvV2F5LFxuICAgICAgICAgICAgY2FsbGJhY2s6ICdwcm9wQ2hhbmdlZCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdwcm9wJyxcbiAgICAgICAgICAgIHByaW1hcnk6IHRydWUsXG4gICAgICAgICAgICBzZXQ6IHZhbHVlID0+IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfSlcbiAgICBdLCBGb28ucHJvdG90eXBlLCBcInByb3BcIiwgdm9pZCAwKTtcbiAgICBGb28gPSBfX2RlY29yYXRlKFtcbiAgICAgICAgYmluZGFibGUoJ3Byb3AnKVxuICAgICAgICAvLyA+IGV4cGVjdGVkIGVycm9yIC0gY2xhc3MgZGVjb3JhdG9yIG9ubHkgYWNjZXB0cyBhIHN0cmluZ1xuICAgICAgICAvL0BiaW5kYWJsZSh7fSlcbiAgICBdLCBGb28pO1xuICAgIEJpbmRhYmxlLmZvcihGb28pXG4gICAgICAgIC8vID4gZXhwZWN0ZWQgZXJyb3IgLSB0aGVyZSBpcyBubyBhZGQoKSBmdW5jdGlvbiB3aXRoIG9ubHkgb3B0aW9uYWwgcGFyYW1zIG9uIHRoZSBmbHVlbnQgYXBpXG4gICAgICAgIC8vLmFkZCgpXG4gICAgICAgIC8vID4gZXhwZWN0ZWQgZXJyb3IgLSAncHJvcGVydHknIGlzIGEgcmVxdWlyZWQgcHJvcGVydHkgb24gdGhlIGZsdWVudCBhcGlcbiAgICAgICAgLy8uYWRkKHt9KVxuICAgICAgICAuYWRkKHsgcHJvcGVydHk6ICdwcm9wJyB9KVxuICAgICAgICAuYWRkKHsgcHJvcGVydHk6ICdwcm9wJywgbW9kZTogQmluZGluZ01vZGUudHdvV2F5IH0pXG4gICAgICAgIC5hZGQoeyBwcm9wZXJ0eTogJ3Byb3AnLCBjYWxsYmFjazogJ3Byb3BDaGFuZ2VkJyB9KVxuICAgICAgICAuYWRkKHsgcHJvcGVydHk6ICdwcm9wJywgYXR0cmlidXRlOiAncHJvcCcgfSlcbiAgICAgICAgLmFkZCh7IHByb3BlcnR5OiAncHJvcCcsIHByaW1hcnk6IHRydWUgfSlcbiAgICAgICAgLmFkZCh7IHByb3BlcnR5OiAncHJvcCcsIG1vZGU6IEJpbmRpbmdNb2RlLnR3b1dheSwgY2FsbGJhY2s6ICdwcm9wQ2hhbmdlZCcsIGF0dHJpYnV0ZTogJ3Byb3AnLCBwcmltYXJ5OiB0cnVlIH0pXG4gICAgICAgIC5hZGQoJ3Byb3AnKVxuICAgICAgICAvLyA+IGV4cGVjdGVkIGVycm9yIC0gdGhlIGFkZCgpIG1ldGhvZCB0aGF0IGFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwgZG9lcyBub3QgcmV0dXJuIGEgZmx1ZW50IGFwaVxuICAgICAgICAvLy5hZGQoeyBwcm9wZXJ0eTogJ3Byb3AnIH0pLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KVxuICAgICAgICAvLy5hZGQoeyBwcm9wZXJ0eTogJ3Byb3AnIH0pLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpXG4gICAgICAgIC8vLmFkZCh7IHByb3BlcnR5OiAncHJvcCcgfSkuYXR0cmlidXRlKCdwcm9wJylcbiAgICAgICAgLy8uYWRkKHsgcHJvcGVydHk6ICdwcm9wJyB9KS5wcmltYXJ5KClcbiAgICAgICAgLy8gPiBleHBlY3RlZCBlcnJvciAtIGZsdWVudCBhcGkgbWV0aG9kcyBjYW4gb25seSBiZSBpbnZva2VkIG9uY2UgcGVyIGJpbmRhYmxlXG4gICAgICAgIC8vLmFkZCgncHJvcCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSlcbiAgICAgICAgLy8uYWRkKCdwcm9wJykubW9kZShCaW5kaW5nTW9kZS50d29XYXkpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KVxuICAgICAgICAvLy5hZGQoJ3Byb3AnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSkuY2FsbGJhY2soJ3Byb3BDaGFuZ2VkJykuY2FsbGJhY2soJ3Byb3BDaGFuZ2VkJykgLy8gZXRjXG4gICAgICAgIC8vID4gZXhwZWN0ZWQgZXJyb3IgLSB3cm9uZyBpbnZvY2F0aW9uIG9yZGVyXG4gICAgICAgIC8vLmFkZCgncHJvcCcpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KVxuICAgICAgICAvLy5hZGQoJ3Byb3AnKS5wcmltYXJ5KCkubW9kZShCaW5kaW5nTW9kZS50d29XYXkpICAvLyBldGNcbiAgICAgICAgLmFkZCgncHJvcCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KVxuICAgICAgICAuYWRkKCdwcm9wJykubW9kZShCaW5kaW5nTW9kZS50d29XYXkpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5tb2RlKEJpbmRpbmdNb2RlLnR3b1dheSkuY2FsbGJhY2soJ3Byb3BDaGFuZ2VkJykuYXR0cmlidXRlKCdwcm9wJylcbiAgICAgICAgLmFkZCgncHJvcCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KS5jYWxsYmFjaygncHJvcENoYW5nZWQnKS5hdHRyaWJ1dGUoJ3Byb3AnKS5wcmltYXJ5KClcbiAgICAgICAgLmFkZCgncHJvcCcpLm1vZGUoQmluZGluZ01vZGUudHdvV2F5KS5zZXQoKHZhbHVlKSA9PiBOdW1iZXIodmFsdWUpKVxuICAgICAgICAuYWRkKCdwcm9wJykubW9kZShCaW5kaW5nTW9kZS50d29XYXkpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpLnNldCh2YWx1ZSA9PiBOdW1iZXIodmFsdWUpKVxuICAgICAgICAuYWRkKCdwcm9wJykuY2FsbGJhY2soJ3Byb3BDaGFuZ2VkJylcbiAgICAgICAgLmFkZCgncHJvcCcpLmNhbGxiYWNrKCdwcm9wQ2hhbmdlZCcpLmF0dHJpYnV0ZSgncHJvcCcpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5jYWxsYmFjaygncHJvcENoYW5nZWQnKS5hdHRyaWJ1dGUoJ3Byb3AnKS5wcmltYXJ5KClcbiAgICAgICAgLmFkZCgncHJvcCcpLmF0dHJpYnV0ZSgncHJvcCcpXG4gICAgICAgIC5hZGQoJ3Byb3AnKS5hdHRyaWJ1dGUoJ3Byb3AnKS5wcmltYXJ5KClcbiAgICAgICAgLmFkZCgncHJvcCcpLnByaW1hcnkoKTtcbn1cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLHNwYWNlZC1jb21tZW50ICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kYWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBiaW5kaW5nQmVoYXZpb3IsIEJpbmRpbmdNb2RlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5leHBvcnQgY2xhc3MgQmluZGluZ01vZGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IobW9kZSkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTW9kZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE1vZGVzLnNldChiaW5kaW5nLCBiaW5kaW5nLm1vZGUpO1xuICAgICAgICBiaW5kaW5nLm1vZGUgPSB0aGlzLm1vZGU7XG4gICAgfVxuICAgIHVuYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSwgYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLm1vZGUgPSB0aGlzLm9yaWdpbmFsTW9kZXMuZ2V0KGJpbmRpbmcpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTW9kZXMuZGVsZXRlKGJpbmRpbmcpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPbmVUaW1lQmluZGluZ0JlaGF2aW9yIGV4dGVuZHMgQmluZGluZ01vZGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKEJpbmRpbmdNb2RlLm9uZVRpbWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUb1ZpZXdCaW5kaW5nQmVoYXZpb3IgZXh0ZW5kcyBCaW5kaW5nTW9kZUJlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmluZGluZ01vZGUudG9WaWV3KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3IgZXh0ZW5kcyBCaW5kaW5nTW9kZUJlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmluZGluZ01vZGUuZnJvbVZpZXcpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUd29XYXlCaW5kaW5nQmVoYXZpb3IgZXh0ZW5kcyBCaW5kaW5nTW9kZUJlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmluZGluZ01vZGUudHdvV2F5KTtcbiAgICB9XG59XG5iaW5kaW5nQmVoYXZpb3IoJ29uZVRpbWUnKShPbmVUaW1lQmluZGluZ0JlaGF2aW9yKTtcbmJpbmRpbmdCZWhhdmlvcigndG9WaWV3JykoVG9WaWV3QmluZGluZ0JlaGF2aW9yKTtcbmJpbmRpbmdCZWhhdmlvcignZnJvbVZpZXcnKShGcm9tVmlld0JpbmRpbmdCZWhhdmlvcik7XG5iaW5kaW5nQmVoYXZpb3IoJ3R3b1dheScpKFR3b1dheUJpbmRpbmdCZWhhdmlvcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nLW1vZGUuanMubWFwIiwiaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IGJpbmRpbmdCZWhhdmlvciwgQmluZGluZ0ludGVyY2VwdG9yIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5leHBvcnQgY2xhc3MgRGVib3VuY2VCaW5kaW5nQmVoYXZpb3IgZXh0ZW5kcyBCaW5kaW5nSW50ZXJjZXB0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGJpbmRpbmcsIGV4cHIpIHtcbiAgICAgICAgc3VwZXIoYmluZGluZywgZXhwcik7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgZGVsYXk6IDAgfTtcbiAgICAgICAgdGhpcy5maXJzdEFyZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMudGFza1F1ZXVlID0gYmluZGluZy5sb2NhdG9yLmdldChJUGxhdGZvcm0pLm1hY3JvVGFza1F1ZXVlO1xuICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RBcmcgPSBleHByLmFyZ3NbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbFNvdXJjZShhcmdzKSB7XG4gICAgICAgIHRoaXMucXVldWVUYXNrKCgpID0+IHRoaXMuYmluZGluZy5jYWxsU291cmNlKGFyZ3MpKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLnF1ZXVlVGFzaygoKSA9PiB0aGlzLmJpbmRpbmcuaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykpO1xuICAgIH1cbiAgICBxdWV1ZVRhc2soY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMudGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YXNrLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFzayA9IHRoaXMudGFza1F1ZXVlLnF1ZXVlVGFzaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRoaXMub3B0cyk7XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0QXJnICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IE51bWJlcih0aGlzLmZpcnN0QXJnLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIG51bGwpKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kaW5nLiRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICB0aGlzLnRhc2s/LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB0aGlzLmJpbmRpbmcuJHVuYmluZChmbGFncyk7XG4gICAgfVxufVxuYmluZGluZ0JlaGF2aW9yKCdkZWJvdW5jZScpKERlYm91bmNlQmluZGluZ0JlaGF2aW9yKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgYmluZGluZ0JlaGF2aW9yLCBJU2lnbmFsZXIgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmxldCBTaWduYWxCaW5kaW5nQmVoYXZpb3IgPSBjbGFzcyBTaWduYWxCaW5kaW5nQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNpZ25hbGVyKSB7XG4gICAgICAgIHRoaXMuc2lnbmFsZXIgPSBzaWduYWxlcjtcbiAgICAgICAgdGhpcy5sb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUsIGJpbmRpbmcsIC4uLm5hbWVzKSB7XG4gICAgICAgIGlmICghKCdoYW5kbGVDaGFuZ2UnIGluIGJpbmRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzaWduYWwgYmVoYXZpb3IgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGJpbmRpbmdzIHRoYXQgaGF2ZSBhICdoYW5kbGVDaGFuZ2UnIG1ldGhvZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXQgbGVhc3Qgb25lIHNpZ25hbCBuYW1lIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBzaWduYWwgYmVoYXZpb3IsIGUuZy4gXFxgZXhwciAmIHNpZ25hbDonbXktc2lnbmFsJ1xcYGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9va3VwLnNldChiaW5kaW5nLCBuYW1lcyk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgdGhpcy5zaWduYWxlci5hZGRTaWduYWxMaXN0ZW5lcihuYW1lLCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLmxvb2t1cC5nZXQoYmluZGluZyk7XG4gICAgICAgIHRoaXMubG9va3VwLmRlbGV0ZShiaW5kaW5nKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbGVyLnJlbW92ZVNpZ25hbExpc3RlbmVyKG5hbWUsIGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgfVxufTtcblNpZ25hbEJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgSVNpZ25hbGVyKVxuXSwgU2lnbmFsQmluZGluZ0JlaGF2aW9yKTtcbmV4cG9ydCB7IFNpZ25hbEJpbmRpbmdCZWhhdmlvciB9O1xuYmluZGluZ0JlaGF2aW9yKCdzaWduYWwnKShTaWduYWxCaW5kaW5nQmVoYXZpb3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmFscy5qcy5tYXAiLCJpbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgYmluZGluZ0JlaGF2aW9yLCBCaW5kaW5nSW50ZXJjZXB0b3IgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmV4cG9ydCBjbGFzcyBUaHJvdHRsZUJpbmRpbmdCZWhhdmlvciBleHRlbmRzIEJpbmRpbmdJbnRlcmNlcHRvciB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZywgZXhwcikge1xuICAgICAgICBzdXBlcihiaW5kaW5nLCBleHByKTtcbiAgICAgICAgdGhpcy5vcHRzID0geyBkZWxheTogMCB9O1xuICAgICAgICB0aGlzLmZpcnN0QXJnID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2FsbCA9IDA7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBiaW5kaW5nLmxvY2F0b3IuZ2V0KElQbGF0Zm9ybSk7XG4gICAgICAgIHRoaXMudGFza1F1ZXVlID0gdGhpcy5wbGF0Zm9ybS5tYWNyb1Rhc2tRdWV1ZTtcbiAgICAgICAgaWYgKGV4cHIuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0QXJnID0gZXhwci5hcmdzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxTb3VyY2UoYXJncykge1xuICAgICAgICB0aGlzLnF1ZXVlVGFzaygoKSA9PiB0aGlzLmJpbmRpbmcuY2FsbFNvdXJjZShhcmdzKSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVRhc2soKCkgPT4gdGhpcy5iaW5kaW5nLmhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpKTtcbiAgICB9XG4gICAgcXVldWVUYXNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICAgICAgY29uc3QgbmV4dERlbGF5ID0gdGhpcy5sYXN0Q2FsbCArIG9wdHMuZGVsYXkgLSBwbGF0Zm9ybS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBpZiAobmV4dERlbGF5ID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdHMuZGVsYXkgPSBuZXh0RGVsYXk7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLnRhc2tRdWV1ZS5xdWV1ZVRhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENhbGwgPSBwbGF0Zm9ybS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2FsbCA9IHBsYXRmb3JtLnBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0QXJnICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IE51bWJlcih0aGlzLmZpcnN0QXJnLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIG51bGwpKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kaW5nLiRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICB0aGlzLnRhc2s/LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBzdXBlci4kdW5iaW5kKGZsYWdzKTtcbiAgICB9XG59XG5iaW5kaW5nQmVoYXZpb3IoJ3Rocm90dGxlJykoVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGUuanMubWFwIiwiaW1wb3J0IHsgQmluZGluZ01vZGUsIGNvbm5lY3RhYmxlLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgQXR0cmlidXRlT2JzZXJ2ZXIgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi9lbGVtZW50LWF0dHJpYnV0ZS1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuLi9wbGF0Zm9ybS5qcyc7XG4vLyBCaW5kaW5nTW9kZSBpcyBub3QgYSBjb25zdCBlbnVtIChhbmQgdGhlcmVmb3JlIG5vdCBpbmxpbmVkKSwgc28gYXNzaWduaW5nIHRoZW0gdG8gYSB2YXJpYWJsZSB0byBzYXZlIGEgbWVtYmVyIGFjY2Vzc29yIGlzIGEgbWlub3IgcGVyZiB0d2Vha1xuY29uc3QgeyBvbmVUaW1lLCB0b1ZpZXcsIGZyb21WaWV3IH0gPSBCaW5kaW5nTW9kZTtcbi8vIHByZS1jb21iaW5pbmcgZmxhZ3MgZm9yIGJpdHdpc2UgY2hlY2tzIGlzIGEgbWlub3IgcGVyZiB0d2Vha1xuY29uc3QgdG9WaWV3T3JPbmVUaW1lID0gdG9WaWV3IHwgb25lVGltZTtcbmNvbnN0IHRhc2tPcHRpb25zID0ge1xuICAgIHJldXNhYmxlOiBmYWxzZSxcbiAgICBwcmVlbXB0OiB0cnVlLFxufTtcbi8qKlxuICogQXR0cmlidXRlIGJpbmRpbmcuIEhhbmRsZSBhdHRyaWJ1dGUgYmluZGluZyBiZXR3ZW4gdmlldy92aWV3IG1vZGVsLiBVbmRlcnN0YW5kIEh0bWwgc3BlY2lhbCBhdHRyaWJ1dGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VFeHByZXNzaW9uLCB0YXJnZXQsIFxuICAgIC8vIHNvbWUgYXR0cmlidXRlcyBtYXkgaGF2ZSBpbm5lciBzdHJ1Y3R1cmVcbiAgICAvLyBzdWNoIGFzIGNsYXNzIC0+IGNvbGxlY3Rpb24gb2YgY2xhc3MgbmFtZXNcbiAgICAvLyBzdWNoIGFzIHN0eWxlIC0+IGNvbGxlY3Rpb24gb2Ygc3R5bGUgcnVsZXNcbiAgICAvL1xuICAgIC8vIGZvciBub3JtYWwgYXR0cmlidXRlcywgdGFyZ2V0QXR0cmlidXRlIGFuZCB0YXJnZXRQcm9wZXJ0eSBhcmUgdGhlIHNhbWUgYW5kIGNhbiBiZSBpZ25vcmVcbiAgICB0YXJnZXRBdHRyaWJ1dGUsIHRhcmdldFByb3BlcnR5LCBtb2RlLCBvYnNlcnZlckxvY2F0b3IsIGxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uID0gc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50YXJnZXRBdHRyaWJ1dGUgPSB0YXJnZXRBdHRyaWJ1dGU7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kc2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbnRGbGFncyA9IDAgLyogbm9uZSAqLztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGNvbm5lY3RhYmxlLmFzc2lnbklkVG8odGhpcyk7XG4gICAgICAgIHRoaXMuJHBsYXRmb3JtID0gbG9jYXRvci5nZXQoSVBsYXRmb3JtKTtcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0KHZhbHVlLCBmbGFncykge1xuICAgICAgICBmbGFncyB8PSB0aGlzLnBlcnNpc3RlbnRGbGFncztcbiAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlci5zZXRWYWx1ZSh2YWx1ZSwgZmxhZ3MgfCA4IC8qIHVwZGF0ZVRhcmdldCAqLywgdGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICB1cGRhdGVTb3VyY2UodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGZsYWdzIHw9IHRoaXMucGVyc2lzdGVudEZsYWdzO1xuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24uYXNzaWduKGZsYWdzIHwgMTYgLyogdXBkYXRlU291cmNlICovLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBfcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyB8PSB0aGlzLnBlcnNpc3RlbnRGbGFncztcbiAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3IgPSB0aGlzLmludGVyY2VwdG9yO1xuICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBjb25zdCAkc2NvcGUgPSB0aGlzLiRzY29wZTtcbiAgICAgICAgY29uc3QgbG9jYXRvciA9IHRoaXMubG9jYXRvcjtcbiAgICAgICAgaWYgKG1vZGUgPT09IEJpbmRpbmdNb2RlLmZyb21WaWV3KSB7XG4gICAgICAgICAgICBmbGFncyAmPSB+OCAvKiB1cGRhdGVUYXJnZXQgKi87XG4gICAgICAgICAgICBmbGFncyB8PSAxNiAvKiB1cGRhdGVTb3VyY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgOCAvKiB1cGRhdGVUYXJnZXQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgICAgIC8vIEFscGhhOiBkdXJpbmcgYmluZCBhIHNpbXBsZSBzdHJhdGVneSBmb3IgYmluZCBpcyBhbHdheXMgZmx1c2ggaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIHRvZG86XG4gICAgICAgICAgICAvLyAgKDEpLiBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHNob3VsZCBiZSB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vICAoMikuIGlmIG5vdCwgdGhlbiBmaXggdGVzdHMgdG8gcmVmbGVjdCB0aGUgY2hhbmdlcy9wbGF0Zm9ybSB0byBwcm9wZXJseSB5aWVsZCBhbGwgd2l0aCBhdXJlbGlhLnN0YXJ0KClcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFF1ZXVlRmx1c2ggPSAoZmxhZ3MgJiAzMiAvKiBmcm9tQmluZCAqLykgPT09IDAgJiYgKHRhcmdldE9ic2VydmVyLnR5cGUgJiA0IC8qIExheW91dCAqLykgPiAwO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uJGtpbmQgIT09IDEwMDgyIC8qIEFjY2Vzc1Njb3BlICovIHx8IHRoaXMub2JzLmNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSAobW9kZSAmIG9uZVRpbWUpID09PSAwO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JzLnZlcnNpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCAkc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgbG9jYXRvciwgaW50ZXJjZXB0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JzLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFF1ZXVlRmx1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrPy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrID0gdGhpcy4kcGxhdGZvcm0uZG9tV3JpdGVRdWV1ZS5xdWV1ZVRhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyY2VwdG9yLnVwZGF0ZVRhcmdldChuZXdWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0YXNrT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRvci51cGRhdGVUYXJnZXQobmV3VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMTYgLyogdXBkYXRlU291cmNlICovKSB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsICRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCBsb2NhdG9yLCBudWxsKSkge1xuICAgICAgICAgICAgICAgIGludGVyY2VwdG9yLnVwZGF0ZVNvdXJjZShuZXdWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBoYW5kbGVDaGFuZ2UgY29udGV4dCBpbiBBdHRyaWJ1dGVCaW5kaW5nJyk7XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCBwcm9qZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdG9yLiR1bmJpbmQoZmxhZ3MgfCAzMiAvKiBmcm9tQmluZCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgZmxhZ3Mgd2hpY2ggd2UgY2FuIG9ubHkgcmVjZWl2ZSBkdXJpbmcgJGJpbmQgYW5kIG5lZWQgdG8gcGFzcyBvblxuICAgICAgICAvLyB0byB0aGUgQVNUIGR1cmluZyBldmFsdWF0ZS9jb25uZWN0L2Fzc2lnblxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRGbGFncyA9IGZsYWdzICYgMTUzNjcgLyogcGVyc2lzdGVudEJpbmRpbmdGbGFncyAqLztcbiAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gaG9zdFNjb3BlO1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICAgICAgICBsZXQgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uaGFzQmluZCkge1xuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLnRhcmdldE9ic2VydmVyO1xuICAgICAgICBpZiAoIXRhcmdldE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlciA9IHRoaXMudGFyZ2V0T2JzZXJ2ZXIgPSBuZXcgQXR0cmlidXRlT2JzZXJ2ZXIodGhpcy4kcGxhdGZvcm0sIHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCB0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRQcm9wZXJ0eSwgdGhpcy50YXJnZXRBdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGR1cmluZyBiaW5kLCBiaW5kaW5nIGJlaGF2aW9yIG1pZ2h0IGhhdmUgY2hhbmdlZCBzb3VyY2VFeHByZXNzaW9uXG4gICAgICAgIHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGNvbnN0ICRtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IHRoaXMuaW50ZXJjZXB0b3I7XG4gICAgICAgIGlmICgkbW9kZSAmIHRvVmlld09yT25lVGltZSkge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9ICgkbW9kZSAmIHRvVmlldykgPiAwO1xuICAgICAgICAgICAgaW50ZXJjZXB0b3IudXBkYXRlVGFyZ2V0KHRoaXMudmFsdWUgPSBzb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIHNob3VsZENvbm5lY3QgPyBpbnRlcmNlcHRvciA6IG51bGwpLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRtb2RlICYgZnJvbVZpZXcpIHtcbiAgICAgICAgICAgIHRhcmdldE9ic2VydmVyW3RoaXMuaWRdIHw9IDE2IC8qIHVwZGF0ZVNvdXJjZSAqLztcbiAgICAgICAgICAgIHRhcmdldE9ic2VydmVyLnN1YnNjcmliZShpbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIHBlcnNpc3RlbnQgZmxhZ3NcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50RmxhZ3MgPSAwIC8qIG5vbmUgKi87XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUV4cHJlc3Npb24uaGFzVW5iaW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24udW5iaW5kKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzY29wZVxuICAgICAgICAgICAgPSB0aGlzLiRob3N0U2NvcGVcbiAgICAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgaWYgKHRhcmdldE9ic2VydmVyLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgICAgIHRhcmdldE9ic2VydmVyW3RoaXMuaWRdICY9IH4xNiAvKiB1cGRhdGVTb3VyY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXNrPy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5vYnMuY2xlYXIodHJ1ZSk7XG4gICAgICAgIC8vIHJlbW92ZSBpc0JvdW5kIGFuZCBpc1VuYmluZGluZyBmbGFnc1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICB9XG59XG5jb25uZWN0YWJsZShBdHRyaWJ1dGVCaW5kaW5nKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHJpYnV0ZS5qcy5tYXAiLCJleHBvcnQgY2xhc3MgQ2FsbEJpbmRpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZUV4cHJlc3Npb24sIHRhcmdldCwgdGFyZ2V0UHJvcGVydHksIG9ic2VydmVyTG9jYXRvciwgbG9jYXRvcikge1xuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFByb3BlcnR5O1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIgPSBvYnNlcnZlckxvY2F0b3IuZ2V0T2JzZXJ2ZXIodGFyZ2V0LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIGNhbGxTb3VyY2UoYXJncykge1xuICAgICAgICBjb25zdCBvdmVycmlkZUNvbnRleHQgPSB0aGlzLiRzY29wZS5vdmVycmlkZUNvbnRleHQ7XG4gICAgICAgIC8vIHJlYWxseSBuZWVkIHRvIGRlbGV0ZSB0aGUgZm9sbG93aW5nIGxpbmVcbiAgICAgICAgLy8gYW5kIHRoZSBmb3IuLmluIGxvb3AgYmVsb3dcbiAgICAgICAgLy8gY29udmVuaWVuY2UgaW4gdGhlIHRlbXBsYXRlIHdvbid0IG91dHdlaWdodCB0aGUgZHJhdyBiYWNrIG9mIHN1Y2ggY29uZnVzaW5nIGZlYXR1cmVcbiAgICAgICAgLy8gT1IsIGF0IHRoZSB2ZXJ5IGxlYXN0LCB1c2UgZ2V0dGVyL3NldHRlciBmb3IgZWFjaCBwcm9wZXJ0eSBpbiBhcmdzIHRvIGdldC9zZXQgb3JpZ2luYWwgc291cmNlXG4gICAgICAgIC8vIC0tLVxuICAgICAgICBPYmplY3QuYXNzaWduKG92ZXJyaWRlQ29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZSgxMjggLyogbXVzdEV2YWx1YXRlICovLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIG51bGwpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gYXJncykge1xuICAgICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShvdmVycmlkZUNvbnRleHQsIHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdG9yLiR1bmJpbmQoZmxhZ3MgfCAzMiAvKiBmcm9tQmluZCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gaG9zdFNjb3BlO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFeHByZXNzaW9uLmhhc0JpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyLnNldFZhbHVlKCgkYXJncykgPT4gdGhpcy5pbnRlcmNlcHRvci5jYWxsU291cmNlKCRhcmdzKSwgZmxhZ3MsIHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb3VyY2VFeHByZXNzaW9uLmhhc1VuYmluZCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLnVuYmluZChmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIuc2V0VmFsdWUobnVsbCwgZmxhZ3MsIHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldFByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIG9ic2VydmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtYmluZGluZy5qcy5tYXAiLCJpbXBvcnQgeyBCaW5kaW5nTW9kZSwgY29ubmVjdGFibGUsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5jb25zdCB7IHRvVmlldyB9ID0gQmluZGluZ01vZGU7XG5jb25zdCBxdWV1ZVRhc2tPcHRpb25zID0ge1xuICAgIHJldXNhYmxlOiBmYWxzZSxcbiAgICBwcmVlbXB0OiB0cnVlLFxufTtcbi8vIGEgcHNldWRvIGJpbmRpbmcgdG8gbWFuYWdlIG11bHRpcGxlIEludGVycG9sYXRpb25CaW5kaW5nIHNcbi8vID09PT09PT09XG4vLyBOb3RlOiB0aGUgY2hpbGQgZXhwcmVzc2lvbnMgb2YgYW4gSW50ZXJwb2xhdGlvbiBleHByZXNzaW9uIGFyZSBmdWxsIEF1cmVsaWEgZXhwcmVzc2lvbnMsIG1lYW5pbmcgdGhleSBtYXkgaW5jbHVkZVxuLy8gdmFsdWUgY29udmVydGVycyBhbmQgYmluZGluZyBiZWhhdmlvcnMuXG4vLyBFYWNoIGV4cHJlc3Npb24gcmVwcmVzZW50cyBvbmUgJHtpbnRlcnBvbGF0aW9ufSwgYW5kIGZvciBlYWNoIHdlIGNyZWF0ZSBhIGNoaWxkIFRleHRCaW5kaW5nIHVubGVzcyB0aGVyZSBpcyBvbmx5IG9uZSxcbi8vIGluIHdoaWNoIGNhc2UgdGhlIHJlbmRlcmVyIHdpbGwgY3JlYXRlIHRoZSBUZXh0QmluZGluZyBkaXJlY3RseVxuZXhwb3J0IGNsYXNzIEludGVycG9sYXRpb25CaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihvYnNlcnZlckxvY2F0b3IsIGludGVycG9sYXRpb24sIHRhcmdldCwgdGFyZ2V0UHJvcGVydHksIG1vZGUsIGxvY2F0b3IsIHRhc2tRdWV1ZSkge1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgdGhpcy50YXNrUXVldWUgPSB0YXNrUXVldWU7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIgPSBvYnNlcnZlckxvY2F0b3IuZ2V0QWNjZXNzb3IodGFyZ2V0LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gaW50ZXJwb2xhdGlvbi5leHByZXNzaW9ucztcbiAgICAgICAgY29uc3QgcGFydEJpbmRpbmdzID0gdGhpcy5wYXJ0QmluZGluZ3MgPSBBcnJheShleHByZXNzaW9ucy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBleHByZXNzaW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBwYXJ0QmluZGluZ3NbaV0gPSBuZXcgQ29udGVudEJpbmRpbmcoZXhwcmVzc2lvbnNbaV0sIHRhcmdldCwgdGFyZ2V0UHJvcGVydHksIGxvY2F0b3IsIG9ic2VydmVyTG9jYXRvciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0KHZhbHVlLCBmbGFncykge1xuICAgICAgICBjb25zdCBwYXJ0QmluZGluZ3MgPSB0aGlzLnBhcnRCaW5kaW5ncztcbiAgICAgICAgY29uc3Qgc3RhdGljUGFydHMgPSB0aGlzLmludGVycG9sYXRpb24ucGFydHM7XG4gICAgICAgIGNvbnN0IGlpID0gcGFydEJpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBpZiAoaWkgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0YXRpY1BhcnRzWzBdICsgcGFydEJpbmRpbmdzWzBdLnZhbHVlICsgc3RhdGljUGFydHNbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdGF0aWNQYXJ0c1swXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwYXJ0QmluZGluZ3NbaV0udmFsdWUgKyBzdGF0aWNQYXJ0c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLnRhcmdldE9ic2VydmVyO1xuICAgICAgICAvLyBBbHBoYTogZHVyaW5nIGJpbmQgYSBzaW1wbGUgc3RyYXRlZ3kgZm9yIGJpbmQgaXMgYWx3YXlzIGZsdXNoIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIHRvZG86XG4gICAgICAgIC8vICAoMSkuIGRldGVybWluZSB3aGV0aGVyIHRoaXMgc2hvdWxkIGJlIHRoZSBiZWhhdmlvclxuICAgICAgICAvLyAgKDIpLiBpZiBub3QsIHRoZW4gZml4IHRlc3RzIHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMvcGxhdGZvcm0gdG8gcHJvcGVybHkgeWllbGQgYWxsIHdpdGggYXVyZWxpYS5zdGFydCgpLndhaXQoKVxuICAgICAgICBjb25zdCBzaG91bGRRdWV1ZUZsdXNoID0gKGZsYWdzICYgMzIgLyogZnJvbUJpbmQgKi8pID09PSAwICYmICh0YXJnZXRPYnNlcnZlci50eXBlICYgNCAvKiBMYXlvdXQgKi8pID4gMDtcbiAgICAgICAgaWYgKHNob3VsZFF1ZXVlRmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMudGFzaz8uY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLnRhc2tRdWV1ZS5xdWV1ZVRhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIuc2V0VmFsdWUocmVzdWx0LCBmbGFncywgdGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICAgICAgfSwgcXVldWVUYXNrT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlci5zZXRWYWx1ZShyZXN1bHQsIGZsYWdzLCB0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgJGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0b3IuJHVuYmluZChmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgY29uc3QgcGFydEJpbmRpbmdzID0gdGhpcy5wYXJ0QmluZGluZ3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRCaW5kaW5ncy5sZW5ndGg7IGlpID4gaTsgKytpKSB7XG4gICAgICAgICAgICBwYXJ0QmluZGluZ3NbaV0uJGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0KHZvaWQgMCwgZmxhZ3MpO1xuICAgIH1cbiAgICAkdW5iaW5kKGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICBjb25zdCBwYXJ0QmluZGluZ3MgPSB0aGlzLnBhcnRCaW5kaW5ncztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFydEJpbmRpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHBhcnRCaW5kaW5nc1tpXS5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhc2s/LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb250ZW50QmluZGluZyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCB0YXJnZXRQcm9wZXJ0eSwgbG9jYXRvciwgb2JzZXJ2ZXJMb2NhdG9yLCBvd25lcikge1xuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFByb3BlcnR5O1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgLy8gYXQgcnVudGltZSwgbW9kZSBtYXkgYmUgb3ZlcnJpZGVuIGJ5IGJpbmRpbmcgYmVoYXZpb3JcbiAgICAgICAgLy8gYnV0IGl0IHdvdWxkbid0IG1hdHRlciBoZXJlLCBqdXN0IHN0YXJ0IHdpdGggc29tZXRoaW5nIGZvciBsYXRlciBjaGVja1xuICAgICAgICB0aGlzLm1vZGUgPSBCaW5kaW5nTW9kZS50b1ZpZXc7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgY29uc3Qgb2JzUmVjb3JkID0gdGhpcy5vYnM7XG4gICAgICAgIGNvbnN0IGNhbk9wdGltaXplID0gc291cmNlRXhwcmVzc2lvbi4ka2luZCA9PT0gMTAwODIgLyogQWNjZXNzU2NvcGUgKi8gJiYgb2JzUmVjb3JkLmNvdW50ID09PSAxO1xuICAgICAgICBpZiAoIWNhbk9wdGltaXplKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRDb25uZWN0ID0gKHRoaXMubW9kZSAmIHRvVmlldykgPiAwO1xuICAgICAgICAgICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBvYnNSZWNvcmQudmVyc2lvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIHNob3VsZENvbm5lY3QgPyB0aGlzLmludGVyY2VwdG9yIDogbnVsbCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgIG9ic1JlY29yZC5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlQ29sbGVjdGlvbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm93bmVyLnVwZGF0ZVRhcmdldChuZXdWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoaW5kZXhNYXAsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMub3duZXIudXBkYXRlVGFyZ2V0KHZvaWQgMCwgZmxhZ3MpO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBob3N0U2NvcGU7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUV4cHJlc3Npb24uaGFzQmluZCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLmJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbHVlID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsICh0aGlzLm1vZGUgJiB0b1ZpZXcpID4gMCA/IHRoaXMuaW50ZXJjZXB0b3IgOiBudWxsKTtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlQ29sbGVjdGlvbih2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkdW5iaW5kKGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUV4cHJlc3Npb24uaGFzVW5iaW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24udW5iaW5kKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzY29wZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vYnMuY2xlYXIodHJ1ZSk7XG4gICAgfVxufVxuY29ubmVjdGFibGUoQ29udGVudEJpbmRpbmcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJwb2xhdGlvbi1iaW5kaW5nLmpzLm1hcCIsImltcG9ydCB7IGNvbm5lY3RhYmxlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5leHBvcnQgY2xhc3MgTGV0QmluZGluZyB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0UHJvcGVydHksIG9ic2VydmVyTG9jYXRvciwgbG9jYXRvciwgdG9CaW5kaW5nQ29udGV4dCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbiA9IHNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMudG9CaW5kaW5nQ29udGV4dCA9IHRvQmluZGluZ0NvbnRleHQ7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgY29ubmVjdGFibGUuYXNzaWduSWRUbyh0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKF9uZXdWYWx1ZSwgX3ByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgOCAvKiB1cGRhdGVUYXJnZXQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UHJvcGVydHkgPSB0aGlzLnRhcmdldFByb3BlcnR5O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRhcmdldFt0YXJnZXRQcm9wZXJ0eV07XG4gICAgICAgICAgICB0aGlzLm9icy52ZXJzaW9uKys7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgICAgIHRoaXMub2JzLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFt0YXJnZXRQcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaGFuZGxlQ2hhbmdlIGNvbnRleHQgaW4gTGV0QmluZGluZycpO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzIHwgMzIgLyogZnJvbUJpbmQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IGhvc3RTY29wZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSAodGhpcy50b0JpbmRpbmdDb250ZXh0ID8gKGhvc3RTY29wZSA/PyBzY29wZSkuYmluZGluZ0NvbnRleHQgOiAoaG9zdFNjb3BlID8/IHNjb3BlKS5vdmVycmlkZUNvbnRleHQpO1xuICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBpZiAoc291cmNlRXhwcmVzc2lvbi5oYXNCaW5kKSB7XG4gICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLmJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNvdXJjZUV4cHJlc3Npb24gbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgZHVyaW5nIGJpbmRcbiAgICAgICAgdGhpcy50YXJnZXRbdGhpcy50YXJnZXRQcm9wZXJ0eV1cbiAgICAgICAgICAgID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzIHwgMzIgLyogZnJvbUJpbmQgKi8sIHNjb3BlLCBob3N0U2NvcGUsIHRoaXMubG9jYXRvciwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIGFkZCBpc0JvdW5kIGZsYWcgYW5kIHJlbW92ZSBpc0JpbmRpbmcgZmxhZ1xuICAgICAgICB0aGlzLmlzQm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICAkdW5iaW5kKGZsYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uaGFzVW5iaW5kKSB7XG4gICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLnVuYmluZChmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMub2JzLmNsZWFyKHRydWUpO1xuICAgICAgICAvLyByZW1vdmUgaXNCb3VuZCBhbmQgaXNVbmJpbmRpbmcgZmxhZ3NcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxufVxuY29ubmVjdGFibGUoTGV0QmluZGluZyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXQtYmluZGluZy5qcy5tYXAiLCJpbXBvcnQgeyBEZWxlZ2F0aW9uU3RyYXRlZ3ksIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBJRXZlbnRUYXJnZXQgfSBmcm9tICcuLi9kb20uanMnO1xuY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBbRGVsZWdhdGlvblN0cmF0ZWd5LmNhcHR1cmluZ106IHsgY2FwdHVyZTogdHJ1ZSB9LFxuICAgIFtEZWxlZ2F0aW9uU3RyYXRlZ3kuYnViYmxpbmddOiB7IGNhcHR1cmU6IGZhbHNlIH0sXG59O1xuLyoqXG4gKiBMaXN0ZW5lciBiaW5kaW5nLiBIYW5kbGUgZXZlbnQgYmluZGluZyBiZXR3ZWVuIHZpZXcgYW5kIHZpZXcgbW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIExpc3RlbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybSwgdGFyZ2V0RXZlbnQsIGRlbGVnYXRpb25TdHJhdGVneSwgc291cmNlRXhwcmVzc2lvbiwgdGFyZ2V0LCBwcmV2ZW50RGVmYXVsdCwgZXZlbnREZWxlZ2F0b3IsIGxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLnRhcmdldEV2ZW50ID0gdGFyZ2V0RXZlbnQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGlvblN0cmF0ZWd5ID0gZGVsZWdhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuICAgICAgICB0aGlzLmV2ZW50RGVsZWdhdG9yID0gZXZlbnREZWxlZ2F0b3I7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gICAgY2FsbFNvdXJjZShldmVudCkge1xuICAgICAgICBjb25zdCBvdmVycmlkZUNvbnRleHQgPSB0aGlzLiRzY29wZS5vdmVycmlkZUNvbnRleHQ7XG4gICAgICAgIG92ZXJyaWRlQ29udGV4dC4kZXZlbnQgPSBldmVudDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKDEyOCAvKiBtdXN0RXZhbHVhdGUgKi8sIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMubG9jYXRvciwgbnVsbCk7XG4gICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkob3ZlcnJpZGVDb250ZXh0LCAnJGV2ZW50Jyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUgJiYgdGhpcy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yLmNhbGxTb3VyY2UoZXZlbnQpO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzIHwgMzIgLyogZnJvbUJpbmQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IGhvc3RTY29wZTtcbiAgICAgICAgY29uc3Qgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uaGFzQmluZCkge1xuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0aW9uU3RyYXRlZ3kgPT09IERlbGVnYXRpb25TdHJhdGVneS5ub25lKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRoaXMudGFyZ2V0RXZlbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSB0aGlzLmxvY2F0b3IuZ2V0KElFdmVudFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgPSB0aGlzLmV2ZW50RGVsZWdhdG9yLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUYXJnZXQsIHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldEV2ZW50LCB0aGlzLCBvcHRpb25zW3RoaXMuZGVsZWdhdGlvblN0cmF0ZWd5XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBpZiAoc291cmNlRXhwcmVzc2lvbi5oYXNVbmJpbmQpIHtcbiAgICAgICAgICAgIHNvdXJjZUV4cHJlc3Npb24udW5iaW5kKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRzY29wZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRpb25TdHJhdGVneSA9PT0gRGVsZWdhdGlvblN0cmF0ZWd5Lm5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy50YXJnZXRFdmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgaXNCb3VuZCBhbmQgaXNVbmJpbmRpbmcgZmxhZ3NcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIG9ic2VydmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3RlbmVyLmpzLm1hcCIsImltcG9ydCB7IEJpbmRpbmdNb2RlLCBjb25uZWN0YWJsZSB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuLy8gQmluZGluZ01vZGUgaXMgbm90IGEgY29uc3QgZW51bSAoYW5kIHRoZXJlZm9yZSBub3QgaW5saW5lZCksIHNvIGFzc2lnbmluZyB0aGVtIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBhIG1lbWJlciBhY2Nlc3NvciBpcyBhIG1pbm9yIHBlcmYgdHdlYWtcbmNvbnN0IHsgb25lVGltZSwgdG9WaWV3LCBmcm9tVmlldyB9ID0gQmluZGluZ01vZGU7XG4vLyBwcmUtY29tYmluaW5nIGZsYWdzIGZvciBiaXR3aXNlIGNoZWNrcyBpcyBhIG1pbm9yIHBlcmYgdHdlYWtcbmNvbnN0IHRvVmlld09yT25lVGltZSA9IHRvVmlldyB8IG9uZVRpbWU7XG5jb25zdCB1cGRhdGVUYXNrT3B0cyA9IHtcbiAgICByZXVzYWJsZTogZmFsc2UsXG4gICAgcHJlZW1wdDogdHJ1ZSxcbn07XG5leHBvcnQgY2xhc3MgUHJvcGVydHlCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VFeHByZXNzaW9uLCB0YXJnZXQsIHRhcmdldFByb3BlcnR5LCBtb2RlLCBvYnNlcnZlckxvY2F0b3IsIGxvY2F0b3IsIHRhc2tRdWV1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24gPSBzb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFByb3BlcnR5O1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgdGhpcy50YXNrUXVldWUgPSB0YXNrUXVldWU7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0T2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucGVyc2lzdGVudEZsYWdzID0gMCAvKiBub25lICovO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBjb25uZWN0YWJsZS5hc3NpZ25JZFRvKHRoaXMpO1xuICAgIH1cbiAgICB1cGRhdGVUYXJnZXQodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGZsYWdzIHw9IHRoaXMucGVyc2lzdGVudEZsYWdzO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyLnNldFZhbHVlKHZhbHVlLCBmbGFncywgdGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICB1cGRhdGVTb3VyY2UodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGZsYWdzIHw9IHRoaXMucGVyc2lzdGVudEZsYWdzO1xuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24uYXNzaWduKGZsYWdzLCB0aGlzLiRzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBfcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyB8PSB0aGlzLnBlcnNpc3RlbnRGbGFncztcbiAgICAgICAgY29uc3QgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLnRhcmdldE9ic2VydmVyO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IHRoaXMuaW50ZXJjZXB0b3I7XG4gICAgICAgIGNvbnN0IHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGNvbnN0ICRzY29wZSA9IHRoaXMuJHNjb3BlO1xuICAgICAgICBjb25zdCBsb2NhdG9yID0gdGhpcy5sb2NhdG9yO1xuICAgICAgICBpZiAoKGZsYWdzICYgOCAvKiB1cGRhdGVUYXJnZXQgKi8pID4gMCkge1xuICAgICAgICAgICAgLy8gQWxwaGE6IGR1cmluZyBiaW5kIGEgc2ltcGxlIHN0cmF0ZWd5IGZvciBiaW5kIGlzIGFsd2F5cyBmbHVzaCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gdG9kbzpcbiAgICAgICAgICAgIC8vICAoMSkuIGRldGVybWluZSB3aGV0aGVyIHRoaXMgc2hvdWxkIGJlIHRoZSBiZWhhdmlvclxuICAgICAgICAgICAgLy8gICgyKS4gaWYgbm90LCB0aGVuIGZpeCB0ZXN0cyB0byByZWZsZWN0IHRoZSBjaGFuZ2VzL3BsYXRmb3JtIHRvIHByb3Blcmx5IHlpZWxkIGFsbCB3aXRoIGF1cmVsaWEuc3RhcnQoKVxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUXVldWVGbHVzaCA9IChmbGFncyAmIDMyIC8qIGZyb21CaW5kICovKSA9PT0gMCAmJiAodGFyZ2V0T2JzZXJ2ZXIudHlwZSAmIDQgLyogTGF5b3V0ICovKSA+IDA7XG4gICAgICAgICAgICBjb25zdCBvYnNSZWNvcmQgPSB0aGlzLm9icztcbiAgICAgICAgICAgIC8vIGlmIHRoZSBvbmx5IG9ic2VydmFibGUgaXMgYW4gQWNjZXNzU2NvcGUgdGhlbiB3ZSBjYW4gYXNzdW1lIHRoZSBwYXNzZWQtaW4gbmV3VmFsdWUgaXMgdGhlIGNvcnJlY3QgYW5kIGxhdGVzdCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uJGtpbmQgIT09IDEwMDgyIC8qIEFjY2Vzc1Njb3BlICovIHx8IG9ic1JlY29yZC5jb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBpbiBWQyBleHByZXNzaW9ucywgZnJvbSB2aWV3IGFsc28gcmVxdWlyZXMgY29ubmVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZENvbm5lY3QgPSB0aGlzLm1vZGUgPiBvbmVUaW1lO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic1JlY29yZC52ZXJzaW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIGxvY2F0b3IsIGludGVyY2VwdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNSZWNvcmQuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRRdWV1ZUZsdXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXNrPy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhc2sgPSB0aGlzLnRhc2tRdWV1ZS5xdWV1ZVRhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRvci51cGRhdGVUYXJnZXQobmV3VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCB1cGRhdGVUYXNrT3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRvci51cGRhdGVUYXJnZXQobmV3VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGZsYWdzICYgMTYgLyogdXBkYXRlU291cmNlICovKSA+IDApIHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gc291cmNlRXhwcmVzc2lvbi5ldmFsdWF0ZShmbGFncywgJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIGxvY2F0b3IsIG51bGwpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0b3IudXBkYXRlU291cmNlKG5ld1ZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGhhbmRsZUNoYW5nZSBjb250ZXh0IGluIFByb3BlcnR5QmluZGluZycpO1xuICAgIH1cbiAgICAkYmluZChmbGFncywgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGUgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRvci4kdW5iaW5kKGZsYWdzIHwgMzIgLyogZnJvbUJpbmQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcmNlIHByb3BlcnR5IGJpbmRpbmcgdG8gYWx3YXlzIGJlIHN0cmljdFxuICAgICAgICBmbGFncyB8PSA0IC8qIGlzU3RyaWN0QmluZGluZ1N0cmF0ZWd5ICovO1xuICAgICAgICAvLyBTdG9yZSBmbGFncyB3aGljaCB3ZSBjYW4gb25seSByZWNlaXZlIGR1cmluZyAkYmluZCBhbmQgbmVlZCB0byBwYXNzIG9uXG4gICAgICAgIC8vIHRvIHRoZSBBU1QgZHVyaW5nIGV2YWx1YXRlL2Nvbm5lY3QvYXNzaWduXG4gICAgICAgIHRoaXMucGVyc2lzdGVudEZsYWdzID0gZmxhZ3MgJiAxNTM2NyAvKiBwZXJzaXN0ZW50QmluZGluZ0ZsYWdzICovO1xuICAgICAgICB0aGlzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBob3N0U2NvcGU7XG4gICAgICAgIGxldCBzb3VyY2VFeHByZXNzaW9uID0gdGhpcy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICBpZiAoc291cmNlRXhwcmVzc2lvbi5oYXNCaW5kKSB7XG4gICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLmJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0ICRtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgICBsZXQgdGFyZ2V0T2JzZXJ2ZXIgPSB0aGlzLnRhcmdldE9ic2VydmVyO1xuICAgICAgICBpZiAoIXRhcmdldE9ic2VydmVyKSB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlckxvY2F0b3IgPSB0aGlzLm9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgICAgIGlmICgkbW9kZSAmIGZyb21WaWV3KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIgPSBvYnNlcnZlckxvY2F0b3IuZ2V0T2JzZXJ2ZXIodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIgPSBvYnNlcnZlckxvY2F0b3IuZ2V0QWNjZXNzb3IodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50YXJnZXRPYnNlcnZlciA9IHRhcmdldE9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGR1cmluZyBiaW5kLCBiaW5kaW5nIGJlaGF2aW9yIG1pZ2h0IGhhdmUgY2hhbmdlZCBzb3VyY2VFeHByZXNzaW9uXG4gICAgICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yID0gdGhpcy5pbnRlcmNlcHRvcjtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9ICgkbW9kZSAmIHRvVmlldykgPiAwO1xuICAgICAgICBpZiAoJG1vZGUgJiB0b1ZpZXdPck9uZVRpbWUpIHtcbiAgICAgICAgICAgIGludGVyY2VwdG9yLnVwZGF0ZVRhcmdldChzb3VyY2VFeHByZXNzaW9uLmV2YWx1YXRlKGZsYWdzLCBzY29wZSwgdGhpcy4kaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIHNob3VsZENvbm5lY3QgPyBpbnRlcmNlcHRvciA6IG51bGwpLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRtb2RlICYgZnJvbVZpZXcpIHtcbiAgICAgICAgICAgIHRhcmdldE9ic2VydmVyLnN1YnNjcmliZShpbnRlcmNlcHRvcik7XG4gICAgICAgICAgICBpZiAoIXNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRvci51cGRhdGVTb3VyY2UodGFyZ2V0T2JzZXJ2ZXIuZ2V0VmFsdWUodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0UHJvcGVydHkpLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlclt0aGlzLmlkXSB8PSAxNiAvKiB1cGRhdGVTb3VyY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdGVudEZsYWdzID0gMCAvKiBub25lICovO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFeHByZXNzaW9uLmhhc1VuYmluZCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uLnVuYmluZChmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5pbnRlcmNlcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRhcmdldE9ic2VydmVyID0gdGhpcy50YXJnZXRPYnNlcnZlcjtcbiAgICAgICAgY29uc3QgdGFzayA9IHRoaXMudGFzaztcbiAgICAgICAgaWYgKHRhcmdldE9ic2VydmVyLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0YXJnZXRPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzLmludGVyY2VwdG9yKTtcbiAgICAgICAgICAgIHRhcmdldE9ic2VydmVyW3RoaXMuaWRdICY9IH4xNiAvKiB1cGRhdGVTb3VyY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhc2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnMuY2xlYXIodHJ1ZSk7XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgIH1cbn1cbmNvbm5lY3RhYmxlKFByb3BlcnR5QmluZGluZyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0eS1iaW5kaW5nLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBSZWZCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VFeHByZXNzaW9uLCB0YXJnZXQsIGxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFeHByZXNzaW9uID0gc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kc2NvcGUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJGhvc3RTY29wZSA9IG51bGw7XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzY29wZSA9PT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdG9yLiR1bmJpbmQoZmxhZ3MgfCAzMiAvKiBmcm9tQmluZCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy4kaG9zdFNjb3BlID0gaG9zdFNjb3BlO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFeHByZXNzaW9uLmhhc0JpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRXhwcmVzc2lvbi5iaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUV4cHJlc3Npb24uYXNzaWduKGZsYWdzIHwgMTYgLyogdXBkYXRlU291cmNlICovLCB0aGlzLiRzY29wZSwgaG9zdFNjb3BlLCB0aGlzLmxvY2F0b3IsIHRoaXMudGFyZ2V0KTtcbiAgICAgICAgLy8gYWRkIGlzQm91bmQgZmxhZyBhbmQgcmVtb3ZlIGlzQmluZGluZyBmbGFnXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgfVxuICAgICR1bmJpbmQoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc291cmNlRXhwcmVzc2lvbiA9IHRoaXMuc291cmNlRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHNvdXJjZUV4cHJlc3Npb24uZXZhbHVhdGUoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMubG9jYXRvciwgbnVsbCkgPT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICBzb3VyY2VFeHByZXNzaW9uLmFzc2lnbihmbGFncywgdGhpcy4kc2NvcGUsIHRoaXMuJGhvc3RTY29wZSwgdGhpcy5sb2NhdG9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb3VyY2UgZXhwcmVzc2lvbiBtaWdodCBoYXZlIGJlZW4gbW9kaWZpZWQgZHVycmluZyBhc3NpZ24sIHZpYSBhIEJCXG4gICAgICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHNvdXJjZUV4cHJlc3Npb24gPSB0aGlzLnNvdXJjZUV4cHJlc3Npb247XG4gICAgICAgIGlmIChzb3VyY2VFeHByZXNzaW9uLmhhc1VuYmluZCkge1xuICAgICAgICAgICAgc291cmNlRXhwcmVzc2lvbi51bmJpbmQoZmxhZ3MsIHRoaXMuJHNjb3BlLCB0aGlzLiRob3N0U2NvcGUsIHRoaXMuaW50ZXJjZXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNjb3BlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICB9XG4gICAgb2JzZXJ2ZVByb3BlcnR5KG9iaiwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLWJpbmRpbmcuanMubWFwIiwiaW1wb3J0IHsgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuLCBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm4sIERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm4sIFJlZkF0dHJpYnV0ZVBhdHRlcm4sIH0gZnJvbSAnLi9yZXNvdXJjZXMvYXR0cmlidXRlLXBhdHRlcm4uanMnO1xuaW1wb3J0IHsgQ2FsbEJpbmRpbmdDb21tYW5kLCBEZWZhdWx0QmluZGluZ0NvbW1hbmQsIEZvckJpbmRpbmdDb21tYW5kLCBGcm9tVmlld0JpbmRpbmdDb21tYW5kLCBPbmVUaW1lQmluZGluZ0NvbW1hbmQsIFRvVmlld0JpbmRpbmdDb21tYW5kLCBUd29XYXlCaW5kaW5nQ29tbWFuZCwgQXR0ckJpbmRpbmdDb21tYW5kLCBDYXB0dXJlQmluZGluZ0NvbW1hbmQsIENsYXNzQmluZGluZ0NvbW1hbmQsIERlbGVnYXRlQmluZGluZ0NvbW1hbmQsIFJlZkJpbmRpbmdDb21tYW5kLCBTdHlsZUJpbmRpbmdDb21tYW5kLCBUcmlnZ2VyQmluZGluZ0NvbW1hbmQsIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1jb21tYW5kLmpzJztcbmltcG9ydCB7IFRlbXBsYXRlQ29tcGlsZXIgfSBmcm9tICcuL3RlbXBsYXRlLWNvbXBpbGVyLmpzJztcbmltcG9ydCB7IENhbGxCaW5kaW5nUmVuZGVyZXIsIEN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyLCBDdXN0b21FbGVtZW50UmVuZGVyZXIsIEludGVycG9sYXRpb25CaW5kaW5nUmVuZGVyZXIsIEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyLCBMZXRFbGVtZW50UmVuZGVyZXIsIFByb3BlcnR5QmluZGluZ1JlbmRlcmVyLCBSZWZCaW5kaW5nUmVuZGVyZXIsIFNldFByb3BlcnR5UmVuZGVyZXIsIFRlbXBsYXRlQ29udHJvbGxlclJlbmRlcmVyLCBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXIsIExpc3RlbmVyQmluZGluZ1JlbmRlcmVyLCBTZXRBdHRyaWJ1dGVSZW5kZXJlciwgU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciwgVGV4dEJpbmRpbmdSZW5kZXJlciwgU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlciwgU2V0U3R5bGVBdHRyaWJ1dGVSZW5kZXJlciwgfSBmcm9tICcuL3JlbmRlcmVyLmpzJztcbmltcG9ydCB7IEZyb21WaWV3QmluZGluZ0JlaGF2aW9yLCBPbmVUaW1lQmluZGluZ0JlaGF2aW9yLCBUb1ZpZXdCaW5kaW5nQmVoYXZpb3IsIFR3b1dheUJpbmRpbmdCZWhhdmlvciwgfSBmcm9tICcuL2JpbmRpbmctYmVoYXZpb3JzL2JpbmRpbmctbW9kZS5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZUJpbmRpbmdCZWhhdmlvciB9IGZyb20gJy4vYmluZGluZy1iZWhhdmlvcnMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgU2lnbmFsQmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9ycy9zaWduYWxzLmpzJztcbmltcG9ydCB7IFRocm90dGxlQmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9ycy90aHJvdHRsZS5qcyc7XG5pbXBvcnQgeyBTVkdBbmFseXplciB9IGZyb20gJy4vb2JzZXJ2YXRpb24vc3ZnLWFuYWx5emVyLmpzJztcbmltcG9ydCB7IEF0dHJCaW5kaW5nQmVoYXZpb3IgfSBmcm9tICcuL3Jlc291cmNlcy9iaW5kaW5nLWJlaGF2aW9ycy9hdHRyLmpzJztcbmltcG9ydCB7IFNlbGZCaW5kaW5nQmVoYXZpb3IgfSBmcm9tICcuL3Jlc291cmNlcy9iaW5kaW5nLWJlaGF2aW9ycy9zZWxmLmpzJztcbmltcG9ydCB7IFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3IgfSBmcm9tICcuL3Jlc291cmNlcy9iaW5kaW5nLWJlaGF2aW9ycy91cGRhdGUtdHJpZ2dlci5qcyc7XG5pbXBvcnQgeyBCbHVyIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZXMvYmx1ci5qcyc7XG5pbXBvcnQgeyBGb2N1cyB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGVzL2ZvY3VzLmpzJztcbmltcG9ydCB7IFNob3cgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlcy9zaG93LmpzJztcbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gJy4vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3BvcnRhbC5qcyc7XG5pbXBvcnQgeyBGcmVxdWVudE11dGF0aW9ucywgT2JzZXJ2ZVNoYWxsb3cgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9mbGFncy5qcyc7XG5pbXBvcnQgeyBFbHNlLCBJZiB9IGZyb20gJy4vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL2lmLmpzJztcbmltcG9ydCB7IFJlcGVhdCB9IGZyb20gJy4vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3JlcGVhdC5qcyc7XG5pbXBvcnQgeyBXaXRoIH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvd2l0aC5qcyc7XG5pbXBvcnQgeyBTd2l0Y2gsIENhc2UsIERlZmF1bHRDYXNlIH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvc3dpdGNoLmpzJztcbmltcG9ydCB7IENvbXBvc2UgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudHMvY29tcG9zZS5qcyc7XG5pbXBvcnQgeyBBdVNsb3QgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudHMvYXUtc2xvdC5qcyc7XG5pbXBvcnQgeyBTYW5pdGl6ZVZhbHVlQ29udmVydGVyIH0gZnJvbSAnLi9yZXNvdXJjZXMvdmFsdWUtY29udmVydGVycy9zYW5pdGl6ZS5qcyc7XG5pbXBvcnQgeyBWaWV3VmFsdWVDb252ZXJ0ZXIgfSBmcm9tICcuL3Jlc291cmNlcy92YWx1ZS1jb252ZXJ0ZXJzL3ZpZXcuanMnO1xuaW1wb3J0IHsgTm9kZU9ic2VydmVyTG9jYXRvciB9IGZyb20gJy4vb2JzZXJ2YXRpb24vb2JzZXJ2ZXItbG9jYXRvci5qcyc7XG5leHBvcnQgY29uc3QgRGVib3VuY2VCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBEZWJvdW5jZUJpbmRpbmdCZWhhdmlvcjtcbmV4cG9ydCBjb25zdCBPbmVUaW1lQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uID0gT25lVGltZUJpbmRpbmdCZWhhdmlvcjtcbmV4cG9ydCBjb25zdCBUb1ZpZXdCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBUb1ZpZXdCaW5kaW5nQmVoYXZpb3I7XG5leHBvcnQgY29uc3QgRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBGcm9tVmlld0JpbmRpbmdCZWhhdmlvcjtcbmV4cG9ydCBjb25zdCBTaWduYWxCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBTaWduYWxCaW5kaW5nQmVoYXZpb3I7XG5leHBvcnQgY29uc3QgVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBUaHJvdHRsZUJpbmRpbmdCZWhhdmlvcjtcbmV4cG9ydCBjb25zdCBUd29XYXlCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBUd29XYXlCaW5kaW5nQmVoYXZpb3I7XG5leHBvcnQgY29uc3QgSVRlbXBsYXRlQ29tcGlsZXJSZWdpc3RyYXRpb24gPSBUZW1wbGF0ZUNvbXBpbGVyO1xuZXhwb3J0IGNvbnN0IElOb2RlT2JzZXJ2ZXJMb2NhdG9yUmVnaXN0cmF0aW9uID0gTm9kZU9ic2VydmVyTG9jYXRvcjtcbi8qKlxuICogRGVmYXVsdCBIVE1MLXNwZWNpZmljIChidXQgZW52aXJvbm1lbnQtYWdub3N0aWMpIGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBpbnRlcmZhY2VzOlxuICogLSBgSVRlbXBsYXRlQ29tcGlsZXJgXG4gKiAtIGBJVGFyZ2V0QWNjZXNzb3JMb2NhdG9yYFxuICogLSBgSVRhcmdldE9ic2VydmVyTG9jYXRvcmBcbiAqL1xuZXhwb3J0IGNvbnN0IERlZmF1bHRDb21wb25lbnRzID0gW1xuICAgIElUZW1wbGF0ZUNvbXBpbGVyUmVnaXN0cmF0aW9uLFxuICAgIElOb2RlT2JzZXJ2ZXJMb2NhdG9yUmVnaXN0cmF0aW9uLFxuXTtcbmV4cG9ydCBjb25zdCBTVkdBbmFseXplclJlZ2lzdHJhdGlvbiA9IFNWR0FuYWx5emVyO1xuZXhwb3J0IGNvbnN0IEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvbiA9IEF0UHJlZml4ZWRUcmlnZ2VyQXR0cmlidXRlUGF0dGVybjtcbmV4cG9ydCBjb25zdCBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24gPSBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm47XG5leHBvcnQgY29uc3QgUmVmQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvbiA9IFJlZkF0dHJpYnV0ZVBhdHRlcm47XG5leHBvcnQgY29uc3QgRG90U2VwYXJhdGVkQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvbiA9IERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm47XG4vKipcbiAqIERlZmF1bHQgYmluZGluZyBzeW50YXggZm9yIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlIG5hbWUgcGF0dGVybnM6XG4gKiAtIGByZWZgXG4gKiAtIGB0YXJnZXQuY29tbWFuZGAgKGRvdC1zZXBhcmF0ZWQpXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0QmluZGluZ1N5bnRheCA9IFtcbiAgICBSZWZBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLFxuICAgIERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb25cbl07XG4vKipcbiAqIEJpbmRpbmcgc3ludGF4IGZvciBzaG9ydC1oYW5kIGF0dHJpYnV0ZSBuYW1lIHBhdHRlcm5zOlxuICogLSBgQHRhcmdldGAgKHNob3J0LWhhbmQgZm9yIGB0YXJnZXQudHJpZ2dlcmApXG4gKiAtIGA6dGFyZ2V0YCAoc2hvcnQtaGFuZCBmb3IgYHRhcmdldC5iaW5kYClcbiAqL1xuZXhwb3J0IGNvbnN0IFNob3J0SGFuZEJpbmRpbmdTeW50YXggPSBbXG4gICAgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLFxuICAgIENvbG9uUHJlZml4ZWRCaW5kQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvblxuXTtcbmV4cG9ydCBjb25zdCBDYWxsQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBDYWxsQmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgRGVmYXVsdEJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gRGVmYXVsdEJpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IEZvckJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gRm9yQmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgRnJvbVZpZXdCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IEZyb21WaWV3QmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgT25lVGltZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gT25lVGltZUJpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IFRvVmlld0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gVG9WaWV3QmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgVHdvV2F5QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBUd29XYXlCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBSZWZCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IFJlZkJpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IFRyaWdnZXJCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiA9IFRyaWdnZXJCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBEZWxlZ2F0ZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gRGVsZWdhdGVCaW5kaW5nQ29tbWFuZDtcbmV4cG9ydCBjb25zdCBDYXB0dXJlQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBDYXB0dXJlQmluZGluZ0NvbW1hbmQ7XG5leHBvcnQgY29uc3QgQXR0ckJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uID0gQXR0ckJpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IENsYXNzQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBDbGFzc0JpbmRpbmdDb21tYW5kO1xuZXhwb3J0IGNvbnN0IFN0eWxlQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24gPSBTdHlsZUJpbmRpbmdDb21tYW5kO1xuLyoqXG4gKiBEZWZhdWx0IEhUTUwtc3BlY2lmaWMgKGJ1dCBlbnZpcm9ubWVudC1hZ25vc3RpYykgYmluZGluZyBjb21tYW5kczpcbiAqIC0gUHJvcGVydHkgb2JzZXJ2YXRpb246IGAuYmluZGAsIGAub25lLXRpbWVgLCBgLmZyb20tdmlld2AsIGAudG8tdmlld2AsIGAudHdvLXdheWBcbiAqIC0gRnVuY3Rpb24gY2FsbDogYC5jYWxsYFxuICogLSBDb2xsZWN0aW9uIG9ic2VydmF0aW9uOiBgLmZvcmBcbiAqIC0gRXZlbnQgbGlzdGVuZXJzOiBgLnRyaWdnZXJgLCBgLmRlbGVnYXRlYCwgYC5jYXB0dXJlYFxuICovXG5leHBvcnQgY29uc3QgRGVmYXVsdEJpbmRpbmdMYW5ndWFnZSA9IFtcbiAgICBEZWZhdWx0QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4gICAgT25lVGltZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIEZyb21WaWV3QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4gICAgVG9WaWV3QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4gICAgVHdvV2F5QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4gICAgQ2FsbEJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIEZvckJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIFJlZkJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIFRyaWdnZXJCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBEZWxlZ2F0ZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIENhcHR1cmVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbiAgICBDbGFzc0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuICAgIFN0eWxlQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4gICAgQXR0ckJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuXTtcbmV4cG9ydCBjb25zdCBTYW5pdGl6ZVZhbHVlQ29udmVydGVyUmVnaXN0cmF0aW9uID0gU2FuaXRpemVWYWx1ZUNvbnZlcnRlcjtcbmV4cG9ydCBjb25zdCBWaWV3VmFsdWVDb252ZXJ0ZXJSZWdpc3RyYXRpb24gPSBWaWV3VmFsdWVDb252ZXJ0ZXI7XG5leHBvcnQgY29uc3QgRnJlcXVlbnRNdXRhdGlvbnNSZWdpc3RyYXRpb24gPSBGcmVxdWVudE11dGF0aW9ucztcbmV4cG9ydCBjb25zdCBPYnNlcnZlU2hhbGxvd1JlZ2lzdHJhdGlvbiA9IE9ic2VydmVTaGFsbG93O1xuZXhwb3J0IGNvbnN0IElmUmVnaXN0cmF0aW9uID0gSWY7XG5leHBvcnQgY29uc3QgRWxzZVJlZ2lzdHJhdGlvbiA9IEVsc2U7XG5leHBvcnQgY29uc3QgUmVwZWF0UmVnaXN0cmF0aW9uID0gUmVwZWF0O1xuZXhwb3J0IGNvbnN0IFdpdGhSZWdpc3RyYXRpb24gPSBXaXRoO1xuZXhwb3J0IGNvbnN0IFN3aXRjaFJlZ2lzdHJhdGlvbiA9IFN3aXRjaDtcbmV4cG9ydCBjb25zdCBDYXNlUmVnaXN0cmF0aW9uID0gQ2FzZTtcbmV4cG9ydCBjb25zdCBEZWZhdWx0Q2FzZVJlZ2lzdHJhdGlvbiA9IERlZmF1bHRDYXNlO1xuZXhwb3J0IGNvbnN0IEF0dHJCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBBdHRyQmluZGluZ0JlaGF2aW9yO1xuZXhwb3J0IGNvbnN0IFNlbGZCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBTZWxmQmluZGluZ0JlaGF2aW9yO1xuZXhwb3J0IGNvbnN0IFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24gPSBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yO1xuZXhwb3J0IGNvbnN0IENvbXBvc2VSZWdpc3RyYXRpb24gPSBDb21wb3NlO1xuZXhwb3J0IGNvbnN0IFBvcnRhbFJlZ2lzdHJhdGlvbiA9IFBvcnRhbDtcbmV4cG9ydCBjb25zdCBGb2N1c1JlZ2lzdHJhdGlvbiA9IEZvY3VzO1xuZXhwb3J0IGNvbnN0IEJsdXJSZWdpc3RyYXRpb24gPSBCbHVyO1xuZXhwb3J0IGNvbnN0IFNob3dSZWdpc3RyYXRpb24gPSBTaG93O1xuLyoqXG4gKiBEZWZhdWx0IEhUTUwtc3BlY2lmaWMgKGJ1dCBlbnZpcm9ubWVudC1hZ25vc3RpYykgcmVzb3VyY2VzOlxuICogLSBCaW5kaW5nIEJlaGF2aW9yczogYG9uZVRpbWVgLCBgdG9WaWV3YCwgYGZyb21WaWV3YCwgYHR3b1dheWAsIGBzaWduYWxgLCBgZGVib3VuY2VgLCBgdGhyb3R0bGVgLCBgYXR0cmAsIGBzZWxmYCwgYHVwZGF0ZVRyaWdnZXJgXG4gKiAtIEN1c3RvbSBFbGVtZW50czogYGF1LWNvbXBvc2VgLCBgYXUtc2xvdGBcbiAqIC0gQ3VzdG9tIEF0dHJpYnV0ZXM6IGBibHVyYCwgYGZvY3VzYCwgYHBvcnRhbGBcbiAqIC0gVGVtcGxhdGUgY29udHJvbGxlcnM6IGBpZmAvYGVsc2VgLCBgcmVwZWF0YCwgYHdpdGhgXG4gKiAtIFZhbHVlIENvbnZlcnRlcnM6IGBzYW5pdGl6ZWBcbiAqL1xuZXhwb3J0IGNvbnN0IERlZmF1bHRSZXNvdXJjZXMgPSBbXG4gICAgRGVib3VuY2VCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4gICAgT25lVGltZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbiAgICBUb1ZpZXdCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4gICAgRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4gICAgU2lnbmFsQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuICAgIFRocm90dGxlQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuICAgIFR3b1dheUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbiAgICBTYW5pdGl6ZVZhbHVlQ29udmVydGVyUmVnaXN0cmF0aW9uLFxuICAgIFZpZXdWYWx1ZUNvbnZlcnRlclJlZ2lzdHJhdGlvbixcbiAgICBGcmVxdWVudE11dGF0aW9uc1JlZ2lzdHJhdGlvbixcbiAgICBPYnNlcnZlU2hhbGxvd1JlZ2lzdHJhdGlvbixcbiAgICBJZlJlZ2lzdHJhdGlvbixcbiAgICBFbHNlUmVnaXN0cmF0aW9uLFxuICAgIFJlcGVhdFJlZ2lzdHJhdGlvbixcbiAgICBXaXRoUmVnaXN0cmF0aW9uLFxuICAgIFN3aXRjaFJlZ2lzdHJhdGlvbixcbiAgICBDYXNlUmVnaXN0cmF0aW9uLFxuICAgIERlZmF1bHRDYXNlUmVnaXN0cmF0aW9uLFxuICAgIEF0dHJCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4gICAgU2VsZkJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbiAgICBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuICAgIENvbXBvc2VSZWdpc3RyYXRpb24sXG4gICAgUG9ydGFsUmVnaXN0cmF0aW9uLFxuICAgIEZvY3VzUmVnaXN0cmF0aW9uLFxuICAgIEJsdXJSZWdpc3RyYXRpb24sXG4gICAgU2hvd1JlZ2lzdHJhdGlvbixcbiAgICBBdVNsb3QsXG5dO1xuZXhwb3J0IGNvbnN0IENhbGxCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24gPSBDYWxsQmluZGluZ1JlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IEN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uID0gQ3VzdG9tQXR0cmlidXRlUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgQ3VzdG9tRWxlbWVudFJlbmRlcmVyUmVnaXN0cmF0aW9uID0gQ3VzdG9tRWxlbWVudFJlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IEludGVycG9sYXRpb25CaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24gPSBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gSXRlcmF0b3JCaW5kaW5nUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgTGV0RWxlbWVudFJlbmRlcmVyUmVnaXN0cmF0aW9uID0gTGV0RWxlbWVudFJlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IFByb3BlcnR5QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gUHJvcGVydHlCaW5kaW5nUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgUmVmQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gUmVmQmluZGluZ1JlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IFNldFByb3BlcnR5UmVuZGVyZXJSZWdpc3RyYXRpb24gPSBTZXRQcm9wZXJ0eVJlbmRlcmVyO1xuZXhwb3J0IGNvbnN0IFRlbXBsYXRlQ29udHJvbGxlclJlbmRlcmVyUmVnaXN0cmF0aW9uID0gVGVtcGxhdGVDb250cm9sbGVyUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24gPSBMaXN0ZW5lckJpbmRpbmdSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24gPSBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXI7XG5leHBvcnQgY29uc3QgU2V0QXR0cmlidXRlUmVuZGVyZXJSZWdpc3RyYXRpb24gPSBTZXRBdHRyaWJ1dGVSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBTZXRDbGFzc0F0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uID0gU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uID0gU2V0U3R5bGVBdHRyaWJ1dGVSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBTdHlsZVByb3BlcnR5QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlcjtcbmV4cG9ydCBjb25zdCBUZXh0QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uID0gVGV4dEJpbmRpbmdSZW5kZXJlcjtcbi8qKlxuICogRGVmYXVsdCByZW5kZXJlcnMgZm9yOlxuICogLSBQcm9wZXJ0eUJpbmRpbmc6IGBiaW5kYCwgYG9uZS10aW1lYCwgYHRvLXZpZXdgLCBgZnJvbS12aWV3YCwgYHR3by13YXlgXG4gKiAtIEl0ZXJhdG9yQmluZGluZzogYGZvcmBcbiAqIC0gQ2FsbEJpbmRpbmc6IGBjYWxsYFxuICogLSBSZWZCaW5kaW5nOiBgcmVmYFxuICogLSBJbnRlcnBvbGF0aW9uQmluZGluZzogYCR7fWBcbiAqIC0gU2V0UHJvcGVydHlcbiAqIC0gYGN1c3RvbUVsZW1lbnRgIGh5ZHJhdGlvblxuICogLSBgY3VzdG9tQXR0cmlidXRlYCBoeWRyYXRpb25cbiAqIC0gYHRlbXBsYXRlQ29udHJvbGxlcmAgaHlkcmF0aW9uXG4gKiAtIGBsZXRgIGVsZW1lbnQgaHlkcmF0aW9uXG4gKiAtIExpc3RlbmVyIEJpbmRpbmdzOiBgdHJpZ2dlcmAsIGBjYXB0dXJlYCwgYGRlbGVnYXRlYFxuICogLSBTZXRBdHRyaWJ1dGVcbiAqIC0gU3R5bGVQcm9wZXJ0eTogYHN0eWxlYCwgYGNzc2BcbiAqIC0gVGV4dEJpbmRpbmc6IGAke31gXG4gKi9cbmV4cG9ydCBjb25zdCBEZWZhdWx0UmVuZGVyZXJzID0gW1xuICAgIFByb3BlcnR5QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIENhbGxCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgUmVmQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIEludGVycG9sYXRpb25CaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgU2V0UHJvcGVydHlSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBDdXN0b21FbGVtZW50UmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgQ3VzdG9tQXR0cmlidXRlUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgVGVtcGxhdGVDb250cm9sbGVyUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgTGV0RWxlbWVudFJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIExpc3RlbmVyQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIEF0dHJpYnV0ZUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBTZXRBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBTZXRDbGFzc0F0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuICAgIFNldFN0eWxlQXR0cmlidXRlUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4gICAgU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbiAgICBUZXh0QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuXTtcbi8qKlxuICogQSBESSBjb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIGh0bWwtc3BlY2lmaWMgKGJ1dCBlbnZpcm9ubWVudC1hZ25vc3RpYykgcmVnaXN0cmF0aW9uczpcbiAqIC0gYFJ1bnRpbWVDb25maWd1cmF0aW9uYCBmcm9tIGBAYXVyZWxpYS9ydW50aW1lYFxuICogLSBgRGVmYXVsdENvbXBvbmVudHNgXG4gKiAtIGBEZWZhdWx0UmVzb3VyY2VzYFxuICogLSBgRGVmYXVsdFJlbmRlcmVyc2BcbiAqL1xuZXhwb3J0IGNvbnN0IFN0YW5kYXJkQ29uZmlndXJhdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGNvbmZpZ3VyYXRpb24gdG8gdGhlIHByb3ZpZGVkIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5yZWdpc3RlciguLi5EZWZhdWx0Q29tcG9uZW50cywgLi4uRGVmYXVsdFJlc291cmNlcywgLi4uRGVmYXVsdEJpbmRpbmdTeW50YXgsIC4uLkRlZmF1bHRCaW5kaW5nTGFuZ3VhZ2UsIC4uLkRlZmF1bHRSZW5kZXJlcnMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbnRhaW5lciB3aXRoIHRoaXMgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXIoREkuY3JlYXRlQ29udGFpbmVyKCkpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWd1cmF0aW9uLmpzLm1hcCIsImltcG9ydCB7IEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24sIGlzSW5zdHJ1Y3Rpb24sIFNldEF0dHJpYnV0ZUluc3RydWN0aW9uLCB9IGZyb20gJy4vcmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudERlZmluaXRpb24gfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBnZXRSZW5kZXJDb250ZXh0IH0gZnJvbSAnLi90ZW1wbGF0aW5nL3JlbmRlci1jb250ZXh0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHAsIHRhZ09yVHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgaWYgKHR5cGVvZiB0YWdPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50Rm9yVGFnKHAsIHRhZ09yVHlwZSwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQ3VzdG9tRWxlbWVudC5pc1R5cGUodGFnT3JUeXBlKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudEZvclR5cGUocCwgdGFnT3JUeXBlLCBwcm9wcywgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhZ09yVHlwZS5gKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbmRlclBsYW4uIFRvZG86IGRlc2NyaWJlIGdvYWwgb2YgdGhpcyBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgUmVuZGVyUGxhbiB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgaW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmxhenlEZWZpbml0aW9uID0gdm9pZCAwO1xuICAgIH1cbiAgICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGF6eURlZmluaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5sYXp5RGVmaW5pdGlvbiA9IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogQ3VzdG9tRWxlbWVudC5nZW5lcmF0ZU5hbWUoKSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgIG5lZWRzQ29tcGlsZTogdHlwZW9mIHRoaXMubm9kZSA9PT0gJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHRoaXMuZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF6eURlZmluaXRpb247XG4gICAgfVxuICAgIGdldENvbnRleHQocGFyZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBnZXRSZW5kZXJDb250ZXh0KHRoaXMuZGVmaW5pdGlvbiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG4gICAgY3JlYXRlVmlldyhwYXJlbnRDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Vmlld0ZhY3RvcnkocGFyZW50Q29udGFpbmVyKS5jcmVhdGUoKTtcbiAgICB9XG4gICAgZ2V0Vmlld0ZhY3RvcnkocGFyZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRleHQocGFyZW50Q29udGFpbmVyKS5nZXRWaWV3RmFjdG9yeSgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgbWVyZ2VJbnRvKHBhcmVudCwgaW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIGluc3RydWN0aW9ucy5wdXNoKC4uLnRoaXMuaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goLi4udGhpcy5kZXBlbmRlbmNpZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRGb3JUYWcocCwgdGFnTmFtZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgY29uc3QgYWxsSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gW107XG4gICAgY29uc3QgZWxlbWVudCA9IHAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBsZXQgaGFzSW5zdHJ1Y3Rpb25zID0gZmFsc2U7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzKVxuICAgICAgICAgICAgLmZvckVhY2godG8gPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1t0b107XG4gICAgICAgICAgICBpZiAoaXNJbnN0cnVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNJbnN0cnVjdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHRvLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2F1JztcbiAgICAgICAgYWxsSW5zdHJ1Y3Rpb25zLnB1c2goaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGFkZENoaWxkcmVuKHAsIGVsZW1lbnQsIGNoaWxkcmVuLCBhbGxJbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVuZGVyUGxhbihlbGVtZW50LCBhbGxJbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50Rm9yVHlwZShwLCBUeXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKFR5cGUpO1xuICAgIGNvbnN0IHRhZ05hbWUgPSBkZWZpbml0aW9uLm5hbWU7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgY29uc3QgYWxsSW5zdHJ1Y3Rpb25zID0gW2luc3RydWN0aW9uc107XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gW107XG4gICAgY29uc3QgY2hpbGRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBjb25zdCBiaW5kYWJsZXMgPSBkZWZpbml0aW9uLmJpbmRhYmxlcztcbiAgICBjb25zdCBlbGVtZW50ID0gcC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2F1JztcbiAgICBpZiAoIWRlcGVuZGVuY2llcy5pbmNsdWRlcyhUeXBlKSkge1xuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChUeXBlKTtcbiAgICB9XG4gICAgaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24odGFnTmFtZSwgdm9pZCAwLCBjaGlsZEluc3RydWN0aW9ucywgbnVsbCkpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wcylcbiAgICAgICAgICAgIC5mb3JFYWNoKHRvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbdG9dO1xuICAgICAgICAgICAgaWYgKGlzSW5zdHJ1Y3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5kYWJsZSA9IGJpbmRhYmxlc1t0b107XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRhYmxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlXCIgLyogc2V0UHJvcGVydHkgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbnMucHVzaChuZXcgU2V0QXR0cmlidXRlSW5zdHJ1Y3Rpb24odmFsdWUsIHRvKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGFkZENoaWxkcmVuKHAsIGVsZW1lbnQsIGNoaWxkcmVuLCBhbGxJbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVuZGVyUGxhbihlbGVtZW50LCBhbGxJbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBhZGRDaGlsZHJlbihwLCBwYXJlbnQsIGNoaWxkcmVuLCBhbGxJbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjdXJyZW50KSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChwLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBwLk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgnbWVyZ2VJbnRvJyBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVyZ2VJbnRvKHBhcmVudCwgYWxsSW5zdHJ1Y3Rpb25zLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1lbGVtZW50LmpzLm1hcCIsImltcG9ydCB7IERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IElBcHBSb290IH0gZnJvbSAnLi9hcHAtcm9vdC5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5leHBvcnQgY29uc3QgSU5vZGUgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lOb2RlJyk7XG5leHBvcnQgY29uc3QgSUV2ZW50VGFyZ2V0ID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJRXZlbnRUYXJnZXQnLCB4ID0+IHguY2FjaGVkQ2FsbGJhY2soaGFuZGxlciA9PiB7XG4gICAgaWYgKGhhbmRsZXIuaGFzKElBcHBSb290LCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlci5nZXQoSUFwcFJvb3QpLmhvc3Q7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmdldChJUGxhdGZvcm0pLmRvY3VtZW50O1xufSkpO1xuZXhwb3J0IGNvbnN0IElSZW5kZXJMb2NhdGlvbiA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVJlbmRlckxvY2F0aW9uJyk7XG5leHBvcnQgdmFyIE5vZGVUeXBlO1xuKGZ1bmN0aW9uIChOb2RlVHlwZSkge1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRWxlbWVudFwiXSA9IDFdID0gXCJFbGVtZW50XCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJBdHRyXCJdID0gMl0gPSBcIkF0dHJcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiQ0RBVEFTZWN0aW9uXCJdID0gNF0gPSBcIkNEQVRBU2VjdGlvblwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRW50aXR5UmVmZXJlbmNlXCJdID0gNV0gPSBcIkVudGl0eVJlZmVyZW5jZVwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRW50aXR5XCJdID0gNl0gPSBcIkVudGl0eVwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiUHJvY2Vzc2luZ0luc3RydWN0aW9uXCJdID0gN10gPSBcIlByb2Nlc3NpbmdJbnN0cnVjdGlvblwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiQ29tbWVudFwiXSA9IDhdID0gXCJDb21tZW50XCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJEb2N1bWVudFwiXSA9IDldID0gXCJEb2N1bWVudFwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRUeXBlXCJdID0gMTBdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkRvY3VtZW50RnJhZ21lbnRcIl0gPSAxMV0gPSBcIkRvY3VtZW50RnJhZ21lbnRcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIk5vdGF0aW9uXCJdID0gMTJdID0gXCJOb3RhdGlvblwiO1xufSkoTm9kZVR5cGUgfHwgKE5vZGVUeXBlID0ge30pKTtcbmNvbnN0IGVmZmVjdGl2ZVBhcmVudE5vZGVPdmVycmlkZXMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgcGFyZW50Tm9kZSBhY2NvcmRpbmcgdG8gQXVyZWxpYSdzIGNvbXBvbmVudCBoaWVyYXJjaHkuXG4gKlxuICogVXNlZCBieSBBdXJlbGlhIHRvIGZpbmQgdGhlIGNsb3Nlc3QgcGFyZW50IGNvbnRyb2xsZXIgcmVsYXRpdmUgdG8gYSBub2RlLlxuICpcbiAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIDMgYWRkaXRpb25hbCBzY2VuYXJpb3MgdGhhdCBgbm9kZS5wYXJlbnROb2RlYCBkb2VzIG5vdCBzdXBwb3J0OlxuICogLSBDb250YWluZXJsZXNzIGVsZW1lbnRzLiBUaGUgcGFyZW50Tm9kZSBpbiB0aGlzIGNhc2UgaXMgYSBjb21tZW50IHByZWNlbmRpbmcgdGhlIGVsZW1lbnQgdW5kZXIgc3BlY2lmaWMgY29uZGl0aW9ucywgcmF0aGVyIHRoYW4gYSBub2RlIHdyYXBwaW5nIHRoZSBlbGVtZW50LlxuICogLSBTaGFkb3dET00uIElmIGEgYFNoYWRvd1Jvb3RgIGlzIGVuY291bnRlcmVkLCB0aGlzIG1ldGhvZCByZXRyaWV2ZXMgdGhlIGFzc29jaWF0ZWQgY29udHJvbGxlciB2aWEgdGhlIG1ldGFkYXRhIGFwaSB0byBsb2NhdGUgdGhlIG9yaWdpbmFsIGhvc3QuXG4gKiAtIFBvcnRhbHMuIElmIHRoZSBwcm92aWRlZCBub2RlIHdhcyBtb3ZlZCB0byBhIGRpZmZlcmVudCBsb2NhdGlvbiBpbiB0aGUgRE9NIGJ5IGEgYHBvcnRhbGAgYXR0cmlidXRlLCB0aGVuIHRoZSBvcmlnaW5hbCBwYXJlbnQgb2YgdGhlIG5vZGUgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgcGFyZW50IGZvci5cbiAqIEByZXR1cm5zIEVpdGhlciB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSwgdGhlIGNsb3Nlc3QgYElSZW5kZXJMb2NhdGlvbmAgKGNvbW1lbnQgbm9kZSB0aGF0IGlzIHRoZSBjb250YWluZXJsZXNzIGhvc3QpLCBvcmlnaW5hbCBwb3J0YWwgaG9zdCwgb3IgYG51bGxgIGlmIHRoaXMgaXMgZWl0aGVyIHRoZSBhYnNvbHV0ZSBkb2N1bWVudCByb290IG9yIGEgZGlzY29ubmVjdGVkIG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFZmZlY3RpdmVQYXJlbnROb2RlKG5vZGUpIHtcbiAgICAvLyBUT0RPOiB0aGlzIG1ldGhvZCBuZWVkcyBtb3JlIHRlc3RzIVxuICAgIC8vIEZpcnN0IGxvb2sgZm9yIGFueSBvdmVycmlkZXNcbiAgICBpZiAoZWZmZWN0aXZlUGFyZW50Tm9kZU92ZXJyaWRlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGVmZmVjdGl2ZVBhcmVudE5vZGVPdmVycmlkZXMuZ2V0KG5vZGUpO1xuICAgIH1cbiAgICAvLyBUaGVuIHRyeSB0byBnZXQgdGhlIG5lYXJlc3QgYXUtc3RhcnQgcmVuZGVyIGxvY2F0aW9uLCB3aGljaCB3b3VsZCBiZSB0aGUgY29udGFpbmVybGVzcyBwYXJlbnQsXG4gICAgLy8gYWdhaW4gbG9va2luZyBmb3IgYW55IG92ZXJyaWRlcyBhbG9uZyB0aGUgd2F5LlxuICAgIC8vIG90aGVyd2lzZSByZXR1cm4gdGhlIG5vcm1hbCBwYXJlbnQgbm9kZVxuICAgIGxldCBjb250YWluZXJsZXNzT2Zmc2V0ID0gMDtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgd2hpbGUgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT09IDggLyogQ29tbWVudCAqLykge1xuICAgICAgICAgICAgc3dpdGNoIChuZXh0LnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXUtc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzZWUgYW4gYXUtc3RhcnQgYmVmb3JlIHdlIHNlZSBhdS1lbmQsIGl0IHdpbGwgcHJlY2VkZSB0aGUgaG9zdCBvZiBhIHNpYmxpbmcgY29udGFpbmVybGVzcyBlbGVtZW50IHJhdGhlciB0aGFuIGEgcGFyZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyB3ZSB1c2UgdGhlIG9mZnNldCB0byBpZ25vcmUgdGhlIG5leHQgYXUtZW5kXG4gICAgICAgICAgICAgICAgICAgICsrY29udGFpbmVybGVzc09mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXUtZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcmxlc3NPZmZzZXQtLSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICB9XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSA9PT0gbnVsbCAmJiBub2RlLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovKSB7XG4gICAgICAgIC8vIENvdWxkIGJlIGEgc2hhZG93IHJvb3Q7IHNlZSBpZiB0aGVyZSdzIGEgY29udHJvbGxlciBhbmQgaWYgc28sIGdldCB0aGUgb3JpZ2luYWwgaG9zdCB2aWEgdGhlIHByb2plY3RvclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gQ3VzdG9tRWxlbWVudC5mb3Iobm9kZSk7XG4gICAgICAgIGlmIChjb250cm9sbGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIC8vIE5vdCBhIHNoYWRvdyByb290IChvciBhdCBsZWFzdCwgbm90IG9uZSBjcmVhdGVkIGJ5IEF1cmVsaWEpXG4gICAgICAgICAgICAvLyBOb3RoaW5nIG1vcmUgd2UgY2FuIHRyeSwganVzdCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIubW91bnRUYXJnZXQgPT09IDIgLyogc2hhZG93Um9vdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVmZmVjdGl2ZVBhcmVudE5vZGUoY29udHJvbGxlci5ob3N0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVmZmVjdGl2ZVBhcmVudE5vZGUoY2hpbGROb2RlT3JOb2RlU2VxdWVuY2UsIHBhcmVudE5vZGUpIHtcbiAgICBpZiAoY2hpbGROb2RlT3JOb2RlU2VxdWVuY2UucGxhdGZvcm0gIT09IHZvaWQgMCAmJiAhKGNoaWxkTm9kZU9yTm9kZVNlcXVlbmNlIGluc3RhbmNlb2YgY2hpbGROb2RlT3JOb2RlU2VxdWVuY2UucGxhdGZvcm0uTm9kZSkpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZE5vZGVPck5vZGVTZXF1ZW5jZS5jaGlsZE5vZGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBub2Rlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBlZmZlY3RpdmVQYXJlbnROb2RlT3ZlcnJpZGVzLnNldChub2Rlc1tpXSwgcGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVmZmVjdGl2ZVBhcmVudE5vZGVPdmVycmlkZXMuc2V0KGNoaWxkTm9kZU9yTm9kZVNlcXVlbmNlLCBwYXJlbnROb2RlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvUmVuZGVyTG9jYXRpb24obm9kZSkge1xuICAgIGlmIChpc1JlbmRlckxvY2F0aW9uKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlOyAvLyBpdCdzIGFscmVhZHkgYSBJUmVuZGVyTG9jYXRpb24gKGNvbnZlcnRlZCBieSBGcmFnbWVudE5vZGVTZXF1ZW5jZSlcbiAgICB9XG4gICAgY29uc3QgbG9jYXRpb25FbmQgPSBub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnYXUtZW5kJyk7XG4gICAgY29uc3QgbG9jYXRpb25TdGFydCA9IG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KCdhdS1zdGFydCcpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsb2NhdGlvbkVuZCwgbm9kZSk7XG4gICAgICAgIGxvY2F0aW9uRW5kLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxvY2F0aW9uU3RhcnQsIGxvY2F0aW9uRW5kKTtcbiAgICB9XG4gICAgbG9jYXRpb25FbmQuJHN0YXJ0ID0gbG9jYXRpb25TdGFydDtcbiAgICByZXR1cm4gbG9jYXRpb25FbmQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSZW5kZXJMb2NhdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGV4dENvbnRlbnQgPT09ICdhdS1lbmQnO1xufVxuZXhwb3J0IGNsYXNzIEZyYWdtZW50Tm9kZVNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybSwgZnJhZ21lbnQpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgIHRoaXMuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNMaW5rZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnJlZk5vZGUgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGVMaXN0ID0gZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnLmF1Jyk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGlpID0gdGFyZ2V0Tm9kZUxpc3QubGVuZ3RoO1xuICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy50YXJnZXRzID0gQXJyYXkoaWkpO1xuICAgICAgICB3aGlsZSAoaSA8IGlpKSB7XG4gICAgICAgICAgICAvLyBlYWdlcmx5IGNvbnZlcnQgYWxsIG1hcmtlcnMgdG8gUmVuZGVyTG9jYXRpb25zIChvdGhlcndpc2UgdGhlIHJlbmRlcmVyXG4gICAgICAgICAgICAvLyB3aWxsIGRvIGl0IGFueXdheSkgYW5kIHN0b3JlIHRoZW0gaW4gdGhlIHRhcmdldCBsaXN0IChzaW5jZSB0aGUgY29tbWVudHNcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHF1ZXJpZWQpXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXROb2RlTGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdBVS1NJykge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhlIHJlbmRlcmVyIHdpbGwgc3RpbGwgY2FsbCB0aGlzIG1ldGhvZCwgYnV0IGl0IHdpbGwganVzdCByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gbG9jYXRpb24gaWYgaXQgc2VlcyBpdCdzIGFscmVhZHkgYSBsb2NhdGlvblxuICAgICAgICAgICAgICAgIHRhcmdldHNbaV0gPSBjb252ZXJ0VG9SZW5kZXJMb2NhdGlvbih0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYWxzbyBzdG9yZSBub24tbWFya2VycyBmb3IgY29uc2lzdGVudCBvcmRlcmluZ1xuICAgICAgICAgICAgICAgIHRhcmdldHNbaV0gPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGROb2RlTGlzdCA9IGZyYWdtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICBpaSA9IGNoaWxkTm9kZUxpc3QubGVuZ3RoO1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzID0gQXJyYXkoaWkpO1xuICAgICAgICB3aGlsZSAoaSA8IGlpKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGVzW2ldID0gY2hpbGROb2RlTGlzdFtpXTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IGZyYWdtZW50Lmxhc3RDaGlsZDtcbiAgICB9XG4gICAgZmluZFRhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldHM7XG4gICAgfVxuICAgIGluc2VydEJlZm9yZShyZWZOb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTGlua2VkICYmICEhdGhpcy5yZWZOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRvTGlua2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSByZWZOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGN1cnJlbnQsIHJlZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVmTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmZyYWdtZW50LCByZWZOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmRUbyhwYXJlbnQsIGVuaGFuY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5maXJzdENoaWxkO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWVuaGFuY2UpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQ7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRvTGlua2VkKCkge1xuICAgICAgICBjb25zdCByZWZOb2RlID0gdGhpcy5yZWZOb2RlO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSByZWZOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY3VycmVudCwgcmVmTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZnJhZ21lbnQsIHJlZk5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubGluaygpIHtcbiAgICAgICAgdGhpcy5pc0xpbmtlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucmVmTm9kZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgbGluayhuZXh0KSB7XG4gICAgICAgIHRoaXMuaXNMaW5rZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaXNSZW5kZXJMb2NhdGlvbihuZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5yZWZOb2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLm9idGFpblJlZk5vZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnRhaW5SZWZOb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMucmVmTm9kZSA9IHRoaXMubmV4dC5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWZOb2RlID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElXaW5kb3cgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lXaW5kb3cnLCB4ID0+IHguY2FsbGJhY2soaGFuZGxlciA9PiBoYW5kbGVyLmdldChJUGxhdGZvcm0pLndpbmRvdykpO1xuZXhwb3J0IGNvbnN0IElMb2NhdGlvbiA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUxvY2F0aW9uJywgeCA9PiB4LmNhbGxiYWNrKGhhbmRsZXIgPT4gaGFuZGxlci5nZXQoSVdpbmRvdykubG9jYXRpb24pKTtcbmV4cG9ydCBjb25zdCBJSGlzdG9yeSA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUhpc3RvcnknLCB4ID0+IHguY2FsbGJhY2soaGFuZGxlciA9PiBoYW5kbGVyLmdldChJV2luZG93KS5oaXN0b3J5KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb20uanMubWFwIiwiZXhwb3J0IHsgUGxhdGZvcm0sIFRhc2tRdWV1ZSwgVGFzaywgVGFza0Fib3J0RXJyb3IsIFRhc2tRdWV1ZVByaW9yaXR5LCBUYXNrU3RhdHVzLCB9IGZyb20gJ0BhdXJlbGlhL3BsYXRmb3JtJztcbmV4cG9ydCB7IEJyb3dzZXJQbGF0Zm9ybSwgfSBmcm9tICdAYXVyZWxpYS9wbGF0Zm9ybS1icm93c2VyJztcbmV4cG9ydCB7IGJpbmRhYmxlLCBCaW5kYWJsZSwgQmluZGFibGVEZWZpbml0aW9uLCB9IGZyb20gJy4vYmluZGFibGUuanMnO1xuZXhwb3J0IHsgQmluZGFibGVPYnNlcnZlciwgfSBmcm9tICcuL29ic2VydmF0aW9uL2JpbmRhYmxlLW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IERlYm91bmNlQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBPbmVUaW1lQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBUb1ZpZXdCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sIEZyb21WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBTaWduYWxCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sIFRocm90dGxlQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLCBUd29XYXlCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sIH0gZnJvbSAnLi9jb25maWd1cmF0aW9uLmpzJztcbmV4cG9ydCB7IEJpbmRpbmdNb2RlQmVoYXZpb3IsIE9uZVRpbWVCaW5kaW5nQmVoYXZpb3IsIFRvVmlld0JpbmRpbmdCZWhhdmlvciwgRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3IsIFR3b1dheUJpbmRpbmdCZWhhdmlvciwgfSBmcm9tICcuL2JpbmRpbmctYmVoYXZpb3JzL2JpbmRpbmctbW9kZS5qcyc7XG5leHBvcnQgeyBEZWJvdW5jZUJpbmRpbmdCZWhhdmlvciwgfSBmcm9tICcuL2JpbmRpbmctYmVoYXZpb3JzL2RlYm91bmNlLmpzJztcbmV4cG9ydCB7IFNpZ25hbEJpbmRpbmdCZWhhdmlvciwgfSBmcm9tICcuL2JpbmRpbmctYmVoYXZpb3JzL3NpZ25hbHMuanMnO1xuZXhwb3J0IHsgVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3IsIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9ycy90aHJvdHRsZS5qcyc7XG5leHBvcnQgeyBhbGlhcywgcmVnaXN0ZXJBbGlhc2VzLCBDYWxsRnVuY3Rpb25FeHByZXNzaW9uLCBDdXN0b21FeHByZXNzaW9uLCBCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uLCBWYWx1ZUNvbnZlcnRlckV4cHJlc3Npb24sIEFzc2lnbkV4cHJlc3Npb24sIENvbmRpdGlvbmFsRXhwcmVzc2lvbiwgQWNjZXNzVGhpc0V4cHJlc3Npb24sIEFjY2Vzc1Njb3BlRXhwcmVzc2lvbiwgQWNjZXNzTWVtYmVyRXhwcmVzc2lvbiwgQWNjZXNzS2V5ZWRFeHByZXNzaW9uLCBDYWxsU2NvcGVFeHByZXNzaW9uLCBDYWxsTWVtYmVyRXhwcmVzc2lvbiwgQmluYXJ5RXhwcmVzc2lvbiwgVW5hcnlFeHByZXNzaW9uLCBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbiwgSHRtbExpdGVyYWxFeHByZXNzaW9uLCBBcnJheUxpdGVyYWxFeHByZXNzaW9uLCBPYmplY3RMaXRlcmFsRXhwcmVzc2lvbiwgVGVtcGxhdGVFeHByZXNzaW9uLCBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24sIEFycmF5QmluZGluZ1BhdHRlcm4sIE9iamVjdEJpbmRpbmdQYXR0ZXJuLCBCaW5kaW5nSWRlbnRpZmllciwgRm9yT2ZTdGF0ZW1lbnQsIEludGVycG9sYXRpb24sIGNvbm5lY3RhYmxlLCBCaW5kaW5nTWVkaWF0b3IsIElFeHByZXNzaW9uUGFyc2VyLCBCaW5kaW5nVHlwZSwgcGFyc2VFeHByZXNzaW9uLCBDaGFyLCBBY2Nlc3MsIFByZWNlZGVuY2UsIHBhcnNlLCBQYXJzZXJTdGF0ZSwgQXJyYXlPYnNlcnZlciwgQXJyYXlJbmRleE9ic2VydmVyLCBlbmFibGVBcnJheU9ic2VydmF0aW9uLCBkaXNhYmxlQXJyYXlPYnNlcnZhdGlvbiwgYXBwbHlNdXRhdGlvbnNUb0luZGljZXMsIHN5bmNocm9uaXplSW5kaWNlcywgTWFwT2JzZXJ2ZXIsIGVuYWJsZU1hcE9ic2VydmF0aW9uLCBkaXNhYmxlTWFwT2JzZXJ2YXRpb24sIFNldE9ic2VydmVyLCBlbmFibGVTZXRPYnNlcnZhdGlvbiwgZGlzYWJsZVNldE9ic2VydmF0aW9uLCBCaW5kaW5nQ29udGV4dCwgU2NvcGUsIE92ZXJyaWRlQ29udGV4dCwgQ29sbGVjdGlvbkxlbmd0aE9ic2VydmVyLCBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyLCBJRGlydHlDaGVja2VyLCBEaXJ0eUNoZWNrUHJvcGVydHksIERpcnR5Q2hlY2tTZXR0aW5ncywgQ29tcHV0ZWRPYnNlcnZlciwgb2JzZXJ2YWJsZSwgSU9ic2VydmVyTG9jYXRvciwgSU5vZGVPYnNlcnZlckxvY2F0b3IsIGdldENvbGxlY3Rpb25PYnNlcnZlciwgT2JzZXJ2ZXJMb2NhdG9yLCBQcmltaXRpdmVPYnNlcnZlciwgUHJvcGVydHlBY2Nlc3NvciwgU2V0dGVyT2JzZXJ2ZXIsIElTaWduYWxlciwgc3Vic2NyaWJlckNvbGxlY3Rpb24sIGJpbmRpbmdCZWhhdmlvciwgQmluZGluZ0JlaGF2aW9yLCBCaW5kaW5nQmVoYXZpb3JEZWZpbml0aW9uLCBCaW5kaW5nSW50ZXJjZXB0b3IsIEJpbmRpbmdCZWhhdmlvckZhY3RvcnksIEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5LCBWYWx1ZUNvbnZlcnRlciwgVmFsdWVDb252ZXJ0ZXJEZWZpbml0aW9uLCB2YWx1ZUNvbnZlcnRlciwgQmluZGluZ01vZGUsIEV4cHJlc3Npb25LaW5kLCBMaWZlY3ljbGVGbGFncywgQWNjZXNzb3JUeXBlLCBDb2xsZWN0aW9uS2luZCwgRGVsZWdhdGlvblN0cmF0ZWd5LCBpc0luZGV4TWFwLCBjb3B5SW5kZXhNYXAsIGNsb25lSW5kZXhNYXAsIGNyZWF0ZUluZGV4TWFwLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuZXhwb3J0IHsgQXVyZWxpYSwgSUF1cmVsaWEsIH0gZnJvbSAnLi9hdXJlbGlhLmpzJztcbmV4cG9ydCB7IEFwcFJvb3QsIElBcHBSb290LCB9IGZyb20gJy4vYXBwLXJvb3QuanMnO1xuZXhwb3J0IHsgQXBwVGFzaywgSUFwcFRhc2ssIH0gZnJvbSAnLi9hcHAtdGFzay5qcyc7XG5leHBvcnQgeyBBdHRyU3ludGF4LCBJQXR0cmlidXRlUGFyc2VyLCBhdHRyaWJ1dGVQYXR0ZXJuLCBJQXR0cmlidXRlUGF0dGVybiwgQXR0cmlidXRlUGF0dGVybiwgSW50ZXJwcmV0YXRpb24sIElTeW50YXhJbnRlcnByZXRlciwgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuLCBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm4sIERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm4sIFJlZkF0dHJpYnV0ZVBhdHRlcm4sIH0gZnJvbSAnLi9yZXNvdXJjZXMvYXR0cmlidXRlLXBhdHRlcm4uanMnO1xuZXhwb3J0IHsgYmluZGluZ0NvbW1hbmQsIEJpbmRpbmdDb21tYW5kLCBCaW5kaW5nQ29tbWFuZERlZmluaXRpb24sIGdldFRhcmdldCwgQ2FsbEJpbmRpbmdDb21tYW5kLCBEZWZhdWx0QmluZGluZ0NvbW1hbmQsIEZvckJpbmRpbmdDb21tYW5kLCBGcm9tVmlld0JpbmRpbmdDb21tYW5kLCBPbmVUaW1lQmluZGluZ0NvbW1hbmQsIFRvVmlld0JpbmRpbmdDb21tYW5kLCBUd29XYXlCaW5kaW5nQ29tbWFuZCwgVHJpZ2dlckJpbmRpbmdDb21tYW5kLCBEZWxlZ2F0ZUJpbmRpbmdDb21tYW5kLCBDYXB0dXJlQmluZGluZ0NvbW1hbmQsIEF0dHJCaW5kaW5nQ29tbWFuZCwgQ2xhc3NCaW5kaW5nQ29tbWFuZCwgU3R5bGVCaW5kaW5nQ29tbWFuZCwgfSBmcm9tICcuL3Jlc291cmNlcy9iaW5kaW5nLWNvbW1hbmQuanMnO1xuZXhwb3J0IHsgSUF0dHJTeW50YXhUcmFuc2Zvcm1lciwgfSBmcm9tICcuL2F0dHJpYnV0ZS1zeW50YXgtdHJhbnNmb3JtZXIuanMnO1xuZXhwb3J0IHsgTGlzdGVuZXIsIH0gZnJvbSAnLi9iaW5kaW5nL2xpc3RlbmVyLmpzJztcbmV4cG9ydCB7IEF0dHJpYnV0ZUJpbmRpbmcsIH0gZnJvbSAnLi9iaW5kaW5nL2F0dHJpYnV0ZS5qcyc7XG5leHBvcnQgeyBDYWxsQmluZGluZywgfSBmcm9tICcuL2JpbmRpbmcvY2FsbC1iaW5kaW5nLmpzJztcbmV4cG9ydCB7IEludGVycG9sYXRpb25CaW5kaW5nLCB9IGZyb20gJy4vYmluZGluZy9pbnRlcnBvbGF0aW9uLWJpbmRpbmcuanMnO1xuZXhwb3J0IHsgTGV0QmluZGluZywgfSBmcm9tICcuL2JpbmRpbmcvbGV0LWJpbmRpbmcuanMnO1xuZXhwb3J0IHsgUHJvcGVydHlCaW5kaW5nLCB9IGZyb20gJy4vYmluZGluZy9wcm9wZXJ0eS1iaW5kaW5nLmpzJztcbmV4cG9ydCB7IFJlZkJpbmRpbmcsIH0gZnJvbSAnLi9iaW5kaW5nL3JlZi1iaW5kaW5nLmpzJztcbmV4cG9ydCB7IElSZW5kZXJlciwgSVRlbXBsYXRlQ29tcGlsZXIsIHJlbmRlcmVyLCBDYWxsQmluZGluZ0luc3RydWN0aW9uLCBIeWRyYXRlQXR0cmlidXRlSW5zdHJ1Y3Rpb24sIEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24sIEh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIsIEludGVycG9sYXRpb25JbnN0cnVjdGlvbiwgSXRlcmF0b3JCaW5kaW5nSW5zdHJ1Y3Rpb24sIExldEJpbmRpbmdJbnN0cnVjdGlvbiwgSHlkcmF0ZUxldEVsZW1lbnRJbnN0cnVjdGlvbiwgUmVmQmluZGluZ0luc3RydWN0aW9uLCBTZXRQcm9wZXJ0eUluc3RydWN0aW9uLCBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb24sIExpc3RlbmVyQmluZGluZ0luc3RydWN0aW9uLCBQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbiwgU2V0QXR0cmlidXRlSW5zdHJ1Y3Rpb24sIFNldENsYXNzQXR0cmlidXRlSW5zdHJ1Y3Rpb24sIFNldFN0eWxlQXR0cmlidXRlSW5zdHJ1Y3Rpb24sIFN0eWxlUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24sIFRleHRCaW5kaW5nSW5zdHJ1Y3Rpb24sIGlzSW5zdHJ1Y3Rpb24sIElJbnN0cnVjdGlvbiwgSW5zdHJ1Y3Rpb25UeXBlLCB9IGZyb20gJy4vcmVuZGVyZXIuanMnO1xuZXhwb3J0IHsgQXR0cmlidXRlTlNBY2Nlc3NvciwgfSBmcm9tICcuL29ic2VydmF0aW9uL2F0dHJpYnV0ZS1ucy1hY2Nlc3Nvci5qcyc7XG5leHBvcnQgeyBDaGVja2VkT2JzZXJ2ZXIsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9jaGVja2VkLW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IENsYXNzQXR0cmlidXRlQWNjZXNzb3IsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9jbGFzcy1hdHRyaWJ1dGUtYWNjZXNzb3IuanMnO1xuZXhwb3J0IHsgRGF0YUF0dHJpYnV0ZUFjY2Vzc29yLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vZGF0YS1hdHRyaWJ1dGUtYWNjZXNzb3IuanMnO1xuZXhwb3J0IHsgSUV2ZW50RGVsZWdhdG9yLCBFdmVudFN1YnNjcmliZXIsIEV2ZW50RGVsZWdhdG9yLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vZXZlbnQtZGVsZWdhdG9yLmpzJztcbmV4cG9ydCB7IE5vZGVPYnNlcnZlckNvbmZpZywgTm9kZU9ic2VydmVyTG9jYXRvciwgfSBmcm9tICcuL29ic2VydmF0aW9uL29ic2VydmVyLWxvY2F0b3IuanMnO1xuZXhwb3J0IHsgU2VsZWN0VmFsdWVPYnNlcnZlciB9IGZyb20gJy4vb2JzZXJ2YXRpb24vc2VsZWN0LXZhbHVlLW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IFN0eWxlQXR0cmlidXRlQWNjZXNzb3IgfSBmcm9tICcuL29ic2VydmF0aW9uL3N0eWxlLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcyc7XG5leHBvcnQgeyBJU1ZHQW5hbHl6ZXIsIFNWR0FuYWx5emVyLCBOb29wU1ZHQW5hbHl6ZXIsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9zdmctYW5hbHl6ZXIuanMnO1xuZXhwb3J0IHsgVmFsdWVBdHRyaWJ1dGVPYnNlcnZlciwgfSBmcm9tICcuL29ic2VydmF0aW9uL3ZhbHVlLWF0dHJpYnV0ZS1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBBdHRyQmluZGluZ0JlaGF2aW9yLCB9IGZyb20gJy4vcmVzb3VyY2VzL2JpbmRpbmctYmVoYXZpb3JzL2F0dHIuanMnO1xuZXhwb3J0IHsgU2VsZkJpbmRpbmdCZWhhdmlvciwgfSBmcm9tICcuL3Jlc291cmNlcy9iaW5kaW5nLWJlaGF2aW9ycy9zZWxmLmpzJztcbmV4cG9ydCB7IFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3IsIH0gZnJvbSAnLi9yZXNvdXJjZXMvYmluZGluZy1iZWhhdmlvcnMvdXBkYXRlLXRyaWdnZXIuanMnO1xuZXhwb3J0IHsgY3VzdG9tQXR0cmlidXRlLCBDdXN0b21BdHRyaWJ1dGUsIEN1c3RvbUF0dHJpYnV0ZURlZmluaXRpb24sIHRlbXBsYXRlQ29udHJvbGxlciwgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlLmpzJztcbmV4cG9ydCB7IEZyZXF1ZW50TXV0YXRpb25zLCBPYnNlcnZlU2hhbGxvdywgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9mbGFncy5qcyc7XG5leHBvcnQgeyBJZiwgRWxzZSwgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9pZi5qcyc7XG5leHBvcnQgeyBSZXBlYXQgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9yZXBlYXQuanMnO1xuZXhwb3J0IHsgV2l0aCB9IGZyb20gJy4vcmVzb3VyY2VzL3RlbXBsYXRlLWNvbnRyb2xsZXJzL3dpdGguanMnO1xuZXhwb3J0IHsgU3dpdGNoLCBDYXNlLCBEZWZhdWx0Q2FzZSwgfSBmcm9tICcuL3Jlc291cmNlcy90ZW1wbGF0ZS1jb250cm9sbGVycy9zd2l0Y2guanMnO1xuZXhwb3J0IHsgQmx1ciwgQmx1ck1hbmFnZXIsIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZXMvYmx1ci5qcyc7XG5leHBvcnQgeyBGb2N1cywgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tYXR0cmlidXRlcy9mb2N1cy5qcyc7XG5leHBvcnQgeyBQb3J0YWwsIH0gZnJvbSAnLi9yZXNvdXJjZXMvdGVtcGxhdGUtY29udHJvbGxlcnMvcG9ydGFsLmpzJztcbmV4cG9ydCB7IEF1U2xvdCwgSVByb2plY3Rpb25zLCBTbG90SW5mbywgQXVTbG90Q29udGVudFR5cGUsIFJlZ2lzdGVyZWRQcm9qZWN0aW9ucywgSVByb2plY3Rpb25Qcm92aWRlciwgUHJvamVjdGlvbkNvbnRleHQsIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnRzL2F1LXNsb3QuanMnO1xuZXhwb3J0IHsgY29udGFpbmVybGVzcywgY3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudERlZmluaXRpb24sIHVzZVNoYWRvd0RPTSwgfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5leHBvcnQgeyBDb21wb3NlLCB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9jb21wb3NlLmpzJztcbmV4cG9ydCB7IElTYW5pdGl6ZXIsIFNhbml0aXplVmFsdWVDb252ZXJ0ZXIsIH0gZnJvbSAnLi9yZXNvdXJjZXMvdmFsdWUtY29udmVydGVycy9zYW5pdGl6ZS5qcyc7XG5leHBvcnQgeyBWaWV3VmFsdWVDb252ZXJ0ZXIsIH0gZnJvbSAnLi9yZXNvdXJjZXMvdmFsdWUtY29udmVydGVycy92aWV3LmpzJztcbmV4cG9ydCB7IElUZW1wbGF0ZUNvbXBpbGVyUmVnaXN0cmF0aW9uLCBJTm9kZU9ic2VydmVyTG9jYXRvclJlZ2lzdHJhdGlvbiwgRGVmYXVsdENvbXBvbmVudHMsIFJlZkF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24sIERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24sIERlZmF1bHRCaW5kaW5nU3ludGF4LCBBdFByZWZpeGVkVHJpZ2dlckF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24sIENvbG9uUHJlZml4ZWRCaW5kQXR0cmlidXRlUGF0dGVyblJlZ2lzdHJhdGlvbiwgU2hvcnRIYW5kQmluZGluZ1N5bnRheCwgU1ZHQW5hbHl6ZXJSZWdpc3RyYXRpb24sIENhbGxCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgRGVmYXVsdEJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBGb3JCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgUmVmQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIEZyb21WaWV3QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIE9uZVRpbWVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgVG9WaWV3QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIFR3b1dheUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBUcmlnZ2VyQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIERlbGVnYXRlQmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sIENhcHR1cmVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbiwgQXR0ckJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBDbGFzc0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBTdHlsZUJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLCBEZWZhdWx0QmluZGluZ0xhbmd1YWdlLCBWaWV3VmFsdWVDb252ZXJ0ZXJSZWdpc3RyYXRpb24sIFNhbml0aXplVmFsdWVDb252ZXJ0ZXJSZWdpc3RyYXRpb24sIElmUmVnaXN0cmF0aW9uLCBFbHNlUmVnaXN0cmF0aW9uLCBSZXBlYXRSZWdpc3RyYXRpb24sIFdpdGhSZWdpc3RyYXRpb24sIEF0dHJCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sIFNlbGZCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sIFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sIENvbXBvc2VSZWdpc3RyYXRpb24sIERlZmF1bHRSZXNvdXJjZXMsIEF0dHJpYnV0ZUJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbiwgTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sIFNldEF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLCBTZXRDbGFzc0F0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLCBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLCBTdHlsZVByb3BlcnR5QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBUZXh0QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBSZWZCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sIENhbGxCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sIEN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLCBDdXN0b21FbGVtZW50UmVuZGVyZXJSZWdpc3RyYXRpb24sIEludGVycG9sYXRpb25CaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sIEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBMZXRFbGVtZW50UmVuZGVyZXJSZWdpc3RyYXRpb24sIFByb3BlcnR5QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLCBTZXRQcm9wZXJ0eVJlbmRlcmVyUmVnaXN0cmF0aW9uLCBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlclJlZ2lzdHJhdGlvbiwgRGVmYXVsdFJlbmRlcmVycywgU3RhbmRhcmRDb25maWd1cmF0aW9uIH0gZnJvbSAnLi9jb25maWd1cmF0aW9uLmpzJztcbmV4cG9ydCB7IFRlbXBsYXRlQmluZGVyLCB9IGZyb20gJy4vdGVtcGxhdGUtYmluZGVyLmpzJztcbmV4cG9ydCB7IElUZW1wbGF0ZUVsZW1lbnRGYWN0b3J5IH0gZnJvbSAnLi90ZW1wbGF0ZS1lbGVtZW50LWZhY3RvcnkuanMnO1xuZXhwb3J0IHsgQ2hpbGRyZW5EZWZpbml0aW9uLCBDaGlsZHJlbiwgY2hpbGRyZW4sIENoaWxkcmVuT2JzZXJ2ZXIsIH0gZnJvbSAnLi90ZW1wbGF0aW5nL2NoaWxkcmVuLmpzJztcbi8vIFRoZXNlIGV4cG9ydHMgYXJlIHRlbXBvcmFyeSB1bnRpbCB3ZSBoYXZlIGEgcHJvcGVyIHdheSB0byB1bml0IHRlc3QgdGhlbVxuZXhwb3J0IHsgQ29udHJvbGxlciwgaXNDdXN0b21FbGVtZW50Q29udHJvbGxlciwgaXNDdXN0b21FbGVtZW50Vmlld01vZGVsLCBWaWV3TW9kZWxLaW5kLCBJQ29udHJvbGxlciwgfSBmcm9tICcuL3RlbXBsYXRpbmcvY29udHJvbGxlci5qcyc7XG5leHBvcnQgeyBnZXRSZW5kZXJDb250ZXh0LCBpc1JlbmRlckNvbnRleHQsIH0gZnJvbSAnLi90ZW1wbGF0aW5nL3JlbmRlci1jb250ZXh0LmpzJztcbmV4cG9ydCB7IFZpZXdGYWN0b3J5LCBJVmlld0ZhY3RvcnksIElWaWV3TG9jYXRvciwgVmlld0xvY2F0b3IsIHZpZXcsIFZpZXdzLCB9IGZyb20gJy4vdGVtcGxhdGluZy92aWV3LmpzJztcbmV4cG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFJlbmRlclBsYW4gfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50LmpzJztcbmV4cG9ydCB7IElOb2RlLCBJRXZlbnRUYXJnZXQsIElSZW5kZXJMb2NhdGlvbiwgTm9kZVR5cGUsIEZyYWdtZW50Tm9kZVNlcXVlbmNlLCBJSGlzdG9yeSwgSVdpbmRvdywgSUxvY2F0aW9uLCBnZXRFZmZlY3RpdmVQYXJlbnROb2RlLCBzZXRFZmZlY3RpdmVQYXJlbnROb2RlLCBjb252ZXJ0VG9SZW5kZXJMb2NhdGlvbiwgaXNSZW5kZXJMb2NhdGlvbiwgfSBmcm9tICcuL2RvbS5qcyc7XG5leHBvcnQgeyBJUGxhdGZvcm0sIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XG5leHBvcnQgeyBCaW5kYWJsZUluZm8sIEVsZW1lbnRJbmZvLCBBdHRySW5mbywgQmluZGluZ1N5bWJvbCwgQ3VzdG9tQXR0cmlidXRlU3ltYm9sLCBDdXN0b21FbGVtZW50U3ltYm9sLCBMZXRFbGVtZW50U3ltYm9sLCBQbGFpbkF0dHJpYnV0ZVN5bWJvbCwgUGxhaW5FbGVtZW50U3ltYm9sLCBTeW1ib2xGbGFncywgVGVtcGxhdGVDb250cm9sbGVyU3ltYm9sLCBUZXh0U3ltYm9sLCBQcm9qZWN0aW9uU3ltYm9sLCB9IGZyb20gJy4vc2VtYW50aWMtbW9kZWwuanMnO1xuZXhwb3J0IHsgQ1NTTW9kdWxlc1Byb2Nlc3NvclJlZ2lzdHJ5LCBjc3NNb2R1bGVzLCBTaGFkb3dET01SZWdpc3RyeSwgSVNoYWRvd0RPTVN0eWxlRmFjdG9yeSwgc2hhZG93Q1NTLCBTdHlsZUNvbmZpZ3VyYXRpb24sIEFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlcywgU3R5bGVFbGVtZW50U3R5bGVzLCBJU2hhZG93RE9NU3R5bGVzLCBJU2hhZG93RE9NR2xvYmFsU3R5bGVzLCB9IGZyb20gJy4vdGVtcGxhdGluZy9zdHlsZXMuanMnO1xuZXhwb3J0IHsgV2F0Y2gsIHdhdGNoLCB9IGZyb20gJy4vd2F0Y2guanMnO1xuZXhwb3J0IHsgQ29tcHV0ZWRXYXRjaGVyLCBFeHByZXNzaW9uV2F0Y2hlciwgfSBmcm9tICcuL3RlbXBsYXRpbmcvd2F0Y2hlcnMuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiY29uc3QgbnNNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG4gKiBBdHRyaWJ1dGUgYWNjZXNzb3IgaW4gYSBYTUwgZG9jdW1lbnQvZWxlbWVudCB0aGF0IGNhbiBiZSBhY2Nlc3NlZCB2aWEgYSBuYW1lc3BhY2UuXG4gKiBXcmFwcyBbYGdldEF0dHJpYnV0ZU5TYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlTlMpLlxuICovXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlTlNBY2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IobmFtZXNwYWNlKSB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgIC8vIE9ic2VydmVyVHlwZS5MYXlvdXQgaXMgbm90IGFsd2F5cyB0cnVlLCBpdCBkZXBlbmRzIG9uIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBidXQgZm9yIHNpbXBsaWNpdHksIGFsd2F5cyB0cmVhdCBhcyBzdWNoXG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTm9kZSAqLyB8IDQgLyogTGF5b3V0ICovO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yTnMobnMpIHtcbiAgICAgICAgcmV0dXJuIG5zTWFwW25zXSA/PyAobnNNYXBbbnNdID0gbmV3IEF0dHJpYnV0ZU5TQWNjZXNzb3IobnMpKTtcbiAgICB9XG4gICAgZ2V0VmFsdWUob2JqLCBwcm9wZXJ0eUtleSkge1xuICAgICAgICByZXR1cm4gb2JqLmdldEF0dHJpYnV0ZU5TKHRoaXMubmFtZXNwYWNlLCBwcm9wZXJ0eUtleSk7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncywgb2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09IHZvaWQgMCkge1xuICAgICAgICAgICAgb2JqLnJlbW92ZUF0dHJpYnV0ZU5TKHRoaXMubmFtZXNwYWNlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZU5TKHRoaXMubmFtZXNwYWNlLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHJpYnV0ZS1ucy1hY2Nlc3Nvci5qcy5tYXAiLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5leHBvcnQgY2xhc3MgQmluZGFibGVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob2JqLCBwcm9wZXJ0eUtleSwgY2JOYW1lLCBzZXQsICRjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLiRjb250cm9sbGVyID0gJGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gdm9pZCAwO1xuICAgICAgICBjb25zdCBjYiA9IG9ialtjYk5hbWVdO1xuICAgICAgICBjb25zdCBjYkFsbCA9IG9iai5wcm9wZXJ0eUNoYW5nZWQ7XG4gICAgICAgIGNvbnN0IGhhc0NiID0gdGhpcy5oYXNDYiA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgY29uc3QgaGFzQ2JBbGwgPSB0aGlzLmhhc0NiQWxsID0gdHlwZW9mIGNiQWxsID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBjb25zdCBoYXNTZXR0ZXIgPSB0aGlzLmhhc1NldHRlciA9IHNldCAhPT0gbm9vcDtcbiAgICAgICAgdGhpcy5jYiA9IGhhc0NiID8gY2IgOiBub29wO1xuICAgICAgICB0aGlzLmNiQWxsID0gdGhpcy5oYXNDYkFsbCA/IGNiQWxsIDogbm9vcDtcbiAgICAgICAgLy8gd2hlbiB1c2VyIGRlY2xhcmUgQGJpbmRhYmxlKHsgc2V0IH0pXG4gICAgICAgIC8vIGl0J3MgZXhwZWN0ZWQgdG8gd29yayBmcm9tIHRoZSBzdGFydCxcbiAgICAgICAgLy8gcmVnYXJkbGVzcyB3aGVyZSB0aGUgYXNzaWdubWVudCBjb21lcyBmcm9tOiBlaXRoZXIgZGlyZWN0IHZpZXcgbW9kZWwgYXNzaWdubWVudCBvciBmcm9tIGJpbmRpbmcgZHVyaW5nIHJlbmRlclxuICAgICAgICAvLyBzbyBpZiBlaXRoZXIgZ2V0dGVyL3NldHRlciBjb25maWcgaXMgcHJlc2VudCwgYWx0ZXIgdGhlIGFjY2Vzc29yIHN0cmFpZ2h0IGF3YWl0XG4gICAgICAgIGlmICh0aGlzLmNiID09PSB2b2lkIDAgJiYgIWhhc0NiQWxsICYmICFoYXNTZXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBvYmpbcHJvcGVydHlLZXldO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBoYXNTZXR0ZXIgJiYgdmFsICE9PSB2b2lkIDAgPyBzZXQodmFsKSA6IHZhbDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR2V0dGVyU2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiAxIC8qIE9ic2VydmVyICovOyB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1NldHRlcikge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLnNldChuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaXMobmV3VmFsdWUsIGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgLy8gdG9kbzogY29udHJvbGxlciAoaWYgYW55KSBzdGF0ZSBzaG91bGQgZGV0ZXJtaW5lIHRoZSBpbnZvY2F0aW9uIGluc3RlYWRcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAzMiAvKiBmcm9tQmluZCAqLykgPT09IDAgfHwgKGZsYWdzICYgMTYgLyogdXBkYXRlU291cmNlICovKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNDYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5vYmosIG5ld1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ2JBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYkFsbC5jYWxsKHRoaXMub2JqLCB0aGlzLnByb3BlcnR5S2V5LCBuZXdWYWx1ZSwgY3VycmVudFZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShuZXdWYWx1ZSwgY3VycmVudFZhbHVlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTZWUgU2V0dGVyT2JzZXJ2ZXIuc2V0VmFsdWUgZm9yIGV4cGxhbmF0aW9uXG4gICAgICAgICAgICB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5vYnNlcnZpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5oYXNTZXR0ZXJcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2V0KGN1cnJlbnRWYWx1ZSlcbiAgICAgICAgICAgICAgICA6IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR2V0dGVyU2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzLmFkZChzdWJzY3JpYmVyKTtcbiAgICB9XG4gICAgY3JlYXRlR2V0dGVyU2V0dGVyKCkge1xuICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub2JqLCB0aGlzLnByb3BlcnR5S2V5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoIC8qIEJpbmRhYmxlIE9ic2VydmVyICovKSA9PiB0aGlzLmN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIHNldDogKC8qIEJpbmRhYmxlIE9ic2VydmVyICovIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSwgMCAvKiBub25lICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oQmluZGFibGVPYnNlcnZlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kYWJsZS1vYnNlcnZlci5qcy5tYXAiLCJpbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IGdldENvbGxlY3Rpb25PYnNlcnZlciB9IGZyb20gJy4vb2JzZXJ2ZXItbG9jYXRvci5qcyc7XG5mdW5jdGlvbiBkZWZhdWx0TWF0Y2hlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5leHBvcnQgY2xhc3MgQ2hlY2tlZE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvYmosIFxuICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG4gICAgX2tleSwgaGFuZGxlciwgb2JzZXJ2ZXJMb2NhdG9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCAxIC8qIE9ic2VydmVyICovIHwgNCAvKiBMYXlvdXQgKi87XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbk9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlKCk7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuc3Vicy5ub3RpZnkobmV3VmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmxhZ3MpO1xuICAgIH1cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncykge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplRWxlbWVudCgpO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVFbGVtZW50KCk7XG4gICAgfVxuICAgIHN5bmNocm9uaXplRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5vYmo7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdtb2RlbCcpID8gb2JqLm1vZGVsIDogb2JqLnZhbHVlO1xuICAgICAgICBjb25zdCBpc1JhZGlvID0gb2JqLnR5cGUgPT09ICdyYWRpbyc7XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSBvYmoubWF0Y2hlciAhPT0gdm9pZCAwID8gb2JqLm1hdGNoZXIgOiBkZWZhdWx0TWF0Y2hlcjtcbiAgICAgICAgaWYgKGlzUmFkaW8pIHtcbiAgICAgICAgICAgIG9iai5jaGVja2VkID0gISFtYXRjaGVyKGN1cnJlbnRWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50VmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9iai5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBjdXJyZW50VmFsdWUuZmluZEluZGV4KGl0ZW0gPT4gISFtYXRjaGVyKGl0ZW0sIGVsZW1lbnRWYWx1ZSkpICE9PSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIodiwgZWxlbWVudFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHBhaXJbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0ICRpc0NoZWNrZWQgPSBwYWlyWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHBvdGVudGlhbCBjb21wbGFpbiwgd2hlbiBvbmx5IGB0cnVlYCBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0J3MgY29uc2lzdGVudCB3aXRoIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGV4aXN0aW5nSXRlbSwgZWxlbWVudFZhbHVlKSAmJiAkaXNDaGVja2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5jaGVja2VkID0gaGFzTWF0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoKSB7XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5vYmo7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdtb2RlbCcpID8gb2JqLm1vZGVsIDogb2JqLnZhbHVlO1xuICAgICAgICBjb25zdCBpc0NoZWNrZWQgPSBvYmouY2hlY2tlZDtcbiAgICAgICAgY29uc3QgbWF0Y2hlciA9IG9iai5tYXRjaGVyICE9PSB2b2lkIDAgPyBvYmoubWF0Y2hlciA6IGRlZmF1bHRNYXRjaGVyO1xuICAgICAgICBpZiAob2JqLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIEFycmF5IGJpbmRpbmcgc3RlcHMgb24gYSBjaGFuZ2UgZXZlbnQ6XG4gICAgICAgICAgICAgICAgLy8gMS4gZmluZCBjb3JyZXNwb25kaW5nIGl0ZW0gSU5ERVggaW4gdGhlIFNldCBiYXNlZCBvbiBjdXJyZW50IG1vZGVsL3ZhbHVlIGFuZCBtYXRjaGVyXG4gICAgICAgICAgICAgICAgLy8gMi4gaXMgdGhlIGNoZWNrYm94IGNoZWNrZWQ/XG4gICAgICAgICAgICAgICAgLy8gICAgMi4xLiBZZXM6IGlzIHRoZSBjb3JyZXNwb25kaW5nIGl0ZW0gaW4gdGhlIEFycmF5IChpbmRleCA9PT0gLTEpP1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAyLjEuMSBObzogcHVzaCB0aGUgY3VycmVudCBtb2RlbC92YWx1ZSB0byB0aGUgQXJyYXlcbiAgICAgICAgICAgICAgICAvLyAgICAyLjIuIE5vOiBpcyB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBBcnJheSAoaW5kZXggIT09IC0xKT9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgMi4yLjE6IFllczogcmVtb3ZlIHRoZSBjb3JyZXNwb25kaW5nIGl0ZW1cbiAgICAgICAgICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50VmFsdWUuZmluZEluZGV4KGl0ZW0gPT4gISFtYXRjaGVyKGl0ZW0sIGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjaGVja2JveCBpcyBjaGVja2RlLCBhbmQgdGhlcmUncyBubyBtYXRjaGluZyB2YWx1ZSBpbiB0aGUgZXhpc3RpbmcgYXJyYXlcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNoZWNrYm94IG1vZGVsL3ZhbHVlIHRvIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrZWQgJiYgaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5wdXNoKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0NoZWNrZWQgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjaGVja2JveCBpcyBub3QgY2hlY2tlZCwgYW5kIGZvdW5kIGEgbWF0Y2hpbmcgaXRlbSBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gdGhlIGNoZWNrYm94IG1vZGVsL3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZXhpc3RpbmcgaXRlbVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBleGlzdGluZyBjdXJyZW50VmFsdWUgaXMgYW4gYXJyYXksXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGludm9rZSBjYWxsYmFjayBhcyBvbmx5IHRoZSBhcnJheSBvYmogaGFzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgYmluZGluZyBzdGVwcyBvbiBhIGNoYW5nZSBldmVudDpcbiAgICAgICAgICAgICAgICAvLyAxLiBmaW5kIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgU2V0IGJhc2VkIG9uIGN1cnJlbnQgbW9kZWwvdmFsdWUgYW5kIG1hdGNoZXJcbiAgICAgICAgICAgICAgICAvLyAyLiBpcyB0aGUgY2hlY2tib3ggY2hlY2tlZD9cbiAgICAgICAgICAgICAgICAvLyAgICAyLjEuIFllczogaXMgdGhlIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgU2V0P1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAyLjEuMSBObzogYWRkIHRoZSBjdXJyZW50IG1vZGVsL3ZhbHVlIHRvIHRoZSBTZXRcbiAgICAgICAgICAgICAgICAvLyAgICAyLjIuIE5vOiBpcyB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBTZXQ/XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIDIuMi4xOiBZZXM6IHJlbW92ZSB0aGUgY29ycmVzcG9uZGluZyBpdGVtXG4gICAgICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgIC8vIDEuIGZpbmQgY29ycmVzcG9uZGluZyBpdGVtXG4gICAgICAgICAgICAgICAgY29uc3QgdW5zZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdJdGVtID0gdW5zZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIodmFsdWUsIGVsZW1lbnRWYWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSXRlbSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMi4xLiBDaGVja2JveCBpcyBjaGVja2VkLCBpcyB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBTZXQ/XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpZiBjaGVja2JveCBpcyBjaGVja2VkIGFuZCB0aGVyZSdzIG5vIHZhbHVlIGluIHRoZSBleGlzdGluZyBTZXRcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNoZWNrYm94IG1vZGVsL3ZhbHVlIHRvIHRoZSBTZXRcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGVja2VkICYmIGV4aXN0aW5nSXRlbSA9PT0gdW5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4xLjEuIGFkZCB0aGUgY3VycmVudCBtb2RlbC92YWx1ZSB0byB0aGUgU2V0XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5hZGQoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQ2hlY2tlZCAmJiBleGlzdGluZ0l0ZW0gIT09IHVuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDIuMi4xIENoZWNrYm94IGlzIHVuY2hlY2tlZCwgY29ycmVzcG9uZGluZyBpcyBpbiB0aGUgU2V0XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNoZWNrYm94IGlzIG5vdCBjaGVja2VkLCBhbmQgZm91bmQgYSBtYXRjaGluZyBpdGVtIGluIHRoZSBTZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gdGhlIGNoZWNrYm94IG1vZGVsL3ZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZXhpc3RpbmcgaXRlbVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuZGVsZXRlKGV4aXN0aW5nSXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gZXhpc3RpbmcgdmFsdWUgaXMgYSBTZXQsXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGludm9rZSBjYWxsYmFjayBhcyBvbmx5IHRoZSBTZXQgaGFzIGJlZW4gbXV0YXRlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIC8vIE1hcCBiaW5kaW5nIHN0ZXBzIG9uIGEgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gMS4gZmluZCBjb3JyZXNwb25kaW5nIGl0ZW0gaW4gdGhlIE1hcCBiYXNlZCBvbiBjdXJyZW50IG1vZGVsL3ZhbHVlIGFuZCBtYXRjaGVyXG4gICAgICAgICAgICAgICAgLy8gMi4gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBNYXAgYmFzZWQgb24gY2hlY2tlZCBzdGF0ZSBvZiB0aGUgY2hlY2tib3hcbiAgICAgICAgICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAgICAgLy8gMS4gZmluZCB0aGUgY29ycmVzcG9uZGluZyBpdGVtXG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nSXRlbTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJJdGVtID0gcGFpclswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoY3Vyckl0ZW0sIGVsZW1lbnRWYWx1ZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSXRlbSA9IGN1cnJJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMi4gc2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICAvLyBpZiBjaGVja2JveCBpcyBjaGVja2VkIGFuZCB0aGVyZSdzIG5vIHZhbHVlIGluIHRoZSBleGlzdGluZyBNYXBcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNoZWNrYm94IG1vZGVsL3ZhbHVlIHRvIHRoZSBNYXAgYXMga2V5LFxuICAgICAgICAgICAgICAgIC8vIGFuZCB2YWx1ZSB3aWxsIGJlIGNoZWNrZWQgc3RhdGUgb2YgdGhlIGNoZWNrYm94XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnNldChleGlzdGluZ0l0ZW0sIGlzQ2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBleGlzdGluZyB2YWx1ZSBpcyBhIE1hcCxcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgaW52b2tlIGNhbGxiYWNrIGFzIG9ubHkgdGhlIE1hcCBoYXMgYmVlbiBtdXRhdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaXNDaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hlY2tlZCkge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gZWxlbWVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgaXQncyBhIHJhZGlvIGFuZCBpdCBoYXMgYmVlbiB1bmNoZWNrZWRcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcsIGFzIHRoZSByYWRpbyB0aGF0IHdhcyBjaGVja2VkIHdpbGwgZmlyZSBjaGFuZ2UgZXZlbnQgYW5kIGl0IHdpbGwgYmUgaGFuZGxlIHRoZXJlXG4gICAgICAgICAgICAvLyBhIHJhZGlvIGNhbm5vdCBiZSB1bmNoZWNrZWQgYnkgdXNlclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgIHRoaXMuc3Vicy5ub3RpZnkodGhpcy52YWx1ZSwgdGhpcy5vbGRWYWx1ZSwgMCAvKiBub25lICovKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5zdWJzY3JpYmUodGhpcy5vYmosIHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmUoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uT2JzZXJ2ZXI/LnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25PYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVyPy51bnN1YnNjcmliZSh0aGlzKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLnJlbW92ZShzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmUoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqO1xuICAgICAgICAodGhpcy52YWx1ZU9ic2VydmVyID8/ICh0aGlzLnZhbHVlT2JzZXJ2ZXIgPSBvYmouJG9ic2VydmVycz8ubW9kZWwgPz8gb2JqLiRvYnNlcnZlcnM/LnZhbHVlKSk/LnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uT2JzZXJ2ZXI/LnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25PYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgICAgaWYgKG9iai50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAodGhpcy5jb2xsZWN0aW9uT2JzZXJ2ZXIgPSBnZXRDb2xsZWN0aW9uT2JzZXJ2ZXIodGhpcy52YWx1ZSwgdGhpcy5vYnNlcnZlckxvY2F0b3IpKT8uc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oQ2hlY2tlZE9ic2VydmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrZWQtb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgZW1wdHlBcnJheSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgY2xhc3MgQ2xhc3NBdHRyaWJ1dGVBY2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuZG9Ob3RDYWNoZSA9IHRydWU7XG4gICAgICAgIHRoaXMubmFtZUluZGV4ID0ge307XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTm9kZSAqLyB8IDQgLyogTGF5b3V0ICovO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgLy8gaXMgaXQgc2FmZSB0byBhc3N1bWUgdGhlIG9ic2VydmVyIGhhcyB0aGUgbGF0ZXN0IHZhbHVlP1xuICAgICAgICAvLyB0b2RvOiBhYmlsaXR5IHRvIHR1cm4gb24vb2ZmIGNhY2hlIGJhc2VkIG9uIHR5cGVcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZhbHVlO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gbmV3VmFsdWUgIT09IHRoaXMub2xkVmFsdWU7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA0MDk2IC8qIG5vRmx1c2ggKi8pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ2hhbmdlcyhmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hDaGFuZ2VzKGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBuYW1lSW5kZXggPSB0aGlzLm5hbWVJbmRleDtcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXNUb0FkZCA9IGdldENsYXNzZXNUb0FkZChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgLy8gR2V0IHN0cmluZ3Mgc3BsaXQgb24gYSBzcGFjZSBub3QgaW5jbHVkaW5nIGVtcHRpZXNcbiAgICAgICAgICAgIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3Nlc0FuZFVwZGF0ZUluZGV4KGNsYXNzZXNUb0FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gKz0gMTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNhbGwgdG8gc2V0VmFsdWU/ICBXZSdyZSBkb25lLlxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgY2xhc3NlcyBmcm9tIHByZXZpb3VzIHZlcnNpb24uXG4gICAgICAgICAgICB2ZXJzaW9uIC09IDE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmFtZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmFtZUluZGV4LCBuYW1lKSB8fCBuYW1lSW5kZXhbbmFtZV0gIT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaGFzIHRoZSBzaWRlLWVmZmVjdCB0aGF0IGNsYXNzZXMgYWxyZWFkeSBwcmVzZW50IHdoaWNoIGFyZSBhZGRlZCBhZ2FpbixcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHJlbW92ZWQgaWYgdGhleSdyZSBub3QgcHJlc2VudCBpbiB0aGUgbmV4dCB1cGRhdGUuXG4gICAgICAgICAgICAgICAgLy8gQmV0dGVyIHdvdWxkIGJlIGRvIGhhdmUgc29tZSBjb25maWd1cmFiaWxpdHkgZm9yIHRoaXMgYmVoYXZpb3IsIGFsbG93aW5nIHRoZSB1c2VyIHRvXG4gICAgICAgICAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgaW5pdGlhbCBjbGFzc2VzIGFsd2F5cyBuZWVkIHRvIGJlIGtlcHQsIGFsd2F5cyByZW1vdmVkLCBvciBzb21ldGhpbmcgaW4gYmV0d2VlblxuICAgICAgICAgICAgICAgIHRoaXMub2JqLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2xhc3Nlc0FuZFVwZGF0ZUluZGV4KGNsYXNzZXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMub2JqO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzZXNbaV07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uYW1lSW5kZXhbY2xhc3NOYW1lXSA9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzZXNUb0FkZChvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHNwbGl0Q2xhc3NTdHJpbmcob2JqZWN0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gb2JqZWN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goLi4uZ2V0Q2xhc3Nlc1RvQWRkKG9iamVjdFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlBcnJheTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjbGFzc2VzID0gW107XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgLy8gTGV0IG5vbiB0eXBpY2FsIHZhbHVlcyBhbHNvIGV2YWx1YXRlIHRydWUgc28gZGlzYWJsZSBib29sIGNoZWNrXG4gICAgICAgIGlmIChCb29sZWFuKG9iamVjdFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICAvLyBXZSBtdXN0IGRvIHRoaXMgaW4gY2FzZSBvYmplY3QgcHJvcGVydHkgaGFzIGEgc3BhY2UgaW4gdGhlIG5hbWUgd2hpY2ggcmVzdWx0cyBpbiB0d28gY2xhc3Nlc1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5LmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goLi4uc3BsaXRDbGFzc1N0cmluZyhwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn1cbmZ1bmN0aW9uIHNwbGl0Q2xhc3NTdHJpbmcoY2xhc3NTdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gY2xhc3NTdHJpbmcubWF0Y2goL1xcUysvZyk7XG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3MtYXR0cmlidXRlLWFjY2Vzc29yLmpzLm1hcCIsIi8qKlxuICogQXR0cmlidXRlIGFjY2Vzc29yIGZvciBIVE1MIGVsZW1lbnRzLlxuICogTm90ZSB0aGF0IEF1cmVsaWEgd29ya3Mgd2l0aCBwcm9wZXJ0aWVzLCBzbyBpbiBhbGwgY2FzZSBpdCB3aWxsIHRyeSB0byBhc3NpZ24gdG8gcHJvcGVydHkgaW5zdGVhZCBvZiBhdHRyaWJ1dGVzLlxuICogVW5sZXNzIHRoZSBwcm9wZXJ0eSBmYWxscyBpbnRvIGEgc3BlY2lhbCBzZXQsIHRoZW4gaXQgd2lsbCB1c2UgYXR0cmlidXRlIGZvciBpdC5cbiAqXG4gKiBAc2VlIEVsZW1lbnRQcm9wZXJ0eUFjY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQXR0cmlidXRlQWNjZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gJyc7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgICAgLy8gT2JzZXJ2ZXJUeXBlLkxheW91dCBpcyBub3QgYWx3YXlzIHRydWUsIGl0IGRlcGVuZHMgb24gdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIGJ1dCBmb3Igc2ltcGxpY2l0eSwgYWx3YXlzIHRyZWF0IGFzIHN1Y2hcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBOb2RlICovIHwgNCAvKiBMYXlvdXQgKi87XG4gICAgfVxuICAgIGdldFZhbHVlKG9iaiwga2V5KSB7XG4gICAgICAgIHJldHVybiBvYmouZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncywgb2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09IHZvaWQgMCkge1xuICAgICAgICAgICAgb2JqLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZShrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBhdHRyQWNjZXNzb3IgPSBuZXcgRGF0YUF0dHJpYnV0ZUFjY2Vzc29yKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcy5tYXAiLCJpbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuLyoqXG4gKiBPYnNlcnZlciBmb3IgaGFuZGxpbmcgdHdvLXdheSBiaW5kaW5nIHdpdGggYXR0cmlidXRlc1xuICogSGFzIGRpZmZlcmVudCBzdHJhdGVneSBmb3IgY2xhc3Mvc3R5bGUgYW5kIG5vcm1hbCBhdHRyaWJ1dGVzXG4gKiBUT0RPOiBoYW5kbGUgU1ZHL2F0dHJpYnV0ZXMgd2l0aCBuYW1lc3BhY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwbGF0Zm9ybSwgb2JzZXJ2ZXJMb2NhdG9yLCBvYmosIHByb3BlcnR5S2V5LCB0YXJnZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgdGhpcy50YXJnZXRBdHRyaWJ1dGUgPSB0YXJnZXRBdHRyaWJ1dGU7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAvLyBsYXlvdXQgaXMgbm90IGNlcnRhaW4sIGRlcGVuZHMgb24gdGhlIGF0dHJpYnV0ZSBiZWluZyBmbHVzaGVkIHRvIG93bmVyIGVsZW1lbnRcbiAgICAgICAgLy8gYnV0IGZvciBzaW1wbGUgc3RhcnQsIGFsd2F5cyB0cmVhdCBhcyBzdWNoXG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTm9kZSAqLyB8IDEgLyogT2JzZXJ2ZXIgKi8gfCA0IC8qIExheW91dCAqLztcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIC8vIGlzIGl0IHNhZmUgdG8gYXNzdW1lIHRoZSBvYnNlcnZlciBoYXMgdGhlIGxhdGVzdCB2YWx1ZT9cbiAgICAgICAgLy8gdG9kbzogYWJpbGl0eSB0byB0dXJuIG9uL29mZiBjYWNoZSBiYXNlZCBvbiB0eXBlXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IG5ld1ZhbHVlICE9PSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICBpZiAoKGZsYWdzICYgNDA5NiAvKiBub0ZsdXNoICovKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaENoYW5nZXMoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoQ2hhbmdlcyhmbGFncykge1xuICAgICAgICBpZiAodGhpcy5oYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50YXJnZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2h5IGRvZXMgY2xhc3MgYXR0cmlidXRlIG9ic2VydmVyIHNldFZhbHVlIGxvb2sgZGlmZmVyZW50IHdpdGggY2xhc3MgYXR0cmlidXRlIGFjY2Vzc29yP1xuICAgICAgICAgICAgICAgICAgICAvLyA9PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgY2xhc3MgbGlzdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZXdWYWx1ZSBpcyBzaW1wbHkgY2hlY2tlZCBpZiB0cnV0aHkgb3IgZmFsc3lcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRvZ2dsZSB0aGUgY2xhc3MgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gLS0gdGhlIHJ1bGUgb2YgdGhpcyBpcyBxdWl0ZSBkaWZmZXJlbnQgdG8gbm9ybWFsIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY2xhc3MgYXR0cmlidXRlLCBvYnNlcnZlciBpcyBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCBpdCBvbmx5IG9ic2VydmVzIG9uZSBjbGFzcyBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGNvbWVzIGZyb20gc3ludGF4LCB3aGVyZSBpdCB3b3VsZCB0eXBpY2FsbHkgYmUgbXktY2xhc3MuY2xhc3M9XCJzb21lUHJvcGVydHlcIlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGVyZSBpcyBubyBuZWVkIGZvciBzZXBhcmF0aW5nIGNsYXNzIGJ5IHNwYWNlIGFuZCBhZGQgYWxsIG9mIHRoZW0gbGlrZSBjbGFzcyBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiBub3QgdXNpbmcgLnRvZ2dsZSBBUEkgc28gdGhhdCBlbnZpcm9ubWVudCB3aXRoIGJyb2tlbiBpbXBsIChJRTExKSB3b24ndCBuZWVkIHRvIHBvbGZ5ZmlsbCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGlmICghIWN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmouY2xhc3NMaXN0LmFkZCh0aGlzLnByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5wcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlID09PSAnc3RyaW5nJyAmJiBuZXdWYWx1ZS5pbmNsdWRlcygnIWltcG9ydGFudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9ICdpbXBvcnRhbnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5yZXBsYWNlKCchaW1wb3J0YW50JywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLnN0eWxlLnNldFByb3BlcnR5KHRoaXMucHJvcGVydHlLZXksIG5ld1ZhbHVlLCBwcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU11dGF0aW9uKG11dGF0aW9uUmVjb3Jkcykge1xuICAgICAgICBsZXQgc2hvdWxkUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBtdXRhdGlvblJlY29yZHMubGVuZ3RoOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gbXV0YXRpb25SZWNvcmRzW2ldO1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09IHRoaXMucHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9jZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUHJvY2Vzcykge1xuICAgICAgICAgICAgbGV0IG5ld1ZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnRhcmdldEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm9iai5jbGFzc0xpc3QuY29udGFpbnModGhpcy5wcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0aGlzLm9iai5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMucHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRhcmdldEF0dHJpYnV0ZTogJHt0aGlzLnRhcmdldEF0dHJpYnV0ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGN1cnJlbnRWYWx1ZSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMub2xkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnMubm90aWZ5KG5ld1ZhbHVlLCBjdXJyZW50VmFsdWUsIDAgLyogbm9uZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMub2xkVmFsdWUgPSB0aGlzLm9iai5nZXRBdHRyaWJ1dGUodGhpcy5wcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICBzdGFydE9ic2VydmF0aW9uKHRoaXMub2JqLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTXV0YXRpb25PYnNlcnZlciwgdGhpcy5vYmosIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdG9wT2JzZXJ2YXRpb24odGhpcy5vYmosIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oQXR0cmlidXRlT2JzZXJ2ZXIpO1xuY29uc3Qgc3RhcnRPYnNlcnZhdGlvbiA9ICgkTXV0YXRpb25PYnNlcnZlciwgZWxlbWVudCwgc3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgaWYgKGVsZW1lbnQuJGVNT2JzZXJ2ZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudC4kZU1PYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LiRtT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAoZWxlbWVudC4kbU9ic2VydmVyID0gbmV3ICRNdXRhdGlvbk9ic2VydmVyKGhhbmRsZU11dGF0aW9uKSkub2JzZXJ2ZShlbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgfVxuICAgIGVsZW1lbnQuJGVNT2JzZXJ2ZXJzLmFkZChzdWJzY3JpcHRpb24pO1xufTtcbmNvbnN0IHN0b3BPYnNlcnZhdGlvbiA9IChlbGVtZW50LCBzdWJzY3JpcHRpb24pID0+IHtcbiAgICBjb25zdCAkZU1PYnNlcnZlcnMgPSBlbGVtZW50LiRlTU9ic2VydmVycztcbiAgICBpZiAoJGVNT2JzZXJ2ZXJzICYmICRlTU9ic2VydmVycy5kZWxldGUoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgICBpZiAoJGVNT2JzZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGVsZW1lbnQuJG1PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBlbGVtZW50LiRtT2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBoYW5kbGVNdXRhdGlvbiA9IChtdXRhdGlvblJlY29yZHMpID0+IHtcbiAgICBtdXRhdGlvblJlY29yZHNbMF0udGFyZ2V0LiRlTU9ic2VydmVycy5mb3JFYWNoKGludm9rZUhhbmRsZU11dGF0aW9uLCBtdXRhdGlvblJlY29yZHMpO1xufTtcbmZ1bmN0aW9uIGludm9rZUhhbmRsZU11dGF0aW9uKHMpIHtcbiAgICBzLmhhbmRsZU11dGF0aW9uKHRoaXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudC1hdHRyaWJ1dGUtb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgY2FwdHVyZTogZmFsc2UsXG59O1xuY2xhc3MgTGlzdGVuZXJUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaXNoZXIsIGV2ZW50TmFtZSwgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHVibGlzaGVyID0gcHVibGlzaGVyO1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY2FwdHVyZUxvb2t1cHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYnViYmxlTG9va3VwcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaW5jcmVtZW50KCkge1xuICAgICAgICBpZiAoKyt0aGlzLmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY3JlbWVudCgpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhcHR1cmVMb29rdXBzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuYnViYmxlTG9va3Vwcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0TG9va3VwKHRhcmdldCkge1xuICAgICAgICBjb25zdCBsb29rdXBzID0gdGhpcy5vcHRpb25zLmNhcHR1cmUgPT09IHRydWUgPyB0aGlzLmNhcHR1cmVMb29rdXBzIDogdGhpcy5idWJibGVMb29rdXBzO1xuICAgICAgICBsZXQgbG9va3VwID0gbG9va3Vwcy5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKGxvb2t1cCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsb29rdXBzLnNldCh0YXJnZXQsIGxvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXA7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBsb29rdXBzID0gdGhpcy5vcHRpb25zLmNhcHR1cmUgPT09IHRydWUgPyB0aGlzLmNhcHR1cmVMb29rdXBzIDogdGhpcy5idWJibGVMb29rdXBzO1xuICAgICAgICBjb25zdCBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2FwdHVyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcGF0aCkge1xuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gbG9va3Vwcy5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChsb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBsb29rdXBbdGhpcy5ldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuY2VsQnViYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBFbmFibGUgZGlzcG9zZSgpIHBhdHRlcm4gZm9yIGBkZWxlZ2F0ZWAgJiBgY2FwdHVyZWAgY29tbWFuZHNcbiAqL1xuZXhwb3J0IGNsYXNzIERlbGVnYXRlU3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFja2VyLCBsb29rdXAsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gdHJhY2tlcjtcbiAgICAgICAgdGhpcy5sb29rdXAgPSBsb29rdXA7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0cmFja2VyLmluY3JlbWVudCgpO1xuICAgICAgICBsb29rdXBbZXZlbnROYW1lXSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIuZGVjcmVtZW50KCk7XG4gICAgICAgIHRoaXMubG9va3VwW3RoaXMuZXZlbnROYW1lXSA9IHZvaWQgMDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRXZlbnRTdWJzY3JpYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gICAgc3Vic2NyaWJlKG5vZGUsIGNhbGxiYWNrT3JMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5vZGU7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGNhbGxiYWNrT3JMaXN0ZW5lcjtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLmNvbmZpZy5ldmVudHMpIHtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2tPckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBjb25zdCB7IHRhcmdldCwgaGFuZGxlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiBoYW5kbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuY29uZmlnLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuaGFuZGxlciA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElFdmVudERlbGVnYXRvciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUV2ZW50RGVsZWdhdG9yJywgeCA9PiB4LnNpbmdsZXRvbihFdmVudERlbGVnYXRvcikpO1xuZXhwb3J0IGNsYXNzIEV2ZW50RGVsZWdhdG9yIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50cmFja2VyTWFwcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIocHVibGlzaGVyLCB0YXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0cmFja2VyTWFwID0gKF9hID0gdGhpcy50cmFja2VyTWFwcylbZXZlbnROYW1lXSA/PyAoX2FbZXZlbnROYW1lXSA9IG5ldyBNYXAoKSk7XG4gICAgICAgIGxldCB0cmFja2VyID0gdHJhY2tlck1hcC5nZXQocHVibGlzaGVyKTtcbiAgICAgICAgaWYgKHRyYWNrZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHJhY2tlck1hcC5zZXQocHVibGlzaGVyLCB0cmFja2VyID0gbmV3IExpc3RlbmVyVHJhY2tlcihwdWJsaXNoZXIsIGV2ZW50TmFtZSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVsZWdhdGVTdWJzY3JpcHRpb24odHJhY2tlciwgdHJhY2tlci5nZXRMb29rdXAodGFyZ2V0KSwgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIHRoaXMudHJhY2tlck1hcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZXJNYXAgPSB0aGlzLnRyYWNrZXJNYXBzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrZXIgb2YgdHJhY2tlck1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRyYWNrZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2tlck1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQtZGVsZWdhdG9yLmpzLm1hcCIsImltcG9ydCB7IGVtcHR5T2JqZWN0LCBJU2VydmljZUxvY2F0b3IsIFJlZ2lzdHJhdGlvbiB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJRGlydHlDaGVja2VyLCBJTm9kZU9ic2VydmVyTG9jYXRvciwgUHJvcGVydHlBY2Nlc3NvciwgU2V0dGVyT2JzZXJ2ZXIsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVOU0FjY2Vzc29yIH0gZnJvbSAnLi9hdHRyaWJ1dGUtbnMtYWNjZXNzb3IuanMnO1xuaW1wb3J0IHsgQ2hlY2tlZE9ic2VydmVyIH0gZnJvbSAnLi9jaGVja2VkLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IENsYXNzQXR0cmlidXRlQWNjZXNzb3IgfSBmcm9tICcuL2NsYXNzLWF0dHJpYnV0ZS1hY2Nlc3Nvci5qcyc7XG5pbXBvcnQgeyBhdHRyQWNjZXNzb3IgfSBmcm9tICcuL2RhdGEtYXR0cmlidXRlLWFjY2Vzc29yLmpzJztcbmltcG9ydCB7IEV2ZW50U3Vic2NyaWJlciB9IGZyb20gJy4vZXZlbnQtZGVsZWdhdG9yLmpzJztcbmltcG9ydCB7IFNlbGVjdFZhbHVlT2JzZXJ2ZXIgfSBmcm9tICcuL3NlbGVjdC12YWx1ZS1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBTdHlsZUF0dHJpYnV0ZUFjY2Vzc29yIH0gZnJvbSAnLi9zdHlsZS1hdHRyaWJ1dGUtYWNjZXNzb3IuanMnO1xuaW1wb3J0IHsgSVNWR0FuYWx5emVyIH0gZnJvbSAnLi9zdmctYW5hbHl6ZXIuanMnO1xuaW1wb3J0IHsgVmFsdWVBdHRyaWJ1dGVPYnNlcnZlciB9IGZyb20gJy4vdmFsdWUtYXR0cmlidXRlLW9ic2VydmVyLmpzJztcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNuYW1lc3BhY2VzXG5jb25zdCBodG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCBtYXRobWxOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbmNvbnN0IHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCB4bWxOUyA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xuY29uc3QgeG1sbnNOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLyc7XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbmNvbnN0IG5zQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oY3JlYXRlTG9va3VwKCksIHtcbiAgICAneGxpbms6YWN0dWF0ZSc6IFsnYWN0dWF0ZScsIHhsaW5rTlNdLFxuICAgICd4bGluazphcmNyb2xlJzogWydhcmNyb2xlJywgeGxpbmtOU10sXG4gICAgJ3hsaW5rOmhyZWYnOiBbJ2hyZWYnLCB4bGlua05TXSxcbiAgICAneGxpbms6cm9sZSc6IFsncm9sZScsIHhsaW5rTlNdLFxuICAgICd4bGluazpzaG93JzogWydzaG93JywgeGxpbmtOU10sXG4gICAgJ3hsaW5rOnRpdGxlJzogWyd0aXRsZScsIHhsaW5rTlNdLFxuICAgICd4bGluazp0eXBlJzogWyd0eXBlJywgeGxpbmtOU10sXG4gICAgJ3htbDpsYW5nJzogWydsYW5nJywgeG1sTlNdLFxuICAgICd4bWw6c3BhY2UnOiBbJ3NwYWNlJywgeG1sTlNdLFxuICAgICd4bWxucyc6IFsneG1sbnMnLCB4bWxuc05TXSxcbiAgICAneG1sbnM6eGxpbmsnOiBbJ3hsaW5rJywgeG1sbnNOU10sXG59KTtcbmNvbnN0IGVsZW1lbnRQcm9wZXJ0eUFjY2Vzc29yID0gbmV3IFByb3BlcnR5QWNjZXNzb3IoKTtcbmVsZW1lbnRQcm9wZXJ0eUFjY2Vzc29yLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCA0IC8qIExheW91dCAqLztcbmV4cG9ydCBjbGFzcyBOb2RlT2JzZXJ2ZXJDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnR5cGUgPSBjb25maWcudHlwZSA/PyBWYWx1ZUF0dHJpYnV0ZU9ic2VydmVyO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IGNvbmZpZy5ldmVudHM7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSBjb25maWcucmVhZG9ubHk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbmZpZy5kZWZhdWx0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOb2RlT2JzZXJ2ZXJMb2NhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhdG9yLCBwbGF0Zm9ybSwgZGlydHlDaGVja2VyLCBzdmdBbmFseXplcikge1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMuZGlydHlDaGVja2VyID0gZGlydHlDaGVja2VyO1xuICAgICAgICB0aGlzLnN2Z0FuYWx5emVyID0gc3ZnQW5hbHl6ZXI7XG4gICAgICAgIHRoaXMuYWxsb3dEaXJ0eUNoZWNrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBjcmVhdGVMb29rdXAoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxFdmVudHMgPSBjcmVhdGVMb29rdXAoKTtcbiAgICAgICAgdGhpcy5vdmVycmlkZXMgPSBjcmVhdGVMb29rdXAoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxPdmVycmlkZXMgPSBjcmVhdGVMb29rdXAoKTtcbiAgICAgICAgLy8gdG9kbzogYXRtLCBwbGF0Zm9ybSBpcyByZXF1aXJlZCB0byBiZSByZXNvbHZlZCB0b28gZWFnZXJseSBmb3IgdGhlIGAuaGFuZGxlcygpYCBjaGVja1xuICAgICAgICAvLyBhbHNvIGEgbG90IG9mIHRlc3RzIGFzc3VtZSBkZWZhdWx0IGF2YWlsYWJpbGl0eSBvZiBvYnNlcnZhdGlvblxuICAgICAgICAvLyB0aG9zZSAyIGFzc3VtcHRpb25zIG1ha2UgaXQgbm90IHRoZSByaWdodCB0aW1lIHRvIGV4dHJhY3QgdGhlIGZvbGxvd2luZyBsaW5lIGludG8gYVxuICAgICAgICAvLyBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIE5vZGVPYnNlcnZlckxvY2F0b3IgeWV0XG4gICAgICAgIC8vIGJ1dCBpbiB0aGUgZnV0dXJlLCB0aGV5IHNob3VsZCBiZSwgc28gYXBwcyB0aGF0IGRvbid0IHVzZSBjaGVjayBib3gvc2VsZWN0LCBvciBpbXBsZW1lbnQgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gb2JzZXJ2ZXIgZG9uJ3QgaGF2ZSB0byBwYXkgdGhlIG9mIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGNvbnN0IGlucHV0RXZlbnRzID0gWydjaGFuZ2UnLCAnaW5wdXQnXTtcbiAgICAgICAgY29uc3QgaW5wdXRFdmVudHNDb25maWcgPSB7IGV2ZW50czogaW5wdXRFdmVudHMsIGRlZmF1bHQ6ICcnIH07XG4gICAgICAgIHRoaXMudXNlQ29uZmlnKHtcbiAgICAgICAgICAgIElOUFVUOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0RXZlbnRzQ29uZmlnLFxuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHsgdHlwZTogQ2hlY2tlZE9ic2VydmVyLCBldmVudHM6IGlucHV0RXZlbnRzIH0sXG4gICAgICAgICAgICAgICAgZmlsZXM6IHsgZXZlbnRzOiBpbnB1dEV2ZW50cywgcmVhZG9ubHk6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTRUxFQ1Q6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyB0eXBlOiBTZWxlY3RWYWx1ZU9ic2VydmVyLCBldmVudHM6IFsnY2hhbmdlJ10sIGRlZmF1bHQ6ICcnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgVEVYVEFSRUE6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRFdmVudHNDb25maWcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29udGVudEV2ZW50c0NvbmZpZyA9IHsgZXZlbnRzOiBbJ2NoYW5nZScsICdpbnB1dCcsICdibHVyJywgJ2tleXVwJywgJ3Bhc3RlJ10sIGRlZmF1bHQ6ICcnIH07XG4gICAgICAgIGNvbnN0IHNjcm9sbEV2ZW50c0NvbmZpZyA9IHsgZXZlbnRzOiBbJ3Njcm9sbCddLCBkZWZhdWx0OiAwIH07XG4gICAgICAgIHRoaXMudXNlQ29uZmlnR2xvYmFsKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsRXZlbnRzQ29uZmlnLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdDogc2Nyb2xsRXZlbnRzQ29uZmlnLFxuICAgICAgICAgICAgdGV4dENvbnRlbnQ6IGNvbnRlbnRFdmVudHNDb25maWcsXG4gICAgICAgICAgICBpbm5lckhUTUw6IGNvbnRlbnRFdmVudHNDb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm92ZXJyaWRlQWNjZXNzb3JHbG9iYWwoJ2NzcycsICdzdHlsZScsICdjbGFzcycpO1xuICAgICAgICB0aGlzLm92ZXJyaWRlQWNjZXNzb3Ioe1xuICAgICAgICAgICAgSU5QVVQ6IFsndmFsdWUnLCAnY2hlY2tlZCcsICdtb2RlbCddLFxuICAgICAgICAgICAgU0VMRUNUOiBbJ3ZhbHVlJ10sXG4gICAgICAgICAgICBURVhUQVJFQTogWyd2YWx1ZSddLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBSZWdpc3RyYXRpb24uYWxpYXNUbyhJTm9kZU9ic2VydmVyTG9jYXRvciwgTm9kZU9ic2VydmVyTG9jYXRvcikucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihJTm9kZU9ic2VydmVyTG9jYXRvciwgTm9kZU9ic2VydmVyTG9jYXRvcikucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICB9XG4gICAgLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBoYW5kbGVzKG9iaiwgX2tleSkge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdGhpcy5wbGF0Zm9ybS5Ob2RlO1xuICAgIH1cbiAgICB1c2VDb25maWcobm9kZU5hbWVPckNvbmZpZywga2V5LCBldmVudHNDb25maWcpIHtcbiAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5ldmVudHM7XG4gICAgICAgIGxldCBleGlzdGluZ01hcHBpbmc7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZU5hbWVPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nTWFwcGluZyA9IGxvb2t1cFtub2RlTmFtZU9yQ29uZmlnXSA/PyAobG9va3VwW25vZGVOYW1lT3JDb25maWddID0gY3JlYXRlTG9va3VwKCkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTWFwcGluZ1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ01hcHBpbmdba2V5XSA9IG5ldyBOb2RlT2JzZXJ2ZXJDb25maWcoZXZlbnRzQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93TWFwcGluZ0V4aXN0ZWQobm9kZU5hbWVPckNvbmZpZywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZU5hbWUgaW4gbm9kZU5hbWVPckNvbmZpZykge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nTWFwcGluZyA9IGxvb2t1cFtub2RlTmFtZV0gPz8gKGxvb2t1cFtub2RlTmFtZV0gPSBjcmVhdGVMb29rdXAoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWFwcGluZyA9IG5vZGVOYW1lT3JDb25maWdbbm9kZU5hbWVdO1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIG5ld01hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nTWFwcGluZ1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nTWFwcGluZ1trZXldID0gbmV3IE5vZGVPYnNlcnZlckNvbmZpZyhuZXdNYXBwaW5nW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dNYXBwaW5nRXhpc3RlZChub2RlTmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1c2VDb25maWdHbG9iYWwoY29uZmlnT3JLZXksIGV2ZW50c0NvbmZpZykge1xuICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLmdsb2JhbEV2ZW50cztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWdPcktleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZ09yS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2t1cFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwW2tleV0gPSBuZXcgTm9kZU9ic2VydmVyQ29uZmlnKGNvbmZpZ09yS2V5W2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dNYXBwaW5nRXhpc3RlZCgnKicsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxvb2t1cFtjb25maWdPcktleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvb2t1cFtjb25maWdPcktleV0gPSBuZXcgTm9kZU9ic2VydmVyQ29uZmlnKGV2ZW50c0NvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd01hcHBpbmdFeGlzdGVkKCcqJywgY29uZmlnT3JLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dGxpbmVcbiAgICBnZXRBY2Nlc3NvcihvYmosIGtleSwgcmVxdWVzdG9yKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5nbG9iYWxPdmVycmlkZXMgfHwgKGtleSBpbiAodGhpcy5vdmVycmlkZXNbb2JqLnRhZ05hbWVdID8/IGVtcHR5T2JqZWN0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ic2VydmVyKG9iaiwga2V5LCByZXF1ZXN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAvLyBjbGFzcyAvIHN0eWxlIC8gY3NzIGF0dHJpYnV0ZSB3aWxsIGJlIG9ic2VydmVkIHVzaW5nIC5nZXRPYnNlcnZlcigpIHBlciBvdmVycmlkZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGVyZSBhcmUgKG1hbnkpIG1vcmUgc2l0dWF0aW9uIHdoZXJlIHdlIHdhbnQgdG8gZGVmYXVsdCB0byBEYXRhQXR0cmlidXRlQWNjZXNzb3IsXG4gICAgICAgICAgICAvLyBidXQgZm9yIG5vdyBzdGljayB0byB3aGF0IHZDdXJyZW50IGRvZXNcbiAgICAgICAgICAgIGNhc2UgJ3NyYyc6XG4gICAgICAgICAgICBjYXNlICdocmVmJzpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3dhaS1hcmlhXG4gICAgICAgICAgICBjYXNlICdyb2xlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ckFjY2Vzc29yO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5zUHJvcHMgPSBuc0F0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobnNQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBdHRyaWJ1dGVOU0FjY2Vzc29yLmZvck5zKG5zUHJvcHNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRhQXR0cmlidXRlKG9iaiwga2V5LCB0aGlzLnN2Z0FuYWx5emVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ckFjY2Vzc29yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudFByb3BlcnR5QWNjZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3ZlcnJpZGVBY2Nlc3Nvcih0YWdOYW1lT3JPdmVycmlkZXMsIGtleSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgZXhpc3RpbmdUYWdPdmVycmlkZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YWdOYW1lT3JPdmVycmlkZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBleGlzdGluZ1RhZ092ZXJyaWRlID0gKF9hID0gdGhpcy5vdmVycmlkZXMpW3RhZ05hbWVPck92ZXJyaWRlc10gPz8gKF9hW3RhZ05hbWVPck92ZXJyaWRlc10gPSBjcmVhdGVMb29rdXAoKSk7XG4gICAgICAgICAgICBleGlzdGluZ1RhZ092ZXJyaWRlW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdOYW1lIGluIHRhZ05hbWVPck92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRhZ05hbWVPck92ZXJyaWRlc1t0YWdOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1RhZ092ZXJyaWRlID0gKF9iID0gdGhpcy5vdmVycmlkZXMpW3RhZ05hbWVdID8/IChfYlt0YWdOYW1lXSA9IGNyZWF0ZUxvb2t1cCgpKTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUYWdPdmVycmlkZVtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIGFsbCBlbGVtZW50czpcbiAgICAgKiBjb21wb3NlIGEgbGlzdCBvZiBwcm9wZXJ0aWVzLFxuICAgICAqIHRvIGluZGljYXRlIHRoYXQgYW4gb3ZlcnNlciBzaG91bGQgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBhY2Nlc3NvciBpbiBgLmdldEFjY2Vzc29yKClgXG4gICAgICovXG4gICAgb3ZlcnJpZGVBY2Nlc3Nvckdsb2JhbCguLi5rZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsT3ZlcnJpZGVzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE9ic2VydmVyKGVsLCBrZXksIHJlcXVlc3Rvcikge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAncm9sZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJBY2Nlc3NvcjtcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENsYXNzQXR0cmlidXRlQWNjZXNzb3IoZWwpO1xuICAgICAgICAgICAgY2FzZSAnY3NzJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0eWxlQXR0cmlidXRlQWNjZXNzb3IoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50c0NvbmZpZyA9IHRoaXMuZXZlbnRzW2VsLnRhZ05hbWVdPy5ba2V5XSA/PyB0aGlzLmdsb2JhbEV2ZW50c1trZXldO1xuICAgICAgICBpZiAoZXZlbnRzQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXZlbnRzQ29uZmlnLnR5cGUoZWwsIGtleSwgbmV3IEV2ZW50U3Vic2NyaWJlcihldmVudHNDb25maWcpLCByZXF1ZXN0b3IsIHRoaXMubG9jYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnNQcm9wcyA9IG5zQXR0cmlidXRlc1trZXldO1xuICAgICAgICBpZiAobnNQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gQXR0cmlidXRlTlNBY2Nlc3Nvci5mb3JOcyhuc1Byb3BzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEYXRhQXR0cmlidXRlKGVsLCBrZXksIHRoaXMuc3ZnQW5hbHl6ZXIpKSB7XG4gICAgICAgICAgICAvLyB0b2RvOiBzaG91bGQgb2JzZXJ2ZVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJBY2Nlc3NvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5IGluIGVsLmNvbnN0cnVjdG9yLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dEaXJ0eUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlydHlDaGVja2VyLmNyZWF0ZVByb3BlcnR5KGVsLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc2lkZXI6XG4gICAgICAgICAgICAvLyAtIG1heWJlIGFkZCBhIGFkYXB0ZXIgQVBJIHRvIGhhbmRsZSB1bmtub3duIG9iai9rZXkgY29tYm9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG9ic2VydmUgcHJvcGVydHkgJHtTdHJpbmcoa2V5KX0uIFJlZ2lzdGVyIG9ic2VydmF0aW9uIG1hcHBpbmcgd2l0aCAudXNlQ29uZmlnKCkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2RvOiBwcm9iYWJseSBzdGlsbCBuZWVkcyB0byBnZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdmlhIGdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgLy8gYnV0IGxldCdzIHN0YXJ0IHdpdGggc2ltcGxlc3Qgc2NlbmFyaW9cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0dGVyT2JzZXJ2ZXIoZWwsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Ob2RlT2JzZXJ2ZXJMb2NhdG9yLmluamVjdCA9IFtJU2VydmljZUxvY2F0b3IsIElQbGF0Zm9ybSwgSURpcnR5Q2hlY2tlciwgSVNWR0FuYWx5emVyXTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xsZWN0aW9uT2JzZXJ2ZXIoY29sbGVjdGlvbiwgb2JzZXJ2ZXJMb2NhdG9yKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXJMb2NhdG9yLmdldEFycmF5T2JzZXJ2ZXIoY29sbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlckxvY2F0b3IuZ2V0TWFwT2JzZXJ2ZXIoY29sbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZlckxvY2F0b3IuZ2V0U2V0T2JzZXJ2ZXIoY29sbGVjdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gdGhyb3dNYXBwaW5nRXhpc3RlZChub2RlTmFtZSwga2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNYXBwaW5nIGZvciBwcm9wZXJ0eSAke1N0cmluZyhrZXkpfSBvZiA8JHtub2RlTmFtZX0gLz4gYWxyZWFkeSBleGlzdHNgKTtcbn1cbmNvbnN0IElzRGF0YUF0dHJpYnV0ZSA9IGNyZWF0ZUxvb2t1cCgpO1xuZnVuY3Rpb24gaXNEYXRhQXR0cmlidXRlKG9iaiwga2V5LCBzdmdBbmFseXplcikge1xuICAgIGlmIChJc0RhdGFBdHRyaWJ1dGVba2V5XSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0ga2V5LnNsaWNlKDAsIDUpO1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3dhaS1hcmlhXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjY3VzdG9tLWRhdGEtYXR0cmlidXRlXG4gICAgcmV0dXJuIElzRGF0YUF0dHJpYnV0ZVtrZXldID1cbiAgICAgICAgcHJlZml4ID09PSAnYXJpYS0nIHx8XG4gICAgICAgICAgICBwcmVmaXggPT09ICdkYXRhLScgfHxcbiAgICAgICAgICAgIHN2Z0FuYWx5emVyLmlzU3RhbmRhcmRTdmdBdHRyaWJ1dGUob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9va3VwKCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXItbG9jYXRvci5qcy5tYXAiLCJpbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBjaGlsZE9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG59O1xuZnVuY3Rpb24gZGVmYXVsdE1hdGNoZXIoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xufVxuZXhwb3J0IGNsYXNzIFNlbGVjdFZhbHVlT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgXG4gICAgLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBfa2V5LCBoYW5kbGVyLCBvYnNlcnZlckxvY2F0b3IpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gT2JzZXJ2ZXJUeXBlLkxheW91dCBpcyBub3QgYWx3YXlzIHRydWVcbiAgICAgICAgLy8gYnV0IGZvciBzaW1wbGljaXR5LCBhbHdheXMgdHJlYXQgYXMgc3VjaFxuICAgICAgICB0aGlzLnR5cGUgPSAyIC8qIE5vZGUgKi8gfCAxIC8qIE9ic2VydmVyICovIHwgNCAvKiBMYXlvdXQgKi87XG4gICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5ub2RlT2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgLy8gaXMgaXQgc2FmZSB0byBhc3N1bWUgdGhlIG9ic2VydmVyIGhhcyB0aGUgbGF0ZXN0IHZhbHVlP1xuICAgICAgICAvLyB0b2RvOiBhYmlsaXR5IHRvIHR1cm4gb24vb2ZmIGNhY2hlIGJhc2VkIG9uIHR5cGVcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2aW5nXG4gICAgICAgICAgICA/IHRoaXMuY3VycmVudFZhbHVlXG4gICAgICAgICAgICA6IHRoaXMub2JqLm11bHRpcGxlXG4gICAgICAgICAgICAgICAgPyBBcnJheS5mcm9tKHRoaXMub2JqLm9wdGlvbnMpLm1hcChvID0+IG8udmFsdWUpXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9iai52YWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IG5ld1ZhbHVlICE9PSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICB0aGlzLm9ic2VydmVBcnJheShuZXdWYWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gbmV3VmFsdWUgOiBudWxsKTtcbiAgICAgICAgaWYgKChmbGFncyAmIDQwOTYgLyogbm9GbHVzaCAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDaGFuZ2VzKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaENoYW5nZXMoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN5bmNocm9uaXplT3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIC8vIGFsd2F5cyBzeW5jIFwic2VsZWN0ZWRcIiBwcm9wZXJ0eSBvZiA8b3B0aW9ucy8+XG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHdoZW5ldmVyIHRoZSBhcnJheSBub3RpZmllcyBpdHMgbXV0YXRpb25cbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZU9wdGlvbnMoKTtcbiAgICB9XG4gICAgbm90aWZ5KGZsYWdzKSB7XG4gICAgICAgIGlmICgoZmxhZ3MgJiAzMiAvKiBmcm9tQmluZCAqLykgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZE5vdGlmeSA9IHRoaXMuc3luY2hyb25pemVWYWx1ZSgpO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICB0aGlzLnN1YnMubm90aWZ5KHRoaXMuY3VycmVudFZhbHVlLCB0aGlzLm9sZFZhbHVlLCAwIC8qIG5vbmUgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmNocm9uaXplT3B0aW9ucyhpbmRleE1hcCkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRWYWx1ZSwgb2JqIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBtYXRjaGVyID0gb2JqLm1hdGNoZXIgIT09IHZvaWQgMCA/IG9iai5tYXRjaGVyIDogZGVmYXVsdE1hdGNoZXI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBvYmoub3B0aW9ucztcbiAgICAgICAgbGV0IGkgPSBvcHRpb25zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGhhc093bi5jYWxsKG9wdGlvbiwgJ21vZGVsJykgPyBvcHRpb24ubW9kZWwgOiBvcHRpb24udmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGN1cnJlbnRWYWx1ZS5maW5kSW5kZXgoaXRlbSA9PiAhIW1hdGNoZXIob3B0aW9uVmFsdWUsIGl0ZW0pKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSAhIW1hdGNoZXIob3B0aW9uVmFsdWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luY2hyb25pemVWYWx1ZSgpIHtcbiAgICAgICAgLy8gU3BlYyBmb3Igc3luY2hyb25pemluZyB2YWx1ZSBmcm9tIGA8c2VsZWN0Lz5gICB0byBgU2VsZWN0T2JzZXJ2ZXJgXG4gICAgICAgIC8vIFdoZW4gc3luY2hyb25pemluZyB2YWx1ZSB0byBvYnNlcnZlZCA8c2VsZWN0Lz4gZWxlbWVudCwgZG8gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICAgICAgLy8gQS4gSWYgYDxzZWxlY3QvPmAgaXMgbXVsdGlwbGVcbiAgICAgICAgLy8gICAgMS4gQ2hlY2sgaWYgY3VycmVudCB2YWx1ZSwgY2FsbGVkIGBjdXJyZW50VmFsdWVgIGlzIGFuIGFycmF5XG4gICAgICAgIC8vICAgICAgYS4gSWYgbm90IGFuIGFycmF5LCByZXR1cm4gdHJ1ZSB0byBzaWduYWwgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgLy8gICAgICBiLiBJZiBpcyBhbiBhcnJheTpcbiAgICAgICAgLy8gICAgICAgIGkuIGdhdGhlciBhbGwgY3VycmVudCBzZWxlY3RlZCA8b3B0aW9uLz4sIGluIHRvIGFycmF5IGNhbGxlZCBgdmFsdWVzYFxuICAgICAgICAvLyAgICAgICAgaWkuIGxvb3AgdGhyb3VnaCB0aGUgYGN1cnJlbnRWYWx1ZWAgYXJyYXkgYW5kIHJlbW92ZSBpdGVtcyB0aGF0IGFyZSBub2xvbmdlciBzZWxlY3RlZCBiYXNlZCBvbiBtYXRjaGVyXG4gICAgICAgIC8vICAgICAgICBpaWkuIGxvb3AgdGhyb3VnaCB0aGUgYHZhbHVlc2AgYXJyYXkgYW5kIGFkZCBpdGVtcyB0aGF0IGFyZSBzZWxlY3RlZCBiYXNlZCBvbiBtYXRjaGVyXG4gICAgICAgIC8vICAgICAgICBpdi4gUmV0dXJuIGZhbHNlIHRvIHNpZ25hbCB2YWx1ZSBoYXNuJ3QgY2hhbmdlZFxuICAgICAgICAvLyBCLiBJZiB0aGUgc2VsZWN0IGlzIHNpbmdsZVxuICAgICAgICAvLyAgICAxLiBMZXQgYHZhbHVlYCBlcXVhbCB0aGUgZmlyc3Qgc2VsZWN0ZWQgb3B0aW9uLCBpZiBubyBvcHRpb24gc2VsZWN0ZWQsIHRoZW4gYHZhbHVlYCBpcyBgbnVsbGBcbiAgICAgICAgLy8gICAgMi4gYXNzaWduIGB0aGlzLmN1cnJlbnRWYWx1ZWAgdG8gYHRoaXMub2xkVmFsdWVgXG4gICAgICAgIC8vICAgIDMuIGFzc2lnbiBgdmFsdWVgIHRvIGB0aGlzLmN1cnJlbnRWYWx1ZWBcbiAgICAgICAgLy8gICAgNC4gcmV0dXJuIGB0cnVlYCB0byBzaWduYWwgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5vYmo7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBvYmoub3B0aW9ucztcbiAgICAgICAgY29uc3QgbGVuID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGlmIChvYmoubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIC8vIEEuXG4gICAgICAgICAgICBpZiAoIShjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBLjEuYVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQS4xLmJcbiAgICAgICAgICAgIC8vIG11bHRpIHNlbGVjdFxuICAgICAgICAgICAgbGV0IG9wdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXIgPSBvYmoubWF0Y2hlciB8fCBkZWZhdWx0TWF0Y2hlcjtcbiAgICAgICAgICAgIC8vIEEuMS5iLmlcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaGFzT3duLmNhbGwob3B0aW9uLCAnbW9kZWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBvcHRpb24ubW9kZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQS4xLmIuaWlcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGN1cnJlbnRWYWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAvLyBUb2RvOiByZW1vdmUgYXJyb3cgZm5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmZpbmRJbmRleChiID0+ICEhbWF0Y2hlcihhLCBiKSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQS4xLmIuaWlpXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgLy8gVG9kbzogcmVtb3ZlIGFycm93IGZuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZS5maW5kSW5kZXgoYiA9PiAhIW1hdGNoZXIoYSwgYikpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUucHVzaChhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQS4xLmIuaXZcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCLiBzaW5nbGUgc2VsZWN0XG4gICAgICAgIC8vIEIuMVxuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhhc093bi5jYWxsKG9wdGlvbiwgJ21vZGVsJylcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb24ubW9kZWxcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQi4yXG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLy8gQi4zXG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIC8vIEIuNFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgICh0aGlzLm5vZGVPYnNlcnZlciA9IG5ldyB0aGlzLm9iai5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk11dGF0aW9uT2JzZXJ2ZXIodGhpcy5oYW5kbGVOb2RlQ2hhbmdlLmJpbmQodGhpcykpKVxuICAgICAgICAgICAgLm9ic2VydmUodGhpcy5vYmosIGNoaWxkT2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodGhpcy5jdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuY3VycmVudFZhbHVlIDogbnVsbCk7XG4gICAgICAgIHRoaXMub2JzZXJ2aW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5ub2RlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZXI/LnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVPYnNlcnZlclxuICAgICAgICAgICAgPSB0aGlzLmFycmF5T2JzZXJ2ZXJcbiAgICAgICAgICAgICAgICA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gdG9kbzogb2JzZXJ2ZSBhbGwga2luZCBvZiBjb2xsZWN0aW9uXG4gICAgb2JzZXJ2ZUFycmF5KGFycmF5KSB7XG4gICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlcj8udW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXlPYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGFycmF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vYmoubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbnVsbCBvciBBcnJheSBpbnN0YW5jZXMgY2FuIGJlIGJvdW5kIHRvIGEgbXVsdGktc2VsZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRoaXMuYXJyYXlPYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJMb2NhdG9yLmdldEFycmF5T2JzZXJ2ZXIoYXJyYXkpKS5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTm9kZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZU9wdGlvbnMoKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkTm90aWZ5ID0gdGhpcy5zeW5jaHJvbml6ZVZhbHVlKCk7XG4gICAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KDAgLyogbm9uZSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuc3Vic2NyaWJlKHRoaXMub2JqLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMucmVtb3ZlKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oU2VsZWN0VmFsdWVPYnNlcnZlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QtdmFsdWUtb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgZW1wdHlBcnJheSwga2ViYWJDYXNlIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmNvbnN0IGN1c3RvbVByb3BlcnR5UHJlZml4ID0gJy0tJztcbmV4cG9ydCBjbGFzcyBTdHlsZUF0dHJpYnV0ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTm9kZSAqLyB8IDQgLyogTGF5b3V0ICovO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqLnN0eWxlLmNzc1RleHQ7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBuZXdWYWx1ZSAhPT0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgaWYgKChmbGFncyAmIDQwOTYgLyogbm9GbHVzaCAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDaGFuZ2VzKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTdHlsZVR1cGxlc0Zyb21TdHJpbmcoY3VycmVudFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlVHVwbGVzID0gW107XG4gICAgICAgIGNvbnN0IHVybFJlZ2V4VGVzdGVyID0gL3VybFxcKFteKV0rJC87XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY3VycmVudENodW5rID0gJyc7XG4gICAgICAgIGxldCBuZXh0U3BsaXQ7XG4gICAgICAgIGxldCBpbmRleE9mQ29sb247XG4gICAgICAgIGxldCBhdHRyaWJ1dGU7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGN1cnJlbnRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5leHRTcGxpdCA9IGN1cnJlbnRWYWx1ZS5pbmRleE9mKCc7Jywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChuZXh0U3BsaXQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV4dFNwbGl0ID0gY3VycmVudFZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRDaHVuayArPSBjdXJyZW50VmFsdWUuc3Vic3RyaW5nKG9mZnNldCwgbmV4dFNwbGl0KTtcbiAgICAgICAgICAgIG9mZnNldCA9IG5leHRTcGxpdCArIDE7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgbmV2ZXIgc3BsaXQgYSB1cmwgc28gYWR2YW5jZSB0byBuZXh0XG4gICAgICAgICAgICBpZiAodXJsUmVnZXhUZXN0ZXIudGVzdChjdXJyZW50Q2h1bmspKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rICs9ICc7JztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4T2ZDb2xvbiA9IGN1cnJlbnRDaHVuay5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSBjdXJyZW50Q2h1bmsuc3Vic3RyaW5nKDAsIGluZGV4T2ZDb2xvbikudHJpbSgpO1xuICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50Q2h1bmsuc3Vic3RyaW5nKGluZGV4T2ZDb2xvbiArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgIHN0eWxlVHVwbGVzLnB1c2goW2F0dHJpYnV0ZSwgdmFsdWVdKTtcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZVR1cGxlcztcbiAgICB9XG4gICAgZ2V0U3R5bGVUdXBsZXNGcm9tT2JqZWN0KGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50VmFsdWVbcHJvcGVydHldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSB0YW1wZXJlZCB3aXRoXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LnN0YXJ0c1dpdGgoY3VzdG9tUHJvcGVydHlQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFtwcm9wZXJ0eSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFtrZWJhYkNhc2UocHJvcGVydHkpLCB2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVzLnB1c2goLi4udGhpcy5nZXRTdHlsZVR1cGxlcyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxuICAgIGdldFN0eWxlVHVwbGVzRnJvbUFycmF5KGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICBjb25zdCBsZW4gPSBjdXJyZW50VmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goLi4udGhpcy5nZXRTdHlsZVR1cGxlcyhjdXJyZW50VmFsdWVbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgfVxuICAgIGdldFN0eWxlVHVwbGVzKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlVHVwbGVzRnJvbVN0cmluZyhjdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVUdXBsZXNGcm9tQXJyYXkoY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdHlsZVR1cGxlc0Zyb21PYmplY3QoY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHlBcnJheTtcbiAgICB9XG4gICAgZmx1c2hDaGFuZ2VzKGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLnN0eWxlcztcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlVHVwbGVzID0gdGhpcy5nZXRTdHlsZVR1cGxlcyhjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgbGV0IHN0eWxlO1xuICAgICAgICAgICAgbGV0IHZlcnNpb24gPSB0aGlzLnZlcnNpb247XG4gICAgICAgICAgICB0aGlzLm9sZFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgbGV0IHR1cGxlO1xuICAgICAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBzdHlsZVR1cGxlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdHVwbGUgPSBzdHlsZVR1cGxlc1tpXTtcbiAgICAgICAgICAgICAgICBuYW1lID0gdHVwbGVbMF07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0dXBsZVsxXTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNbbmFtZV0gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gKz0gMTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVyc2lvbiAtPSAxO1xuICAgICAgICAgICAgZm9yIChzdHlsZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZXMsIHN0eWxlKSB8fCBzdHlsZXNbc3R5bGVdICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9iai5zdHlsZS5yZW1vdmVQcm9wZXJ0eShzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UHJvcGVydHkoc3R5bGUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBwcmlvcml0eSA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS5pbmNsdWRlcygnIWltcG9ydGFudCcpKSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9ICdpbXBvcnRhbnQnO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCchaW1wb3J0YW50JywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JqLnN0eWxlLnNldFByb3BlcnR5KHN0eWxlLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICBiaW5kKGZsYWdzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5vbGRWYWx1ZSA9IHRoaXMub2JqLnN0eWxlLmNzc1RleHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGUtYXR0cmlidXRlLWFjY2Vzc29yLmpzLm1hcCIsImltcG9ydCB7IERJLCBSZWdpc3RyYXRpb24gfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi4vcGxhdGZvcm0uanMnO1xuZXhwb3J0IGNvbnN0IElTVkdBbmFseXplciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVNWR0FuYWx5emVyJywgeCA9PiB4LnNpbmdsZXRvbihOb29wU1ZHQW5hbHl6ZXIpKTtcbmV4cG9ydCBjbGFzcyBOb29wU1ZHQW5hbHl6ZXIge1xuICAgIGlzU3RhbmRhcmRTdmdBdHRyaWJ1dGUobm9kZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbyhrZXlzKSB7XG4gICAgY29uc3QgbG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGxvb2t1cFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvb2t1cDtcbn1cbmV4cG9ydCBjbGFzcyBTVkdBbmFseXplciB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgICAgJ2EnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RhcmdldCcsICd0cmFuc2Zvcm0nLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2FsdEdseXBoJzogbyhbJ2NsYXNzJywgJ2R4JywgJ2R5JywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9ybWF0JywgJ2dseXBoUmVmJywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncm90YXRlJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3gnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnYWx0Z2x5cGgnOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgJ2FsdEdseXBoRGVmJzogbyhbJ2lkJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdhbHRnbHlwaGRlZic6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAnYWx0R2x5cGhJdGVtJzogbyhbJ2lkJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdhbHRnbHlwaGl0ZW0nOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgJ2FuaW1hdGUnOiBvKFsnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhdHRyaWJ1dGVOYW1lJywgJ2F0dHJpYnV0ZVR5cGUnLCAnYmVnaW4nLCAnYnknLCAnY2FsY01vZGUnLCAnZHVyJywgJ2VuZCcsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZpbGwnLCAnZnJvbScsICdpZCcsICdrZXlTcGxpbmVzJywgJ2tleVRpbWVzJywgJ21heCcsICdtaW4nLCAnb25iZWdpbicsICdvbmVuZCcsICdvbmxvYWQnLCAnb25yZXBlYXQnLCAncmVwZWF0Q291bnQnLCAncmVwZWF0RHVyJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3Jlc3RhcnQnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndG8nLCAndmFsdWVzJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdhbmltYXRlQ29sb3InOiBvKFsnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhdHRyaWJ1dGVOYW1lJywgJ2F0dHJpYnV0ZVR5cGUnLCAnYmVnaW4nLCAnYnknLCAnY2FsY01vZGUnLCAnZHVyJywgJ2VuZCcsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZpbGwnLCAnZnJvbScsICdpZCcsICdrZXlTcGxpbmVzJywgJ2tleVRpbWVzJywgJ21heCcsICdtaW4nLCAnb25iZWdpbicsICdvbmVuZCcsICdvbmxvYWQnLCAnb25yZXBlYXQnLCAncmVwZWF0Q291bnQnLCAncmVwZWF0RHVyJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3Jlc3RhcnQnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndG8nLCAndmFsdWVzJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdhbmltYXRlTW90aW9uJzogbyhbJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYmVnaW4nLCAnYnknLCAnY2FsY01vZGUnLCAnZHVyJywgJ2VuZCcsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZpbGwnLCAnZnJvbScsICdpZCcsICdrZXlQb2ludHMnLCAna2V5U3BsaW5lcycsICdrZXlUaW1lcycsICdtYXgnLCAnbWluJywgJ29uYmVnaW4nLCAnb25lbmQnLCAnb25sb2FkJywgJ29ucmVwZWF0JywgJ29yaWdpbicsICdwYXRoJywgJ3JlcGVhdENvdW50JywgJ3JlcGVhdER1cicsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyZXN0YXJ0JywgJ3JvdGF0ZScsICdzeXN0ZW1MYW5ndWFnZScsICd0bycsICd2YWx1ZXMnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2FuaW1hdGVUcmFuc2Zvcm0nOiBvKFsnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhdHRyaWJ1dGVOYW1lJywgJ2F0dHJpYnV0ZVR5cGUnLCAnYmVnaW4nLCAnYnknLCAnY2FsY01vZGUnLCAnZHVyJywgJ2VuZCcsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZpbGwnLCAnZnJvbScsICdpZCcsICdrZXlTcGxpbmVzJywgJ2tleVRpbWVzJywgJ21heCcsICdtaW4nLCAnb25iZWdpbicsICdvbmVuZCcsICdvbmxvYWQnLCAnb25yZXBlYXQnLCAncmVwZWF0Q291bnQnLCAncmVwZWF0RHVyJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3Jlc3RhcnQnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndG8nLCAndHlwZScsICd2YWx1ZXMnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2NpcmNsZSc6IG8oWydjbGFzcycsICdjeCcsICdjeScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncicsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2NsaXBQYXRoJzogbyhbJ2NsYXNzJywgJ2NsaXBQYXRoVW5pdHMnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2NvbG9yLXByb2ZpbGUnOiBvKFsnaWQnLCAnbG9jYWwnLCAnbmFtZScsICdyZW5kZXJpbmctaW50ZW50JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdjdXJzb3InOiBvKFsnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzeXN0ZW1MYW5ndWFnZScsICd4JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2RlZnMnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZGVzYyc6IG8oWydjbGFzcycsICdpZCcsICdzdHlsZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZWxsaXBzZSc6IG8oWydjbGFzcycsICdjeCcsICdjeScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncngnLCAncnknLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmZUJsZW5kJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdpbjInLCAnbW9kZScsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZUNvbG9yTWF0cml4JzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdyZXN1bHQnLCAnc3R5bGUnLCAndHlwZScsICd2YWx1ZXMnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZUNvbXBvbmVudFRyYW5zZmVyJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZUNvbXBvc2l0ZSc6IG8oWydjbGFzcycsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAnaW4yJywgJ2sxJywgJ2syJywgJ2szJywgJ2s0JywgJ29wZXJhdG9yJywgJ3Jlc3VsdCcsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZlQ29udm9sdmVNYXRyaXgnOiBvKFsnYmlhcycsICdjbGFzcycsICdkaXZpc29yJywgJ2VkZ2VNb2RlJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdrZXJuZWxNYXRyaXgnLCAna2VybmVsVW5pdExlbmd0aCcsICdvcmRlcicsICdwcmVzZXJ2ZUFscGhhJywgJ3Jlc3VsdCcsICdzdHlsZScsICd0YXJnZXRYJywgJ3RhcmdldFknLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZURpZmZ1c2VMaWdodGluZyc6IG8oWydjbGFzcycsICdkaWZmdXNlQ29uc3RhbnQnLCAnaGVpZ2h0JywgJ2lkJywgJ2luJywgJ2tlcm5lbFVuaXRMZW5ndGgnLCAncmVzdWx0JywgJ3N0eWxlJywgJ3N1cmZhY2VTY2FsZScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZlRGlzcGxhY2VtZW50TWFwJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdpbjInLCAncmVzdWx0JywgJ3NjYWxlJywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneENoYW5uZWxTZWxlY3RvcicsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneScsICd5Q2hhbm5lbFNlbGVjdG9yJ10pLFxuICAgICAgICAgICAgJ2ZlRGlzdGFudExpZ2h0JzogbyhbJ2F6aW11dGgnLCAnZWxldmF0aW9uJywgJ2lkJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmZUZsb29kJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZUZ1bmNBJzogbyhbJ2FtcGxpdHVkZScsICdleHBvbmVudCcsICdpZCcsICdpbnRlcmNlcHQnLCAnb2Zmc2V0JywgJ3Nsb3BlJywgJ3RhYmxlVmFsdWVzJywgJ3R5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2ZlRnVuY0InOiBvKFsnYW1wbGl0dWRlJywgJ2V4cG9uZW50JywgJ2lkJywgJ2ludGVyY2VwdCcsICdvZmZzZXQnLCAnc2xvcGUnLCAndGFibGVWYWx1ZXMnLCAndHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnZmVGdW5jRyc6IG8oWydhbXBsaXR1ZGUnLCAnZXhwb25lbnQnLCAnaWQnLCAnaW50ZXJjZXB0JywgJ29mZnNldCcsICdzbG9wZScsICd0YWJsZVZhbHVlcycsICd0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmZUZ1bmNSJzogbyhbJ2FtcGxpdHVkZScsICdleHBvbmVudCcsICdpZCcsICdpbnRlcmNlcHQnLCAnb2Zmc2V0JywgJ3Nsb3BlJywgJ3RhYmxlVmFsdWVzJywgJ3R5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2ZlR2F1c3NpYW5CbHVyJzogbyhbJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdpbicsICdyZXN1bHQnLCAnc3RkRGV2aWF0aW9uJywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVJbWFnZSc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2hlaWdodCcsICdpZCcsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3Jlc3VsdCcsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZlTWVyZ2UnOiBvKFsnY2xhc3MnLCAnaGVpZ2h0JywgJ2lkJywgJ3Jlc3VsdCcsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZlTWVyZ2VOb2RlJzogbyhbJ2lkJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmZU1vcnBob2xvZ3knOiBvKFsnY2xhc3MnLCAnaGVpZ2h0JywgJ2lkJywgJ2luJywgJ29wZXJhdG9yJywgJ3JhZGl1cycsICdyZXN1bHQnLCAnc3R5bGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZU9mZnNldCc6IG8oWydjbGFzcycsICdkeCcsICdkeScsICdoZWlnaHQnLCAnaWQnLCAnaW4nLCAncmVzdWx0JywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZmVQb2ludExpZ2h0JzogbyhbJ2lkJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knLCAneiddKSxcbiAgICAgICAgICAgICdmZVNwZWN1bGFyTGlnaHRpbmcnOiBvKFsnY2xhc3MnLCAnaGVpZ2h0JywgJ2lkJywgJ2luJywgJ2tlcm5lbFVuaXRMZW5ndGgnLCAncmVzdWx0JywgJ3NwZWN1bGFyQ29uc3RhbnQnLCAnc3BlY3VsYXJFeHBvbmVudCcsICdzdHlsZScsICdzdXJmYWNlU2NhbGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmZVNwb3RMaWdodCc6IG8oWydpZCcsICdsaW1pdGluZ0NvbmVBbmdsZScsICdwb2ludHNBdFgnLCAncG9pbnRzQXRZJywgJ3BvaW50c0F0WicsICdzcGVjdWxhckV4cG9uZW50JywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knLCAneiddKSxcbiAgICAgICAgICAgICdmZVRpbGUnOiBvKFsnY2xhc3MnLCAnaGVpZ2h0JywgJ2lkJywgJ2luJywgJ3Jlc3VsdCcsICdzdHlsZScsICd3aWR0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2ZlVHVyYnVsZW5jZSc6IG8oWydiYXNlRnJlcXVlbmN5JywgJ2NsYXNzJywgJ2hlaWdodCcsICdpZCcsICdudW1PY3RhdmVzJywgJ3Jlc3VsdCcsICdzZWVkJywgJ3N0aXRjaFRpbGVzJywgJ3N0eWxlJywgJ3R5cGUnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdmaWx0ZXInOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmaWx0ZXJSZXMnLCAnZmlsdGVyVW5pdHMnLCAnaGVpZ2h0JywgJ2lkJywgJ3ByaW1pdGl2ZVVuaXRzJywgJ3N0eWxlJywgJ3dpZHRoJywgJ3gnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZm9udCc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2hvcml6LW9yaWdpbi15JywgJ2lkJywgJ3N0eWxlJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmb250LWZhY2UnOiBvKFsnYWNjZW50LWhlaWdodCcsICdhbHBoYWJldGljJywgJ2FzY2VudCcsICdiYm94JywgJ2NhcC1oZWlnaHQnLCAnZGVzY2VudCcsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2hhbmdpbmcnLCAnaWQnLCAnaWRlb2dyYXBoaWMnLCAnbWF0aGVtYXRpY2FsJywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYW5vc2UtMScsICdzbG9wZScsICdzdGVtaCcsICdzdGVtdicsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd3aWR0aHMnLCAneC1oZWlnaHQnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ2ZvbnQtZmFjZS1mb3JtYXQnOiBvKFsnaWQnLCAnc3RyaW5nJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmb250LWZhY2UtbmFtZSc6IG8oWydpZCcsICduYW1lJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmb250LWZhY2Utc3JjJzogbyhbJ2lkJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmb250LWZhY2UtdXJpJzogbyhbJ2lkJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdmb3JlaWduT2JqZWN0JzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaGVpZ2h0JywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnZyc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdnbHlwaCc6IG8oWydhcmFiaWMtZm9ybScsICdjbGFzcycsICdkJywgJ2dseXBoLW5hbWUnLCAnaG9yaXotYWR2LXgnLCAnaWQnLCAnbGFuZycsICdvcmllbnRhdGlvbicsICdzdHlsZScsICd1bmljb2RlJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdnbHlwaFJlZic6IG8oWydjbGFzcycsICdkeCcsICdkeScsICdmb3JtYXQnLCAnZ2x5cGhSZWYnLCAnaWQnLCAnc3R5bGUnLCAneCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdnbHlwaHJlZic6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAnaGtlcm4nOiBvKFsnZzEnLCAnZzInLCAnaWQnLCAnaycsICd1MScsICd1MicsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnaW1hZ2UnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdoZWlnaHQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd3aWR0aCcsICd4JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ2xpbmUnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd4MScsICd4MicsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneTEnLCAneTInXSksXG4gICAgICAgICAgICAnbGluZWFyR3JhZGllbnQnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdncmFkaWVudFRyYW5zZm9ybScsICdncmFkaWVudFVuaXRzJywgJ2lkJywgJ3NwcmVhZE1ldGhvZCcsICdzdHlsZScsICd4MScsICd4MicsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5MScsICd5MiddKSxcbiAgICAgICAgICAgICdtYXJrZXInOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdtYXJrZXJIZWlnaHQnLCAnbWFya2VyVW5pdHMnLCAnbWFya2VyV2lkdGgnLCAnb3JpZW50JywgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAncmVmWCcsICdyZWZZJywgJ3N0eWxlJywgJ3ZpZXdCb3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ21hc2snOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdoZWlnaHQnLCAnaWQnLCAnbWFza0NvbnRlbnRVbml0cycsICdtYXNrVW5pdHMnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAnd2lkdGgnLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICdtZXRhZGF0YSc6IG8oWydpZCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnbWlzc2luZy1nbHlwaCc6IG8oWydjbGFzcycsICdkJywgJ2hvcml6LWFkdi14JywgJ2lkJywgJ3N0eWxlJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdtcGF0aCc6IG8oWydleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdwYXRoJzogbyhbJ2NsYXNzJywgJ2QnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3BhdGhMZW5ndGgnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdwYXR0ZXJuJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaGVpZ2h0JywgJ2lkJywgJ3BhdHRlcm5Db250ZW50VW5pdHMnLCAncGF0dGVyblRyYW5zZm9ybScsICdwYXR0ZXJuVW5pdHMnLCAncHJlc2VydmVBc3BlY3RSYXRpbycsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd2aWV3Qm94JywgJ3dpZHRoJywgJ3gnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAncG9seWdvbic6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncG9pbnRzJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAncG9seWxpbmUnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3BvaW50cycsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzdHlsZScsICdzeXN0ZW1MYW5ndWFnZScsICd0cmFuc2Zvcm0nLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3JhZGlhbEdyYWRpZW50JzogbyhbJ2NsYXNzJywgJ2N4JywgJ2N5JywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZngnLCAnZnknLCAnZ3JhZGllbnRUcmFuc2Zvcm0nLCAnZ3JhZGllbnRVbml0cycsICdpZCcsICdyJywgJ3NwcmVhZE1ldGhvZCcsICdzdHlsZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdyZWN0JzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaGVpZ2h0JywgJ2lkJywgJ29uYWN0aXZhdGUnLCAnb25jbGljaycsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAncngnLCAncnknLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndHJhbnNmb3JtJywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAnc2NyaXB0JzogbyhbJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAndHlwZScsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnc2V0JzogbyhbJ2F0dHJpYnV0ZU5hbWUnLCAnYXR0cmlidXRlVHlwZScsICdiZWdpbicsICdkdXInLCAnZW5kJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZmlsbCcsICdpZCcsICdtYXgnLCAnbWluJywgJ29uYmVnaW4nLCAnb25lbmQnLCAnb25sb2FkJywgJ29ucmVwZWF0JywgJ3JlcGVhdENvdW50JywgJ3JlcGVhdER1cicsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyZXN0YXJ0JywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RvJywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgICAgICdzdG9wJzogbyhbJ2NsYXNzJywgJ2lkJywgJ29mZnNldCcsICdzdHlsZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnc3R5bGUnOiBvKFsnaWQnLCAnbWVkaWEnLCAndGl0bGUnLCAndHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnc3ZnJzogbyhbJ2Jhc2VQcm9maWxlJywgJ2NsYXNzJywgJ2NvbnRlbnRTY3JpcHRUeXBlJywgJ2NvbnRlbnRTdHlsZVR5cGUnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdoZWlnaHQnLCAnaWQnLCAnb25hYm9ydCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25lcnJvcicsICdvbmZvY3VzaW4nLCAnb25mb2N1c291dCcsICdvbmxvYWQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZW1vdmUnLCAnb25tb3VzZW91dCcsICdvbm1vdXNlb3ZlcicsICdvbm1vdXNldXAnLCAnb25yZXNpemUnLCAnb25zY3JvbGwnLCAnb251bmxvYWQnLCAnb256b29tJywgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndmVyc2lvbicsICd2aWV3Qm94JywgJ3dpZHRoJywgJ3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knLCAnem9vbUFuZFBhbiddKSxcbiAgICAgICAgICAgICdzd2l0Y2gnOiBvKFsnY2xhc3MnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbyhbJ2NsYXNzJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnaWQnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3N0eWxlJywgJ3ZpZXdCb3gnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3RleHQnOiBvKFsnY2xhc3MnLCAnZHgnLCAnZHknLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdsZW5ndGhBZGp1c3QnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyb3RhdGUnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndGV4dExlbmd0aCcsICd0cmFuc2Zvcm0nLCAneCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAneSddKSxcbiAgICAgICAgICAgICd0ZXh0UGF0aCc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2lkJywgJ2xlbmd0aEFkanVzdCcsICdtZXRob2QnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdzcGFjaW5nJywgJ3N0YXJ0T2Zmc2V0JywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RleHRMZW5ndGgnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXSksXG4gICAgICAgICAgICAndGl0bGUnOiBvKFsnY2xhc3MnLCAnaWQnLCAnc3R5bGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10pLFxuICAgICAgICAgICAgJ3RyZWYnOiBvKFsnY2xhc3MnLCAnZHgnLCAnZHknLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdsZW5ndGhBZGp1c3QnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyb3RhdGUnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndGV4dExlbmd0aCcsICd4JywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJywgJ3knXSksXG4gICAgICAgICAgICAndHNwYW4nOiBvKFsnY2xhc3MnLCAnZHgnLCAnZHknLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdsZW5ndGhBZGp1c3QnLCAnb25hY3RpdmF0ZScsICdvbmNsaWNrJywgJ29uZm9jdXNpbicsICdvbmZvY3Vzb3V0JywgJ29ubG9hZCcsICdvbm1vdXNlZG93bicsICdvbm1vdXNlbW92ZScsICdvbm1vdXNlb3V0JywgJ29ubW91c2VvdmVyJywgJ29ubW91c2V1cCcsICdyZXF1aXJlZEV4dGVuc2lvbnMnLCAncmVxdWlyZWRGZWF0dXJlcycsICdyb3RhdGUnLCAnc3R5bGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndGV4dExlbmd0aCcsICd4JywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ3VzZSc6IG8oWydjbGFzcycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2hlaWdodCcsICdpZCcsICdvbmFjdGl2YXRlJywgJ29uY2xpY2snLCAnb25mb2N1c2luJywgJ29uZm9jdXNvdXQnLCAnb25sb2FkJywgJ29ubW91c2Vkb3duJywgJ29ubW91c2Vtb3ZlJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZW92ZXInLCAnb25tb3VzZXVwJywgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsICdyZXF1aXJlZEZlYXR1cmVzJywgJ3N0eWxlJywgJ3N5c3RlbUxhbmd1YWdlJywgJ3RyYW5zZm9ybScsICd3aWR0aCcsICd4JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScsICd5J10pLFxuICAgICAgICAgICAgJ3ZpZXcnOiBvKFsnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdpZCcsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3ZpZXdCb3gnLCAndmlld1RhcmdldCcsICd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnLCAnem9vbUFuZFBhbiddKSxcbiAgICAgICAgICAgICd2a2Vybic6IG8oWydnMScsICdnMicsICdpZCcsICdrJywgJ3UxJywgJ3UyJywgJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3ZnUHJlc2VudGF0aW9uRWxlbWVudHMgPSBvKFtcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICdhbHRHbHlwaCcsXG4gICAgICAgICAgICAnYW5pbWF0ZScsXG4gICAgICAgICAgICAnYW5pbWF0ZUNvbG9yJyxcbiAgICAgICAgICAgICdjaXJjbGUnLFxuICAgICAgICAgICAgJ2NsaXBQYXRoJyxcbiAgICAgICAgICAgICdkZWZzJyxcbiAgICAgICAgICAgICdlbGxpcHNlJyxcbiAgICAgICAgICAgICdmZUJsZW5kJyxcbiAgICAgICAgICAgICdmZUNvbG9yTWF0cml4JyxcbiAgICAgICAgICAgICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcbiAgICAgICAgICAgICdmZUNvbXBvc2l0ZScsXG4gICAgICAgICAgICAnZmVDb252b2x2ZU1hdHJpeCcsXG4gICAgICAgICAgICAnZmVEaWZmdXNlTGlnaHRpbmcnLFxuICAgICAgICAgICAgJ2ZlRGlzcGxhY2VtZW50TWFwJyxcbiAgICAgICAgICAgICdmZUZsb29kJyxcbiAgICAgICAgICAgICdmZUdhdXNzaWFuQmx1cicsXG4gICAgICAgICAgICAnZmVJbWFnZScsXG4gICAgICAgICAgICAnZmVNZXJnZScsXG4gICAgICAgICAgICAnZmVNb3JwaG9sb2d5JyxcbiAgICAgICAgICAgICdmZU9mZnNldCcsXG4gICAgICAgICAgICAnZmVTcGVjdWxhckxpZ2h0aW5nJyxcbiAgICAgICAgICAgICdmZVRpbGUnLFxuICAgICAgICAgICAgJ2ZlVHVyYnVsZW5jZScsXG4gICAgICAgICAgICAnZmlsdGVyJyxcbiAgICAgICAgICAgICdmb250JyxcbiAgICAgICAgICAgICdmb3JlaWduT2JqZWN0JyxcbiAgICAgICAgICAgICdnJyxcbiAgICAgICAgICAgICdnbHlwaCcsXG4gICAgICAgICAgICAnZ2x5cGhSZWYnLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICdsaW5lJyxcbiAgICAgICAgICAgICdsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnbWFya2VyJyxcbiAgICAgICAgICAgICdtYXNrJyxcbiAgICAgICAgICAgICdtaXNzaW5nLWdseXBoJyxcbiAgICAgICAgICAgICdwYXRoJyxcbiAgICAgICAgICAgICdwYXR0ZXJuJyxcbiAgICAgICAgICAgICdwb2x5Z29uJyxcbiAgICAgICAgICAgICdwb2x5bGluZScsXG4gICAgICAgICAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3JlY3QnLFxuICAgICAgICAgICAgJ3N0b3AnLFxuICAgICAgICAgICAgJ3N2ZycsXG4gICAgICAgICAgICAnc3dpdGNoJyxcbiAgICAgICAgICAgICdzeW1ib2wnLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ3RleHRQYXRoJyxcbiAgICAgICAgICAgICd0cmVmJyxcbiAgICAgICAgICAgICd0c3BhbicsXG4gICAgICAgICAgICAndXNlJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuc3ZnUHJlc2VudGF0aW9uQXR0cmlidXRlcyA9IG8oW1xuICAgICAgICAgICAgJ2FsaWdubWVudC1iYXNlbGluZScsXG4gICAgICAgICAgICAnYmFzZWxpbmUtc2hpZnQnLFxuICAgICAgICAgICAgJ2NsaXAtcGF0aCcsXG4gICAgICAgICAgICAnY2xpcC1ydWxlJyxcbiAgICAgICAgICAgICdjbGlwJyxcbiAgICAgICAgICAgICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLFxuICAgICAgICAgICAgJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICAgICAgICAgICAgJ2NvbG9yLXByb2ZpbGUnLFxuICAgICAgICAgICAgJ2NvbG9yLXJlbmRlcmluZycsXG4gICAgICAgICAgICAnY29sb3InLFxuICAgICAgICAgICAgJ2N1cnNvcicsXG4gICAgICAgICAgICAnZGlyZWN0aW9uJyxcbiAgICAgICAgICAgICdkaXNwbGF5JyxcbiAgICAgICAgICAgICdkb21pbmFudC1iYXNlbGluZScsXG4gICAgICAgICAgICAnZW5hYmxlLWJhY2tncm91bmQnLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgICAgICAgICAnZmlsbC1ydWxlJyxcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgICdmaWx0ZXInLFxuICAgICAgICAgICAgJ2Zsb29kLWNvbG9yJyxcbiAgICAgICAgICAgICdmbG9vZC1vcGFjaXR5JyxcbiAgICAgICAgICAgICdmb250LWZhbWlseScsXG4gICAgICAgICAgICAnZm9udC1zaXplLWFkanVzdCcsXG4gICAgICAgICAgICAnZm9udC1zaXplJyxcbiAgICAgICAgICAgICdmb250LXN0cmV0Y2gnLFxuICAgICAgICAgICAgJ2ZvbnQtc3R5bGUnLFxuICAgICAgICAgICAgJ2ZvbnQtdmFyaWFudCcsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQnLFxuICAgICAgICAgICAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLFxuICAgICAgICAgICAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgICAgICAgICAgICdpbWFnZS1yZW5kZXJpbmcnLFxuICAgICAgICAgICAgJ2tlcm5pbmcnLFxuICAgICAgICAgICAgJ2xldHRlci1zcGFjaW5nJyxcbiAgICAgICAgICAgICdsaWdodGluZy1jb2xvcicsXG4gICAgICAgICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAgICAgICAnbWFya2VyLW1pZCcsXG4gICAgICAgICAgICAnbWFya2VyLXN0YXJ0JyxcbiAgICAgICAgICAgICdtYXNrJyxcbiAgICAgICAgICAgICdvcGFjaXR5JyxcbiAgICAgICAgICAgICdvdmVyZmxvdycsXG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnLFxuICAgICAgICAgICAgJ3NoYXBlLXJlbmRlcmluZycsXG4gICAgICAgICAgICAnc3RvcC1jb2xvcicsXG4gICAgICAgICAgICAnc3RvcC1vcGFjaXR5JyxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgICAgICAgICAgJ3N0cm9rZS1saW5lam9pbicsXG4gICAgICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnLFxuICAgICAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICAgICAndGV4dC1hbmNob3InLFxuICAgICAgICAgICAgJ3RleHQtZGVjb3JhdGlvbicsXG4gICAgICAgICAgICAndGV4dC1yZW5kZXJpbmcnLFxuICAgICAgICAgICAgJ3VuaWNvZGUtYmlkaScsXG4gICAgICAgICAgICAndmlzaWJpbGl0eScsXG4gICAgICAgICAgICAnd29yZC1zcGFjaW5nJyxcbiAgICAgICAgICAgICd3cml0aW5nLW1vZGUnLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5TVkdFbGVtZW50ID0gcGxhdGZvcm0uZ2xvYmFsVGhpcy5TVkdFbGVtZW50O1xuICAgICAgICBjb25zdCBkaXYgPSBwbGF0Zm9ybS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8c3ZnPjxhbHRHbHlwaCAvPjwvc3ZnPic7XG4gICAgICAgIGlmIChkaXYuZmlyc3RFbGVtZW50Q2hpbGQubm9kZU5hbWUgPT09ICdhbHRnbHlwaCcpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBjaHJvbWUgY2FzaW5nIGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRWxlbWVudHM7XG4gICAgICAgICAgICBsZXQgdG1wID0gc3ZnLmFsdEdseXBoO1xuICAgICAgICAgICAgc3ZnLmFsdEdseXBoID0gc3ZnLmFsdGdseXBoO1xuICAgICAgICAgICAgc3ZnLmFsdGdseXBoID0gdG1wO1xuICAgICAgICAgICAgdG1wID0gc3ZnLmFsdEdseXBoRGVmO1xuICAgICAgICAgICAgc3ZnLmFsdEdseXBoRGVmID0gc3ZnLmFsdGdseXBoZGVmO1xuICAgICAgICAgICAgc3ZnLmFsdGdseXBoZGVmID0gdG1wO1xuICAgICAgICAgICAgdG1wID0gc3ZnLmFsdEdseXBoSXRlbTtcbiAgICAgICAgICAgIHN2Zy5hbHRHbHlwaEl0ZW0gPSBzdmcuYWx0Z2x5cGhpdGVtO1xuICAgICAgICAgICAgc3ZnLmFsdGdseXBoaXRlbSA9IHRtcDtcbiAgICAgICAgICAgIHRtcCA9IHN2Zy5nbHlwaFJlZjtcbiAgICAgICAgICAgIHN2Zy5nbHlwaFJlZiA9IHN2Zy5nbHlwaHJlZjtcbiAgICAgICAgICAgIHN2Zy5nbHlwaHJlZiA9IHRtcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBSZWdpc3RyYXRpb24uc2luZ2xldG9uKElTVkdBbmFseXplciwgdGhpcykucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICB9XG4gICAgaXNTdGFuZGFyZFN2Z0F0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiB0aGlzLlNWR0VsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnN2Z1ByZXNlbnRhdGlvbkVsZW1lbnRzW25vZGUubm9kZU5hbWVdID09PSB0cnVlICYmIHRoaXMuc3ZnUHJlc2VudGF0aW9uQXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgdGhpcy5zdmdFbGVtZW50c1tub2RlLm5vZGVOYW1lXT8uW2F0dHJpYnV0ZU5hbWVdID09PSB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5TVkdBbmFseXplci5pbmplY3QgPSBbSVBsYXRmb3JtXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN2Zy1hbmFseXplci5qcy5tYXAiLCJpbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuLyoqXG4gKiBPYnNlcnZlciBmb3Igbm9uLXJhZGlvLCBub24tY2hlY2tib3ggaW5wdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBWYWx1ZUF0dHJpYnV0ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvYmosIHByb3BlcnR5S2V5LCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gT2JzZXJ2ZXJUeXBlLkxheW91dCBpcyBub3QgYWx3YXlzIHRydWUsIGl0IGRlcGVuZHMgb24gdGhlIGVsZW1lbnQgJiBwcm9wZXJ0eSBjb21ib1xuICAgICAgICAvLyBidXQgZm9yIHNpbXBsaWNpdHksIGFsd2F5cyB0cmVhdCBhcyBzdWNoXG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTm9kZSAqLyB8IDEgLyogT2JzZXJ2ZXIgKi8gfCA0IC8qIExheW91dCAqLztcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICAvLyBpcyBpdCBzYWZlIHRvIGFzc3VtZSB0aGUgb2JzZXJ2ZXIgaGFzIHRoZSBsYXRlc3QgdmFsdWU/XG4gICAgICAgIC8vIHRvZG86IGFiaWxpdHkgdG8gdHVybiBvbi9vZmYgY2FjaGUgYmFzZWQgb24gdHlwZVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSBuZXdWYWx1ZSAhPT0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXIuY29uZmlnLnJlYWRvbmx5ICYmIChmbGFncyAmIDQwOTYgLyogbm9GbHVzaCAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDaGFuZ2VzKGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaENoYW5nZXMoZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5oYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMub2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XSA9IGN1cnJlbnRWYWx1ZSA/PyB0aGlzLmhhbmRsZXIuY29uZmlnLmRlZmF1bHQ7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMzIgLyogZnJvbUJpbmQgKi8pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShjdXJyZW50VmFsdWUsIG9sZFZhbHVlLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5vbGRWYWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlO1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnRWYWx1ZSA9IHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldO1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3Vicy5ub3RpZnkoY3VycmVudFZhbHVlLCBvbGRWYWx1ZSwgMCAvKiBub25lICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLmFkZChzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5zdWJzY3JpYmUodGhpcy5vYmosIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB0aGlzLm9sZFZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLnJlbW92ZShzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihWYWx1ZUF0dHJpYnV0ZU9ic2VydmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlLWF0dHJpYnV0ZS1vYnNlcnZlci5qcy5tYXAiLCJpbXBvcnQgeyBJUGxhdGZvcm0gYXMgJElQbGF0Zm9ybSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgY29uc3QgSVBsYXRmb3JtID0gJElQbGF0Zm9ybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgTWV0YWRhdGEsIFJlZ2lzdHJhdGlvbiwgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQmluZGluZ01vZGUsIElFeHByZXNzaW9uUGFyc2VyLCBJT2JzZXJ2ZXJMb2NhdG9yLCBCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uLCBCaW5kaW5nQmVoYXZpb3JGYWN0b3J5LCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgQ2FsbEJpbmRpbmcgfSBmcm9tICcuL2JpbmRpbmcvY2FsbC1iaW5kaW5nLmpzJztcbmltcG9ydCB7IEF0dHJpYnV0ZUJpbmRpbmcgfSBmcm9tICcuL2JpbmRpbmcvYXR0cmlidXRlLmpzJztcbmltcG9ydCB7IEludGVycG9sYXRpb25CaW5kaW5nIH0gZnJvbSAnLi9iaW5kaW5nL2ludGVycG9sYXRpb24tYmluZGluZy5qcyc7XG5pbXBvcnQgeyBMZXRCaW5kaW5nIH0gZnJvbSAnLi9iaW5kaW5nL2xldC1iaW5kaW5nLmpzJztcbmltcG9ydCB7IFByb3BlcnR5QmluZGluZyB9IGZyb20gJy4vYmluZGluZy9wcm9wZXJ0eS1iaW5kaW5nLmpzJztcbmltcG9ydCB7IFJlZkJpbmRpbmcgfSBmcm9tICcuL2JpbmRpbmcvcmVmLWJpbmRpbmcuanMnO1xuaW1wb3J0IHsgTGlzdGVuZXIgfSBmcm9tICcuL2JpbmRpbmcvbGlzdGVuZXIuanMnO1xuaW1wb3J0IHsgSUV2ZW50RGVsZWdhdG9yIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9ldmVudC1kZWxlZ2F0b3IuanMnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudCB9IGZyb20gJy4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50LmpzJztcbmltcG9ydCB7IGdldFJlbmRlckNvbnRleHQgfSBmcm9tICcuL3RlbXBsYXRpbmcvcmVuZGVyLWNvbnRleHQuanMnO1xuaW1wb3J0IHsgQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9SZW5kZXJMb2NhdGlvbiB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICcuL3RlbXBsYXRpbmcvY29udHJvbGxlci5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmV4cG9ydCB2YXIgSW5zdHJ1Y3Rpb25UeXBlO1xuKGZ1bmN0aW9uIChJbnN0cnVjdGlvblR5cGUpIHtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJoeWRyYXRlRWxlbWVudFwiXSA9IFwicmFcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJoeWRyYXRlQXR0cmlidXRlXCJdID0gXCJyYlwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcImh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXJcIl0gPSBcInJjXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wiaHlkcmF0ZUxldEVsZW1lbnRcIl0gPSBcInJkXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wic2V0UHJvcGVydHlcIl0gPSBcInJlXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wiaW50ZXJwb2xhdGlvblwiXSA9IFwicmZcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJwcm9wZXJ0eUJpbmRpbmdcIl0gPSBcInJnXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wiY2FsbEJpbmRpbmdcIl0gPSBcInJoXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wibGV0QmluZGluZ1wiXSA9IFwicmlcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJyZWZCaW5kaW5nXCJdID0gXCJyalwiO1xuICAgIEluc3RydWN0aW9uVHlwZVtcIml0ZXJhdG9yQmluZGluZ1wiXSA9IFwicmtcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJ0ZXh0QmluZGluZ1wiXSA9IFwiaGFcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJsaXN0ZW5lckJpbmRpbmdcIl0gPSBcImhiXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wiYXR0cmlidXRlQmluZGluZ1wiXSA9IFwiaGNcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJzdHlsZVByb3BlcnR5QmluZGluZ1wiXSA9IFwiaGRcIjtcbiAgICBJbnN0cnVjdGlvblR5cGVbXCJzZXRBdHRyaWJ1dGVcIl0gPSBcImhlXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wic2V0Q2xhc3NBdHRyaWJ1dGVcIl0gPSBcImhmXCI7XG4gICAgSW5zdHJ1Y3Rpb25UeXBlW1wic2V0U3R5bGVBdHRyaWJ1dGVcIl0gPSBcImhnXCI7XG59KShJbnN0cnVjdGlvblR5cGUgfHwgKEluc3RydWN0aW9uVHlwZSA9IHt9KSk7XG5leHBvcnQgY29uc3QgSUluc3RydWN0aW9uID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJbnN0cnVjdGlvbicpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5zdHJ1Y3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCB0eXBlID0gdmFsdWUudHlwZTtcbiAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmIHR5cGUubGVuZ3RoID09PSAyO1xufVxuZXhwb3J0IGNsYXNzIEludGVycG9sYXRpb25JbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIFwicmZcIiAvKiBpbnRlcnBvbGF0aW9uICovOyB9XG59XG5leHBvcnQgY2xhc3MgUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBtb2RlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJnXCIgLyogcHJvcGVydHlCaW5kaW5nICovOyB9XG59XG5leHBvcnQgY2xhc3MgSXRlcmF0b3JCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJrXCIgLyogaXRlcmF0b3JCaW5kaW5nICovOyB9XG59XG5leHBvcnQgY2xhc3MgQ2FsbEJpbmRpbmdJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIFwicmhcIiAvKiBjYWxsQmluZGluZyAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIFJlZkJpbmRpbmdJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIFwicmpcIiAvKiByZWZCaW5kaW5nICovOyB9XG59XG5leHBvcnQgY2xhc3MgU2V0UHJvcGVydHlJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRvKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIFwicmVcIiAvKiBzZXRQcm9wZXJ0eSAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlcywgYWxpYXMsIGluc3RydWN0aW9ucywgc2xvdEluZm8pIHtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XG4gICAgICAgIHRoaXMuc2xvdEluZm8gPSBzbG90SW5mbztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJhXCIgLyogaHlkcmF0ZUVsZW1lbnQgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBIeWRyYXRlQXR0cmlidXRlSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlcywgYWxpYXMsIGluc3RydWN0aW9ucykge1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJiXCIgLyogaHlkcmF0ZUF0dHJpYnV0ZSAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIEh5ZHJhdGVUZW1wbGF0ZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlZiwgcmVzLCBhbGlhcywgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJjXCIgLyogaHlkcmF0ZVRlbXBsYXRlQ29udHJvbGxlciAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIEh5ZHJhdGVMZXRFbGVtZW50SW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGluc3RydWN0aW9ucywgdG9CaW5kaW5nQ29udGV4dCkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucztcbiAgICAgICAgdGhpcy50b0JpbmRpbmdDb250ZXh0ID0gdG9CaW5kaW5nQ29udGV4dDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJkXCIgLyogaHlkcmF0ZUxldEVsZW1lbnQgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBMZXRCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcInJpXCIgLyogbGV0QmluZGluZyAqLzsgfVxufVxuZXhwb3J0IGNsYXNzIFRleHRCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb20pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcImhhXCIgLyogdGV4dEJpbmRpbmcgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBMaXN0ZW5lckJpbmRpbmdJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHByZXZlbnREZWZhdWx0LCBzdHJhdGVneSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIFwiaGJcIiAvKiBsaXN0ZW5lckJpbmRpbmcgKi87IH1cbn1cbmV4cG9ydCBjbGFzcyBTdHlsZVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gXCJoZFwiIC8qIHN0eWxlUHJvcGVydHlCaW5kaW5nICovOyB9XG59XG5leHBvcnQgY2xhc3MgU2V0QXR0cmlidXRlSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0bykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcImhlXCIgLyogc2V0QXR0cmlidXRlICovOyB9XG59XG5leHBvcnQgY2xhc3MgU2V0Q2xhc3NBdHRyaWJ1dGVJbnN0cnVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSBcImhmXCIgLyogc2V0Q2xhc3NBdHRyaWJ1dGUgKi87XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNldFN0eWxlQXR0cmlidXRlSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJoZ1wiIC8qIHNldFN0eWxlQXR0cmlidXRlICovO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIGBhdHRyYCBhbmQgYHRvYCBoYXZlIHRoZSBzYW1lIHZhbHVlIG9uIGEgbm9ybWFsIGF0dHJpYnV0ZVxuICAgICAqIFdpbGwgYmUgZGlmZmVyZW50IG9uIGBjbGFzc2AgYW5kIGBzdHlsZWBcbiAgICAgKiBvbiBgY2xhc3NgOiBhdHRyID0gYGNsYXNzYCAoZnJvbSBiaW5kaW5nIGNvbW1hbmQpLCB0byA9IGF0dHJpYnV0ZSBuYW1lXG4gICAgICogb24gYHN0eWxlYDogYXR0ciA9IGBzdHlsZWAgKGZyb20gYmluZGluZyBjb21tYW5kKSwgdG8gPSBhdHRyaWJ1dGUgbmFtZVxuICAgICAqL1xuICAgIGF0dHIsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBcImhjXCIgLyogYXR0cmlidXRlQmluZGluZyAqLzsgfVxufVxuZXhwb3J0IGNvbnN0IElUZW1wbGF0ZUNvbXBpbGVyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJVGVtcGxhdGVDb21waWxlcicpO1xuZXhwb3J0IGNvbnN0IElSZW5kZXJlciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVJlbmRlcmVyJyk7XG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyZXIoaW5zdHJ1Y3Rpb25UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQpIHtcbiAgICAgICAgLy8gd3JhcCB0aGUgY29uc3RydWN0b3IgdG8gc2V0IHRoZSBpbnN0cnVjdGlvblR5cGUgdG8gdGhlIGluc3RhbmNlIChmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIHRoYW4gd2hlbiBzZXQgb24gdGhlIHByb3RvdHlwZSlcbiAgICAgICAgY29uc3QgZGVjb3JhdGVkVGFyZ2V0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IHRhcmdldCguLi5hcmdzKTtcbiAgICAgICAgICAgIGluc3RhbmNlLmluc3RydWN0aW9uVHlwZSA9IGluc3RydWN0aW9uVHlwZTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHJlZ2lzdGVyIHRoZSBkZWNvcmF0ZWQgY29uc3RydWN0b3Igd2l0aCBESVxuICAgICAgICBkZWNvcmF0ZWRUYXJnZXQucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgICAgIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oSVJlbmRlcmVyLCBkZWNvcmF0ZWRUYXJnZXQpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNvcHkgb3ZlciBhbnkgbWV0YWRhdGEgc3VjaCBhcyBhbm5vdGF0aW9ucyAoc2V0IGJ5IHByZWNlZGluZyBkZWNvcmF0b3JzKSBhcyB3ZWxsIGFzIHN0YXRpYyBwcm9wZXJ0aWVzIHNldCBieSB0aGUgdXNlclxuICAgICAgICAvLyBhbHNvIGNvcHkgdGhlIG5hbWUsIHRvIGJlIGxlc3MgY29uZnVzaW5nIHRvIHVzZXJzIChzbyB0aGV5IGNhbiBzdGlsbCB1c2UgY29uc3RydWN0b3IubmFtZSBmb3Igd2hhdGV2ZXIgcmVhc29uKVxuICAgICAgICAvLyB0aGUgbGVuZ3RoIChudW1iZXIgb2YgY3RvciBhcmd1bWVudHMpIGlzIGNvcGllZCBmb3IgdGhlIHNhbWUgcmVhc29uXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhS2V5cyA9IE1ldGFkYXRhLmdldE93bktleXModGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgbWV0YWRhdGFLZXlzKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoa2V5LCBNZXRhZGF0YS5nZXRPd24oa2V5LCB0YXJnZXQpLCBkZWNvcmF0ZWRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG93blByb3BlcnRpZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpO1xuICAgICAgICBPYmplY3Qua2V5cyhvd25Qcm9wZXJ0aWVzKS5maWx0ZXIocHJvcCA9PiBwcm9wICE9PSAncHJvdG90eXBlJykuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZGVjb3JhdGVkVGFyZ2V0LCBwcm9wLCBvd25Qcm9wZXJ0aWVzW3Byb3BdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWNvcmF0ZWRUYXJnZXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUV4cHJlc3Npb24ocGFyc2VyLCBzcmNPckV4cHIsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBzcmNPckV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2Uoc3JjT3JFeHByLCBiaW5kaW5nVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBzcmNPckV4cHI7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXQocG90ZW50aWFsVGFyZ2V0KSB7XG4gICAgaWYgKHBvdGVudGlhbFRhcmdldC52aWV3TW9kZWwgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcG90ZW50aWFsVGFyZ2V0LnZpZXdNb2RlbDtcbiAgICB9XG4gICAgcmV0dXJuIHBvdGVudGlhbFRhcmdldDtcbn1cbmZ1bmN0aW9uIGdldFJlZlRhcmdldChyZWZIb3N0LCByZWZUYXJnZXROYW1lKSB7XG4gICAgaWYgKHJlZlRhcmdldE5hbWUgPT09ICdlbGVtZW50Jykge1xuICAgICAgICByZXR1cm4gcmVmSG9zdDtcbiAgICB9XG4gICAgc3dpdGNoIChyZWZUYXJnZXROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2NvbnRyb2xsZXInOlxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyBpdCBzdXBwb3J0cyByZXR1cm5pbmcgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tRWxlbWVudC5mb3IocmVmSG9zdCk7XG4gICAgICAgIGNhc2UgJ3ZpZXcnOlxuICAgICAgICAgICAgLy8gdG9kbzogcmV0dXJucyBub2RlIHNlcXVlbmNlcyBmb3IgZnVuP1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIEFQSScpO1xuICAgICAgICBjYXNlICd2aWV3LW1vZGVsJzpcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaXQgc3VwcG9ydHMgcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbUVsZW1lbnQuZm9yKHJlZkhvc3QpLnZpZXdNb2RlbDtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgY2FDb250cm9sbGVyID0gQ3VzdG9tQXR0cmlidXRlLmZvcihyZWZIb3N0LCByZWZUYXJnZXROYW1lKTtcbiAgICAgICAgICAgIGlmIChjYUNvbnRyb2xsZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYUNvbnRyb2xsZXIudmlld01vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2VDb250cm9sbGVyID0gQ3VzdG9tRWxlbWVudC5mb3IocmVmSG9zdCwgeyBuYW1lOiByZWZUYXJnZXROYW1lIH0pO1xuICAgICAgICAgICAgaWYgKGNlQ29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gcmVmZXJlbmNlIFwiJHtyZWZUYXJnZXROYW1lfVwiLCBidXQgaXQgd2FzIG5vdCBmb3VuZCBhbW9uZ3N0IHRoZSB0YXJnZXQncyBBUEkuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2VDb250cm9sbGVyLnZpZXdNb2RlbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBTZXRQcm9wZXJ0eVJlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBTZXRQcm9wZXJ0eVJlbmRlcmVyIHtcbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZ2V0VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmIChvYmouJG9ic2VydmVycyAhPT0gdm9pZCAwICYmIG9iai4kb2JzZXJ2ZXJzW2luc3RydWN0aW9uLnRvXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvYmouJG9ic2VydmVyc1tpbnN0cnVjdGlvbi50b10uc2V0VmFsdWUoaW5zdHJ1Y3Rpb24udmFsdWUsIDMyIC8qIGZyb21CaW5kICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ialtpbnN0cnVjdGlvbi50b10gPSBpbnN0cnVjdGlvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5TZXRQcm9wZXJ0eVJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJyZVwiIC8qIHNldFByb3BlcnR5ICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbl0sIFNldFByb3BlcnR5UmVuZGVyZXIpO1xuZXhwb3J0IHsgU2V0UHJvcGVydHlSZW5kZXJlciB9O1xubGV0IEN1c3RvbUVsZW1lbnRSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgQ3VzdG9tRWxlbWVudFJlbmRlcmVyIHtcbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgbGV0IHZpZXdGYWN0b3J5O1xuICAgICAgICBjb25zdCBzbG90SW5mbyA9IGluc3RydWN0aW9uLnNsb3RJbmZvO1xuICAgICAgICBpZiAoc2xvdEluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3Rpb25DdHggPSBzbG90SW5mby5wcm9qZWN0aW9uQ29udGV4dDtcbiAgICAgICAgICAgIHZpZXdGYWN0b3J5ID0gZ2V0UmVuZGVyQ29udGV4dChwcm9qZWN0aW9uQ3R4LmNvbnRlbnQsIGNvbnRleHQpLmdldFZpZXdGYWN0b3J5KHZvaWQgMCwgc2xvdEluZm8udHlwZSwgcHJvamVjdGlvbkN0eC5zY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IGNvbnRleHQuZ2V0Q29tcG9uZW50RmFjdG9yeShcbiAgICAgICAgLyogcGFyZW50Q29udHJvbGxlciAqLyBjb250cm9sbGVyLCBcbiAgICAgICAgLyogaG9zdCAgICAgICAgICAgICAqLyB0YXJnZXQsIFxuICAgICAgICAvKiBpbnN0cnVjdGlvbiAgICAgICovIGluc3RydWN0aW9uLCBcbiAgICAgICAgLyogdmlld0ZhY3RvcnkgICAgICAqLyB2aWV3RmFjdG9yeSwgXG4gICAgICAgIC8qIGxvY2F0aW9uICAgICAgICAgKi8gdGFyZ2V0KTtcbiAgICAgICAgY29uc3Qga2V5ID0gQ3VzdG9tRWxlbWVudC5rZXlGcm9tKGluc3RydWN0aW9uLnJlcyk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGZhY3RvcnkuY3JlYXRlQ29tcG9uZW50KGtleSk7XG4gICAgICAgIGNvbnN0IGNoaWxkQ29udHJvbGxlciA9IENvbnRyb2xsZXIuZm9yQ3VzdG9tRWxlbWVudChcbiAgICAgICAgLyogcm9vdCAgICAgICAgICAgICAgICAqLyBjb250cm9sbGVyLnJvb3QsIFxuICAgICAgICAvKiBjb250YWluZXIgICAgICAgICAgICovIGNvbnRleHQsIFxuICAgICAgICAvKiB2aWV3TW9kZWwgICAgICAgICAgICovIGNvbXBvbmVudCwgXG4gICAgICAgIC8qIGhvc3QgICAgICAgICAgICAgICAgKi8gdGFyZ2V0LCBcbiAgICAgICAgLyogdGFyZ2V0ZWRQcm9qZWN0aW9ucyAqLyBjb250ZXh0LmdldFByb2plY3Rpb25Gb3IoaW5zdHJ1Y3Rpb24pLCBcbiAgICAgICAgLyogZmxhZ3MgICAgICAgICAgICAgICAqLyBmbGFncyk7XG4gICAgICAgIGZsYWdzID0gY2hpbGRDb250cm9sbGVyLmZsYWdzO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoa2V5LCBjaGlsZENvbnRyb2xsZXIsIHRhcmdldCk7XG4gICAgICAgIGNvbnRleHQucmVuZGVyQ2hpbGRyZW4oXG4gICAgICAgIC8qIGZsYWdzICAgICAgICAqLyBmbGFncywgXG4gICAgICAgIC8qIGluc3RydWN0aW9ucyAqLyBpbnN0cnVjdGlvbi5pbnN0cnVjdGlvbnMsIFxuICAgICAgICAvKiBjb250cm9sbGVyICAgKi8gY29udHJvbGxlciwgXG4gICAgICAgIC8qIHRhcmdldCAgICAgICAqLyBjaGlsZENvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLmFkZENvbnRyb2xsZXIoY2hpbGRDb250cm9sbGVyKTtcbiAgICAgICAgZmFjdG9yeS5kaXNwb3NlKCk7XG4gICAgfVxufTtcbkN1c3RvbUVsZW1lbnRSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwicmFcIiAvKiBoeWRyYXRlRWxlbWVudCAqLylcbiAgICAvKiogQGludGVybmFsICovXG5dLCBDdXN0b21FbGVtZW50UmVuZGVyZXIpO1xuZXhwb3J0IHsgQ3VzdG9tRWxlbWVudFJlbmRlcmVyIH07XG5sZXQgQ3VzdG9tQXR0cmlidXRlUmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIEN1c3RvbUF0dHJpYnV0ZVJlbmRlcmVyIHtcbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IGNvbnRleHQuZ2V0Q29tcG9uZW50RmFjdG9yeShcbiAgICAgICAgLyogcGFyZW50Q29udHJvbGxlciAqLyBjb250cm9sbGVyLCBcbiAgICAgICAgLyogaG9zdCAgICAgICAgICAgICAqLyB0YXJnZXQsIFxuICAgICAgICAvKiBpbnN0cnVjdGlvbiAgICAgICovIGluc3RydWN0aW9uLCBcbiAgICAgICAgLyogdmlld0ZhY3RvcnkgICAgICAqLyB2b2lkIDAsIFxuICAgICAgICAvKiBsb2NhdGlvbiAgICAgICAgICovIHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IGtleSA9IEN1c3RvbUF0dHJpYnV0ZS5rZXlGcm9tKGluc3RydWN0aW9uLnJlcyk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGZhY3RvcnkuY3JlYXRlQ29tcG9uZW50KGtleSk7XG4gICAgICAgIGNvbnN0IGNoaWxkQ29udHJvbGxlciA9IENvbnRyb2xsZXIuZm9yQ3VzdG9tQXR0cmlidXRlKFxuICAgICAgICAvKiByb290ICAgICAgKi8gY29udHJvbGxlci5yb290LCBcbiAgICAgICAgLyogY29udGFpbmVyICovIGNvbnRleHQsIFxuICAgICAgICAvKiB2aWV3TW9kZWwgKi8gY29tcG9uZW50LCBcbiAgICAgICAgLyogaG9zdCAgICAgICovIHRhcmdldCwgXG4gICAgICAgIC8qIGZsYWdzICAgICAqLyBmbGFncyk7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShrZXksIGNoaWxkQ29udHJvbGxlciwgdGFyZ2V0KTtcbiAgICAgICAgY29udGV4dC5yZW5kZXJDaGlsZHJlbihcbiAgICAgICAgLyogZmxhZ3MgICAgICAgICovIGZsYWdzLCBcbiAgICAgICAgLyogaW5zdHJ1Y3Rpb25zICovIGluc3RydWN0aW9uLmluc3RydWN0aW9ucywgXG4gICAgICAgIC8qIGNvbnRyb2xsZXIgICAqLyBjb250cm9sbGVyLCBcbiAgICAgICAgLyogdGFyZ2V0ICAgICAgICovIGNoaWxkQ29udHJvbGxlcik7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQ29udHJvbGxlcihjaGlsZENvbnRyb2xsZXIpO1xuICAgICAgICBmYWN0b3J5LmRpc3Bvc2UoKTtcbiAgICB9XG59O1xuQ3VzdG9tQXR0cmlidXRlUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcInJiXCIgLyogaHlkcmF0ZUF0dHJpYnV0ZSAqLylcbiAgICAvKiogQGludGVybmFsICovXG5dLCBDdXN0b21BdHRyaWJ1dGVSZW5kZXJlcik7XG5leHBvcnQgeyBDdXN0b21BdHRyaWJ1dGVSZW5kZXJlciB9O1xubGV0IFRlbXBsYXRlQ29udHJvbGxlclJlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlciB7XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHZpZXdGYWN0b3J5ID0gZ2V0UmVuZGVyQ29udGV4dChpbnN0cnVjdGlvbi5kZWYsIGNvbnRleHQpLmdldFZpZXdGYWN0b3J5KCk7XG4gICAgICAgIGNvbnN0IHJlbmRlckxvY2F0aW9uID0gY29udmVydFRvUmVuZGVyTG9jYXRpb24odGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50RmFjdG9yeSA9IGNvbnRleHQuZ2V0Q29tcG9uZW50RmFjdG9yeShcbiAgICAgICAgLyogcGFyZW50Q29udHJvbGxlciAqLyBjb250cm9sbGVyLCBcbiAgICAgICAgLyogaG9zdCAgICAgICAgICAgICAqLyB0YXJnZXQsIFxuICAgICAgICAvKiBpbnN0cnVjdGlvbiAgICAgICovIGluc3RydWN0aW9uLCBcbiAgICAgICAgLyogdmlld0ZhY3RvcnkgICAgICAqLyB2aWV3RmFjdG9yeSwgXG4gICAgICAgIC8qIGxvY2F0aW9uICAgICAgICAgKi8gcmVuZGVyTG9jYXRpb24pO1xuICAgICAgICBjb25zdCBrZXkgPSBDdXN0b21BdHRyaWJ1dGUua2V5RnJvbShpbnN0cnVjdGlvbi5yZXMpO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRGYWN0b3J5LmNyZWF0ZUNvbXBvbmVudChrZXkpO1xuICAgICAgICBjb25zdCBjaGlsZENvbnRyb2xsZXIgPSBDb250cm9sbGVyLmZvckN1c3RvbUF0dHJpYnV0ZShcbiAgICAgICAgLyogcm9vdCAgICAgICovIGNvbnRyb2xsZXIucm9vdCwgXG4gICAgICAgIC8qIGNvbnRhaW5lciAqLyBjb250ZXh0LCBcbiAgICAgICAgLyogdmlld01vZGVsICovIGNvbXBvbmVudCwgXG4gICAgICAgIC8qIGhvc3QgICAgICAqLyB0YXJnZXQsIFxuICAgICAgICAvKiBmbGFncyAgICAgKi8gZmxhZ3MpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoa2V5LCBjaGlsZENvbnRyb2xsZXIsIHJlbmRlckxvY2F0aW9uKTtcbiAgICAgICAgY29tcG9uZW50Lmxpbms/LihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgY2hpbGRDb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKTtcbiAgICAgICAgY29udGV4dC5yZW5kZXJDaGlsZHJlbihcbiAgICAgICAgLyogZmxhZ3MgICAgICAgICovIGZsYWdzLCBcbiAgICAgICAgLyogaW5zdHJ1Y3Rpb25zICovIGluc3RydWN0aW9uLmluc3RydWN0aW9ucywgXG4gICAgICAgIC8qIGNvbnRyb2xsZXIgICAqLyBjb250cm9sbGVyLCBcbiAgICAgICAgLyogdGFyZ2V0ICAgICAgICovIGNoaWxkQ29udHJvbGxlcik7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQ29udHJvbGxlcihjaGlsZENvbnRyb2xsZXIpO1xuICAgICAgICBjb21wb25lbnRGYWN0b3J5LmRpc3Bvc2UoKTtcbiAgICB9XG59O1xuVGVtcGxhdGVDb250cm9sbGVyUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcInJjXCIgLyogaHlkcmF0ZVRlbXBsYXRlQ29udHJvbGxlciAqLylcbiAgICAvKiogQGludGVybmFsICovXG5dLCBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlcik7XG5leHBvcnQgeyBUZW1wbGF0ZUNvbnRyb2xsZXJSZW5kZXJlciB9O1xubGV0IExldEVsZW1lbnRSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgTGV0RWxlbWVudFJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIGNvbnN0IGNoaWxkSW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb25zO1xuICAgICAgICBjb25zdCB0b0JpbmRpbmdDb250ZXh0ID0gaW5zdHJ1Y3Rpb24udG9CaW5kaW5nQ29udGV4dDtcbiAgICAgICAgbGV0IGNoaWxkSW5zdHJ1Y3Rpb247XG4gICAgICAgIGxldCBleHByO1xuICAgICAgICBsZXQgYmluZGluZztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2hpbGRJbnN0cnVjdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgY2hpbGRJbnN0cnVjdGlvbiA9IGNoaWxkSW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICAgICAgZXhwciA9IGVuc3VyZUV4cHJlc3Npb24odGhpcy5wYXJzZXIsIGNoaWxkSW5zdHJ1Y3Rpb24uZnJvbSwgNDggLyogSXNQcm9wZXJ0eUNvbW1hbmQgKi8pO1xuICAgICAgICAgICAgYmluZGluZyA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKG5ldyBMZXRCaW5kaW5nKGV4cHIsIGNoaWxkSW5zdHJ1Y3Rpb24udG8sIHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCBjb250ZXh0LCB0b0JpbmRpbmdDb250ZXh0KSwgZXhwciwgY29udGV4dCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuTGV0RWxlbWVudFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJyZFwiIC8qIGh5ZHJhdGVMZXRFbGVtZW50ICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJT2JzZXJ2ZXJMb2NhdG9yKVxuXSwgTGV0RWxlbWVudFJlbmRlcmVyKTtcbmV4cG9ydCB7IExldEVsZW1lbnRSZW5kZXJlciB9O1xubGV0IENhbGxCaW5kaW5nUmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIENhbGxCaW5kaW5nUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgb2JzZXJ2ZXJMb2NhdG9yKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICB9XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBlbnN1cmVFeHByZXNzaW9uKHRoaXMucGFyc2VyLCBpbnN0cnVjdGlvbi5mcm9tLCAxNTMgLyogQ2FsbENvbW1hbmQgKi8pO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gYXBwbHlCaW5kaW5nQmVoYXZpb3IobmV3IENhbGxCaW5kaW5nKGV4cHIsIGdldFRhcmdldCh0YXJnZXQpLCBpbnN0cnVjdGlvbi50bywgdGhpcy5vYnNlcnZlckxvY2F0b3IsIGNvbnRleHQpLCBleHByLCBjb250ZXh0KTtcbiAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbn07XG5DYWxsQmluZGluZ1JlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJyaFwiIC8qIGNhbGxCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJT2JzZXJ2ZXJMb2NhdG9yKVxuXSwgQ2FsbEJpbmRpbmdSZW5kZXJlcik7XG5leHBvcnQgeyBDYWxsQmluZGluZ1JlbmRlcmVyIH07XG5sZXQgUmVmQmluZGluZ1JlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBSZWZCaW5kaW5nUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBlbnN1cmVFeHByZXNzaW9uKHRoaXMucGFyc2VyLCBpbnN0cnVjdGlvbi5mcm9tLCA1Mzc2IC8qIElzUmVmICovKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKG5ldyBSZWZCaW5kaW5nKGV4cHIsIGdldFJlZlRhcmdldCh0YXJnZXQsIGluc3RydWN0aW9uLnRvKSwgY29udGV4dCksIGV4cHIsIGNvbnRleHQpO1xuICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgfVxufTtcblJlZkJpbmRpbmdSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwicmpcIiAvKiByZWZCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlcilcbl0sIFJlZkJpbmRpbmdSZW5kZXJlcik7XG5leHBvcnQgeyBSZWZCaW5kaW5nUmVuZGVyZXIgfTtcbmxldCBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvciwgcGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IG5ldyBJbnRlcnBvbGF0aW9uQmluZGluZyh0aGlzLm9ic2VydmVyTG9jYXRvciwgZXhwciwgZ2V0VGFyZ2V0KHRhcmdldCksIGluc3RydWN0aW9uLnRvLCBCaW5kaW5nTW9kZS50b1ZpZXcsIGNvbnRleHQsIHRoaXMucGxhdGZvcm0uZG9tV3JpdGVRdWV1ZSk7XG4gICAgICAgIGNvbnN0IHBhcnRCaW5kaW5ncyA9IGJpbmRpbmcucGFydEJpbmRpbmdzO1xuICAgICAgICBsZXQgcGFydEJpbmRpbmc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRCaW5kaW5ncy5sZW5ndGg7IGlpID4gaTsgKytpKSB7XG4gICAgICAgICAgICBwYXJ0QmluZGluZyA9IHBhcnRCaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIHBhcnRCaW5kaW5nc1tpXSA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKHBhcnRCaW5kaW5nLCBwYXJ0QmluZGluZy5zb3VyY2VFeHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgfVxufTtcbkludGVycG9sYXRpb25CaW5kaW5nUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcInJmXCIgLyogaW50ZXJwb2xhdGlvbiAqLylcbiAgICAvKiogQGludGVybmFsICovXG4gICAgLFxuICAgIF9fcGFyYW0oMCwgSUV4cHJlc3Npb25QYXJzZXIpLFxuICAgIF9fcGFyYW0oMSwgSU9ic2VydmVyTG9jYXRvciksXG4gICAgX19wYXJhbSgyLCBJUGxhdGZvcm0pXG5dLCBJbnRlcnBvbGF0aW9uQmluZGluZ1JlbmRlcmVyKTtcbmV4cG9ydCB7IEludGVycG9sYXRpb25CaW5kaW5nUmVuZGVyZXIgfTtcbmxldCBQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgb2JzZXJ2ZXJMb2NhdG9yLCBwbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICB9XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBlbnN1cmVFeHByZXNzaW9uKHRoaXMucGFyc2VyLCBpbnN0cnVjdGlvbi5mcm9tLCA0OCAvKiBJc1Byb3BlcnR5Q29tbWFuZCAqLyB8IGluc3RydWN0aW9uLm1vZGUpO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gYXBwbHlCaW5kaW5nQmVoYXZpb3IobmV3IFByb3BlcnR5QmluZGluZyhleHByLCBnZXRUYXJnZXQodGFyZ2V0KSwgaW5zdHJ1Y3Rpb24udG8sIGluc3RydWN0aW9uLm1vZGUsIHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCBjb250ZXh0LCB0aGlzLnBsYXRmb3JtLmRvbVdyaXRlUXVldWUpLCBleHByLCBjb250ZXh0KTtcbiAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbn07XG5Qcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwicmdcIiAvKiBwcm9wZXJ0eUJpbmRpbmcgKi8pXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICxcbiAgICBfX3BhcmFtKDAsIElFeHByZXNzaW9uUGFyc2VyKSxcbiAgICBfX3BhcmFtKDEsIElPYnNlcnZlckxvY2F0b3IpLFxuICAgIF9fcGFyYW0oMiwgSVBsYXRmb3JtKVxuXSwgUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIpO1xuZXhwb3J0IHsgUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIgfTtcbmxldCBJdGVyYXRvckJpbmRpbmdSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgSXRlcmF0b3JCaW5kaW5nUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgb2JzZXJ2ZXJMb2NhdG9yLCBwbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICB9XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBlbnN1cmVFeHByZXNzaW9uKHRoaXMucGFyc2VyLCBpbnN0cnVjdGlvbi5mcm9tLCA1MzkgLyogRm9yQ29tbWFuZCAqLyk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBhcHBseUJpbmRpbmdCZWhhdmlvcihuZXcgUHJvcGVydHlCaW5kaW5nKGV4cHIsIGdldFRhcmdldCh0YXJnZXQpLCBpbnN0cnVjdGlvbi50bywgQmluZGluZ01vZGUudG9WaWV3LCB0aGlzLm9ic2VydmVyTG9jYXRvciwgY29udGV4dCwgdGhpcy5wbGF0Zm9ybS5kb21Xcml0ZVF1ZXVlKSwgZXhwciwgY29udGV4dCk7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICB9XG59O1xuSXRlcmF0b3JCaW5kaW5nUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcInJrXCIgLyogaXRlcmF0b3JCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJT2JzZXJ2ZXJMb2NhdG9yKSxcbiAgICBfX3BhcmFtKDIsIElQbGF0Zm9ybSlcbl0sIEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyKTtcbmV4cG9ydCB7IEl0ZXJhdG9yQmluZGluZ1JlbmRlcmVyIH07XG5sZXQgYmVoYXZpb3JFeHByZXNzaW9uSW5kZXggPSAwO1xuY29uc3QgYmVoYXZpb3JFeHByZXNzaW9ucyA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QmluZGluZ0JlaGF2aW9yKGJpbmRpbmcsIGV4cHJlc3Npb24sIGxvY2F0b3IpIHtcbiAgICB3aGlsZSAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEJpbmRpbmdCZWhhdmlvckV4cHJlc3Npb24pIHtcbiAgICAgICAgYmVoYXZpb3JFeHByZXNzaW9uc1tiZWhhdmlvckV4cHJlc3Npb25JbmRleCsrXSA9IGV4cHJlc3Npb247XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLmV4cHJlc3Npb247XG4gICAgfVxuICAgIHdoaWxlIChiZWhhdmlvckV4cHJlc3Npb25JbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgYmVoYXZpb3JFeHByZXNzaW9uID0gYmVoYXZpb3JFeHByZXNzaW9uc1stLWJlaGF2aW9yRXhwcmVzc2lvbkluZGV4XTtcbiAgICAgICAgY29uc3QgYmVoYXZpb3JPckZhY3RvcnkgPSBsb2NhdG9yLmdldChiZWhhdmlvckV4cHJlc3Npb24uYmVoYXZpb3JLZXkpO1xuICAgICAgICBpZiAoYmVoYXZpb3JPckZhY3RvcnkgaW5zdGFuY2VvZiBCaW5kaW5nQmVoYXZpb3JGYWN0b3J5KSB7XG4gICAgICAgICAgICBiaW5kaW5nID0gYmVoYXZpb3JPckZhY3RvcnkuY29uc3RydWN0KGJpbmRpbmcsIGJlaGF2aW9yRXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmVoYXZpb3JFeHByZXNzaW9ucy5sZW5ndGggPSAwO1xuICAgIHJldHVybiBiaW5kaW5nO1xufVxubGV0IFRleHRCaW5kaW5nUmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFRleHRCaW5kaW5nUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgb2JzZXJ2ZXJMb2NhdG9yLCBwbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICB9XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0YXJnZXQubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdBVS1NJykge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cHIgPSBlbnN1cmVFeHByZXNzaW9uKHRoaXMucGFyc2VyLCBpbnN0cnVjdGlvbi5mcm9tLCAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gbmV3IEludGVycG9sYXRpb25CaW5kaW5nKHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCBleHByLCBuZXh0LCAndGV4dENvbnRlbnQnLCBCaW5kaW5nTW9kZS50b1ZpZXcsIGNvbnRleHQsIHRoaXMucGxhdGZvcm0uZG9tV3JpdGVRdWV1ZSk7XG4gICAgICAgIGNvbnN0IHBhcnRCaW5kaW5ncyA9IGJpbmRpbmcucGFydEJpbmRpbmdzO1xuICAgICAgICBsZXQgcGFydEJpbmRpbmc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRCaW5kaW5ncy5sZW5ndGg7IGlpID4gaTsgKytpKSB7XG4gICAgICAgICAgICBwYXJ0QmluZGluZyA9IHBhcnRCaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIHBhcnRCaW5kaW5nc1tpXSA9IGFwcGx5QmluZGluZ0JlaGF2aW9yKHBhcnRCaW5kaW5nLCBwYXJ0QmluZGluZy5zb3VyY2VFeHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgfVxufTtcblRleHRCaW5kaW5nUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcImhhXCIgLyogdGV4dEJpbmRpbmcgKi8pXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICxcbiAgICBfX3BhcmFtKDAsIElFeHByZXNzaW9uUGFyc2VyKSxcbiAgICBfX3BhcmFtKDEsIElPYnNlcnZlckxvY2F0b3IpLFxuICAgIF9fcGFyYW0oMiwgSVBsYXRmb3JtKVxuXSwgVGV4dEJpbmRpbmdSZW5kZXJlcik7XG5leHBvcnQgeyBUZXh0QmluZGluZ1JlbmRlcmVyIH07XG5sZXQgTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXIgPSBcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIExpc3RlbmVyQmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIGV2ZW50RGVsZWdhdG9yKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV2ZW50RGVsZWdhdG9yID0gZXZlbnREZWxlZ2F0b3I7XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgODAgLyogSXNFdmVudENvbW1hbmQgKi8gfCAoaW5zdHJ1Y3Rpb24uc3RyYXRlZ3kgKyA2IC8qIERlbGVnYXRpb25TdHJhdGVneURlbHRhICovKSk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBhcHBseUJpbmRpbmdCZWhhdmlvcihuZXcgTGlzdGVuZXIoY29udGV4dC5wbGF0Zm9ybSwgaW5zdHJ1Y3Rpb24udG8sIGluc3RydWN0aW9uLnN0cmF0ZWd5LCBleHByLCB0YXJnZXQsIGluc3RydWN0aW9uLnByZXZlbnREZWZhdWx0LCB0aGlzLmV2ZW50RGVsZWdhdG9yLCBjb250ZXh0KSwgZXhwciwgY29udGV4dCk7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICB9XG59O1xuTGlzdGVuZXJCaW5kaW5nUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcImhiXCIgLyogbGlzdGVuZXJCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJRXZlbnREZWxlZ2F0b3IpXG5dLCBMaXN0ZW5lckJpbmRpbmdSZW5kZXJlcik7XG5leHBvcnQgeyBMaXN0ZW5lckJpbmRpbmdSZW5kZXJlciB9O1xubGV0IFNldEF0dHJpYnV0ZVJlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBTZXRBdHRyaWJ1dGVSZW5kZXJlciB7XG4gICAgcmVuZGVyKGZsYWdzLCBjb250ZXh0LCBjb250cm9sbGVyLCB0YXJnZXQsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoaW5zdHJ1Y3Rpb24udG8sIGluc3RydWN0aW9uLnZhbHVlKTtcbiAgICB9XG59O1xuU2V0QXR0cmlidXRlUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcImhlXCIgLyogc2V0QXR0cmlidXRlICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbl0sIFNldEF0dHJpYnV0ZVJlbmRlcmVyKTtcbmV4cG9ydCB7IFNldEF0dHJpYnV0ZVJlbmRlcmVyIH07XG5sZXQgU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlciA9IGNsYXNzIFNldENsYXNzQXR0cmlidXRlUmVuZGVyZXIge1xuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBhZGRDbGFzc2VzKHRhcmdldC5jbGFzc0xpc3QsIGluc3RydWN0aW9uLnZhbHVlKTtcbiAgICB9XG59O1xuU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgIHJlbmRlcmVyKFwiaGZcIiAvKiBzZXRDbGFzc0F0dHJpYnV0ZSAqLylcbl0sIFNldENsYXNzQXR0cmlidXRlUmVuZGVyZXIpO1xuZXhwb3J0IHsgU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlciB9O1xubGV0IFNldFN0eWxlQXR0cmlidXRlUmVuZGVyZXIgPSBjbGFzcyBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyIHtcbiAgICByZW5kZXIoZmxhZ3MsIGNvbnRleHQsIGNvbnRyb2xsZXIsIHRhcmdldCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gaW5zdHJ1Y3Rpb24udmFsdWU7XG4gICAgfVxufTtcblNldFN0eWxlQXR0cmlidXRlUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICByZW5kZXJlcihcImhnXCIgLyogc2V0U3R5bGVBdHRyaWJ1dGUgKi8pXG5dLCBTZXRTdHlsZUF0dHJpYnV0ZVJlbmRlcmVyKTtcbmV4cG9ydCB7IFNldFN0eWxlQXR0cmlidXRlUmVuZGVyZXIgfTtcbmxldCBTdHlsZVByb3BlcnR5QmluZGluZ1JlbmRlcmVyID0gXG4vKiogQGludGVybmFsICovXG5jbGFzcyBTdHlsZVByb3BlcnR5QmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvciwgcGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgNDggLyogSXNQcm9wZXJ0eUNvbW1hbmQgKi8gfCBCaW5kaW5nTW9kZS50b1ZpZXcpO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gYXBwbHlCaW5kaW5nQmVoYXZpb3IobmV3IFByb3BlcnR5QmluZGluZyhleHByLCB0YXJnZXQuc3R5bGUsIGluc3RydWN0aW9uLnRvLCBCaW5kaW5nTW9kZS50b1ZpZXcsIHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCBjb250ZXh0LCB0aGlzLnBsYXRmb3JtLmRvbVdyaXRlUXVldWUpLCBleHByLCBjb250ZXh0KTtcbiAgICAgICAgY29udHJvbGxlci5hZGRCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbn07XG5TdHlsZVByb3BlcnR5QmluZGluZ1JlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJoZFwiIC8qIHN0eWxlUHJvcGVydHlCaW5kaW5nICovKVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAsXG4gICAgX19wYXJhbSgwLCBJRXhwcmVzc2lvblBhcnNlciksXG4gICAgX19wYXJhbSgxLCBJT2JzZXJ2ZXJMb2NhdG9yKSxcbiAgICBfX3BhcmFtKDIsIElQbGF0Zm9ybSlcbl0sIFN0eWxlUHJvcGVydHlCaW5kaW5nUmVuZGVyZXIpO1xuZXhwb3J0IHsgU3R5bGVQcm9wZXJ0eUJpbmRpbmdSZW5kZXJlciB9O1xubGV0IEF0dHJpYnV0ZUJpbmRpbmdSZW5kZXJlciA9IFxuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vYnNlcnZlckxvY2F0b3IgPSBvYnNlcnZlckxvY2F0b3I7XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udGV4dCwgY29udHJvbGxlciwgdGFyZ2V0LCBpbnN0cnVjdGlvbikge1xuICAgICAgICBjb25zdCBleHByID0gZW5zdXJlRXhwcmVzc2lvbih0aGlzLnBhcnNlciwgaW5zdHJ1Y3Rpb24uZnJvbSwgNDggLyogSXNQcm9wZXJ0eUNvbW1hbmQgKi8gfCBCaW5kaW5nTW9kZS50b1ZpZXcpO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gYXBwbHlCaW5kaW5nQmVoYXZpb3IobmV3IEF0dHJpYnV0ZUJpbmRpbmcoZXhwciwgdGFyZ2V0LCBpbnN0cnVjdGlvbi5hdHRyIC8qIHRhcmdldEF0dHJpYnV0ZSAqLywgaW5zdHJ1Y3Rpb24udG8gLyogdGFyZ2V0S2V5ICovLCBCaW5kaW5nTW9kZS50b1ZpZXcsIHRoaXMub2JzZXJ2ZXJMb2NhdG9yLCBjb250ZXh0KSwgZXhwciwgY29udGV4dCk7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICB9XG59O1xuQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgcmVuZGVyZXIoXCJoY1wiIC8qIGF0dHJpYnV0ZUJpbmRpbmcgKi8pXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICxcbiAgICBfX3BhcmFtKDAsIElFeHByZXNzaW9uUGFyc2VyKSxcbiAgICBfX3BhcmFtKDEsIElPYnNlcnZlckxvY2F0b3IpXG5dLCBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXIpO1xuZXhwb3J0IHsgQXR0cmlidXRlQmluZGluZ1JlbmRlcmVyIH07XG4vLyBodHRwOi8vanNiZW4uY2gvN241S3RcbmZ1bmN0aW9uIGFkZENsYXNzZXMoY2xhc3NMaXN0LCBjbGFzc05hbWUpIHtcbiAgICBjb25zdCBsZW4gPSBjbGFzc05hbWUubGVuZ3RoO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoY2xhc3NOYW1lLmNoYXJDb2RlQXQoaSkgPT09IDB4MjApIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLnNsaWNlKHN0YXJ0LCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgKyAxID09PSBsZW4pIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLnNsaWNlKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXJlci5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IERJLCBNZXRhZGF0YSwgZW1wdHlBcnJheSwgUHJvdG9jb2wsIFJlZ2lzdHJhdGlvbiwgYWxsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBDaGFyU3BlYyB7XG4gICAgY29uc3RydWN0b3IoY2hhcnMsIHJlcGVhdCwgaXNTeW1ib2wsIGlzSW52ZXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5jaGFycyA9IGNoYXJzO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgdGhpcy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgICAgICB0aGlzLmlzSW52ZXJ0ZWQgPSBpc0ludmVydGVkO1xuICAgICAgICBpZiAoaXNJbnZlcnRlZCkge1xuICAgICAgICAgICAgc3dpdGNoIChjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzID0gdGhpcy5oYXNPZk5vbmVJbnZlcnNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzID0gdGhpcy5oYXNPZlNpbmdsZUludmVyc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzID0gdGhpcy5oYXNPZk11bHRpcGxlSW52ZXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhcyA9IHRoaXMuaGFzT2ZOb25lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzID0gdGhpcy5oYXNPZlNpbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXMgPSB0aGlzLmhhc09mTXVsdGlwbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJzID09PSBvdGhlci5jaGFyc1xuICAgICAgICAgICAgJiYgdGhpcy5yZXBlYXQgPT09IG90aGVyLnJlcGVhdFxuICAgICAgICAgICAgJiYgdGhpcy5pc1N5bWJvbCA9PT0gb3RoZXIuaXNTeW1ib2xcbiAgICAgICAgICAgICYmIHRoaXMuaXNJbnZlcnRlZCA9PT0gb3RoZXIuaXNJbnZlcnRlZDtcbiAgICB9XG4gICAgaGFzT2ZNdWx0aXBsZShjaGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJzLmluY2x1ZGVzKGNoYXIpO1xuICAgIH1cbiAgICBoYXNPZlNpbmdsZShjaGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJzID09PSBjaGFyO1xuICAgIH1cbiAgICBoYXNPZk5vbmUoY2hhcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc09mTXVsdGlwbGVJbnZlcnNlKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNoYXJzLmluY2x1ZGVzKGNoYXIpO1xuICAgIH1cbiAgICBoYXNPZlNpbmdsZUludmVyc2UoY2hhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFycyAhPT0gY2hhcjtcbiAgICB9XG4gICAgaGFzT2ZOb25lSW52ZXJzZShjaGFyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnRlcnByZXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBlbXB0eUFycmF5O1xuICAgICAgICB0aGlzLl9wYXR0ZXJuID0gJyc7XG4gICAgICAgIHRoaXMuY3VycmVudFJlY29yZCA9IHt9O1xuICAgICAgICB0aGlzLnBhcnRzUmVjb3JkID0ge307XG4gICAgfVxuICAgIGdldCBwYXR0ZXJuKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3BhdHRlcm47XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBwYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXR0ZXJuID0gJyc7XG4gICAgICAgICAgICB0aGlzLnBhcnRzID0gZW1wdHlBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGFydHMgPSB0aGlzLnBhcnRzUmVjb3JkW3ZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQocGF0dGVybiwgY2gpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50UmVjb3JkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoY3VycmVudFJlY29yZFtwYXR0ZXJuXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjb3JkW3BhdHRlcm5dID0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjb3JkW3BhdHRlcm5dICs9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHQocGF0dGVybikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRSZWNvcmQgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJyZW50UmVjb3JkW3BhdHRlcm5dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFydHNSZWNvcmQgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocGFydHNSZWNvcmRbcGF0dGVybl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnRzUmVjb3JkW3BhdHRlcm5dID0gW2N1cnJlbnRSZWNvcmRbcGF0dGVybl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydHNSZWNvcmRbcGF0dGVybl0ucHVzaChjdXJyZW50UmVjb3JkW3BhdHRlcm5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRSZWNvcmRbcGF0dGVybl0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJTcGVjLCAuLi5wYXR0ZXJucykge1xuICAgICAgICB0aGlzLmNoYXJTcGVjID0gY2hhclNwZWM7XG4gICAgICAgIHRoaXMubmV4dFN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnR5cGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0VuZHBvaW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucztcbiAgICB9XG4gICAgZ2V0IHBhdHRlcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW5kcG9pbnQgPyB0aGlzLnBhdHRlcm5zWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZmluZENoaWxkKGNoYXJTcGVjKSB7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IG5leHRTdGF0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgY2hpbGQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5leHRTdGF0ZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hhclNwZWMuZXF1YWxzKGNoaWxkLmNoYXJTcGVjKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXBwZW5kKGNoYXJTcGVjLCBwYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0dGVybnMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcGF0dGVybnMuaW5jbHVkZXMocGF0dGVybikpIHtcbiAgICAgICAgICAgIHBhdHRlcm5zLnB1c2gocGF0dGVybik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5maW5kQ2hpbGQoY2hhclNwZWMpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoY2hhclNwZWMsIHBhdHRlcm4pO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGNoYXJTcGVjLnJlcGVhdCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm5leHRTdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmaW5kTWF0Y2hlcyhjaCwgaW50ZXJwcmV0YXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogcmV1c2UgcHJlYWxsb2NhdGVkIGFycmF5c1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZXMgPSB0aGlzLm5leHRTdGF0ZXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IG5leHRTdGF0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgY2hpbGRMZW4gPSAwO1xuICAgICAgICBsZXQgY2hpbGQgPSBudWxsO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY2hpbGQgPSBuZXh0U3RhdGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmNoYXJTcGVjLmhhcyhjaCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkTGVuID0gY2hpbGQucGF0dGVybnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGFyU3BlYy5pc1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaiA8IGNoaWxkTGVuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldGF0aW9uLm5leHQoY2hpbGQucGF0dGVybnNbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaiA8IGNoaWxkTGVuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldGF0aW9uLmFwcGVuZChjaGlsZC5wYXR0ZXJuc1tqXSwgY2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBTdGF0aWNTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHNwZWNzID0gdGhpcy5zcGVjcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKG5ldyBDaGFyU3BlYyh0ZXh0W2ldLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgeyBsZW4sIHNwZWNzIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzcGVjc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgRHluYW1pY1NlZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKHN5bWJvbHMpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gJ1BBUlQnO1xuICAgICAgICB0aGlzLnNwZWMgPSBuZXcgQ2hhclNwZWMoc3ltYm9scywgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBlYWNoQ2hhcihjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnNwZWMpO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBTeW1ib2xTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuc3BlYyA9IG5ldyBDaGFyU3BlYyh0ZXh0LCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBlYWNoQ2hhcihjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnNwZWMpO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBTZWdtZW50VHlwZXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXRpY3MgPSAwO1xuICAgICAgICB0aGlzLmR5bmFtaWNzID0gMDtcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gMDtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgSVN5bnRheEludGVycHJldGVyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJU3ludGF4SW50ZXJwcmV0ZXInLCB4ID0+IHguc2luZ2xldG9uKFN5bnRheEludGVycHJldGVyKSk7XG5leHBvcnQgY2xhc3MgU3ludGF4SW50ZXJwcmV0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJvb3RTdGF0ZSA9IG5ldyBTdGF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5pbml0aWFsU3RhdGVzID0gW3RoaXMucm9vdFN0YXRlXTtcbiAgICB9XG4gICAgYWRkKGRlZk9yRGVmcykge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZk9yRGVmcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlpID0gZGVmT3JEZWZzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGRlZk9yRGVmc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IHRoaXMucm9vdFN0YXRlO1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZPckRlZnM7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBkZWYucGF0dGVybjtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBuZXcgU2VnbWVudFR5cGVzKCk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5wYXJzZShkZWYsIHR5cGVzKTtcbiAgICAgICAgY29uc3QgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChjaCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFN0YXRlLmFwcGVuZChjaCwgcGF0dGVybik7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgc2VnbWVudHNbaV0uZWFjaENoYXIoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRTdGF0ZS50eXBlcyA9IHR5cGVzO1xuICAgICAgICBjdXJyZW50U3RhdGUuaXNFbmRwb2ludCA9IHRydWU7XG4gICAgfVxuICAgIGludGVycHJldChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGludGVycHJldGF0aW9uID0gbmV3IEludGVycHJldGF0aW9uKCk7XG4gICAgICAgIGxldCBzdGF0ZXMgPSB0aGlzLmluaXRpYWxTdGF0ZXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IG5hbWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzdGF0ZXMgPSB0aGlzLmdldE5leHRTdGF0ZXMoc3RhdGVzLCBuYW1lLmNoYXJBdChpKSwgaW50ZXJwcmV0YXRpb24pO1xuICAgICAgICAgICAgaWYgKHN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEuaXNFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIGlmICghYi5pc0VuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlzRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYVR5cGVzID0gYS50eXBlcztcbiAgICAgICAgICAgIGNvbnN0IGJUeXBlcyA9IGIudHlwZXM7XG4gICAgICAgICAgICBpZiAoYVR5cGVzLnN0YXRpY3MgIT09IGJUeXBlcy5zdGF0aWNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJUeXBlcy5zdGF0aWNzIC0gYVR5cGVzLnN0YXRpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVR5cGVzLmR5bmFtaWNzICE9PSBiVHlwZXMuZHluYW1pY3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYlR5cGVzLmR5bmFtaWNzIC0gYVR5cGVzLmR5bmFtaWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFUeXBlcy5zeW1ib2xzICE9PSBiVHlwZXMuc3ltYm9scykge1xuICAgICAgICAgICAgICAgIHJldHVybiBiVHlwZXMuc3ltYm9scyAtIGFUeXBlcy5zeW1ib2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzWzBdO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5jaGFyU3BlYy5pc1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIGludGVycHJldGF0aW9uLm5leHQoc3RhdGUucGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcnByZXRhdGlvbi5wYXR0ZXJuID0gc3RhdGUucGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJwcmV0YXRpb247XG4gICAgfVxuICAgIGdldE5leHRTdGF0ZXMoc3RhdGVzLCBjaCwgaW50ZXJwcmV0YXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogcmV1c2UgcHJlYWxsb2NhdGVkIGFycmF5c1xuICAgICAgICBjb25zdCBuZXh0U3RhdGVzID0gW107XG4gICAgICAgIGxldCBzdGF0ZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGxlbiA9IHN0YXRlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGVzW2ldO1xuICAgICAgICAgICAgbmV4dFN0YXRlcy5wdXNoKC4uLnN0YXRlLmZpbmRNYXRjaGVzKGNoLCBpbnRlcnByZXRhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0U3RhdGVzO1xuICAgIH1cbiAgICBwYXJzZShkZWYsIHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gZGVmLnBhdHRlcm47XG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBjID0gJyc7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gcGF0dGVybi5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoIWRlZi5zeW1ib2xzLmluY2x1ZGVzKGMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnUCcgJiYgcGF0dGVybi5zbGljZShpLCBpICsgNCkgPT09ICdQQVJUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpID0gKGkgKyA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEeW5hbWljU2VnbWVudChkZWYuc3ltYm9scykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKyt0eXBlcy5keW5hbWljcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgIT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YXRpY1NlZ21lbnQocGF0dGVybi5zbGljZShzdGFydCwgaSkpKTtcbiAgICAgICAgICAgICAgICArK3R5cGVzLnN0YXRpY3M7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN5bWJvbFNlZ21lbnQocGF0dGVybi5zbGljZShzdGFydCwgaSArIDEpKSk7XG4gICAgICAgICAgICAgICAgKyt0eXBlcy5zeW1ib2xzO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCAhPT0gaSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YXRpY1NlZ21lbnQocGF0dGVybi5zbGljZShzdGFydCwgaSkpKTtcbiAgICAgICAgICAgICsrdHlwZXMuc3RhdGljcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdHRyU3ludGF4IHtcbiAgICBjb25zdHJ1Y3RvcihyYXdOYW1lLCByYXdWYWx1ZSwgdGFyZ2V0LCBjb21tYW5kKSB7XG4gICAgICAgIHRoaXMucmF3TmFtZSA9IHJhd05hbWU7XG4gICAgICAgIHRoaXMucmF3VmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElBdHRyaWJ1dGVQYXR0ZXJuID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJQXR0cmlidXRlUGF0dGVybicpO1xuZXhwb3J0IGNvbnN0IElBdHRyaWJ1dGVQYXJzZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lBdHRyaWJ1dGVQYXJzZXInLCB4ID0+IHguc2luZ2xldG9uKEF0dHJpYnV0ZVBhcnNlcikpO1xubGV0IEF0dHJpYnV0ZVBhcnNlciA9IGNsYXNzIEF0dHJpYnV0ZVBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoaW50ZXJwcmV0ZXIsIGF0dHJQYXR0ZXJucykge1xuICAgICAgICB0aGlzLmludGVycHJldGVyID0gaW50ZXJwcmV0ZXI7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSB0aGlzLnBhdHRlcm5zID0ge307XG4gICAgICAgIGF0dHJQYXR0ZXJucy5mb3JFYWNoKGF0dHJQYXR0ZXJuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlZnMgPSBBdHRyaWJ1dGVQYXR0ZXJuLmdldFBhdHRlcm5EZWZpbml0aW9ucyhhdHRyUGF0dGVybi5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICBpbnRlcnByZXRlci5hZGQoZGVmcyk7XG4gICAgICAgICAgICBkZWZzLmZvckVhY2goZGVmID0+IHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuc1tkZWYucGF0dGVybl0gPSBhdHRyUGF0dGVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2UobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGludGVycHJldGF0aW9uID0gdGhpcy5jYWNoZVtuYW1lXTtcbiAgICAgICAgaWYgKGludGVycHJldGF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGludGVycHJldGF0aW9uID0gdGhpcy5jYWNoZVtuYW1lXSA9IHRoaXMuaW50ZXJwcmV0ZXIuaW50ZXJwcmV0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBpbnRlcnByZXRhdGlvbi5wYXR0ZXJuO1xuICAgICAgICBpZiAocGF0dGVybiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0dHJTeW50YXgobmFtZSwgdmFsdWUsIG5hbWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0dGVybnNbcGF0dGVybl1bcGF0dGVybl0obmFtZSwgdmFsdWUsIGludGVycHJldGF0aW9uLnBhcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5BdHRyaWJ1dGVQYXJzZXIgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElTeW50YXhJbnRlcnByZXRlciksXG4gICAgX19wYXJhbSgxLCBhbGwoSUF0dHJpYnV0ZVBhdHRlcm4pKVxuXSwgQXR0cmlidXRlUGFyc2VyKTtcbmV4cG9ydCB7IEF0dHJpYnV0ZVBhcnNlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZVBhdHRlcm4oLi4ucGF0dGVybkRlZnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gQXR0cmlidXRlUGF0dGVybi5kZWZpbmUocGF0dGVybkRlZnMsIHRhcmdldCk7XG4gICAgfTtcbn1cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVQYXR0ZXJuUmVzb3VyY2VEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihUeXBlKSB7XG4gICAgICAgIHRoaXMuVHlwZSA9IFR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9ICh2b2lkIDApO1xuICAgIH1cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihJQXR0cmlidXRlUGF0dGVybiwgdGhpcy5UeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBBdHRyaWJ1dGVQYXR0ZXJuID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgbmFtZTogUHJvdG9jb2wucmVzb3VyY2Uua2V5Rm9yKCdhdHRyaWJ1dGUtcGF0dGVybicpLFxuICAgIGRlZmluaXRpb25Bbm5vdGF0aW9uS2V5OiAnYXR0cmlidXRlLXBhdHRlcm4tZGVmaW5pdGlvbnMnLFxuICAgIGRlZmluZShwYXR0ZXJuRGVmcywgVHlwZSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gbmV3IEF0dHJpYnV0ZVBhdHRlcm5SZXNvdXJjZURlZmluaXRpb24oVHlwZSk7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZGVmaW5pdGlvbkFubm90YXRpb25LZXkgfSA9IEF0dHJpYnV0ZVBhdHRlcm47XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShuYW1lLCBkZWZpbml0aW9uLCBUeXBlKTtcbiAgICAgICAgUHJvdG9jb2wucmVzb3VyY2UuYXBwZW5kVG8oVHlwZSwgbmFtZSk7XG4gICAgICAgIFByb3RvY29sLmFubm90YXRpb24uc2V0KFR5cGUsIGRlZmluaXRpb25Bbm5vdGF0aW9uS2V5LCBwYXR0ZXJuRGVmcyk7XG4gICAgICAgIFByb3RvY29sLmFubm90YXRpb24uYXBwZW5kVG8oVHlwZSwgZGVmaW5pdGlvbkFubm90YXRpb25LZXkpO1xuICAgICAgICByZXR1cm4gVHlwZTtcbiAgICB9LFxuICAgIGdldFBhdHRlcm5EZWZpbml0aW9ucyhUeXBlKSB7XG4gICAgICAgIHJldHVybiBQcm90b2NvbC5hbm5vdGF0aW9uLmdldChUeXBlLCBBdHRyaWJ1dGVQYXR0ZXJuLmRlZmluaXRpb25Bbm5vdGF0aW9uS2V5KTtcbiAgICB9XG59KTtcbmxldCBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuID0gY2xhc3MgRG90U2VwYXJhdGVkQXR0cmlidXRlUGF0dGVybiB7XG4gICAgJ1BBUlQuUEFSVCcocmF3TmFtZSwgcmF3VmFsdWUsIHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN5bnRheChyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHNbMF0sIHBhcnRzWzFdKTtcbiAgICB9XG4gICAgJ1BBUlQuUEFSVC5QQVJUJyhyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3ludGF4KHJhd05hbWUsIHJhd1ZhbHVlLCBwYXJ0c1swXSwgcGFydHNbMl0pO1xuICAgIH1cbn07XG5Eb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuID0gX19kZWNvcmF0ZShbXG4gICAgYXR0cmlidXRlUGF0dGVybih7IHBhdHRlcm46ICdQQVJULlBBUlQnLCBzeW1ib2xzOiAnLicgfSwgeyBwYXR0ZXJuOiAnUEFSVC5QQVJULlBBUlQnLCBzeW1ib2xzOiAnLicgfSlcbl0sIERvdFNlcGFyYXRlZEF0dHJpYnV0ZVBhdHRlcm4pO1xuZXhwb3J0IHsgRG90U2VwYXJhdGVkQXR0cmlidXRlUGF0dGVybiB9O1xubGV0IFJlZkF0dHJpYnV0ZVBhdHRlcm4gPSBjbGFzcyBSZWZBdHRyaWJ1dGVQYXR0ZXJuIHtcbiAgICAncmVmJyhyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3ludGF4KHJhd05hbWUsIHJhd1ZhbHVlLCAnZWxlbWVudCcsICdyZWYnKTtcbiAgICB9XG4gICAgJ1BBUlQucmVmJyhyYXdOYW1lLCByYXdWYWx1ZSwgcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3ludGF4KHJhd05hbWUsIHJhd1ZhbHVlLCBwYXJ0c1swXSwgJ3JlZicpO1xuICAgIH1cbn07XG5SZWZBdHRyaWJ1dGVQYXR0ZXJuID0gX19kZWNvcmF0ZShbXG4gICAgYXR0cmlidXRlUGF0dGVybih7IHBhdHRlcm46ICdyZWYnLCBzeW1ib2xzOiAnJyB9LCB7IHBhdHRlcm46ICdQQVJULnJlZicsIHN5bWJvbHM6ICcuJyB9KVxuXSwgUmVmQXR0cmlidXRlUGF0dGVybik7XG5leHBvcnQgeyBSZWZBdHRyaWJ1dGVQYXR0ZXJuIH07XG5sZXQgQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuID0gY2xhc3MgQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuIHtcbiAgICAnOlBBUlQnKHJhd05hbWUsIHJhd1ZhbHVlLCBwYXJ0cykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTeW50YXgocmF3TmFtZSwgcmF3VmFsdWUsIHBhcnRzWzBdLCAnYmluZCcpO1xuICAgIH1cbn07XG5Db2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm4gPSBfX2RlY29yYXRlKFtcbiAgICBhdHRyaWJ1dGVQYXR0ZXJuKHsgcGF0dGVybjogJzpQQVJUJywgc3ltYm9sczogJzonIH0pXG5dLCBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm4pO1xuZXhwb3J0IHsgQ29sb25QcmVmaXhlZEJpbmRBdHRyaWJ1dGVQYXR0ZXJuIH07XG5sZXQgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuID0gY2xhc3MgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuIHtcbiAgICAnQFBBUlQnKHJhd05hbWUsIHJhd1ZhbHVlLCBwYXJ0cykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTeW50YXgocmF3TmFtZSwgcmF3VmFsdWUsIHBhcnRzWzBdLCAndHJpZ2dlcicpO1xuICAgIH1cbn07XG5BdFByZWZpeGVkVHJpZ2dlckF0dHJpYnV0ZVBhdHRlcm4gPSBfX2RlY29yYXRlKFtcbiAgICBhdHRyaWJ1dGVQYXR0ZXJuKHsgcGF0dGVybjogJ0BQQVJUJywgc3ltYm9sczogJ0AnIH0pXG5dLCBBdFByZWZpeGVkVHJpZ2dlckF0dHJpYnV0ZVBhdHRlcm4pO1xuZXhwb3J0IHsgQXRQcmVmaXhlZFRyaWdnZXJBdHRyaWJ1dGVQYXR0ZXJuIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGUtcGF0dGVybi5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBiaW5kaW5nQmVoYXZpb3IgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IGF0dHJBY2Nlc3NvciB9IGZyb20gJy4uLy4uL29ic2VydmF0aW9uL2RhdGEtYXR0cmlidXRlLWFjY2Vzc29yLmpzJztcbmxldCBBdHRyQmluZGluZ0JlaGF2aW9yID0gY2xhc3MgQXR0ckJpbmRpbmdCZWhhdmlvciB7XG4gICAgYmluZChmbGFncywgX3Njb3BlLCBfaG9zdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcudGFyZ2V0T2JzZXJ2ZXIgPSBhdHRyQWNjZXNzb3I7XG4gICAgfVxuICAgIHVuYmluZChmbGFncywgX3Njb3BlLCBfaG9zdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59O1xuQXR0ckJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdCZWhhdmlvcignYXR0cicpXG5dLCBBdHRyQmluZGluZ0JlaGF2aW9yKTtcbmV4cG9ydCB7IEF0dHJCaW5kaW5nQmVoYXZpb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHIuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgYmluZGluZ0JlaGF2aW9yIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlU2VsZkV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgaWYgKHRoaXMudGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZWxmRXZlbnRDYWxsU291cmNlKGV2ZW50KTtcbn1cbmxldCBTZWxmQmluZGluZ0JlaGF2aW9yID0gY2xhc3MgU2VsZkJpbmRpbmdCZWhhdmlvciB7XG4gICAgYmluZChmbGFncywgX3Njb3BlLCBfaG9zdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgIGlmICghYmluZGluZy5jYWxsU291cmNlIHx8ICFiaW5kaW5nLnRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbGYgYmluZGluZyBiZWhhdmlvciBvbmx5IHN1cHBvcnRzIGV2ZW50cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kaW5nLnNlbGZFdmVudENhbGxTb3VyY2UgPSBiaW5kaW5nLmNhbGxTb3VyY2U7XG4gICAgICAgIGJpbmRpbmcuY2FsbFNvdXJjZSA9IGhhbmRsZVNlbGZFdmVudDtcbiAgICB9XG4gICAgdW5iaW5kKGZsYWdzLCBfc2NvcGUsIF9ob3N0U2NvcGUsIGJpbmRpbmcpIHtcbiAgICAgICAgYmluZGluZy5jYWxsU291cmNlID0gYmluZGluZy5zZWxmRXZlbnRDYWxsU291cmNlO1xuICAgICAgICBiaW5kaW5nLnNlbGZFdmVudENhbGxTb3VyY2UgPSBudWxsO1xuICAgIH1cbn07XG5TZWxmQmluZGluZ0JlaGF2aW9yID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0JlaGF2aW9yKCdzZWxmJylcbl0sIFNlbGZCaW5kaW5nQmVoYXZpb3IpO1xuZXhwb3J0IHsgU2VsZkJpbmRpbmdCZWhhdmlvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZi5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IEJpbmRpbmdNb2RlLCBJT2JzZXJ2ZXJMb2NhdG9yLCBiaW5kaW5nQmVoYXZpb3IgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IEV2ZW50U3Vic2NyaWJlciB9IGZyb20gJy4uLy4uL29ic2VydmF0aW9uL2V2ZW50LWRlbGVnYXRvci5qcyc7XG5pbXBvcnQgeyBOb2RlT2JzZXJ2ZXJDb25maWcgfSBmcm9tICcuLi8uLi9vYnNlcnZhdGlvbi9vYnNlcnZlci1sb2NhdG9yLmpzJztcbmxldCBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yID0gY2xhc3MgVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3Iob2JzZXJ2ZXJMb2NhdG9yKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgIH1cbiAgICBiaW5kKGZsYWdzLCBfc2NvcGUsIF9ob3N0U2NvcGUsIGJpbmRpbmcsIC4uLmV2ZW50cykge1xuICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdXBkYXRlVHJpZ2dlciBiaW5kaW5nIGJlaGF2aW9yIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBldmVudCBuYW1lIGFyZ3VtZW50OiBlZyA8aW5wdXQgdmFsdWUuYmluZD1cImZpcnN0TmFtZSAmIHVwZGF0ZVRyaWdnZXI6XFwnYmx1clxcJ1wiPicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5kaW5nLm1vZGUgIT09IEJpbmRpbmdNb2RlLnR3b1dheSAmJiBiaW5kaW5nLm1vZGUgIT09IEJpbmRpbmdNb2RlLmZyb21WaWV3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB1cGRhdGVUcmlnZ2VyIGJpbmRpbmcgYmVoYXZpb3IgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0d28td2F5LyBmcm9tLXZpZXcgYmluZGluZ3Mgb24gaW5wdXQvc2VsZWN0IGVsZW1lbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSB0aGUgYmluZGluZydzIHRhcmdldCBvYnNlcnZlciBoYXMgYmVlbiBzZXQuXG4gICAgICAgIGNvbnN0IHRhcmdldE9ic2VydmVyID0gdGhpcy5vYnNlcnZlckxvY2F0b3IuZ2V0T2JzZXJ2ZXIoYmluZGluZy50YXJnZXQsIGJpbmRpbmcudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgICBpZiAoIXRhcmdldE9ic2VydmVyLmhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHVwZGF0ZVRyaWdnZXIgYmluZGluZyBiZWhhdmlvciBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHR3by13YXkvIGZyb20tdmlldyBiaW5kaW5ncyBvbiBpbnB1dC9zZWxlY3QgZWxlbWVudHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZy50YXJnZXRPYnNlcnZlciA9IHRhcmdldE9ic2VydmVyO1xuICAgICAgICAvLyBzdGFzaCB0aGUgb3JpZ2luYWwgZWxlbWVudCBzdWJzY3JpYmUgZnVuY3Rpb24uXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSGFuZGxlciA9IHRhcmdldE9ic2VydmVyLmhhbmRsZXI7XG4gICAgICAgIHRhcmdldE9ic2VydmVyLm9yaWdpbmFsSGFuZGxlciA9IG9yaWdpbmFsSGFuZGxlcjtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgZWxlbWVudCBzdWJzY3JpYmUgZnVuY3Rpb24gd2l0aCBvbmUgdGhhdCB1c2VzIHRoZSBjb3JyZWN0IGV2ZW50cy5cbiAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIuaGFuZGxlciA9IG5ldyBFdmVudFN1YnNjcmliZXIobmV3IE5vZGVPYnNlcnZlckNvbmZpZyh7XG4gICAgICAgICAgICBkZWZhdWx0OiBvcmlnaW5hbEhhbmRsZXIuY29uZmlnLmRlZmF1bHQsXG4gICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICByZWFkb25seTogb3JpZ2luYWxIYW5kbGVyLmNvbmZpZy5yZWFkb25seVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHVuYmluZChmbGFncywgX3Njb3BlLCBfaG9zdFNjb3BlLCBiaW5kaW5nKSB7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBiaW5kaW5nLlxuICAgICAgICBiaW5kaW5nLnRhcmdldE9ic2VydmVyLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICBiaW5kaW5nLnRhcmdldE9ic2VydmVyLmhhbmRsZXIgPSBiaW5kaW5nLnRhcmdldE9ic2VydmVyLm9yaWdpbmFsSGFuZGxlcjtcbiAgICAgICAgYmluZGluZy50YXJnZXRPYnNlcnZlci5vcmlnaW5hbEhhbmRsZXIgPSBudWxsO1xuICAgIH1cbn07XG5VcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0JlaGF2aW9yKCd1cGRhdGVUcmlnZ2VyJyksXG4gICAgX19wYXJhbSgwLCBJT2JzZXJ2ZXJMb2NhdG9yKVxuXSwgVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvcik7XG5leHBvcnQgeyBVcGRhdGVUcmlnZ2VyQmluZGluZ0JlaGF2aW9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGUtdHJpZ2dlci5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBjYW1lbENhc2UsIFJlZ2lzdHJhdGlvbiwgbWVyZ2VBcnJheXMsIFByb3RvY29sLCBmaXJzdERlZmluZWQsIE1ldGFkYXRhIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdNb2RlLCBEZWxlZ2F0aW9uU3RyYXRlZ3ksIHJlZ2lzdGVyQWxpYXNlcyB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uLCBQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbiwgQ2FsbEJpbmRpbmdJbnN0cnVjdGlvbiwgSXRlcmF0b3JCaW5kaW5nSW5zdHJ1Y3Rpb24sIFJlZkJpbmRpbmdJbnN0cnVjdGlvbiwgTGlzdGVuZXJCaW5kaW5nSW5zdHJ1Y3Rpb24sIH0gZnJvbSAnLi4vcmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgQmluZGluZ1N5bWJvbCB9IGZyb20gJy4uL3NlbWFudGljLW1vZGVsLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBiaW5kaW5nQ29tbWFuZChuYW1lT3JEZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIEJpbmRpbmdDb21tYW5kLmRlZmluZShuYW1lT3JEZWZpbml0aW9uLCB0YXJnZXQpO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgQmluZGluZ0NvbW1hbmREZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihUeXBlLCBuYW1lLCBhbGlhc2VzLCBrZXksIHR5cGUpIHtcbiAgICAgICAgdGhpcy5UeXBlID0gVHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gYWxpYXNlcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUobmFtZU9yRGVmLCBUeXBlKSB7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBsZXQgZGVmO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVPckRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JEZWY7XG4gICAgICAgICAgICBkZWYgPSB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JEZWYubmFtZTtcbiAgICAgICAgICAgIGRlZiA9IG5hbWVPckRlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdDb21tYW5kRGVmaW5pdGlvbihUeXBlLCBmaXJzdERlZmluZWQoQmluZGluZ0NvbW1hbmQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnbmFtZScpLCBuYW1lKSwgbWVyZ2VBcnJheXMoQmluZGluZ0NvbW1hbmQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYWxpYXNlcycpLCBkZWYuYWxpYXNlcywgVHlwZS5hbGlhc2VzKSwgQmluZGluZ0NvbW1hbmQua2V5RnJvbShuYW1lKSwgZmlyc3REZWZpbmVkKEJpbmRpbmdDb21tYW5kLmdldEFubm90YXRpb24oVHlwZSwgJ3R5cGUnKSwgZGVmLnR5cGUsIFR5cGUudHlwZSwgbnVsbCkpO1xuICAgIH1cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgeyBUeXBlLCBrZXksIGFsaWFzZXMgfSA9IHRoaXM7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oa2V5LCBUeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICBSZWdpc3RyYXRpb24uYWxpYXNUbyhrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIHJlZ2lzdGVyQWxpYXNlcyhhbGlhc2VzLCBCaW5kaW5nQ29tbWFuZCwga2V5LCBjb250YWluZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBCaW5kaW5nQ29tbWFuZCA9IHtcbiAgICBuYW1lOiBQcm90b2NvbC5yZXNvdXJjZS5rZXlGb3IoJ2JpbmRpbmctY29tbWFuZCcpLFxuICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7QmluZGluZ0NvbW1hbmQubmFtZX06JHtuYW1lfWA7XG4gICAgfSxcbiAgICBpc1R5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBNZXRhZGF0YS5oYXNPd24oQmluZGluZ0NvbW1hbmQubmFtZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZGVmaW5lKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQmluZGluZ0NvbW1hbmREZWZpbml0aW9uLmNyZWF0ZShuYW1lT3JEZWYsIFR5cGUpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQmluZGluZ0NvbW1hbmQubmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbi5UeXBlKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEJpbmRpbmdDb21tYW5kLm5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICBQcm90b2NvbC5yZXNvdXJjZS5hcHBlbmRUbyhUeXBlLCBCaW5kaW5nQ29tbWFuZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24uVHlwZTtcbiAgICB9LFxuICAgIGdldERlZmluaXRpb24oVHlwZSkge1xuICAgICAgICBjb25zdCBkZWYgPSBNZXRhZGF0YS5nZXRPd24oQmluZGluZ0NvbW1hbmQubmFtZSwgVHlwZSk7XG4gICAgICAgIGlmIChkZWYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZWZpbml0aW9uIGZvdW5kIGZvciB0eXBlICR7VHlwZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfSxcbiAgICBhbm5vdGF0ZShUeXBlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIHZhbHVlLCBUeXBlKTtcbiAgICB9LFxuICAgIGdldEFubm90YXRpb24oVHlwZSwgcHJvcCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKHByb3ApLCBUeXBlKTtcbiAgICB9LFxufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRUYXJnZXQoYmluZGluZywgbWFrZUNhbWVsQ2FzZSkge1xuICAgIGlmIChiaW5kaW5nLmZsYWdzICYgMjU2IC8qIGlzQmluZGluZyAqLykge1xuICAgICAgICByZXR1cm4gYmluZGluZy5iaW5kYWJsZS5wcm9wTmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWFrZUNhbWVsQ2FzZSkge1xuICAgICAgICByZXR1cm4gY2FtZWxDYXNlKGJpbmRpbmcuc3ludGF4LnRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYmluZGluZy5zeW50YXgudGFyZ2V0O1xuICAgIH1cbn1cbmxldCBPbmVUaW1lQmluZGluZ0NvbW1hbmQgPSBjbGFzcyBPbmVUaW1lQmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gNDkgLyogT25lVGltZUNvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSwgQmluZGluZ01vZGUub25lVGltZSk7XG4gICAgfVxufTtcbk9uZVRpbWVCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdDb21tYW5kKCdvbmUtdGltZScpXG5dLCBPbmVUaW1lQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgT25lVGltZUJpbmRpbmdDb21tYW5kIH07XG5sZXQgVG9WaWV3QmluZGluZ0NvbW1hbmQgPSBjbGFzcyBUb1ZpZXdCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSA1MCAvKiBUb1ZpZXdDb21tYW5kICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIEJpbmRpbmdNb2RlLnRvVmlldyk7XG4gICAgfVxufTtcblRvVmlld0JpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ3RvLXZpZXcnKVxuXSwgVG9WaWV3QmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgVG9WaWV3QmluZGluZ0NvbW1hbmQgfTtcbmxldCBGcm9tVmlld0JpbmRpbmdDb21tYW5kID0gY2xhc3MgRnJvbVZpZXdCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSA1MSAvKiBGcm9tVmlld0NvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSwgQmluZGluZ01vZGUuZnJvbVZpZXcpO1xuICAgIH1cbn07XG5Gcm9tVmlld0JpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ2Zyb20tdmlldycpXG5dLCBGcm9tVmlld0JpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IEZyb21WaWV3QmluZGluZ0NvbW1hbmQgfTtcbmxldCBUd29XYXlCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIFR3b1dheUJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDUyIC8qIFR3b1dheUNvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSwgQmluZGluZ01vZGUudHdvV2F5KTtcbiAgICB9XG59O1xuVHdvV2F5QmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgndHdvLXdheScpXG5dLCBUd29XYXlCaW5kaW5nQ29tbWFuZCk7XG5leHBvcnQgeyBUd29XYXlCaW5kaW5nQ29tbWFuZCB9O1xubGV0IERlZmF1bHRCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIERlZmF1bHRCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSA1MyAvKiBCaW5kQ29tbWFuZCAqLztcbiAgICB9XG4gICAgY29tcGlsZShiaW5kaW5nKSB7XG4gICAgICAgIGxldCBtb2RlID0gQmluZGluZ01vZGUuZGVmYXVsdDtcbiAgICAgICAgaWYgKGJpbmRpbmcgaW5zdGFuY2VvZiBCaW5kaW5nU3ltYm9sKSB7XG4gICAgICAgICAgICBtb2RlID0gYmluZGluZy5iaW5kYWJsZS5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IGJpbmRpbmcuc3ludGF4LmNvbW1hbmQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdiaW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0by12aWV3JzpcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJpbmRpbmdNb2RlLnRvVmlldztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb25lLXRpbWUnOlxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gQmluZGluZ01vZGUub25lVGltZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnJvbS12aWV3JzpcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJpbmRpbmdNb2RlLmZyb21WaWV3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0d28td2F5JzpcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IEJpbmRpbmdNb2RlLnR3b1dheTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmdJbnN0cnVjdGlvbihiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSksIG1vZGUgPT09IEJpbmRpbmdNb2RlLmRlZmF1bHQgPyBCaW5kaW5nTW9kZS50b1ZpZXcgOiBtb2RlKTtcbiAgICB9XG59O1xuRGVmYXVsdEJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ2JpbmQnKVxuXSwgRGVmYXVsdEJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IERlZmF1bHRCaW5kaW5nQ29tbWFuZCB9O1xubGV0IENhbGxCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIENhbGxCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSAxNTMgLyogQ2FsbENvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IENhbGxCaW5kaW5nSW5zdHJ1Y3Rpb24oYmluZGluZy5leHByZXNzaW9uLCBnZXRUYXJnZXQoYmluZGluZywgdHJ1ZSkpO1xuICAgIH1cbn07XG5DYWxsQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgnY2FsbCcpXG5dLCBDYWxsQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgQ2FsbEJpbmRpbmdDb21tYW5kIH07XG5sZXQgRm9yQmluZGluZ0NvbW1hbmQgPSBjbGFzcyBGb3JCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSA1MzkgLyogRm9yQ29tbWFuZCAqLztcbiAgICB9XG4gICAgY29tcGlsZShiaW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3JCaW5kaW5nSW5zdHJ1Y3Rpb24oYmluZGluZy5leHByZXNzaW9uLCBnZXRUYXJnZXQoYmluZGluZywgZmFsc2UpKTtcbiAgICB9XG59O1xuRm9yQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgnZm9yJylcbl0sIEZvckJpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IEZvckJpbmRpbmdDb21tYW5kIH07XG5sZXQgVHJpZ2dlckJpbmRpbmdDb21tYW5kID0gY2xhc3MgVHJpZ2dlckJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDQxODIgLyogVHJpZ2dlckNvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpc3RlbmVyQmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSwgdHJ1ZSwgRGVsZWdhdGlvblN0cmF0ZWd5Lm5vbmUpO1xuICAgIH1cbn07XG5UcmlnZ2VyQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgndHJpZ2dlcicpXG5dLCBUcmlnZ2VyQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgVHJpZ2dlckJpbmRpbmdDb21tYW5kIH07XG5sZXQgRGVsZWdhdGVCaW5kaW5nQ29tbWFuZCA9IGNsYXNzIERlbGVnYXRlQmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gNDE4NCAvKiBEZWxlZ2F0ZUNvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpc3RlbmVyQmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSwgZmFsc2UsIERlbGVnYXRpb25TdHJhdGVneS5idWJibGluZyk7XG4gICAgfVxufTtcbkRlbGVnYXRlQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgnZGVsZWdhdGUnKVxuXSwgRGVsZWdhdGVCaW5kaW5nQ29tbWFuZCk7XG5leHBvcnQgeyBEZWxlZ2F0ZUJpbmRpbmdDb21tYW5kIH07XG5sZXQgQ2FwdHVyZUJpbmRpbmdDb21tYW5kID0gY2xhc3MgQ2FwdHVyZUJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDQxODMgLyogQ2FwdHVyZUNvbW1hbmQgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpc3RlbmVyQmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSwgZmFsc2UsIERlbGVnYXRpb25TdHJhdGVneS5jYXB0dXJpbmcpO1xuICAgIH1cbn07XG5DYXB0dXJlQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgnY2FwdHVyZScpXG5dLCBDYXB0dXJlQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgQ2FwdHVyZUJpbmRpbmdDb21tYW5kIH07XG4vKipcbiAqIEF0dHIgYmluZGluZyBjb21tYW5kLiBDb21waWxlIGF0dHIgd2l0aCBiaW5kaW5nIHN5bWJvbCB3aXRoIGNvbW1hbmQgYGF0dHJgIHRvIGBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb25gXG4gKi9cbmxldCBBdHRyQmluZGluZ0NvbW1hbmQgPSBjbGFzcyBBdHRyQmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gMzIgLyogSXNQcm9wZXJ0eSAqLztcbiAgICB9XG4gICAgY29tcGlsZShiaW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlQmluZGluZ0luc3RydWN0aW9uKHRhcmdldCwgYmluZGluZy5leHByZXNzaW9uLCB0YXJnZXQpO1xuICAgIH1cbn07XG5BdHRyQmluZGluZ0NvbW1hbmQgPSBfX2RlY29yYXRlKFtcbiAgICBiaW5kaW5nQ29tbWFuZCgnYXR0cicpXG5dLCBBdHRyQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgQXR0ckJpbmRpbmdDb21tYW5kIH07XG4vKipcbiAqIFN0eWxlIGJpbmRpbmcgY29tbWFuZC4gQ29tcGlsZSBhdHRyIHdpdGggYmluZGluZyBzeW1ib2wgd2l0aCBjb21tYW5kIGBzdHlsZWAgdG8gYEF0dHJpYnV0ZUJpbmRpbmdJbnN0cnVjdGlvbmBcbiAqL1xubGV0IFN0eWxlQmluZGluZ0NvbW1hbmQgPSBjbGFzcyBTdHlsZUJpbmRpbmdDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nVHlwZSA9IDMyIC8qIElzUHJvcGVydHkgKi87XG4gICAgfVxuICAgIGNvbXBpbGUoYmluZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZUJpbmRpbmdJbnN0cnVjdGlvbignc3R5bGUnLCBiaW5kaW5nLmV4cHJlc3Npb24sIGdldFRhcmdldChiaW5kaW5nLCBmYWxzZSkpO1xuICAgIH1cbn07XG5TdHlsZUJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ3N0eWxlJylcbl0sIFN0eWxlQmluZGluZ0NvbW1hbmQpO1xuZXhwb3J0IHsgU3R5bGVCaW5kaW5nQ29tbWFuZCB9O1xuLyoqXG4gKiBDbGFzcyBiaW5kaW5nIGNvbW1hbmQuIENvbXBpbGUgYXR0ciB3aXRoIGJpbmRpbmcgc3ltYm9sIHdpdGggY29tbWFuZCBgY2xhc3NgIHRvIGBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb25gXG4gKi9cbmxldCBDbGFzc0JpbmRpbmdDb21tYW5kID0gY2xhc3MgQ2xhc3NCaW5kaW5nQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1R5cGUgPSAzMiAvKiBJc1Byb3BlcnR5ICovO1xuICAgIH1cbiAgICBjb21waWxlKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb24oJ2NsYXNzJywgYmluZGluZy5leHByZXNzaW9uLCBnZXRUYXJnZXQoYmluZGluZywgZmFsc2UpKTtcbiAgICB9XG59O1xuQ2xhc3NCaW5kaW5nQ29tbWFuZCA9IF9fZGVjb3JhdGUoW1xuICAgIGJpbmRpbmdDb21tYW5kKCdjbGFzcycpXG5dLCBDbGFzc0JpbmRpbmdDb21tYW5kKTtcbmV4cG9ydCB7IENsYXNzQmluZGluZ0NvbW1hbmQgfTtcbi8qKlxuICogQmluZGluZyBjb21tYW5kIHRvIHJlZmVyIGRpZmZlcmVudCB0YXJnZXRzIChlbGVtZW50LCBjdXN0b20gZWxlbWVudC9hdHRyaWJ1dGUgdmlldyBtb2RlbHMsIGNvbnRyb2xsZXIpIGF0dGFjaGVkIHRvIGFuIGVsZW1lbnRcbiAqL1xubGV0IFJlZkJpbmRpbmdDb21tYW5kID0gY2xhc3MgUmVmQmluZGluZ0NvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdUeXBlID0gMzIgLyogSXNQcm9wZXJ0eSAqLyB8IDQwOTYgLyogSWdub3JlQ3VzdG9tQXR0ciAqLztcbiAgICB9XG4gICAgY29tcGlsZShiaW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmQmluZGluZ0luc3RydWN0aW9uKGJpbmRpbmcuZXhwcmVzc2lvbiwgZ2V0VGFyZ2V0KGJpbmRpbmcsIGZhbHNlKSk7XG4gICAgfVxufTtcblJlZkJpbmRpbmdDb21tYW5kID0gX19kZWNvcmF0ZShbXG4gICAgYmluZGluZ0NvbW1hbmQoJ3JlZicpXG5dLCBSZWZCaW5kaW5nQ29tbWFuZCk7XG5leHBvcnQgeyBSZWZCaW5kaW5nQ29tbWFuZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGluZy1jb21tYW5kLmpzLm1hcCIsImltcG9ydCB7IFJlZ2lzdHJhdGlvbiwgUHJvdG9jb2wsIE1ldGFkYXRhLCBtZXJnZUFycmF5cywgZmlyc3REZWZpbmVkLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBCaW5kaW5nTW9kZSwgcmVnaXN0ZXJBbGlhc2VzLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgQmluZGFibGUsIH0gZnJvbSAnLi4vYmluZGFibGUuanMnO1xuaW1wb3J0IHsgV2F0Y2ggfSBmcm9tICcuLi93YXRjaC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tQXR0cmlidXRlKG5hbWVPckRlZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBDdXN0b21BdHRyaWJ1dGUuZGVmaW5lKG5hbWVPckRlZiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlQ29udHJvbGxlcihuYW1lT3JEZWYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gQ3VzdG9tQXR0cmlidXRlLmRlZmluZSh0eXBlb2YgbmFtZU9yRGVmID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7IGlzVGVtcGxhdGVDb250cm9sbGVyOiB0cnVlLCBuYW1lOiBuYW1lT3JEZWYgfVxuICAgICAgICAgICAgOiB7IGlzVGVtcGxhdGVDb250cm9sbGVyOiB0cnVlLCAuLi5uYW1lT3JEZWYgfSwgdGFyZ2V0KTtcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIEN1c3RvbUF0dHJpYnV0ZURlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFR5cGUsIG5hbWUsIGFsaWFzZXMsIGtleSwgZGVmYXVsdEJpbmRpbmdNb2RlLCBpc1RlbXBsYXRlQ29udHJvbGxlciwgYmluZGFibGVzLCBub011bHRpQmluZGluZ3MsIHdhdGNoZXMpIHtcbiAgICAgICAgdGhpcy5UeXBlID0gVHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gYWxpYXNlcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEJpbmRpbmdNb2RlID0gZGVmYXVsdEJpbmRpbmdNb2RlO1xuICAgICAgICB0aGlzLmlzVGVtcGxhdGVDb250cm9sbGVyID0gaXNUZW1wbGF0ZUNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuYmluZGFibGVzID0gYmluZGFibGVzO1xuICAgICAgICB0aGlzLm5vTXVsdGlCaW5kaW5ncyA9IG5vTXVsdGlCaW5kaW5ncztcbiAgICAgICAgdGhpcy53YXRjaGVzID0gd2F0Y2hlcztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShuYW1lT3JEZWYsIFR5cGUpIHtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGxldCBkZWY7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yRGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVPckRlZjtcbiAgICAgICAgICAgIGRlZiA9IHsgbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVPckRlZi5uYW1lO1xuICAgICAgICAgICAgZGVmID0gbmFtZU9yRGVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQXR0cmlidXRlRGVmaW5pdGlvbihUeXBlLCBmaXJzdERlZmluZWQoQ3VzdG9tQXR0cmlidXRlLmdldEFubm90YXRpb24oVHlwZSwgJ25hbWUnKSwgbmFtZSksIG1lcmdlQXJyYXlzKEN1c3RvbUF0dHJpYnV0ZS5nZXRBbm5vdGF0aW9uKFR5cGUsICdhbGlhc2VzJyksIGRlZi5hbGlhc2VzLCBUeXBlLmFsaWFzZXMpLCBDdXN0b21BdHRyaWJ1dGUua2V5RnJvbShuYW1lKSwgZmlyc3REZWZpbmVkKEN1c3RvbUF0dHJpYnV0ZS5nZXRBbm5vdGF0aW9uKFR5cGUsICdkZWZhdWx0QmluZGluZ01vZGUnKSwgZGVmLmRlZmF1bHRCaW5kaW5nTW9kZSwgVHlwZS5kZWZhdWx0QmluZGluZ01vZGUsIEJpbmRpbmdNb2RlLnRvVmlldyksIGZpcnN0RGVmaW5lZChDdXN0b21BdHRyaWJ1dGUuZ2V0QW5ub3RhdGlvbihUeXBlLCAnaXNUZW1wbGF0ZUNvbnRyb2xsZXInKSwgZGVmLmlzVGVtcGxhdGVDb250cm9sbGVyLCBUeXBlLmlzVGVtcGxhdGVDb250cm9sbGVyLCBmYWxzZSksIEJpbmRhYmxlLmZyb20oLi4uQmluZGFibGUuZ2V0QWxsKFR5cGUpLCBDdXN0b21BdHRyaWJ1dGUuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYmluZGFibGVzJyksIFR5cGUuYmluZGFibGVzLCBkZWYuYmluZGFibGVzKSwgZmlyc3REZWZpbmVkKEN1c3RvbUF0dHJpYnV0ZS5nZXRBbm5vdGF0aW9uKFR5cGUsICdub011bHRpQmluZGluZ3MnKSwgZGVmLm5vTXVsdGlCaW5kaW5ncywgVHlwZS5ub011bHRpQmluZGluZ3MsIGZhbHNlKSwgbWVyZ2VBcnJheXMoV2F0Y2guZ2V0QW5ub3RhdGlvbihUeXBlKSwgVHlwZS53YXRjaGVzKSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCB7IFR5cGUsIGtleSwgYWxpYXNlcyB9ID0gdGhpcztcbiAgICAgICAgUmVnaXN0cmF0aW9uLnRyYW5zaWVudChrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5hbGlhc1RvKGtleSwgVHlwZSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgcmVnaXN0ZXJBbGlhc2VzKGFsaWFzZXMsIEN1c3RvbUF0dHJpYnV0ZSwga2V5LCBjb250YWluZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBDdXN0b21BdHRyaWJ1dGUgPSB7XG4gICAgbmFtZTogUHJvdG9jb2wucmVzb3VyY2Uua2V5Rm9yKCdjdXN0b20tYXR0cmlidXRlJyksXG4gICAga2V5RnJvbShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtDdXN0b21BdHRyaWJ1dGUubmFtZX06JHtuYW1lfWA7XG4gICAgfSxcbiAgICBpc1R5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBNZXRhZGF0YS5oYXNPd24oQ3VzdG9tQXR0cmlidXRlLm5hbWUsIHZhbHVlKTtcbiAgICB9LFxuICAgIGZvcihub2RlLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5nZXRPd24oQ3VzdG9tQXR0cmlidXRlLmtleUZyb20obmFtZSksIG5vZGUpO1xuICAgIH0sXG4gICAgZGVmaW5lKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tQXR0cmlidXRlRGVmaW5pdGlvbi5jcmVhdGUobmFtZU9yRGVmLCBUeXBlKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUF0dHJpYnV0ZS5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLlR5cGUpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ3VzdG9tQXR0cmlidXRlLm5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICBQcm90b2NvbC5yZXNvdXJjZS5hcHBlbmRUbyhUeXBlLCBDdXN0b21BdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLlR5cGU7XG4gICAgfSxcbiAgICBnZXREZWZpbml0aW9uKFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmID0gTWV0YWRhdGEuZ2V0T3duKEN1c3RvbUF0dHJpYnV0ZS5uYW1lLCBUeXBlKTtcbiAgICAgICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlZmluaXRpb24gZm91bmQgZm9yIHR5cGUgJHtUeXBlLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9LFxuICAgIGFubm90YXRlKFR5cGUsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcihwcm9wKSwgdmFsdWUsIFR5cGUpO1xuICAgIH0sXG4gICAgZ2V0QW5ub3RhdGlvbihUeXBlLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5nZXRPd24oUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIFR5cGUpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLWF0dHJpYnV0ZS5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGVtcHR5QXJyYXkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgSU5vZGUgfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgY3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi4vY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBiaW5kYWJsZSB9IGZyb20gJy4uLy4uL2JpbmRhYmxlLmpzJztcbmNvbnN0IHVuc2V0ID0gU3ltYm9sKCk7XG4vLyBVc2luZyBwYXNzaXZlIHRvIGhlbHAgd2l0aCBwZXJmb3JtYW5jZVxuY29uc3QgZGVmYXVsdENhcHR1cmVFdmVudEluaXQgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICBjYXB0dXJlOiB0cnVlXG59O1xuLy8gVXNpbmcgcGFzc2l2ZSB0byBoZWxwIHdpdGggcGVyZm9ybWFuY2VcbmNvbnN0IGRlZmF1bHRCdWJibGVFdmVudEluaXQgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxufTtcbi8vIHdlYWtseSBjb25uZWN0IGEgZG9jdW1lbnQgdG8gYSBibHVyIG1hbmFnZXJcbi8vIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZG9jdW1lbnQgcHJvcGVydGllc1xuY29uc3QgYmx1ckRvY01hcCA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgY2xhc3MgQmx1ck1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5ibHVycyA9IFtdO1xuICAgICAgICBibHVyRG9jTWFwLnNldChwbGF0Zm9ybS5kb2N1bWVudCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIodGhpcywgdGhpcy5ibHVycyk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGb3IocGxhdGZvcm0pIHtcbiAgICAgICAgcmV0dXJuIGJsdXJEb2NNYXAuZ2V0KHBsYXRmb3JtLmRvY3VtZW50KSB8fCBuZXcgQmx1ck1hbmFnZXIocGxhdGZvcm0pO1xuICAgIH1cbiAgICByZWdpc3RlcihibHVyKSB7XG4gICAgICAgIGNvbnN0IGJsdXJzID0gdGhpcy5ibHVycztcbiAgICAgICAgaWYgKCFibHVycy5pbmNsdWRlcyhibHVyKSAmJiBibHVycy5wdXNoKGJsdXIpID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVnaXN0ZXIoYmx1cikge1xuICAgICAgICBjb25zdCBibHVycyA9IHRoaXMuYmx1cnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmx1cnMuaW5kZXhPZihibHVyKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGJsdXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsdXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBsYXRmb3JtO1xuICAgICAgICBjb25zdCBkb2MgPSBwLmRvY3VtZW50O1xuICAgICAgICBjb25zdCB3aW4gPSBwLndpbmRvdztcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcbiAgICAgICAgaWYgKHdpbi5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgfVxuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlciwgZGVmYXVsdENhcHR1cmVFdmVudEluaXQpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIGRlZmF1bHRCdWJibGVFdmVudEluaXQpO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBsYXRmb3JtO1xuICAgICAgICBjb25zdCBkb2MgPSBwLmRvY3VtZW50O1xuICAgICAgICBjb25zdCB3aW4gPSBwLndpbmRvdztcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcbiAgICAgICAgaWYgKHdpbi5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgfVxuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZXIsIGRlZmF1bHRDYXB0dXJlRXZlbnRJbml0KTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlciwgZGVmYXVsdENhcHR1cmVFdmVudEluaXQpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIGRlZmF1bHRCdWJibGVFdmVudEluaXQpO1xuICAgIH1cbn1cbmxldCBCbHVyID0gY2xhc3MgQmx1ciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgcCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGJlaGF2aW9yIHNob3VsZCBiZSBsZWFzdCBzdXJwcmlzZSBwb3NzaWJsZSwgdGhhdDpcbiAgICAgICAgICpcbiAgICAgICAgICogaXQgc2VhcmNoZXMgZm9yIGFueXRoaW5nIGZyb20gcm9vdCBjb250ZXh0LFxuICAgICAgICAgKiBhbmQgcm9vdCBjb250ZXh0IGlzIGRvY3VtZW50IGJvZHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlua2VkTXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlYXJjaFN1YlRyZWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpbmtpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuc2V0O1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBCbHVyTWFuYWdlci5jcmVhdGVGb3IocCk7XG4gICAgfVxuICAgIGF0dGFjaGVkKCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICAgIGRldGFjaGluZygpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50VGFyZ2V0KHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwID0gdGhpcy5wO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBwLndpbmRvdyB8fCB0YXJnZXQgPT09IHAuZG9jdW1lbnQgfHwgIXRoaXMuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5zKHRhcmdldCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWxzO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGosIGpqO1xuICAgICAgICBsZXQgbGluaztcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgaWYgKGNvbnRhaW5zRWxlbWVudE9yU2hhZG93Um9vdChlbGVtZW50LCB0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubGlua2VkV2l0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IHRoaXMucC5kb2N1bWVudDtcbiAgICAgICAgY29uc3QgbGlua2VkV2l0aCA9IHRoaXMubGlua2VkV2l0aDtcbiAgICAgICAgY29uc3QgbGlua2luZ0NvbnRleHQgPSB0aGlzLmxpbmtpbmdDb250ZXh0O1xuICAgICAgICBjb25zdCBzZWFyY2hTdWJUcmVlID0gdGhpcy5zZWFyY2hTdWJUcmVlO1xuICAgICAgICBjb25zdCBsaW5rZWRNdWx0aXBsZSA9IHRoaXMubGlua2VkTXVsdGlwbGU7XG4gICAgICAgIGNvbnN0IGxpbmtzID0gQXJyYXkuaXNBcnJheShsaW5rZWRXaXRoKSA/IGxpbmtlZFdpdGggOiBbbGlua2VkV2l0aF07XG4gICAgICAgIGNvbnN0IGNvbnRleHROb2RlID0gKHR5cGVvZiBsaW5raW5nQ29udGV4dCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gZG9jLnF1ZXJ5U2VsZWN0b3IobGlua2luZ0NvbnRleHQpXG4gICAgICAgICAgICA6IGxpbmtpbmdDb250ZXh0KVxuICAgICAgICAgICAgfHwgZG9jLmJvZHk7XG4gICAgICAgIGNvbnN0IGlpID0gbGlua3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpaSA+IGk7ICsraSkge1xuICAgICAgICAgICAgbGluayA9IGxpbmtzW2ldO1xuICAgICAgICAgICAgLy8gV2hlbiB1c2VyIHNwZWNpZnkgdG8gbGluayB3aXRoIHNvbWV0aGluZyBieSBhIHN0cmluZywgaXQgYWN0cyBhcyBhIENTUyBzZWxlY3RvclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkbyBzb21lIHF1ZXJ5aW5nIHN0dWZmIHRvIGRldGVybWluZSBpZiB0YXJnZXQgYWJvdmUgaXMgY29udGFpbmVkLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IsIHNlYXJjaCB0aGUgd2hvbGUgdHJlZSwgZnJvbSBjb250ZXh0IHRoYXQgdXNlciBzcGVjaWZpZWQsIHdoaWNoIGRlZmF1bHQgdG8gZG9jdW1lbnQgYm9keVxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hTdWJUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IGFyZSB0aGVyZSB0b28gbWFueSBrbm9icz8/IENvbnNpZGVyIHJlbW92ZSBcImxpbmtlZE11bHRpcGxlXCI/P1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmtlZE11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGNvbnRleHROb2RlLnF1ZXJ5U2VsZWN0b3IobGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHMgPSBlbCAhPT0gbnVsbCA/IFtlbF0gOiBlbXB0eUFycmF5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzID0gY29udGV4dE5vZGUucXVlcnlTZWxlY3RvckFsbChsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqaiA9IGVscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGpqID4gajsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxzW2pdLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBkb2N1bWVudCBib2R5LCBpZiB1c2VyIGRpZG4ndCBkZWZpbmUgYSBsaW5raW5nIGNvbnRleHQsIGFuZCB3YW50ZWQgdG8gaWdub3JlIHN1YnRyZWUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgc3BlY2lmaWNhbGx5IHBlcmZvcm1hbnQgYW5kIHVzZWZ1bCBmb3IgZGlhbG9ncywgcGx1Z2luc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHVzdWFsbHkgZ2VuZXJhdGUgY29udGVudHMgdG8gZG9jdW1lbnQgYm9keVxuICAgICAgICAgICAgICAgICAgICBlbHMgPSBjb250ZXh0Tm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgamogPSBlbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqaiA+IGo7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsc1tqXS5tYXRjaGVzKGxpbmspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzZXIgcGFzc2VkIGluIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIHN0cmluZyxcbiAgICAgICAgICAgICAgICAvLyBzaW1wbHkgY2hlY2sgaWYgaGFzIG1ldGhvZCBgY29udGFpbnNgIChhbGxvdyBkdWNrIHR5cGluZylcbiAgICAgICAgICAgICAgICAvLyBhbmQgY2FsbCBpdCBhZ2FpbnN0IHRhcmdldC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGVuYWJsZXMgZmxleGlibGUgdXNhZ2VzXG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgJiYgbGluay5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyaWdnZXJCbHVyKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkJsdXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25CbHVyLmNhbGwobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgQmx1ci5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIEJsdXIucHJvdG90eXBlLCBcIm9uQmx1clwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgQmx1ci5wcm90b3R5cGUsIFwibGlua2VkV2l0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgQmx1ci5wcm90b3R5cGUsIFwibGlua2VkTXVsdGlwbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIEJsdXIucHJvdG90eXBlLCBcInNlYXJjaFN1YlRyZWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIEJsdXIucHJvdG90eXBlLCBcImxpbmtpbmdDb250ZXh0XCIsIHZvaWQgMCk7XG5CbHVyID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tQXR0cmlidXRlKCdibHVyJyksXG4gICAgX19wYXJhbSgwLCBJTm9kZSksXG4gICAgX19wYXJhbSgxLCBJUGxhdGZvcm0pXG5dLCBCbHVyKTtcbmV4cG9ydCB7IEJsdXIgfTtcbmNvbnN0IGNvbnRhaW5zRWxlbWVudE9yU2hhZG93Um9vdCA9IChjb250YWluZXIsIHRhcmdldCkgPT4ge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGUgPSBudWxsO1xuICAgIHdoaWxlICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaG9zdDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBjcmVhdGVIYW5kbGVyID0gKG1hbmFnZXIsIGNoZWNrVGFyZ2V0cykgPT4ge1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBFVkVOVFMgT1JERVJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHBvaW50ZXJkb3duXG4gICAgLy8gdG91Y2hzdGFydFxuICAgIC8vIHBvaW50ZXJ1cFxuICAgIC8vIHRvdWNoZW5kXG4gICAgLy8gbW91c2Vkb3duXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCTFVSXG4gICAgLy8gRk9DVVNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgIC8vIG1vdXNldXBcbiAgICAvLyBjbGlja1xuICAgIC8vXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy9cbiAgICAvLyBUaGVyZSBhcmUgY2FzZXMgZm9jdXMgaGFwcGVucyB3aXRob3V0IG1vdXNlIGludGVyYWN0aW9uIChrZXlib2FyZClcbiAgICAvLyBTbyBpdCBuZWVkcyB0byBjYXB0dXJlIGJvdGggbW91c2UgLyBmb2N1cyBtb3ZlbWVudFxuICAgIC8vXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgbGV0IGhhc0NoZWNrZWQgPSBmYWxzZTtcbiAgICBjb25zdCByZXZlcnRDaGVja2FnZSA9ICgpID0+IHtcbiAgICAgICAgaGFzQ2hlY2tlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgbWFya0NoZWNrZWQgPSAoKSA9PiB7XG4gICAgICAgIGhhc0NoZWNrZWQgPSB0cnVlO1xuICAgICAgICBtYW5hZ2VyLnBsYXRmb3JtLmRvbVdyaXRlUXVldWUucXVldWVUYXNrKHJldmVydENoZWNrYWdlLCB7IHByZWVtcHQ6IHRydWUgfSk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVNb3VzZWRvd24gPSAoZSkgPT4ge1xuICAgICAgICBpZiAoIWhhc0NoZWNrZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgbWFya0NoZWNrZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGdsb2JhbGx5IGNhcHR1cmVkIGZvY3VzIGV2ZW50XG4gICAgICogVGhpcyBjYW4gaGFwcGVuIHZpYSBhIGZldyB3YXk6XG4gICAgICogVXNlciBjbGlja3Mgb24gYSBmb2N1c2FibGUgZWxlbWVudFxuICAgICAqIFVzZXIgdXNlcyBrZXlib2FyZCB0byBuYXZpZ2F0ZSB0byBhIGZvY3VzYWJsZSBlbGVtZW50XG4gICAgICogVXNlciBnb2VzIGJhY2sgdG8gdGhlIHdpbmRvdyBmcm9tIGFub3RoZXIgYnJvd3NlciB0YWJcbiAgICAgKiBVc2VyIGNsaWNrcyBvbiBhIG5vbi1mb2N1c2FibGUgZWxlbWVudFxuICAgICAqIFVzZXIgY2xpY2tzIG9uIHRoZSB3aW5kb3csIG91dHNpZGUgb2YgdGhlIGRvY3VtZW50XG4gICAgICovXG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoZSkgPT4ge1xuICAgICAgICBpZiAoaGFzQ2hlY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXJlIGFyZSB0d28gd2F5IGEgZm9jdXMgZ2V0cyBjYXB0dXJlZCBvbiB3aW5kb3dcbiAgICAgICAgLy8gd2hlbiB0aGUgd2luZG93cyBpdHNlbGYgZ290IGZvY3VzXG4gICAgICAgIC8vIGFuZCB3aGVuIGFuIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50IGdldHMgZm9jdXNcbiAgICAgICAgLy8gd2hlbiB0aGUgd2luZG93IGl0c2VsZiBnb3QgZm9jdXMsIHJlYWN0aW5nIHRvIGl0IGlzIHF1aXRlIHVubmVjZXNzYXJ5XG4gICAgICAgIC8vIGFzIGl0IGRvZXNuJ3QgcmVhbGx5IGFmZmVjdCBlbGVtZW50IGluc2lkZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgLy8gRG8gYSBzaW1wbGUgY2hlY2sgYW5kIGJhaWwgaW1tZWRpYXRlbHlcbiAgICAgICAgY29uc3QgaXNXaW5kb3cgPSBlLnRhcmdldCA9PT0gbWFuYWdlci5wbGF0Zm9ybS53aW5kb3c7XG4gICAgICAgIGlmIChpc1dpbmRvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2hlY2tUYXJnZXRzLmxlbmd0aDsgaWkgPiBpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjaGVja1RhcmdldHNbaV0udHJpZ2dlckJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtDaGVja2VkKCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVXaW5kb3dCbHVyID0gKCkgPT4ge1xuICAgICAgICBoYXNDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoZWNrVGFyZ2V0cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjaGVja1RhcmdldHNbaV0udHJpZ2dlckJsdXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRXZlbnQgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLmNvbXBvc2VkID8gZS5jb21wb3NlZFBhdGgoKVswXSA6IGUudGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2hlY2tUYXJnZXRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGNoZWNrVGFyZ2V0c1tpXS5oYW5kbGVFdmVudFRhcmdldCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbnBvaW50ZXJkb3duOiBoYW5kbGVNb3VzZWRvd24sXG4gICAgICAgIG9udG91Y2hzdGFydDogaGFuZGxlTW91c2Vkb3duLFxuICAgICAgICBvbm1vdXNlZG93bjogaGFuZGxlTW91c2Vkb3duLFxuICAgICAgICBvbmZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICAgICAgb25ibHVyOiBoYW5kbGVXaW5kb3dCbHVyLFxuICAgICAgICBoYW5kbGVFdmVudChlKSB7XG4gICAgICAgICAgICB0aGlzW2BvbiR7ZS50eXBlfWBdKGUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibHVyLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgQmluZGluZ01vZGUgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IElOb2RlIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uLy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IGN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tICcuLi8uLi9iaW5kYWJsZS5qcyc7XG4vKipcbiAqIEZvY3VzIGF0dHJpYnV0ZSBmb3IgZWxlbWVudCBmb2N1cyBiaW5kaW5nXG4gKi9cbmxldCBGb2N1cyA9IGNsYXNzIEZvY3VzIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBwKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBgYXBwbHlgIHNob3VsZCBiZSBjYWxsZWQgd2hlbiBgYXR0YWNoZWRgIGNhbGxiYWNrIGlzIGludm9rZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmVlZHNBcHBseSA9IGZhbHNlO1xuICAgIH1cbiAgICBiaW5kaW5nKCkge1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIGV2ZXJ5dGltZSB0aGUgYm91bmQgdmFsdWUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWVDaGFuZ2VkKCkge1xuICAgICAgICAvLyBJbiB0aGVvcnksIHdlIGNvdWxkL3Nob3VsZCByZWFjdCBpbW1lZGlhdGVseVxuICAgICAgICAvLyBidXQgZm9jdXMgc3RhdGUgb2YgYW4gZWxlbWVudCBjYW5ub3QgYmUgYWNoaWV2ZWRcbiAgICAgICAgLy8gd2hpbGUgaXQncyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgICAgICAgLy8gdGh1cywgdGhlcmUgbmVlc2QgdG8gYmUgYSBjaGVjayBpZiBpdCdzIGN1cnJlbnRseSBjb25uZWN0ZWQgb3Igbm90XG4gICAgICAgIC8vIGJlZm9yZSBhcHBseWluZyB0aGUgdmFsdWUgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRyb2xsZXIuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBjdXJyZW50bHkgY29ubmVjdFxuICAgICAgICAgICAgLy8gdG9nZ2xlIHRoZSBmbGFnIHRvIGFkZCBwZW5kaW5nIHdvcmsgZm9yIGxhdGVyXG4gICAgICAgICAgICAvLyBpbiBhdHRhY2hlZCBsaWZlY3ljbGVcbiAgICAgICAgICAgIHRoaXMubmVlZHNBcHBseSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgKi9cbiAgICBhdHRhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNBcHBseSkge1xuICAgICAgICAgICAgdGhpcy5uZWVkc0FwcGx5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcyk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgYWZ0ZXJEZXRhY2hDaGlsZHJlbiBmcm9tIHRoZSBET00uXG4gICAgICovXG4gICAgYWZ0ZXJEZXRhY2hDaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcyk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnRUYXJnZXQgaW50ZXJmYWNlIGhhbmRsZXIgZm9yIGJldHRlciBtZW1vcnkgdXNhZ2VcbiAgICAgKi9cbiAgICBoYW5kbGVFdmVudChlKSB7XG4gICAgICAgIC8vIHRoZXJlIGFyZSBvbmx5IHR3byBldmVudCBsaXN0ZW5lZCB0b1xuICAgICAgICAvLyBpZiB0aGUgZXZlbiBpcyBmb2N1cywgaXQgbWVuYW5zIHRoZSBlbGVtZW50IGlzIGZvY3VzZWRcbiAgICAgICAgLy8gb25seSBuZWVkIHRvIHN3aXRjaCB0aGUgdmFsdWUgdG8gdHJ1ZVxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5pc0VsRm9jdXNlZCkge1xuICAgICAgICAgICAgLy8gZWxzZSwgaXQncyBibHVyIGV2ZW50XG4gICAgICAgICAgICAvLyB3aGVuIGEgYmx1ciBldmVudCBoYXBwZW5zLCB0aGVyZSBhcmUgdHdvIHNpdHVhdGlvbnNcbiAgICAgICAgICAgIC8vIDEuIHRoZSBlbGVtZW50IGl0c2VsZiBsb3N0IHRoZSBmb2N1c1xuICAgICAgICAgICAgLy8gMi4gd2luZG93IGxvc3QgdGhlIGZvY3VzXG4gICAgICAgICAgICAvLyBUbyBoYW5kbGUgYm90aCAoMSkgYW5kICgyKSwgb25seSBuZWVkIHRvIGNoZWNrIGlmXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBlbGVtZW50IGlzIHN0aWxsIHRoZSBzYW1lIGVsZW1lbnQgb2YgdGhpcyBmb2N1cyBjdXN0b20gYXR0cmlidXRlXG4gICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCwgaXQncyBhIGJsdXIgZXZlbnQgaGFwcGVuZWQgb24gV2luZG93IGJlY2F1c2UgdGhlIGJyb3dzZXIgdGFiIGxvc3QgZm9jdXNcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1cy9ibHVyIGJhc2VkIG9uIGN1cnJlbnQgdmFsdWVcbiAgICAgKi9cbiAgICBhcHBseSgpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNlZCA9IHRoaXMuaXNFbEZvY3VzZWQ7XG4gICAgICAgIGNvbnN0IHNob3VsZEZvY3VzID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKHNob3VsZEZvY3VzICYmICFpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNob3VsZEZvY3VzICYmIGlzRm9jdXNlZCkge1xuICAgICAgICAgICAgZWwuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0VsRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudCA9PT0gdGhpcy5wLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKHsgbW9kZTogQmluZGluZ01vZGUudHdvV2F5IH0pXG5dLCBGb2N1cy5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbkZvY3VzID0gX19kZWNvcmF0ZShbXG4gICAgY3VzdG9tQXR0cmlidXRlKCdmb2N1cycpLFxuICAgIF9fcGFyYW0oMCwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMSwgSVBsYXRmb3JtKVxuXSwgRm9jdXMpO1xuZXhwb3J0IHsgRm9jdXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgYWxpYXMgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IElOb2RlIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uLy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IGN1c3RvbUF0dHJpYnV0ZSB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tICcuLi8uLi9iaW5kYWJsZS5qcyc7XG5pbXBvcnQgeyBJSW5zdHJ1Y3Rpb24gfSBmcm9tICcuLi8uLi9yZW5kZXJlci5qcyc7XG5sZXQgU2hvdyA9IGNsYXNzIFNob3cge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBwLCBpbnN0cikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy4kdmFsID0gJyc7XG4gICAgICAgIHRoaXMuJHByaW8gPSAnJztcbiAgICAgICAgdGhpcy51cGRhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgLy8gT25seSBjb21wYXJlIGF0IHRoZSBzeW5jaHJvbm91cyBtb21lbnQgd2hlbiB3ZSdyZSBhYm91dCB0byB1cGRhdGUsIGJlY2F1c2UgdGhlIHZhbHVlIG1pZ2h0IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgdXBkYXRlIHdhcyBxdWV1ZWQuXG4gICAgICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnZhbHVlKSAhPT0gdGhpcy5pc1RvZ2dsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQgPT09IHRoaXMuYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVG9nZ2xlZCA9ICF0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGluIHYxIHdlIHVzZWQgdGhlICdhdS1oaWRlJyBjbGFzcywgYnV0IGluIHYyIGl0J3Mgc28gdHJpdmlhbCB0byBjb25kaXRpb25hbGx5IGFwcGx5IGNsYXNzZXMgKGUuZy4gJ2hpZGUuY2xhc3M9XCJzb21lQ29uZGl0aW9uXCInKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBpdCdzIHByb2JhYmx5IGJldHRlciB0byBhdm9pZCB0aGUgQ1NTIGluamVjdCBpbmZyYSBpbnZvbHZlbWVudCBhbmQga2VlcCB0aGlzIENBIGFzIHNpbXBsZSBhcyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCwganVzdCBzdG9yZSBhbmQgcmVzdG9yZSB0aGUgcHJvcGVydHkgdmFsdWVzICh3aXRoIGVhY2ggbXV0YXRpb24sIHRvIGFjY291bnQgZm9yIGluLWJldHdlZW4gdXBkYXRlcyksIHRvIGNvdmVyIHRoZSBjb21tb24gY2FzZXMsIHVudGlsIHRoZXJlIGlzIGNvbnZpbmNpbmcgZmVlZGJhY2sgdG8gZG8gb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiR2YWwgPSB0aGlzLmVsLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcHJpbyA9IHRoaXMuZWwuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlzcGxheScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVG9nZ2xlZCA9IHRoaXMuYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsIHRoaXMuJHZhbCwgdGhpcy4kcHJpbyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdHlsZSBhdHRyaWJ1dGUgaXMgbm93IGVtcHR5LCByZW1vdmUgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBpZiB0aGlzIGlzIGRlY2xhcmVkIGFzIGEgJ2hpZGUnIGF0dHJpYnV0ZSwgdGhlbiB0aGlzLmJhc2Ugd2lsbCBiZSBmYWxzZSwgaW52ZXJ0aW5nIGV2ZXJ5dGhpbmcuXG4gICAgICAgIHRoaXMuaXNUb2dnbGVkID0gdGhpcy5iYXNlID0gaW5zdHIuYWxpYXMgIT09ICdoaWRlJztcbiAgICB9XG4gICAgYmluZGluZygpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGRldGFjaGluZygpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRhc2s/LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlICYmIHRoaXMudGFzayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YXNrID0gdGhpcy5wLmRvbVdyaXRlUXVldWUucXVldWVUYXNrKHRoaXMudXBkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZVxuXSwgU2hvdy5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcblNob3cgPSBfX2RlY29yYXRlKFtcbiAgICBjdXN0b21BdHRyaWJ1dGUoJ3Nob3cnKSxcbiAgICBhbGlhcygnaGlkZScpLFxuICAgIF9fcGFyYW0oMCwgSU5vZGUpLFxuICAgIF9fcGFyYW0oMSwgSVBsYXRmb3JtKSxcbiAgICBfX3BhcmFtKDIsIElJbnN0cnVjdGlvbilcbl0sIFNob3cpO1xuZXhwb3J0IHsgU2hvdyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hvdy5qcy5tYXAiLCJpbXBvcnQgeyBESSwgUmVnaXN0cmF0aW9uLCBQcm90b2NvbCwgTWV0YWRhdGEsIG1lcmdlQXJyYXlzLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCwgcGFzY2FsQ2FzZSwgZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQsIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0LCBlbXB0eUFycmF5LCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyByZWdpc3RlckFsaWFzZXMsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBCaW5kYWJsZSwgfSBmcm9tICcuLi9iaW5kYWJsZS5qcyc7XG5pbXBvcnQgeyBnZXRFZmZlY3RpdmVQYXJlbnROb2RlIH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAnLi4vdGVtcGxhdGluZy9jaGlsZHJlbi5qcyc7XG5pbXBvcnQgeyBXYXRjaCB9IGZyb20gJy4uL3dhdGNoLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21FbGVtZW50KG5hbWVPckRlZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBDdXN0b21FbGVtZW50LmRlZmluZShuYW1lT3JEZWYsIHRhcmdldCk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VTaGFkb3dET00odGFyZ2V0T3JPcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldE9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoJHRhcmdldCkge1xuICAgICAgICAgICAgQ3VzdG9tRWxlbWVudC5hbm5vdGF0ZSgkdGFyZ2V0LCAnc2hhZG93T3B0aW9ucycsIHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhcmdldE9yT3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCR0YXJnZXQpIHtcbiAgICAgICAgICAgIEN1c3RvbUVsZW1lbnQuYW5ub3RhdGUoJHRhcmdldCwgJ3NoYWRvd09wdGlvbnMnLCB0YXJnZXRPck9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBDdXN0b21FbGVtZW50LmFubm90YXRlKHRhcmdldE9yT3B0aW9ucywgJ3NoYWRvd09wdGlvbnMnLCB7IG1vZGU6ICdvcGVuJyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluZXJsZXNzKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCR0YXJnZXQpIHtcbiAgICAgICAgICAgIEN1c3RvbUVsZW1lbnQuYW5ub3RhdGUoJHRhcmdldCwgJ2NvbnRhaW5lcmxlc3MnLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ3VzdG9tRWxlbWVudC5hbm5vdGF0ZSh0YXJnZXQsICdjb250YWluZXJsZXNzJywgdHJ1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaWN0KHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCR0YXJnZXQpIHtcbiAgICAgICAgICAgIEN1c3RvbUVsZW1lbnQuYW5ub3RhdGUoJHRhcmdldCwgJ2lzU3RyaWN0QmluZGluZycsIHRydWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBDdXN0b21FbGVtZW50LmFubm90YXRlKHRhcmdldCwgJ2lzU3RyaWN0QmluZGluZycsIHRydWUpO1xufVxuY29uc3QgZGVmaW5pdGlvbkxvb2t1cCA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgY2xhc3MgQ3VzdG9tRWxlbWVudERlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFR5cGUsIG5hbWUsIGFsaWFzZXMsIGtleSwgY2FjaGUsIHRlbXBsYXRlLCBpbnN0cnVjdGlvbnMsIGRlcGVuZGVuY2llcywgaW5qZWN0YWJsZSwgbmVlZHNDb21waWxlLCBzdXJyb2dhdGVzLCBiaW5kYWJsZXMsIGNoaWxkcmVuT2JzZXJ2ZXJzLCBjb250YWluZXJsZXNzLCBpc1N0cmljdEJpbmRpbmcsIHNoYWRvd09wdGlvbnMsIGhhc1Nsb3RzLCBlbmhhbmNlLCBwcm9qZWN0aW9uc01hcCwgd2F0Y2hlcykge1xuICAgICAgICB0aGlzLlR5cGUgPSBUeXBlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsaWFzZXMgPSBhbGlhc2VzO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5pbmplY3RhYmxlID0gaW5qZWN0YWJsZTtcbiAgICAgICAgdGhpcy5uZWVkc0NvbXBpbGUgPSBuZWVkc0NvbXBpbGU7XG4gICAgICAgIHRoaXMuc3Vycm9nYXRlcyA9IHN1cnJvZ2F0ZXM7XG4gICAgICAgIHRoaXMuYmluZGFibGVzID0gYmluZGFibGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuT2JzZXJ2ZXJzID0gY2hpbGRyZW5PYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuY29udGFpbmVybGVzcyA9IGNvbnRhaW5lcmxlc3M7XG4gICAgICAgIHRoaXMuaXNTdHJpY3RCaW5kaW5nID0gaXNTdHJpY3RCaW5kaW5nO1xuICAgICAgICB0aGlzLnNoYWRvd09wdGlvbnMgPSBzaGFkb3dPcHRpb25zO1xuICAgICAgICB0aGlzLmhhc1Nsb3RzID0gaGFzU2xvdHM7XG4gICAgICAgIHRoaXMuZW5oYW5jZSA9IGVuaGFuY2U7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbnNNYXAgPSBwcm9qZWN0aW9uc01hcDtcbiAgICAgICAgdGhpcy53YXRjaGVzID0gd2F0Y2hlcztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShuYW1lT3JEZWYsIFR5cGUgPSBudWxsKSB7XG4gICAgICAgIGlmIChUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkZWYgPSBuYW1lT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSBjdXN0b20gZWxlbWVudCBkZWZpbml0aW9uIHdpdGggb25seSBhIG5hbWUgYW5kIG5vIHR5cGU6ICR7bmFtZU9yRGVmfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCduYW1lJywgZGVmLCBDdXN0b21FbGVtZW50LmdlbmVyYXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZi5UeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhIGNsb25lIChpdCB3aWxsIHVzdWFsbHkgYmUgdGhlIGNvbXBpbGVyIGNhbGxpbmcgdGhpcyBzaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2UgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBkb2N1bWVudGVkIHRoYXQgcGFzc2luZyBpbiB0aGUgdHlwZSB2aWEgdGhlIGRlZmluaXRpb24gKHdoaWxlIHBhc3NpbmcgaW4gbnVsbFxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBcIlR5cGVcIiBwYXJhbWV0ZXIpIGVmZmVjdGl2ZWx5IHNraXBzIHR5cGUgYW5hbHlzaXMsIHNvIGl0IHNob3VsZCBvbmx5IGJlIHVzZWQgdGhpcyB3YXkgZm9yIGNsb25pbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAgICAgVHlwZSA9IGRlZi5UeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgVHlwZSA9IEN1c3RvbUVsZW1lbnQuZ2VuZXJhdGVUeXBlKHBhc2NhbENhc2UobmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FbGVtZW50RGVmaW5pdGlvbihUeXBlLCBuYW1lLCBtZXJnZUFycmF5cyhkZWYuYWxpYXNlcyksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdrZXknLCBkZWYsICgpID0+IEN1c3RvbUVsZW1lbnQua2V5RnJvbShuYW1lKSksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdjYWNoZScsIGRlZiwgKCkgPT4gMCksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCd0ZW1wbGF0ZScsIGRlZiwgKCkgPT4gbnVsbCksIG1lcmdlQXJyYXlzKGRlZi5pbnN0cnVjdGlvbnMpLCBtZXJnZUFycmF5cyhkZWYuZGVwZW5kZW5jaWVzKSwgZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ2luamVjdGFibGUnLCBkZWYsICgpID0+IG51bGwpLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnbmVlZHNDb21waWxlJywgZGVmLCAoKSA9PiB0cnVlKSwgbWVyZ2VBcnJheXMoZGVmLnN1cnJvZ2F0ZXMpLCBCaW5kYWJsZS5mcm9tKGRlZi5iaW5kYWJsZXMpLCBDaGlsZHJlbi5mcm9tKGRlZi5jaGlsZHJlbk9ic2VydmVycyksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdjb250YWluZXJsZXNzJywgZGVmLCAoKSA9PiBmYWxzZSksIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0KCdpc1N0cmljdEJpbmRpbmcnLCBkZWYsICgpID0+IGZhbHNlKSwgZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ3NoYWRvd09wdGlvbnMnLCBkZWYsICgpID0+IG51bGwpLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnaGFzU2xvdHMnLCBkZWYsICgpID0+IGZhbHNlKSwgZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ2VuaGFuY2UnLCBkZWYsICgpID0+IGZhbHNlKSwgZnJvbURlZmluaXRpb25PckRlZmF1bHQoJ3Byb2plY3Rpb25zTWFwJywgZGVmLCAoKSA9PiBuZXcgTWFwKCkpLCBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnd2F0Y2hlcycsIGRlZiwgKCkgPT4gZW1wdHlBcnJheSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgdHlwZSBpcyBwYXNzZWQgaW4sIHdlIGlnbm9yZSB0aGUgVHlwZSBwcm9wZXJ0eSBvbiB0aGUgZGVmaW5pdGlvbiBpZiBpdCBleGlzdHMuXG4gICAgICAgIC8vIFRPRE86IGRvY3VtZW50IHRoaXMgYmVoYXZpb3JcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JEZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uKFR5cGUsIG5hbWVPckRlZiwgbWVyZ2VBcnJheXMoQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdhbGlhc2VzJyksIFR5cGUuYWxpYXNlcyksIEN1c3RvbUVsZW1lbnQua2V5RnJvbShuYW1lT3JEZWYpLCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCgnY2FjaGUnLCBUeXBlLCAoKSA9PiAwKSwgZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQoJ3RlbXBsYXRlJywgVHlwZSwgKCkgPT4gbnVsbCksIG1lcmdlQXJyYXlzKEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnaW5zdHJ1Y3Rpb25zJyksIFR5cGUuaW5zdHJ1Y3Rpb25zKSwgbWVyZ2VBcnJheXMoQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdkZXBlbmRlbmNpZXMnKSwgVHlwZS5kZXBlbmRlbmNpZXMpLCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCgnaW5qZWN0YWJsZScsIFR5cGUsICgpID0+IG51bGwpLCBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCgnbmVlZHNDb21waWxlJywgVHlwZSwgKCkgPT4gdHJ1ZSksIG1lcmdlQXJyYXlzKEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnc3Vycm9nYXRlcycpLCBUeXBlLnN1cnJvZ2F0ZXMpLCBCaW5kYWJsZS5mcm9tKC4uLkJpbmRhYmxlLmdldEFsbChUeXBlKSwgQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdiaW5kYWJsZXMnKSwgVHlwZS5iaW5kYWJsZXMpLCBDaGlsZHJlbi5mcm9tKC4uLkNoaWxkcmVuLmdldEFsbChUeXBlKSwgQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdjaGlsZHJlbk9ic2VydmVycycpLCBUeXBlLmNoaWxkcmVuT2JzZXJ2ZXJzKSwgZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQoJ2NvbnRhaW5lcmxlc3MnLCBUeXBlLCAoKSA9PiBmYWxzZSksIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KCdpc1N0cmljdEJpbmRpbmcnLCBUeXBlLCAoKSA9PiBmYWxzZSksIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KCdzaGFkb3dPcHRpb25zJywgVHlwZSwgKCkgPT4gbnVsbCksIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KCdoYXNTbG90cycsIFR5cGUsICgpID0+IGZhbHNlKSwgZnJvbUFubm90YXRpb25PclR5cGVPckRlZmF1bHQoJ2VuaGFuY2UnLCBUeXBlLCAoKSA9PiBmYWxzZSksIGZyb21Bbm5vdGF0aW9uT3JUeXBlT3JEZWZhdWx0KCdwcm9qZWN0aW9uc01hcCcsIFR5cGUsICgpID0+IG5ldyBNYXAoKSksIG1lcmdlQXJyYXlzKFdhdGNoLmdldEFubm90YXRpb24oVHlwZSksIFR5cGUud2F0Y2hlcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHR5cGljYWwgZGVmYXVsdCBiZWhhdmlvciwgZS5nLiBmcm9tIHJlZ3VsYXIgQ3VzdG9tRWxlbWVudC5kZWZpbmUgaW52b2NhdGlvbnMgb3IgZnJvbSBAY3VzdG9tRWxlbWVudCBkZWNvXG4gICAgICAgIC8vIFRoZSBWaWV3VmFsdWVDb252ZXJ0ZXIgYWxzbyB1c2VzIHRoaXMgc2lnbmF0dXJlIGFuZCBwYXNzZXMgaW4gYSBkZWZpbml0aW9uIHdoZXJlIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgJ2hvb2tzJ1xuICAgICAgICAvLyBwcm9wZXJ0eSBuZWVkcyB0byBiZSBjb3BpZWQuIFNvIHdlIGhhdmUgdGhhdCBleGNlcHRpb24gZm9yICdob29rcycsIGJ1dCB3ZSBtYXkgbmVlZCB0byByZXZpc2l0IHRoYXQgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAvLyBpZiB0aGlzIHR1cm5zIG91dCB0byBiZSB0b28gb3BpbmlvbmF0ZWQuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcm9tRGVmaW5pdGlvbk9yRGVmYXVsdCgnbmFtZScsIG5hbWVPckRlZiwgQ3VzdG9tRWxlbWVudC5nZW5lcmF0ZU5hbWUpO1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uKFR5cGUsIG5hbWUsIG1lcmdlQXJyYXlzKEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYWxpYXNlcycpLCBuYW1lT3JEZWYuYWxpYXNlcywgVHlwZS5hbGlhc2VzKSwgQ3VzdG9tRWxlbWVudC5rZXlGcm9tKG5hbWUpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgnY2FjaGUnLCBuYW1lT3JEZWYsIFR5cGUsICgpID0+IDApLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgndGVtcGxhdGUnLCBuYW1lT3JEZWYsIFR5cGUsICgpID0+IG51bGwpLCBtZXJnZUFycmF5cyhDdXN0b21FbGVtZW50LmdldEFubm90YXRpb24oVHlwZSwgJ2luc3RydWN0aW9ucycpLCBuYW1lT3JEZWYuaW5zdHJ1Y3Rpb25zLCBUeXBlLmluc3RydWN0aW9ucyksIG1lcmdlQXJyYXlzKEN1c3RvbUVsZW1lbnQuZ2V0QW5ub3RhdGlvbihUeXBlLCAnZGVwZW5kZW5jaWVzJyksIG5hbWVPckRlZi5kZXBlbmRlbmNpZXMsIFR5cGUuZGVwZW5kZW5jaWVzKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ2luamVjdGFibGUnLCBuYW1lT3JEZWYsIFR5cGUsICgpID0+IG51bGwpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgnbmVlZHNDb21waWxlJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiB0cnVlKSwgbWVyZ2VBcnJheXMoQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdzdXJyb2dhdGVzJyksIG5hbWVPckRlZi5zdXJyb2dhdGVzLCBUeXBlLnN1cnJvZ2F0ZXMpLCBCaW5kYWJsZS5mcm9tKC4uLkJpbmRhYmxlLmdldEFsbChUeXBlKSwgQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdiaW5kYWJsZXMnKSwgVHlwZS5iaW5kYWJsZXMsIG5hbWVPckRlZi5iaW5kYWJsZXMpLCBDaGlsZHJlbi5mcm9tKC4uLkNoaWxkcmVuLmdldEFsbChUeXBlKSwgQ3VzdG9tRWxlbWVudC5nZXRBbm5vdGF0aW9uKFR5cGUsICdjaGlsZHJlbk9ic2VydmVycycpLCBUeXBlLmNoaWxkcmVuT2JzZXJ2ZXJzLCBuYW1lT3JEZWYuY2hpbGRyZW5PYnNlcnZlcnMpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgnY29udGFpbmVybGVzcycsIG5hbWVPckRlZiwgVHlwZSwgKCkgPT4gZmFsc2UpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgnaXNTdHJpY3RCaW5kaW5nJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiBmYWxzZSksIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0KCdzaGFkb3dPcHRpb25zJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiBudWxsKSwgZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQoJ2hhc1Nsb3RzJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiBmYWxzZSksIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0KCdlbmhhbmNlJywgbmFtZU9yRGVmLCBUeXBlLCAoKSA9PiBmYWxzZSksIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0KCdwcm9qZWN0aW9uc01hcCcsIG5hbWVPckRlZiwgVHlwZSwgKCkgPT4gbmV3IE1hcCgpKSwgbWVyZ2VBcnJheXMobmFtZU9yRGVmLndhdGNoZXMsIFdhdGNoLmdldEFubm90YXRpb24oVHlwZSksIFR5cGUud2F0Y2hlcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0T3JDcmVhdGUocGFydGlhbERlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKHBhcnRpYWxEZWZpbml0aW9uIGluc3RhbmNlb2YgQ3VzdG9tRWxlbWVudERlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsRGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbkxvb2t1cC5oYXMocGFydGlhbERlZmluaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbkxvb2t1cC5nZXQocGFydGlhbERlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5jcmVhdGUocGFydGlhbERlZmluaXRpb24pO1xuICAgICAgICBkZWZpbml0aW9uTG9va3VwLnNldChwYXJ0aWFsRGVmaW5pdGlvbiwgZGVmaW5pdGlvbik7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnVsbCBkZWZpbml0aW9uIGNhbiBiZSByZXRyaWV2ZWQgZnJvbSBkeW5hbWljYWxseSBjcmVhdGVkIGNsYXNzZXMgYXMgd2VsbFxuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ3VzdG9tRWxlbWVudC5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLlR5cGUpO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHsgVHlwZSwga2V5LCBhbGlhc2VzIH0gPSB0aGlzO1xuICAgICAgICBSZWdpc3RyYXRpb24udHJhbnNpZW50KGtleSwgVHlwZSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgUmVnaXN0cmF0aW9uLmFsaWFzVG8oa2V5LCBUeXBlKS5yZWdpc3Rlcihjb250YWluZXIpO1xuICAgICAgICByZWdpc3RlckFsaWFzZXMoYWxpYXNlcywgQ3VzdG9tRWxlbWVudCwga2V5LCBjb250YWluZXIpO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRGb3JPcHRzID0ge1xuICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICBzZWFyY2hQYXJlbnRzOiBmYWxzZSxcbiAgICBvcHRpb25hbDogZmFsc2UsXG59O1xuZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnQgPSB7XG4gICAgbmFtZTogUHJvdG9jb2wucmVzb3VyY2Uua2V5Rm9yKCdjdXN0b20tZWxlbWVudCcpLFxuICAgIGtleUZyb20obmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7Q3VzdG9tRWxlbWVudC5uYW1lfToke25hbWV9YDtcbiAgICB9LFxuICAgIGlzVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIE1ldGFkYXRhLmhhc093bihDdXN0b21FbGVtZW50Lm5hbWUsIHZhbHVlKTtcbiAgICB9LFxuICAgIGZvcihub2RlLCBvcHRzID0gZGVmYXVsdEZvck9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubmFtZSA9PT0gdm9pZCAwICYmIG9wdHMuc2VhcmNoUGFyZW50cyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE1ldGFkYXRhLmdldE93bihDdXN0b21FbGVtZW50Lm5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLm9wdGlvbmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwcm92aWRlZCBub2RlIGlzIG5vdCBhIGN1c3RvbSBlbGVtZW50IG9yIGNvbnRhaW5lcmxlc3MgaG9zdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm5hbWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuc2VhcmNoUGFyZW50cyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBNZXRhZGF0YS5nZXRPd24oQ3VzdG9tRWxlbWVudC5uYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHByb3ZpZGVkIG5vZGUgaXMgbm90IGEgY3VzdG9tIGVsZW1lbnQgb3IgY29udGFpbmVybGVzcyBob3N0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pcyhvcHRzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VyID0gbm9kZTtcbiAgICAgICAgICAgIGxldCBmb3VuZEFDb250cm9sbGVyID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoY3VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE1ldGFkYXRhLmdldE93bihDdXN0b21FbGVtZW50Lm5hbWUsIGN1cik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEFDb250cm9sbGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXMob3B0cy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyID0gZ2V0RWZmZWN0aXZlUGFyZW50Tm9kZShjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kQUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwcm92aWRlZCBub2RlIGRvZXMgZG9lcyBub3QgYXBwZWFyIHRvIGJlIHBhcnQgb2YgYW4gQXVyZWxpYSBhcHAgRE9NIHRyZWUsIG9yIGl0IHdhcyBhZGRlZCB0byB0aGUgRE9NIGluIGEgd2F5IHRoYXQgQXVyZWxpYSBjYW5ub3QgcHJvcGVybHkgcmVzb2x2ZSBpdHMgcG9zaXRpb24gaW4gdGhlIGNvbXBvbmVudCB0cmVlLmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXIgPSBub2RlO1xuICAgICAgICB3aGlsZSAoY3VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gTWV0YWRhdGEuZ2V0T3duKEN1c3RvbUVsZW1lbnQubmFtZSwgY3VyKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGdldEVmZmVjdGl2ZVBhcmVudE5vZGUoY3VyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwcm92aWRlZCBub2RlIGRvZXMgZG9lcyBub3QgYXBwZWFyIHRvIGJlIHBhcnQgb2YgYW4gQXVyZWxpYSBhcHAgRE9NIHRyZWUsIG9yIGl0IHdhcyBhZGRlZCB0byB0aGUgRE9NIGluIGEgd2F5IHRoYXQgQXVyZWxpYSBjYW5ub3QgcHJvcGVybHkgcmVzb2x2ZSBpdHMgcG9zaXRpb24gaW4gdGhlIGNvbXBvbmVudCB0cmVlLmApO1xuICAgIH0sXG4gICAgZGVmaW5lKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uY3JlYXRlKG5hbWVPckRlZiwgVHlwZSk7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShDdXN0b21FbGVtZW50Lm5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb24uVHlwZSk7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShDdXN0b21FbGVtZW50Lm5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICBQcm90b2NvbC5yZXNvdXJjZS5hcHBlbmRUbyhkZWZpbml0aW9uLlR5cGUsIEN1c3RvbUVsZW1lbnQubmFtZSk7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLlR5cGU7XG4gICAgfSxcbiAgICBnZXREZWZpbml0aW9uKFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmID0gTWV0YWRhdGEuZ2V0T3duKEN1c3RvbUVsZW1lbnQubmFtZSwgVHlwZSk7XG4gICAgICAgIGlmIChkZWYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZWZpbml0aW9uIGZvdW5kIGZvciB0eXBlICR7VHlwZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfSxcbiAgICBhbm5vdGF0ZShUeXBlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIHZhbHVlLCBUeXBlKTtcbiAgICB9LFxuICAgIGdldEFubm90YXRpb24oVHlwZSwgcHJvcCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKHByb3ApLCBUeXBlKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlTmFtZTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGlkID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBgdW5uYW1lZC0keysraWR9YDtcbiAgICAgICAgfTtcbiAgICB9KSgpLFxuICAgIGNyZWF0ZUluamVjdGFibGUoKSB7XG4gICAgICAgIGNvbnN0ICRpbmplY3RhYmxlID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uUGFyYW10eXBlcyA9IERJLmdldE9yQ3JlYXRlQW5ub3RhdGlvblBhcmFtVHlwZXModGFyZ2V0KTtcbiAgICAgICAgICAgIGFubm90YXRpb25QYXJhbXR5cGVzW2luZGV4XSA9ICRpbmplY3RhYmxlO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfTtcbiAgICAgICAgJGluamVjdGFibGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoY29udGFpbmVyLCByZXF1ZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Rvci5oYXMoJGluamVjdGFibGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdG9yLmdldCgkaW5qZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJGluamVjdGFibGU7XG4gICAgfSxcbiAgICBnZW5lcmF0ZVR5cGU6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcm90byA9IHt9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUsIHByb3RvID0gZGVmYXVsdFByb3RvKSB7XG4gICAgICAgICAgICAvLyBBbm9ueW1vdXMgY2xhc3MgZW5zdXJlcyB0aGF0IG1pbmlmaWNhdGlvbiBjYW5ub3QgY2F1c2UgdW5pbnRlbmRlZCBzaWRlLWVmZmVjdHMsIGFuZCBrZWVwcyB0aGUgY2xhc3NcbiAgICAgICAgICAgIC8vIGxvb2tpbmcgc2ltaWxhcmx5IGZyb20gdGhlIG91dHNpZGUgKHdoZW4gaW5zcGVjdGVkIHZpYSBkZWJ1Z2dlciwgZXRjKS5cbiAgICAgICAgICAgIGNvbnN0IFR5cGUgPSBjbGFzcyB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gRGVmaW5lIHRoZSBuYW1lIHByb3BlcnR5IHNvIHRoYXQgVHlwZS5uYW1lIGNhbiBiZSB1c2VkIGJ5IGVuZCB1c2VycyAvIHBsdWdpbiBhdXRob3JzIGlmIHRoZXkgcmVhbGx5IG5lZWQgdG8sXG4gICAgICAgICAgICAvLyBldmVuIHdoZW4gbWluaWZpZWQuXG4gICAgICAgICAgICBuYW1lRGVzY3JpcHRvci52YWx1ZSA9IG5hbWU7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KFR5cGUsICduYW1lJywgbmFtZURlc2NyaXB0b3IpO1xuICAgICAgICAgICAgLy8gQXNzaWduIGFueXRoaW5nIGZyb20gdGhlIHByb3RvdHlwZSB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgICAgICAgIGlmIChwcm90byAhPT0gZGVmYXVsdFByb3RvKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihUeXBlLnByb3RvdHlwZSwgcHJvdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFR5cGU7XG4gICAgICAgIH07XG4gICAgfSkoKSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXN0b20tZWxlbWVudC5qcy5tYXAiLCJpbXBvcnQgeyBESSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCB9IGZyb20gJy4uL2N1c3RvbS1lbGVtZW50LmpzJztcbmltcG9ydCB7IElWaWV3RmFjdG9yeSB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvdmlldy5qcyc7XG5leHBvcnQgY29uc3QgSVByb2plY3Rpb25zID0gREkuY3JlYXRlSW50ZXJmYWNlKFwiSVByb2plY3Rpb25zXCIpO1xuZXhwb3J0IHZhciBBdVNsb3RDb250ZW50VHlwZTtcbihmdW5jdGlvbiAoQXVTbG90Q29udGVudFR5cGUpIHtcbiAgICBBdVNsb3RDb250ZW50VHlwZVtBdVNsb3RDb250ZW50VHlwZVtcIlByb2plY3Rpb25cIl0gPSAwXSA9IFwiUHJvamVjdGlvblwiO1xuICAgIEF1U2xvdENvbnRlbnRUeXBlW0F1U2xvdENvbnRlbnRUeXBlW1wiRmFsbGJhY2tcIl0gPSAxXSA9IFwiRmFsbGJhY2tcIjtcbn0pKEF1U2xvdENvbnRlbnRUeXBlIHx8IChBdVNsb3RDb250ZW50VHlwZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgU2xvdEluZm8ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIHByb2plY3Rpb25Db250ZXh0KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbkNvbnRleHQgPSBwcm9qZWN0aW9uQ29udGV4dDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJvamVjdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQsIHNjb3BlID0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlZ2lzdGVyZWRQcm9qZWN0aW9ucyB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUsIHByb2plY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9ucyA9IHByb2plY3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJUHJvamVjdGlvblByb3ZpZGVyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJUHJvamVjdGlvblByb3ZpZGVyJywgeCA9PiB4LnNpbmdsZXRvbihQcm9qZWN0aW9uUHJvdmlkZXIpKTtcbmNvbnN0IHByb2plY3Rpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNsYXNzIFByb2plY3Rpb25Qcm92aWRlciB7XG4gICAgcmVnaXN0ZXJQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucywgc2NvcGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdHJ1Y3Rpb24sICRwcm9qZWN0aW9uc10gb2YgcHJvamVjdGlvbnMpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXAuc2V0KGluc3RydWN0aW9uLCBuZXcgUmVnaXN0ZXJlZFByb2plY3Rpb25zKHNjb3BlLCAkcHJvamVjdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRQcm9qZWN0aW9uRm9yKGluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uTWFwLmdldChpbnN0cnVjdGlvbikgPz8gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXVTbG90IHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLmhvc3RTY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlldyA9IGZhY3RvcnkuY3JlYXRlKCkuc2V0TG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgICB0aGlzLmlzUHJvamVjdGlvbiA9IGZhY3RvcnkuY29udGVudFR5cGUgPT09IEF1U2xvdENvbnRlbnRUeXBlLlByb2plY3Rpb247XG4gICAgICAgIHRoaXMub3V0ZXJTY29wZSA9IGZhY3RvcnkucHJvamVjdGlvblNjb3BlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGluamVjdCgpIHsgcmV0dXJuIFtJVmlld0ZhY3RvcnksIElSZW5kZXJMb2NhdGlvbl07IH1cbiAgICBiaW5kaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICB0aGlzLmhvc3RTY29wZSA9IHRoaXMuJGNvbnRyb2xsZXIuc2NvcGUucGFyZW50U2NvcGU7XG4gICAgfVxuICAgIGF0dGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5hY3RpdmF0ZShpbml0aWF0b3IsICRjb250cm9sbGVyLCBmbGFncywgdGhpcy5vdXRlclNjb3BlID8/IHRoaXMuaG9zdFNjb3BlLCB0aGlzLmhvc3RTY29wZSk7XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciwgdGhpcy4kY29udHJvbGxlciwgZmxhZ3MpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnZpZXcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldz8uYWNjZXB0KHZpc2l0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmN1c3RvbUVsZW1lbnQoeyBuYW1lOiAnYXUtc2xvdCcsIHRlbXBsYXRlOiBudWxsLCBjb250YWluZXJsZXNzOiB0cnVlIH0pKEF1U2xvdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdS1zbG90LmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuaW1wb3J0IHsgbmV4dElkLCBvblJlc29sdmUgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQmluZGluZ01vZGUgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi8uLi9jcmVhdGUtZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBJSW5zdHJ1Y3Rpb24gfSBmcm9tICcuLi8uLi9yZW5kZXJlci5qcyc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS5qcyc7XG5pbXBvcnQgeyBnZXRSZW5kZXJDb250ZXh0IH0gZnJvbSAnLi4vLi4vdGVtcGxhdGluZy9yZW5kZXItY29udGV4dC5qcyc7XG5pbXBvcnQgeyBjdXN0b21FbGVtZW50LCBDdXN0b21FbGVtZW50RGVmaW5pdGlvbiB9IGZyb20gJy4uL2N1c3RvbS1lbGVtZW50LmpzJztcbmltcG9ydCB7IGJpbmRhYmxlIH0gZnJvbSAnLi4vLi4vYmluZGFibGUuanMnO1xuZnVuY3Rpb24gdG9Mb29rdXAoYWNjLCBpdGVtKSB7XG4gICAgY29uc3QgdG8gPSBpdGVtLnRvO1xuICAgIGlmICh0byAhPT0gdm9pZCAwICYmIHRvICE9PSAnc3ViamVjdCcgJiYgdG8gIT09ICdjb21wb3NpbmcnKSB7XG4gICAgICAgIGFjY1t0b10gPSBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxubGV0IENvbXBvc2UgPSBjbGFzcyBDb21wb3NlIHtcbiAgICBjb25zdHJ1Y3RvcihwLCBpbnN0cnVjdGlvbikge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXcgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubGFzdFN1YmplY3QgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IGluc3RydWN0aW9uLmluc3RydWN0aW9ucy5yZWR1Y2UodG9Mb29rdXAsIHt9KTtcbiAgICB9XG4gICAgYXR0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICBjb25zdCB7IHN1YmplY3QsIHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmICh2aWV3ID09PSB2b2lkIDAgfHwgdGhpcy5sYXN0U3ViamVjdCAhPT0gc3ViamVjdCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NlKHZvaWQgMCwgc3ViamVjdCwgaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zZSh2aWV3LCBzdWJqZWN0LCBpbml0aWF0b3IsIGZsYWdzKTtcbiAgICB9XG4gICAgZGV0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWFjdGl2YXRlKHRoaXMudmlldywgaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgfVxuICAgIHN1YmplY3RDaGFuZ2VkKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykge1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoISRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFzdFN1YmplY3QgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0U3ViamVjdCA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IHRydWU7XG4gICAgICAgIGZsYWdzIHw9ICRjb250cm9sbGVyLmZsYWdzO1xuICAgICAgICBjb25zdCByZXQgPSBvblJlc29sdmUodGhpcy5kZWFjdGl2YXRlKHRoaXMudmlldywgbnVsbCwgZmxhZ3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogaGFuZGxlICYgdGVzdCByYWNlIGNvbmRpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zZSh2b2lkIDAsIG5ld1ZhbHVlLCBudWxsLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0LmNhdGNoKGVyciA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9zZSh2aWV3LCBzdWJqZWN0LCBpbml0aWF0b3IsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBvblJlc29sdmUodmlldyA9PT0gdm9pZCAwXG4gICAgICAgICAgICA/IG9uUmVzb2x2ZShzdWJqZWN0LCByZXNvbHZlZFN1YmplY3QgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVWaWV3KHJlc29sdmVkU3ViamVjdCwgZmxhZ3MpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdmlldywgcmVzb2x2ZWRWaWV3ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlKHJlc29sdmVkVmlldywgaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWFjdGl2YXRlKHZpZXcsIGluaXRpYXRvciwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHZpZXc/LmRlYWN0aXZhdGUoaW5pdGlhdG9yID8/IHZpZXcsIHRoaXMuJGNvbnRyb2xsZXIsIGZsYWdzKTtcbiAgICB9XG4gICAgYWN0aXZhdGUodmlldywgaW5pdGlhdG9yLCBmbGFncykge1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gb25SZXNvbHZlKHZpZXc/LmFjdGl2YXRlKGluaXRpYXRvciA/PyB2aWV3LCAkY29udHJvbGxlciwgZmxhZ3MsICRjb250cm9sbGVyLnNjb3BlLCAkY29udHJvbGxlci5ob3N0U2NvcGUpLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZVZpZXcoc3ViamVjdCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMucHJvdmlkZVZpZXdGb3Ioc3ViamVjdCwgZmxhZ3MpO1xuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmlldy5zZXRMb2NhdGlvbih0aGlzLiRjb250cm9sbGVyLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZpZXcubG9ja1Njb3BlKHRoaXMuJGNvbnRyb2xsZXIuc2NvcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcHJvdmlkZVZpZXdGb3Ioc3ViamVjdCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbnRyb2xsZXIoc3ViamVjdCkpIHsgLy8gSUNvbnRyb2xsZXJcbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICgnY3JlYXRlVmlldycgaW4gc3ViamVjdCkgeyAvLyBSZW5kZXJQbGFuXG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdC5jcmVhdGVWaWV3KHRoaXMuJGNvbnRyb2xsZXIuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjcmVhdGUnIGluIHN1YmplY3QpIHsgLy8gSVZpZXdGYWN0b3J5XG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdC5jcmVhdGUoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgndGVtcGxhdGUnIGluIHN1YmplY3QpIHsgLy8gUmF3IFRlbXBsYXRlIERlZmluaXRpb25cbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5nZXRPckNyZWF0ZShzdWJqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZW5kZXJDb250ZXh0KGRlZmluaXRpb24sIHRoaXMuJGNvbnRyb2xsZXIuY29udGV4dCkuZ2V0Vmlld0ZhY3RvcnkoKS5jcmVhdGUoZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0cnVjdGFibGUgKEN1c3RvbSBFbGVtZW50IENvbnN0cnVjdG9yKVxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0aGlzLnAsIHN1YmplY3QsIHRoaXMucHJvcGVydGllcywgdGhpcy4kY29udHJvbGxlci5ob3N0LmNoaWxkTm9kZXMpLmNyZWF0ZVZpZXcodGhpcy4kY29udHJvbGxlci5jb250ZXh0KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy52aWV3Py5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmlldyA9ICh2b2lkIDApO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy52aWV3Py5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBDb21wb3NlLnByb3RvdHlwZSwgXCJzdWJqZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSh7IG1vZGU6IEJpbmRpbmdNb2RlLmZyb21WaWV3IH0pXG5dLCBDb21wb3NlLnByb3RvdHlwZSwgXCJjb21wb3NpbmdcIiwgdm9pZCAwKTtcbkNvbXBvc2UgPSBfX2RlY29yYXRlKFtcbiAgICBjdXN0b21FbGVtZW50KHsgbmFtZTogJ2F1LWNvbXBvc2UnLCB0ZW1wbGF0ZTogbnVsbCwgY29udGFpbmVybGVzczogdHJ1ZSB9KSxcbiAgICBfX3BhcmFtKDAsIElQbGF0Zm9ybSksXG4gICAgX19wYXJhbSgxLCBJSW5zdHJ1Y3Rpb24pXG5dLCBDb21wb3NlKTtcbmV4cG9ydCB7IENvbXBvc2UgfTtcbmZ1bmN0aW9uIGlzQ29udHJvbGxlcihzdWJqZWN0KSB7XG4gICAgcmV0dXJuICdsb2NrU2NvcGUnIGluIHN1YmplY3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb3NlLmpzLm1hcCIsImltcG9ydCB7IG5leHRJZCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHsgSVZpZXdGYWN0b3J5IH0gZnJvbSAnLi4vLi4vdGVtcGxhdGluZy92aWV3LmpzJztcbmltcG9ydCB7IHRlbXBsYXRlQ29udHJvbGxlciB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuY2xhc3MgRmxhZ3NUZW1wbGF0ZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnksIGxvY2F0aW9uLCBmbGFncykge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SWQoJ2F1JGNvbXBvbmVudCcpO1xuICAgICAgICB0aGlzLnZpZXcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKCkuc2V0TG9jYXRpb24obG9jYXRpb24pO1xuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuYWN0aXZhdGUoaW5pdGlhdG9yLCAkY29udHJvbGxlciwgZmxhZ3MgfCB0aGlzLmZsYWdzLCAkY29udHJvbGxlci5zY29wZSwgJGNvbnRyb2xsZXIuaG9zdFNjb3BlKTtcbiAgICB9XG4gICAgZGV0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRlYWN0aXZhdGUoaW5pdGlhdG9yLCB0aGlzLiRjb250cm9sbGVyLCBmbGFncyk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMudmlldy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmlldyA9ICh2b2lkIDApO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy52aWV3Py5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZyZXF1ZW50TXV0YXRpb25zIGV4dGVuZHMgRmxhZ3NUZW1wbGF0ZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnksIGxvY2F0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZhY3RvcnksIGxvY2F0aW9uLCA4MTkyIC8qIHBlcnNpc3RlbnRUYXJnZXRPYnNlcnZlclF1ZXVlICovKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5GcmVxdWVudE11dGF0aW9ucy5pbmplY3QgPSBbSVZpZXdGYWN0b3J5LCBJUmVuZGVyTG9jYXRpb25dO1xuZXhwb3J0IGNsYXNzIE9ic2VydmVTaGFsbG93IGV4dGVuZHMgRmxhZ3NUZW1wbGF0ZUNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcnksIGxvY2F0aW9uKSB7XG4gICAgICAgIHN1cGVyKGZhY3RvcnksIGxvY2F0aW9uLCAyMDQ4IC8qIG9ic2VydmVMZWFmUHJvcGVydGllc09ubHkgKi8pO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbk9ic2VydmVTaGFsbG93LmluamVjdCA9IFtJVmlld0ZhY3RvcnksIElSZW5kZXJMb2NhdGlvbl07XG50ZW1wbGF0ZUNvbnRyb2xsZXIoJ2ZyZXF1ZW50LW11dGF0aW9ucycpKEZyZXF1ZW50TXV0YXRpb25zKTtcbnRlbXBsYXRlQ29udHJvbGxlcignb2JzZXJ2ZS1zaGFsbG93JykoT2JzZXJ2ZVNoYWxsb3cpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmxhZ3MuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBuZXh0SWQsIG9uUmVzb2x2ZSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHsgSVZpZXdGYWN0b3J5IH0gZnJvbSAnLi4vLi4vdGVtcGxhdGluZy92aWV3LmpzJztcbmltcG9ydCB7IHRlbXBsYXRlQ29udHJvbGxlciB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tICcuLi8uLi9iaW5kYWJsZS5qcyc7XG5sZXQgSWYgPSBjbGFzcyBJZiB7XG4gICAgY29uc3RydWN0b3IoaWZGYWN0b3J5LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlmRmFjdG9yeSA9IGlmRmFjdG9yeTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5lbHNlRmFjdG9yeSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5lbHNlVmlldyA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5pZlZpZXcgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudmlldyA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXcgPSB0aGlzLnVwZGF0ZVZpZXcodGhpcy52YWx1ZSwgZmxhZ3MpO1xuICAgICAgICBpZiAodmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuYWN0aXZhdGUoaW5pdGlhdG9yLCAkY29udHJvbGxlciwgZmxhZ3MsICRjb250cm9sbGVyLnNjb3BlLCAkY29udHJvbGxlci5ob3N0U2NvcGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRlYWN0aXZhdGUoaW5pdGlhdG9yLCB0aGlzLiRjb250cm9sbGVyLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKCEkY29udHJvbGxlci5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IG9uUmVzb2x2ZSh0aGlzLnZpZXc/LmRlYWN0aXZhdGUodGhpcy52aWV3LCAkY29udHJvbGxlciwgZmxhZ3MpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy52aWV3ID0gdGhpcy51cGRhdGVWaWV3KHRoaXMudmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgIGlmICh2aWV3ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogYWRkIGxvZ2ljIHRvIHRoZSBjb250cm9sbGVyIHRoYXQgZW5zdXJlcyBjb3JyZWN0IGhhbmRsaW5nIG9mIHJhY2UgY29uZGl0aW9ucyBhbmQgYWRkIGEgdmFyaWV0eSBvZiBgaWZgIGludGVncmF0aW9uIHRlc3RzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXcuYWN0aXZhdGUodmlldywgJGNvbnRyb2xsZXIsIGZsYWdzLCAkY29udHJvbGxlci5zY29wZSwgJGNvbnRyb2xsZXIuaG9zdFNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXQuY2F0Y2goZXJyID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgdXBkYXRlVmlldyh2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZlZpZXcgPSB0aGlzLmVuc3VyZVZpZXcodGhpcy5pZlZpZXcsIHRoaXMuaWZGYWN0b3J5LCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWxzZUZhY3RvcnkgIT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbHNlVmlldyA9IHRoaXMuZW5zdXJlVmlldyh0aGlzLmVsc2VWaWV3LCB0aGlzLmVsc2VGYWN0b3J5LCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGVuc3VyZVZpZXcodmlldywgZmFjdG9yeSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmlldyA9IGZhY3RvcnkuY3JlYXRlKGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnNldExvY2F0aW9uKHRoaXMubG9jYXRpb24pO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWZWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuaWZWaWV3LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaWZWaWV3ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsc2VWaWV3ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuZWxzZVZpZXcuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5lbHNlVmlldyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcgPSB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXc/LmFjY2VwdCh2aXNpdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIElmLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuSWYgPSBfX2RlY29yYXRlKFtcbiAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ2lmJyksXG4gICAgX19wYXJhbSgwLCBJVmlld0ZhY3RvcnkpLFxuICAgIF9fcGFyYW0oMSwgSVJlbmRlckxvY2F0aW9uKVxuXSwgSWYpO1xuZXhwb3J0IHsgSWYgfTtcbmxldCBFbHNlID0gY2xhc3MgRWxzZSB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICB9XG4gICAgbGluayhmbGFncywgcGFyZW50Q29udGV4dCwgY29udHJvbGxlciwgX2NoaWxkQ29udHJvbGxlciwgX3RhcmdldCwgX2luc3RydWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY29udHJvbGxlci5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaWZCZWhhdmlvciA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaWZCZWhhdmlvciBpbnN0YW5jZW9mIElmKSB7XG4gICAgICAgICAgICBpZkJlaGF2aW9yLmVsc2VGYWN0b3J5ID0gdGhpcy5mYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlmQmVoYXZpb3Iudmlld01vZGVsIGluc3RhbmNlb2YgSWYpIHtcbiAgICAgICAgICAgIGlmQmVoYXZpb3Iudmlld01vZGVsLmVsc2VGYWN0b3J5ID0gdGhpcy5mYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBJZkJlaGF2aW9yYCk7IC8vIFRPRE86IGNyZWF0ZSBlcnJvciBjb2RlXG4gICAgICAgIH1cbiAgICB9XG59O1xuRWxzZSA9IF9fZGVjb3JhdGUoW1xuICAgIHRlbXBsYXRlQ29udHJvbGxlcih7IG5hbWU6ICdlbHNlJyB9KSxcbiAgICBfX3BhcmFtKDAsIElWaWV3RmFjdG9yeSlcbl0sIEVsc2UpO1xuZXhwb3J0IHsgRWxzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBuZXh0SWQsIG9uUmVzb2x2ZSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJUmVuZGVyTG9jYXRpb24sIHNldEVmZmVjdGl2ZVBhcmVudE5vZGUgfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgSVZpZXdGYWN0b3J5IH0gZnJvbSAnLi4vLi4vdGVtcGxhdGluZy92aWV3LmpzJztcbmltcG9ydCB7IHRlbXBsYXRlQ29udHJvbGxlciB9IGZyb20gJy4uL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tICcuLi8uLi9iaW5kYWJsZS5qcyc7XG5sZXQgUG9ydGFsID0gY2xhc3MgUG9ydGFsIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBvcmlnaW5hbExvYywgcCkge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLm9yaWdpbmFsTG9jID0gb3JpZ2luYWxMb2M7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SWQoJ2F1JGNvbXBvbmVudCcpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICAvLyB0byBtYWtlIHRoZSBzaGFwZSBvZiB0aGlzIG9iamVjdCBjb25zaXN0ZW50LlxuICAgICAgICAvLyB0b2RvOiBpcyB0aGlzIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBwLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnZpZXcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKCk7XG4gICAgICAgIHNldEVmZmVjdGl2ZVBhcmVudE5vZGUodGhpcy52aWV3Lm5vZGVzLCBvcmlnaW5hbExvYyk7XG4gICAgfVxuICAgIGF0dGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tDb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gdGhpcy4kY29udHJvbGxlci5zY29wZS5iaW5kaW5nQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdUYXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0aGlzLnJlc29sdmVUYXJnZXQoKTtcbiAgICAgICAgdGhpcy52aWV3LnNldEhvc3QobmV3VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGFjdGl2YXRpbmcoaW5pdGlhdG9yLCBuZXdUYXJnZXQsIGZsYWdzKTtcbiAgICB9XG4gICAgZGV0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICByZXR1cm4gdGhpcy4kZGVhY3RpdmF0aW5nKGluaXRpYXRvciwgdGhpcy5jdXJyZW50VGFyZ2V0LCBmbGFncyk7XG4gICAgfVxuICAgIHRhcmdldENoYW5nZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmICghJGNvbnRyb2xsZXIuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRUYXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IG5ld1RhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldCA9IHRoaXMucmVzb2x2ZVRhcmdldCgpO1xuICAgICAgICBpZiAob2xkVGFyZ2V0ID09PSBuZXdUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcuc2V0SG9zdChuZXdUYXJnZXQpO1xuICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogZml4IGFuZCB0ZXN0IHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uXG4gICAgICAgIGNvbnN0IHJldCA9IG9uUmVzb2x2ZSh0aGlzLiRkZWFjdGl2YXRpbmcobnVsbCwgbmV3VGFyZ2V0LCAkY29udHJvbGxlci5mbGFncyksICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRhY3RpdmF0aW5nKG51bGwsIG5ld1RhcmdldCwgJGNvbnRyb2xsZXIuZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldC5jYXRjaChlcnIgPT4geyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgICRhY3RpdmF0aW5nKGluaXRpYXRvciwgdGFyZ2V0LCBmbGFncykge1xuICAgICAgICBjb25zdCB7IGFjdGl2YXRpbmcsIGNhbGxiYWNrQ29udGV4dCwgdmlldyB9ID0gdGhpcztcbiAgICAgICAgdmlldy5zZXRIb3N0KHRhcmdldCk7XG4gICAgICAgIHJldHVybiBvblJlc29sdmUoYWN0aXZhdGluZz8uY2FsbChjYWxsYmFja0NvbnRleHQsIHRhcmdldCwgdmlldyksICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlKGluaXRpYXRvciwgdGFyZ2V0LCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY3RpdmF0ZShpbml0aWF0b3IsIHRhcmdldCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciwgdmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGluaXRpYXRvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmlldy5ub2Rlcy5hcHBlbmRUbyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGZpeCBhbmQgdGVzdCBwb3NzaWJsZSByYWNlIGNvbmRpdGlvblxuICAgICAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSh2aWV3LmFjdGl2YXRlKGluaXRpYXRvciA/PyB2aWV3LCAkY29udHJvbGxlciwgZmxhZ3MsICRjb250cm9sbGVyLnNjb3BlKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRhY3RpdmF0ZWQodGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiRhY3RpdmF0ZWQodGFyZ2V0KTtcbiAgICB9XG4gICAgJGFjdGl2YXRlZCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmF0ZWQsIGNhbGxiYWNrQ29udGV4dCwgdmlldyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFjdGl2YXRlZD8uY2FsbChjYWxsYmFja0NvbnRleHQsIHRhcmdldCwgdmlldyk7XG4gICAgfVxuICAgICRkZWFjdGl2YXRpbmcoaW5pdGlhdG9yLCB0YXJnZXQsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgZGVhY3RpdmF0aW5nLCBjYWxsYmFja0NvbnRleHQsIHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvblJlc29sdmUoZGVhY3RpdmF0aW5nPy5jYWxsKGNhbGxiYWNrQ29udGV4dCwgdGFyZ2V0LCB2aWV3KSwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVhY3RpdmF0ZShpbml0aWF0b3IsIHRhcmdldCwgZmxhZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZShpbml0aWF0b3IsIHRhcmdldCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciwgdmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGluaXRpYXRvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmlldy5ub2Rlcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvblJlc29sdmUodmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciwgJGNvbnRyb2xsZXIsIGZsYWdzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRkZWFjdGl2YXRlZCh0YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJGRlYWN0aXZhdGVkKHRhcmdldCk7XG4gICAgfVxuICAgICRkZWFjdGl2YXRlZCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgeyBkZWFjdGl2YXRlZCwgY2FsbGJhY2tDb250ZXh0LCB2aWV3IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGVhY3RpdmF0ZWQ/LmNhbGwoY2FsbGJhY2tDb250ZXh0LCB0YXJnZXQsIHZpZXcpO1xuICAgIH1cbiAgICByZXNvbHZlVGFyZ2V0KCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wO1xuICAgICAgICAvLyB3aXRoIGEgJCBpbiBmcm9udCB0byBtYWtlIGl0IGxlc3MgY29uZnVzaW5nL2Vycm9yIHByb25lXG4gICAgICAgIGNvbnN0ICRkb2N1bWVudCA9IHAuZG9jdW1lbnQ7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLnJlbmRlckNvbnRleHQ7XG4gICAgICAgIGlmICh0YXJnZXQgPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IHF1ZXJ5U2VsZWN0b3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeUNvbnRleHQgPSAkZG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9ICRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBwLk5vZGUpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0ID0gcXVlcnlDb250ZXh0LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgcC5Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0YWwgdGFyZ2V0IG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRkb2N1bWVudC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMudmlldy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmlldyA9ICh2b2lkIDApO1xuICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXc/LmFjY2VwdCh2aXNpdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoeyBwcmltYXJ5OiB0cnVlIH0pXG5dLCBQb3J0YWwucHJvdG90eXBlLCBcInRhcmdldFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoeyBjYWxsYmFjazogJ3RhcmdldENoYW5nZWQnIH0pXG5dLCBQb3J0YWwucHJvdG90eXBlLCBcInJlbmRlckNvbnRleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlKClcbl0sIFBvcnRhbC5wcm90b3R5cGUsIFwic3RyaWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSgpXG5dLCBQb3J0YWwucHJvdG90eXBlLCBcImRlYWN0aXZhdGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgUG9ydGFsLnByb3RvdHlwZSwgXCJhY3RpdmF0aW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSgpXG5dLCBQb3J0YWwucHJvdG90eXBlLCBcImRlYWN0aXZhdGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBiaW5kYWJsZSgpXG5dLCBQb3J0YWwucHJvdG90eXBlLCBcImFjdGl2YXRlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoKVxuXSwgUG9ydGFsLnByb3RvdHlwZSwgXCJjYWxsYmFja0NvbnRleHRcIiwgdm9pZCAwKTtcblBvcnRhbCA9IF9fZGVjb3JhdGUoW1xuICAgIHRlbXBsYXRlQ29udHJvbGxlcigncG9ydGFsJyksXG4gICAgX19wYXJhbSgwLCBJVmlld0ZhY3RvcnkpLFxuICAgIF9fcGFyYW0oMSwgSVJlbmRlckxvY2F0aW9uKSxcbiAgICBfX3BhcmFtKDIsIElQbGF0Zm9ybSlcbl0sIFBvcnRhbCk7XG5leHBvcnQgeyBQb3J0YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcnRhbC5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGNvbXBhcmVOdW1iZXIsIG5leHRJZCwgb25SZXNvbHZlIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IGFwcGx5TXV0YXRpb25zVG9JbmRpY2VzLCBCaW5kaW5nQ29udGV4dCwgZ2V0Q29sbGVjdGlvbk9ic2VydmVyLCBTY29wZSwgc3luY2hyb25pemVJbmRpY2VzLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgSVJlbmRlckxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7IElWaWV3RmFjdG9yeSB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvdmlldy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUNvbnRyb2xsZXIgfSBmcm9tICcuLi9jdXN0b20tYXR0cmlidXRlLmpzJztcbmltcG9ydCB7IElDb250cm9sbGVyIH0gZnJvbSAnLi4vLi4vdGVtcGxhdGluZy9jb250cm9sbGVyLmpzJztcbmltcG9ydCB7IGJpbmRhYmxlIH0gZnJvbSAnLi4vLi4vYmluZGFibGUuanMnO1xuZnVuY3Rpb24gZGlzcG9zZShkaXNwb3NhYmxlKSB7XG4gICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG59XG5sZXQgUmVwZWF0ID0gY2xhc3MgUmVwZWF0IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhdGlvbiwgcGFyZW50LCBmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SWQoJ2F1JGNvbXBvbmVudCcpO1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdJbnN0YW5jZU11dGF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubm9ybWFsaXplZEl0ZW1zID0gdm9pZCAwO1xuICAgIH1cbiAgICBiaW5kaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICB0aGlzLmNoZWNrQ29sbGVjdGlvbk9ic2VydmVyKGZsYWdzKTtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSB0aGlzLnBhcmVudC5iaW5kaW5ncztcbiAgICAgICAgbGV0IGJpbmRpbmcgPSAodm9pZCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYmluZGluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSB0aGlzICYmIGJpbmRpbmcudGFyZ2V0UHJvcGVydHkgPT09ICdpdGVtcycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvck9mID0gYmluZGluZy5zb3VyY2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWwgPSB0aGlzLmZvck9mLmRlY2xhcmF0aW9uLmV2YWx1YXRlKGZsYWdzLCB0aGlzLiRjb250cm9sbGVyLnNjb3BlLCBudWxsLCBiaW5kaW5nLmxvY2F0b3IsIG51bGwpO1xuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMubm9ybWFsaXplVG9BcnJheShmbGFncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlQWxsVmlld3MoaW5pdGlhdG9yLCBmbGFncyk7XG4gICAgfVxuICAgIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0NvbGxlY3Rpb25PYnNlcnZlcihmbGFncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlYWN0aXZhdGVBbGxWaWV3cyhpbml0aWF0b3IsIGZsYWdzKTtcbiAgICB9XG4gICAgLy8gY2FsbGVkIGJ5IFNldHRlck9ic2VydmVyXG4gICAgaXRlbXNDaGFuZ2VkKGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmICghJGNvbnRyb2xsZXIuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyB8PSAkY29udHJvbGxlci5mbGFncztcbiAgICAgICAgdGhpcy5jaGVja0NvbGxlY3Rpb25PYnNlcnZlcihmbGFncyk7XG4gICAgICAgIGZsYWdzIHw9IDggLyogdXBkYXRlVGFyZ2V0ICovO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZVRvQXJyYXkoZmxhZ3MpO1xuICAgICAgICBjb25zdCByZXQgPSBvblJlc29sdmUodGhpcy5kZWFjdGl2YXRlQWxsVmlld3MobnVsbCwgZmxhZ3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogYWRkIGxvZ2ljIHRvIHRoZSBjb250cm9sbGVyIHRoYXQgZW5zdXJlcyBjb3JyZWN0IGhhbmRsaW5nIG9mIHJhY2UgY29uZGl0aW9ucyBhbmQgYWRkIGEgdmFyaWV0eSBvZiBgaWZgIGludGVncmF0aW9uIHRlc3RzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZUFsbFZpZXdzKG51bGwsIGZsYWdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXQuY2F0Y2goZXJyID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjYWxsZWQgYnkgYSBDb2xsZWN0aW9uT2JzZXJ2ZXJcbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncykge1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoISRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3MgfD0gJGNvbnRyb2xsZXIuZmxhZ3M7XG4gICAgICAgIGZsYWdzIHw9IDggLyogdXBkYXRlVGFyZ2V0ICovO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZVRvQXJyYXkoZmxhZ3MpO1xuICAgICAgICBpZiAoaW5kZXhNYXAgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gb25SZXNvbHZlKHRoaXMuZGVhY3RpdmF0ZUFsbFZpZXdzKG51bGwsIGZsYWdzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oZmtsZXV2ZXIpOiBhZGQgbG9naWMgdG8gdGhlIGNvbnRyb2xsZXIgdGhhdCBlbnN1cmVzIGNvcnJlY3QgaGFuZGxpbmcgb2YgcmFjZSBjb25kaXRpb25zIGFuZCBhZGQgYSB2YXJpZXR5IG9mIGBpZmAgaW50ZWdyYXRpb24gdGVzdHNcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZUFsbFZpZXdzKG51bGwsIGZsYWdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXQuY2F0Y2goZXJyID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IHRoaXMudmlld3MubGVuZ3RoO1xuICAgICAgICAgICAgYXBwbHlNdXRhdGlvbnNUb0luZGljZXMoaW5kZXhNYXApO1xuICAgICAgICAgICAgLy8gZmlyc3QgZGV0YWNoK3VuYmluZCsocmVtb3ZlIGZyb20gYXJyYXkpIHRoZSBkZWxldGVkIHZpZXcgaW5kaWNlc1xuICAgICAgICAgICAgaWYgKGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnNvcnQoY29tcGFyZU51bWJlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gb25SZXNvbHZlKHRoaXMuZGVhY3RpdmF0ZUFuZFJlbW92ZVZpZXdzQnlLZXkoaW5kZXhNYXAsIGZsYWdzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogYWRkIGxvZ2ljIHRvIHRoZSBjb250cm9sbGVyIHRoYXQgZW5zdXJlcyBjb3JyZWN0IGhhbmRsaW5nIG9mIHJhY2UgY29uZGl0aW9ucyBhbmQgYWRkIGEgdmFyaWV0eSBvZiBgaWZgIGludGVncmF0aW9uIHRlc3RzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZEFjdGl2YXRlQW5kU29ydFZpZXdzQnlLZXkob2xkTGVuZ3RoLCBpbmRleE1hcCwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5jYXRjaChlcnIgPT4geyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oZmtsZXV2ZXIpOiBhZGQgbG9naWMgdG8gdGhlIGNvbnRyb2xsZXIgdGhhdCBlbnN1cmVzIGNvcnJlY3QgaGFuZGxpbmcgb2YgcmFjZSBjb25kaXRpb25zIGFuZCBhZGQgaW50ZWdyYXRpb24gdGVzdHNcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVBbmRBY3RpdmF0ZUFuZFNvcnRWaWV3c0J5S2V5KG9sZExlbmd0aCwgaW5kZXhNYXAsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0b2RvOiBzdWJzY3JpYmUgdG8gY29sbGVjdGlvbiBmcm9tIGlubmVyIGV4cHJlc3Npb25cbiAgICBjaGVja0NvbGxlY3Rpb25PYnNlcnZlcihmbGFncykge1xuICAgICAgICBjb25zdCBvbGRPYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA2NCAvKiBmcm9tVW5iaW5kICovKSkge1xuICAgICAgICAgICAgaWYgKG9sZE9ic2VydmVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvbGRPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdPYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIgPSBnZXRDb2xsZWN0aW9uT2JzZXJ2ZXIodGhpcy5pdGVtcyk7XG4gICAgICAgICAgICBpZiAob2xkT2JzZXJ2ZXIgIT09IG5ld09ic2VydmVyICYmIG9sZE9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgb2xkT2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBuZXdPYnNlcnZlci5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplVG9BcnJheShmbGFncykge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRJdGVtcyA9IGl0ZW1zO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvck9mID0gdGhpcy5mb3JPZjtcbiAgICAgICAgaWYgKGZvck9mID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3JtYWxpemVkSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JPZi5pdGVyYXRlKGZsYWdzLCBpdGVtcywgKGFyciwgaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkSXRlbXMgPSBub3JtYWxpemVkSXRlbXM7XG4gICAgfVxuICAgIGFjdGl2YXRlQWxsVmlld3MoaW5pdGlhdG9yLCBmbGFncykge1xuICAgICAgICBsZXQgcHJvbWlzZXMgPSB2b2lkIDA7XG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICBsZXQgdmlld1Njb3BlO1xuICAgICAgICBjb25zdCB7ICRjb250cm9sbGVyLCBmYWN0b3J5LCBsb2NhbCwgbG9jYXRpb24sIGl0ZW1zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBwYXJlbnRTY29wZSA9ICRjb250cm9sbGVyLnNjb3BlO1xuICAgICAgICBjb25zdCBob3N0U2NvcGUgPSAkY29udHJvbGxlci5ob3N0U2NvcGU7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHRoaXMuZm9yT2YuY291bnQoZmxhZ3MsIGl0ZW1zKTtcbiAgICAgICAgY29uc3Qgdmlld3MgPSB0aGlzLnZpZXdzID0gQXJyYXkobmV3TGVuKTtcbiAgICAgICAgdGhpcy5mb3JPZi5pdGVyYXRlKGZsYWdzLCBpdGVtcywgKGFyciwgaSwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgdmlldyA9IHZpZXdzW2ldID0gZmFjdG9yeS5jcmVhdGUoZmxhZ3MpLnNldExvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZpZXcubm9kZXMudW5saW5rKCk7XG4gICAgICAgICAgICB2aWV3U2NvcGUgPSBTY29wZS5mcm9tUGFyZW50KHBhcmVudFNjb3BlLCBCaW5kaW5nQ29udGV4dC5jcmVhdGUobG9jYWwsIGl0ZW0pKTtcbiAgICAgICAgICAgIHNldENvbnRleHR1YWxQcm9wZXJ0aWVzKHZpZXdTY29wZS5vdmVycmlkZUNvbnRleHQsIGksIG5ld0xlbik7XG4gICAgICAgICAgICByZXQgPSB2aWV3LmFjdGl2YXRlKGluaXRpYXRvciA/PyB2aWV3LCAkY29udHJvbGxlciwgZmxhZ3MsIHZpZXdTY29wZSwgaG9zdFNjb3BlKTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgKHByb21pc2VzID8/IChwcm9taXNlcyA9IFtdKSkucHVzaChyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2VzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgICA/IHByb21pc2VzWzBdXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZUFsbFZpZXdzKGluaXRpYXRvciwgZmxhZ3MpIHtcbiAgICAgICAgbGV0IHByb21pc2VzID0gdm9pZCAwO1xuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgY29uc3QgeyB2aWV3cywgJGNvbnRyb2xsZXIgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZpZXdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZpZXcgPSB2aWV3c1tpXTtcbiAgICAgICAgICAgIHZpZXcucmVsZWFzZSgpO1xuICAgICAgICAgICAgcmV0ID0gdmlldy5kZWFjdGl2YXRlKGluaXRpYXRvciA/PyB2aWV3LCAkY29udHJvbGxlciwgZmxhZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAocHJvbWlzZXMgPz8gKHByb21pc2VzID0gW10pKS5wdXNoKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgICA/IHByb21pc2VzWzBdXG4gICAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZUFuZFJlbW92ZVZpZXdzQnlLZXkoaW5kZXhNYXAsIGZsYWdzKSB7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IHZvaWQgMDtcbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIsIHZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkZWxldGVkID0gaW5kZXhNYXAuZGVsZXRlZEl0ZW1zO1xuICAgICAgICBjb25zdCBkZWxldGVkTGVuID0gZGVsZXRlZC5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBkZWxldGVkTGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZpZXcgPSB2aWV3c1tkZWxldGVkW2ldXTtcbiAgICAgICAgICAgIHZpZXcucmVsZWFzZSgpO1xuICAgICAgICAgICAgcmV0ID0gdmlldy5kZWFjdGl2YXRlKHZpZXcsICRjb250cm9sbGVyLCBmbGFncyk7XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIChwcm9taXNlcyA/PyAocHJvbWlzZXMgPSBbXSkpLnB1c2gocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpID0gMDtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGRlbGV0ZWRMZW47ICsraSkge1xuICAgICAgICAgICAgaiA9IGRlbGV0ZWRbaV0gLSBpO1xuICAgICAgICAgICAgdmlld3Muc3BsaWNlKGosIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgPyBwcm9taXNlc1swXVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUFuZEFjdGl2YXRlQW5kU29ydFZpZXdzQnlLZXkob2xkTGVuZ3RoLCBpbmRleE1hcCwgZmxhZ3MpIHtcbiAgICAgICAgbGV0IHByb21pc2VzID0gdm9pZCAwO1xuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgbGV0IHZpZXdTY29wZTtcbiAgICAgICAgY29uc3QgeyAkY29udHJvbGxlciwgZmFjdG9yeSwgbG9jYWwsIG5vcm1hbGl6ZWRJdGVtcywgbG9jYXRpb24sIHZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXBMZW4gPSBpbmRleE1hcC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gZmFjdG9yeS5jcmVhdGUoZmxhZ3MpO1xuICAgICAgICAgICAgICAgIHZpZXdzLnNwbGljZShpLCAwLCB2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld3MubGVuZ3RoICE9PSBtYXBMZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGNyZWF0ZSBlcnJvciBjb2RlIGFuZCB1c2UgcmVwb3J0ZXIgd2l0aCBtb3JlIGluZm9ybWF0aXZlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmlld3NMZW49JHt2aWV3cy5sZW5ndGh9LCBtYXBMZW49JHttYXBMZW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50U2NvcGUgPSAkY29udHJvbGxlci5zY29wZTtcbiAgICAgICAgY29uc3QgaG9zdFNjb3BlID0gJGNvbnRyb2xsZXIuaG9zdFNjb3BlO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBpbmRleE1hcC5sZW5ndGg7XG4gICAgICAgIHN5bmNocm9uaXplSW5kaWNlcyh2aWV3cywgaW5kZXhNYXApO1xuICAgICAgICAvLyB0aGlzIGFsZ29yaXRobSByZXRyaWV2ZXMgdGhlIGluZGljZXMgb2YgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBpdGVtcyBpbiB0aGUgcmVwZWF0ZXJcbiAgICAgICAgLy8gdGhlIGl0ZW1zIG9uIHRob3NlIGluZGljZXMgYXJlIG5vdCBtb3ZlZDsgdGhpcyBtaW5pbWl6ZXMgdGhlIG51bWJlciBvZiBET00gb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYmUgcGVyZm9ybWVkXG4gICAgICAgIGNvbnN0IHNlcSA9IGxvbmdlc3RJbmNyZWFzaW5nU3Vic2VxdWVuY2UoaW5kZXhNYXApO1xuICAgICAgICBjb25zdCBzZXFMZW4gPSBzZXEubGVuZ3RoO1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgbGV0IGogPSBzZXFMZW4gLSAxO1xuICAgICAgICBsZXQgaSA9IG5ld0xlbiAtIDE7XG4gICAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmlldyA9IHZpZXdzW2ldO1xuICAgICAgICAgICAgbmV4dCA9IHZpZXdzW2kgKyAxXTtcbiAgICAgICAgICAgIHZpZXcubm9kZXMubGluayhuZXh0Py5ub2RlcyA/PyBsb2NhdGlvbik7XG4gICAgICAgICAgICBpZiAoaW5kZXhNYXBbaV0gPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdmlld1Njb3BlID0gU2NvcGUuZnJvbVBhcmVudChwYXJlbnRTY29wZSwgQmluZGluZ0NvbnRleHQuY3JlYXRlKGxvY2FsLCBub3JtYWxpemVkSXRlbXNbaV0pKTtcbiAgICAgICAgICAgICAgICBzZXRDb250ZXh0dWFsUHJvcGVydGllcyh2aWV3U2NvcGUub3ZlcnJpZGVDb250ZXh0LCBpLCBuZXdMZW4pO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0TG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldCA9IHZpZXcuYWN0aXZhdGUodmlldywgJGNvbnRyb2xsZXIsIGZsYWdzLCB2aWV3U2NvcGUsIGhvc3RTY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgKHByb21pc2VzID8/IChwcm9taXNlcyA9IFtdKSkucHVzaChyZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGogPCAwIHx8IHNlcUxlbiA9PT0gMSB8fCBpICE9PSBzZXFbal0pIHtcbiAgICAgICAgICAgICAgICBzZXRDb250ZXh0dWFsUHJvcGVydGllcyh2aWV3LnNjb3BlLm92ZXJyaWRlQ29udGV4dCwgaSwgbmV3TGVuKTtcbiAgICAgICAgICAgICAgICB2aWV3Lm5vZGVzLmluc2VydEJlZm9yZSh2aWV3LmxvY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvbGRMZW5ndGggIT09IG5ld0xlbikge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb250ZXh0dWFsUHJvcGVydGllcyh2aWV3LnNjb3BlLm92ZXJyaWRlQ29udGV4dCwgaSwgbmV3TGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgPyBwcm9taXNlc1swXVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMudmlld3MuZm9yRWFjaChkaXNwb3NlKTtcbiAgICAgICAgdGhpcy52aWV3cyA9ICh2b2lkIDApO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBjb25zdCB7IHZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBpZiAodmlld3MgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmlld3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh2aWV3c1tpXS5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBSZXBlYXQucHJvdG90eXBlLCBcIml0ZW1zXCIsIHZvaWQgMCk7XG5SZXBlYXQgPSBfX2RlY29yYXRlKFtcbiAgICB0ZW1wbGF0ZUNvbnRyb2xsZXIoJ3JlcGVhdCcpLFxuICAgIF9fcGFyYW0oMCwgSVJlbmRlckxvY2F0aW9uKSxcbiAgICBfX3BhcmFtKDEsIElDb250cm9sbGVyKSxcbiAgICBfX3BhcmFtKDIsIElWaWV3RmFjdG9yeSlcbl0sIFJlcGVhdCk7XG5leHBvcnQgeyBSZXBlYXQgfTtcbmxldCBtYXhMZW4gPSAxNjtcbmxldCBwcmV2SW5kaWNlcyA9IG5ldyBJbnQzMkFycmF5KG1heExlbik7XG5sZXQgdGFpbEluZGljZXMgPSBuZXcgSW50MzJBcnJheShtYXhMZW4pO1xuLy8gQmFzZWQgb24gaW5mZXJubydzIGxpc19hbGdvcml0aG0gQCBodHRwczovL2dpdGh1Yi5jb20vaW5mZXJub2pzL2luZmVybm8vYmxvYi9tYXN0ZXIvcGFja2FnZXMvaW5mZXJuby9zcmMvRE9NL3BhdGNoaW5nLnRzI0w3MzJcbi8vIHdpdGggc29tZSB0d2Vha3MgdG8gbWFrZSBpdCBqdXN0IGEgYml0IGZhc3RlciArIGFjY291bnQgZm9yIEluZGV4TWFwIChhbmQgc29tZSBuYW1lcyBjaGFuZ2VzIGZvciByZWFkYWJpbGl0eSlcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBsb25nZXN0SW5jcmVhc2luZ1N1YnNlcXVlbmNlKGluZGV4TWFwKSB7XG4gICAgY29uc3QgbGVuID0gaW5kZXhNYXAubGVuZ3RoO1xuICAgIGlmIChsZW4gPiBtYXhMZW4pIHtcbiAgICAgICAgbWF4TGVuID0gbGVuO1xuICAgICAgICBwcmV2SW5kaWNlcyA9IG5ldyBJbnQzMkFycmF5KGxlbik7XG4gICAgICAgIHRhaWxJbmRpY2VzID0gbmV3IEludDMyQXJyYXkobGVuKTtcbiAgICB9XG4gICAgbGV0IGN1cnNvciA9IDA7XG4gICAgbGV0IGN1ciA9IDA7XG4gICAgbGV0IHByZXYgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSAwO1xuICAgIGxldCBtaWQgPSAwO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY3VyID0gaW5kZXhNYXBbaV07XG4gICAgICAgIGlmIChjdXIgIT09IC0yKSB7XG4gICAgICAgICAgICBqID0gcHJldkluZGljZXNbY3Vyc29yXTtcbiAgICAgICAgICAgIHByZXYgPSBpbmRleE1hcFtqXTtcbiAgICAgICAgICAgIGlmIChwcmV2ICE9PSAtMiAmJiBwcmV2IDwgY3VyKSB7XG4gICAgICAgICAgICAgICAgdGFpbEluZGljZXNbaV0gPSBqO1xuICAgICAgICAgICAgICAgIHByZXZJbmRpY2VzWysrY3Vyc29yXSA9IGk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb3cgPSAwO1xuICAgICAgICAgICAgaGlnaCA9IGN1cnNvcjtcbiAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgICAgICAgICAgcHJldiA9IGluZGV4TWFwW3ByZXZJbmRpY2VzW21pZF1dO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSAtMiAmJiBwcmV2IDwgY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBpbmRleE1hcFtwcmV2SW5kaWNlc1tsb3ddXTtcbiAgICAgICAgICAgIGlmIChjdXIgPCBwcmV2IHx8IHByZXYgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFpbEluZGljZXNbaV0gPSBwcmV2SW5kaWNlc1tsb3cgLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldkluZGljZXNbbG93XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaSA9ICsrY3Vyc29yO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KGkpO1xuICAgIGN1ciA9IHByZXZJbmRpY2VzW2N1cnNvciAtIDFdO1xuICAgIHdoaWxlIChjdXJzb3ItLSA+IDApIHtcbiAgICAgICAgcmVzdWx0W2N1cnNvcl0gPSBjdXI7XG4gICAgICAgIGN1ciA9IHRhaWxJbmRpY2VzW2N1cl07XG4gICAgfVxuICAgIHdoaWxlIChpLS0gPiAwKVxuICAgICAgICBwcmV2SW5kaWNlc1tpXSA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHR1YWxQcm9wZXJ0aWVzKG9jLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgaXNGaXJzdCA9IGluZGV4ID09PSAwO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID09PSBsZW5ndGggLSAxO1xuICAgIGNvbnN0IGlzRXZlbiA9IGluZGV4ICUgMiA9PT0gMDtcbiAgICBvYy4kaW5kZXggPSBpbmRleDtcbiAgICBvYy4kZmlyc3QgPSBpc0ZpcnN0O1xuICAgIG9jLiRsYXN0ID0gaXNMYXN0O1xuICAgIG9jLiRtaWRkbGUgPSAhaXNGaXJzdCAmJiAhaXNMYXN0O1xuICAgIG9jLiRldmVuID0gaXNFdmVuO1xuICAgIG9jLiRvZGQgPSAhaXNFdmVuO1xuICAgIG9jLiRsZW5ndGggPSBsZW5ndGg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXQuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBJTG9nZ2VyLCBuZXh0SWQsIG9uUmVzb2x2ZSwgcmVzb2x2ZUFsbCwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQmluZGluZ01vZGUsIElPYnNlcnZlckxvY2F0b3IsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBJUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHsgdGVtcGxhdGVDb250cm9sbGVyIH0gZnJvbSAnLi4vY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBJVmlld0ZhY3RvcnkgfSBmcm9tICcuLi8uLi90ZW1wbGF0aW5nL3ZpZXcuanMnO1xuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tICcuLi8uLi9iaW5kYWJsZS5qcyc7XG5sZXQgU3dpdGNoID0gY2xhc3MgU3dpdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SWQoJ2F1JGNvbXBvbmVudCcpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuY2FzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVDYXNlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBrZXB0IGFyb3VuZCBoZXJlIHNvIHRoYXQgY2hhbmdlcyBjYW4gYmUgYXdhaXRlZCBmcm9tIHRoZSB0ZXN0cy5cbiAgICAgICAgICogVGhpcyBuZWVkcyB0byBiZSByZW1vdmVkIGFmdGVyIHRoZSBzY2hlZHVsZXIgaXMgcmVhZHkgdG8gaGFuZGxlL3F1ZXVlIHRoZSBmbG9hdGluZyBwcm9taXNlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgbGluayhmbGFncywgX3BhcmVudENvbnRleHQsIF9jb250cm9sbGVyLCBfY2hpbGRDb250cm9sbGVyLCBfdGFyZ2V0LCBfaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdGhpcy5mYWN0b3J5LmNyZWF0ZShmbGFncywgdGhpcy4kY29udHJvbGxlcikuc2V0TG9jYXRpb24odGhpcy5sb2NhdGlvbik7XG4gICAgfVxuICAgIGF0dGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmlldztcbiAgICAgICAgY29uc3QgJGNvbnRyb2xsZXIgPSB0aGlzLiRjb250cm9sbGVyO1xuICAgICAgICB0aGlzLnF1ZXVlKCgpID0+IHZpZXcuYWN0aXZhdGUoaW5pdGlhdG9yLCAkY29udHJvbGxlciwgZmxhZ3MsICRjb250cm9sbGVyLnNjb3BlLCAkY29udHJvbGxlci5ob3N0U2NvcGUpKTtcbiAgICAgICAgdGhpcy5xdWV1ZSgoKSA9PiB0aGlzLnN3YXAoaW5pdGlhdG9yLCBmbGFncywgdGhpcy52YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICBkZXRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMucXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmlldztcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmRlYWN0aXZhdGUoaW5pdGlhdG9yLCB0aGlzLiRjb250cm9sbGVyLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnZpZXc/LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKHZvaWQgMCk7XG4gICAgfVxuICAgIHZhbHVlQ2hhbmdlZChfbmV3VmFsdWUsIF9vbGRWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZSgoKSA9PiB0aGlzLnN3YXAobnVsbCwgZmxhZ3MsIHRoaXMudmFsdWUpKTtcbiAgICB9XG4gICAgY2FzZUNoYW5nZWQoJGNhc2UsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMucXVldWUoKCkgPT4gdGhpcy5oYW5kbGVDYXNlQ2hhbmdlKCRjYXNlLCBmbGFncykpO1xuICAgIH1cbiAgICBoYW5kbGVDYXNlQ2hhbmdlKCRjYXNlLCBmbGFncykge1xuICAgICAgICBjb25zdCBpc01hdGNoID0gJGNhc2UuaXNNYXRjaCh0aGlzLnZhbHVlLCBmbGFncyk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNhc2VzID0gdGhpcy5hY3RpdmVDYXNlcztcbiAgICAgICAgY29uc3QgbnVtQWN0aXZlQ2FzZXMgPSBhY3RpdmVDYXNlcy5sZW5ndGg7XG4gICAgICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uICMxXG4gICAgICAgIGlmICghaXNNYXRjaCkge1xuICAgICAgICAgICAgLyoqIFRoZSBwcmV2aW91cyBtYXRjaCBzdGFydGVkIHdpdGggdGhpczsgdGh1cyBjbGVhci4gKi9cbiAgICAgICAgICAgIGlmIChudW1BY3RpdmVDYXNlcyA+IDAgJiYgYWN0aXZlQ2FzZXNbMF0uaWQgPT09ICRjYXNlLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJBY3RpdmVDYXNlcyhudWxsLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZXJlIGFyZSAyIGRpZmZlcmVudCBzY2VuYXJpb3MgaGVyZTpcbiAgICAgICAgICAgICAqIDEuICRjYXNlIGluIGFjdGl2ZUNhc2VzOiBJbmRpY2F0ZXMgYnktcHJvZHVjdCBvZiBmYWxsdGhyb3VnaC4gVGhlIHN0YXJ0aW5nIGNhc2Ugc3RpbGwgc2F0aXNmaWVzLiBSZXR1cm4uXG4gICAgICAgICAgICAgKiAyLiAkY2FzZSBub3QgaW4gYWN0aXZlQ2FzZXM6IEl0IHdhcyBwcmV2aW91c2x5IG5vdCBhY3RpdmUsIGFuZCBjdXJyZW50bHkgYWxzbyBub3QgYSBtYXRjaC4gUmV0dXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWFybHkgdGVybWluYXRpb24gIzJcbiAgICAgICAgaWYgKG51bUFjdGl2ZUNhc2VzID4gMCAmJiBhY3RpdmVDYXNlc1swXS5pZCA8ICRjYXNlLmlkKSB7XG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgY2FzZSBub3cgYSBtYXRjaCwgdGhlIHByZXZpb3VzIGNhc2Ugc3RpbGwgd2lucyBieSBhcyB0aGF0IGhhcyBsb3dlciBvcmRpbmFsLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIG5ldyBhY3RpdmUgY2FzZXNcbiAgICAgICAgY29uc3QgbmV3QWN0aXZlQ2FzZXMgPSBbXTtcbiAgICAgICAgbGV0IGZhbGxUaHJvdWdoID0gJGNhc2UuZmFsbFRocm91Z2g7XG4gICAgICAgIGlmICghZmFsbFRocm91Z2gpIHtcbiAgICAgICAgICAgIG5ld0FjdGl2ZUNhc2VzLnB1c2goJGNhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FzZXMgPSB0aGlzLmNhc2VzO1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FzZXMuaW5kZXhPZigkY2FzZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaWR4LCBpaSA9IGNhc2VzLmxlbmd0aDsgaSA8IGlpICYmIGZhbGxUaHJvdWdoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gY2FzZXNbaV07XG4gICAgICAgICAgICAgICAgbmV3QWN0aXZlQ2FzZXMucHVzaChjKTtcbiAgICAgICAgICAgICAgICBmYWxsVGhyb3VnaCA9IGMuZmFsbFRocm91Z2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSh0aGlzLmNsZWFyQWN0aXZlQ2FzZXMobnVsbCwgZmxhZ3MsIG5ld0FjdGl2ZUNhc2VzKSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDYXNlcyA9IG5ld0FjdGl2ZUNhc2VzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVDYXNlcyhudWxsLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzd2FwKGluaXRpYXRvciwgZmxhZ3MsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld0FjdGl2ZUNhc2VzID0gW107XG4gICAgICAgIGxldCBmYWxsVGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0ICRjYXNlIG9mIHRoaXMuY2FzZXMpIHtcbiAgICAgICAgICAgIGlmIChmYWxsVGhyb3VnaCB8fCAkY2FzZS5pc01hdGNoKHZhbHVlLCBmbGFncykpIHtcbiAgICAgICAgICAgICAgICBuZXdBY3RpdmVDYXNlcy5wdXNoKCRjYXNlKTtcbiAgICAgICAgICAgICAgICBmYWxsVGhyb3VnaCA9ICRjYXNlLmZhbGxUaHJvdWdoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld0FjdGl2ZUNhc2VzLmxlbmd0aCA+IDAgJiYgIWZhbGxUaHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdENhc2UgPSB0aGlzLmRlZmF1bHRDYXNlO1xuICAgICAgICBpZiAobmV3QWN0aXZlQ2FzZXMubGVuZ3RoID09PSAwICYmIGRlZmF1bHRDYXNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG5ld0FjdGl2ZUNhc2VzLnB1c2goZGVmYXVsdENhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvblJlc29sdmUodGhpcy5hY3RpdmVDYXNlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHRoaXMuY2xlYXJBY3RpdmVDYXNlcyhpbml0aWF0b3IsIGZsYWdzLCBuZXdBY3RpdmVDYXNlcylcbiAgICAgICAgICAgIDogdm9pZCAwLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNhc2VzID0gbmV3QWN0aXZlQ2FzZXM7XG4gICAgICAgICAgICBpZiAobmV3QWN0aXZlQ2FzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVDYXNlcyhpbml0aWF0b3IsIGZsYWdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjdGl2YXRlQ2FzZXMoaW5pdGlhdG9yLCBmbGFncykge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy4kY29udHJvbGxlcjtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FzZXMgPSB0aGlzLmFjdGl2ZUNhc2VzO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjYXNlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY29wZSA9IGNvbnRyb2xsZXIuc2NvcGU7XG4gICAgICAgIGNvbnN0IGhvc3RTY29wZSA9IGNvbnRyb2xsZXIuaG9zdFNjb3BlO1xuICAgICAgICAvLyBtb3N0IGNvbW1vbiBjYXNlXG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlc1swXS5hY3RpdmF0ZShpbml0aWF0b3IsIGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZUFsbCguLi5jYXNlcy5tYXAoKCRjYXNlKSA9PiAkY2FzZS5hY3RpdmF0ZShpbml0aWF0b3IsIGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSkpO1xuICAgIH1cbiAgICBjbGVhckFjdGl2ZUNhc2VzKGluaXRpYXRvciwgZmxhZ3MsIG5ld0FjdGl2ZUNhc2VzID0gW10pIHtcbiAgICAgICAgY29uc3QgY2FzZXMgPSB0aGlzLmFjdGl2ZUNhc2VzO1xuICAgICAgICBjb25zdCBudW1DYXNlcyA9IGNhc2VzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bUNhc2VzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUNhc2VzID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENhc2UgPSBjYXNlc1swXTtcbiAgICAgICAgICAgIGlmICghbmV3QWN0aXZlQ2FzZXMuaW5jbHVkZXMoZmlyc3RDYXNlKSkge1xuICAgICAgICAgICAgICAgIGNhc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q2FzZS5kZWFjdGl2YXRlKGluaXRpYXRvciwgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvblJlc29sdmUocmVzb2x2ZUFsbCguLi5jYXNlcy5yZWR1Y2UoKGFjYywgJGNhc2UpID0+IHtcbiAgICAgICAgICAgIGlmICghbmV3QWN0aXZlQ2FzZXMuaW5jbHVkZXMoJGNhc2UpKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goJGNhc2UuZGVhY3RpdmF0ZShpbml0aWF0b3IsIGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSkpLCAoKSA9PiB7XG4gICAgICAgICAgICBjYXNlcy5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVldWUoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzUHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICAgICAgbGV0IHByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLnByb21pc2UgPSBvblJlc29sdmUob25SZXNvbHZlKHByZXZpb3VzUHJvbWlzZSwgYWN0aW9uKSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvbWlzZSA9PT0gcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250cm9sbGVyLmFjY2VwdCh2aXNpdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FzZXMuc29tZSh4ID0+IHguYWNjZXB0KHZpc2l0b3IpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGVcbl0sIFN3aXRjaC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcblN3aXRjaCA9IF9fZGVjb3JhdGUoW1xuICAgIHRlbXBsYXRlQ29udHJvbGxlcignc3dpdGNoJyksXG4gICAgX19wYXJhbSgwLCBJVmlld0ZhY3RvcnkpLFxuICAgIF9fcGFyYW0oMSwgSVJlbmRlckxvY2F0aW9uKVxuXSwgU3dpdGNoKTtcbmV4cG9ydCB7IFN3aXRjaCB9O1xubGV0IENhc2UgPSBjbGFzcyBDYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBsb2NhdG9yLCBsb2NhdGlvbiwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMubG9jYXRvciA9IGxvY2F0b3I7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SWQoJ2F1JGNvbXBvbmVudCcpO1xuICAgICAgICB0aGlzLmZhbGxUaHJvdWdoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVidWcgPSBsb2dnZXIuY29uZmlnLmxldmVsIDw9IDEgLyogZGVidWcgKi87XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLnNjb3BlVG8oYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS0jJHt0aGlzLmlkfWApO1xuICAgICAgICB0aGlzLnZpZXcgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKCkuc2V0TG9jYXRpb24obG9jYXRpb24pO1xuICAgIH1cbiAgICBsaW5rKGZsYWdzLCBwYXJlbnRDb250ZXh0LCBjb250cm9sbGVyLCBfY2hpbGRDb250cm9sbGVyLCBfdGFyZ2V0LCBfaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgY29uc3Qgc3dpdGNoQ29udHJvbGxlciA9IGNvbnRyb2xsZXIucGFyZW50O1xuICAgICAgICBjb25zdCAkc3dpdGNoID0gc3dpdGNoQ29udHJvbGxlcj8udmlld01vZGVsO1xuICAgICAgICBpZiAoJHN3aXRjaCBpbnN0YW5jZW9mIFN3aXRjaCkge1xuICAgICAgICAgICAgdGhpcy4kc3dpdGNoID0gJHN3aXRjaDtcbiAgICAgICAgICAgIHRoaXMubGlua1RvU3dpdGNoKCRzd2l0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFyZW50IHN3aXRjaCBub3QgZm91bmQ7IG9ubHkgYCpbc3dpdGNoXSA+ICpbY2FzZXxkZWZhdWx0LWNhc2VdYCByZWxhdGlvbiBpcyBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWFjdGl2YXRlKGluaXRpYXRvciwgZmxhZ3MpO1xuICAgIH1cbiAgICBpc01hdGNoKHZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ2lzTWF0Y2goKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0ICR2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KCR2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyID0gdGhpcy5vYnNlcnZlQ29sbGVjdGlvbihmbGFncywgJHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkdmFsdWUuaW5jbHVkZXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdmFsdWUgPT09IHZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZWQobmV3VmFsdWUsIF9vbGRWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyPy51bnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVDb2xsZWN0aW9uKGZsYWdzLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vYnNlcnZlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHN3aXRjaC5jYXNlQ2hhbmdlZCh0aGlzLCBmbGFncyk7XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoX2luZGV4TWFwLCBmbGFncykge1xuICAgICAgICB0aGlzLiRzd2l0Y2guY2FzZUNoYW5nZWQodGhpcywgZmxhZ3MpO1xuICAgIH1cbiAgICBhY3RpdmF0ZShpbml0aWF0b3IsIGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgICAgIGlmICh2aWV3LmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXcuYWN0aXZhdGUoaW5pdGlhdG9yID8/IHZpZXcsIHRoaXMuJGNvbnRyb2xsZXIsIGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZShpbml0aWF0b3IsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgICAgIGlmICghdmlldy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3LmRlYWN0aXZhdGUoaW5pdGlhdG9yID8/IHZpZXcsIHRoaXMuJGNvbnRyb2xsZXIsIGZsYWdzKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcj8udW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIHRoaXMudmlldz8uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpZXcgPSAodm9pZCAwKTtcbiAgICB9XG4gICAgbGlua1RvU3dpdGNoKGF1U3dpdGNoKSB7XG4gICAgICAgIGF1U3dpdGNoLmNhc2VzLnB1c2godGhpcyk7XG4gICAgfVxuICAgIG9ic2VydmVDb2xsZWN0aW9uKGZsYWdzLCAkdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLmxvY2F0b3IuZ2V0QXJyYXlPYnNlcnZlcigkdmFsdWUpO1xuICAgICAgICBvYnNlcnZlci5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNvbnRyb2xsZXIuYWNjZXB0KHZpc2l0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Py5hY2NlcHQodmlzaXRvcik7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBDYXNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgYmluZGFibGUoe1xuICAgICAgICBzZXQ6IHYgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzogcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gISF2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb2RlOiBCaW5kaW5nTW9kZS5vbmVUaW1lXG4gICAgfSlcbl0sIENhc2UucHJvdG90eXBlLCBcImZhbGxUaHJvdWdoXCIsIHZvaWQgMCk7XG5DYXNlID0gX19kZWNvcmF0ZShbXG4gICAgdGVtcGxhdGVDb250cm9sbGVyKCdjYXNlJyksXG4gICAgX19wYXJhbSgwLCBJVmlld0ZhY3RvcnkpLFxuICAgIF9fcGFyYW0oMSwgSU9ic2VydmVyTG9jYXRvciksXG4gICAgX19wYXJhbSgyLCBJUmVuZGVyTG9jYXRpb24pLFxuICAgIF9fcGFyYW0oMywgSUxvZ2dlcilcbl0sIENhc2UpO1xuZXhwb3J0IHsgQ2FzZSB9O1xubGV0IERlZmF1bHRDYXNlID0gY2xhc3MgRGVmYXVsdENhc2UgZXh0ZW5kcyBDYXNlIHtcbiAgICBsaW5rVG9Td2l0Y2goJHN3aXRjaCkge1xuICAgICAgICBpZiAoJHN3aXRjaC5kZWZhdWx0Q2FzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIFxcJ2RlZmF1bHQtY2FzZVxcJ3MgYXJlIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgICRzd2l0Y2guZGVmYXVsdENhc2UgPSB0aGlzO1xuICAgIH1cbn07XG5EZWZhdWx0Q2FzZSA9IF9fZGVjb3JhdGUoW1xuICAgIHRlbXBsYXRlQ29udHJvbGxlcignZGVmYXVsdC1jYXNlJylcbl0sIERlZmF1bHRDYXNlKTtcbmV4cG9ydCB7IERlZmF1bHRDYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBuZXh0SWQgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgU2NvcGUgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IElSZW5kZXJMb2NhdGlvbiB9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQgeyBJVmlld0ZhY3RvcnkgfSBmcm9tICcuLi8uLi90ZW1wbGF0aW5nL3ZpZXcuanMnO1xuaW1wb3J0IHsgdGVtcGxhdGVDb250cm9sbGVyIH0gZnJvbSAnLi4vY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBiaW5kYWJsZSB9IGZyb20gJy4uLy4uL2JpbmRhYmxlLmpzJztcbmxldCBXaXRoID0gY2xhc3MgV2l0aCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElkKCdhdSRjb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJZCgnYXUkY29tcG9uZW50Jyk7XG4gICAgICAgIHRoaXMudmlldyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoKS5zZXRMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgfVxuICAgIHZhbHVlQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLiRjb250cm9sbGVyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGZrbGV1dmVyKTogYWRkIGxvZ2ljIHRvIHRoZSBjb250cm9sbGVyIHRoYXQgZW5zdXJlcyBjb3JyZWN0IGhhbmRsaW5nIG9mIHJhY2UgY29uZGl0aW9ucyBhbmQgYWRkIGludGVncmF0aW9uIHRlc3RzXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlVmlldyh0aGlzLnZpZXcsIDMyIC8qIGZyb21CaW5kICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlVmlldyhpbml0aWF0b3IsIGZsYWdzKTtcbiAgICB9XG4gICAgZGV0YWNoaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRlYWN0aXZhdGUoaW5pdGlhdG9yLCB0aGlzLiRjb250cm9sbGVyLCBmbGFncyk7XG4gICAgfVxuICAgIGFjdGl2YXRlVmlldyhpbml0aWF0b3IsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHsgJGNvbnRyb2xsZXIsIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzY29wZSA9IFNjb3BlLmZyb21QYXJlbnQoJGNvbnRyb2xsZXIuc2NvcGUsIHZhbHVlID09PSB2b2lkIDAgPyB7fSA6IHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5hY3RpdmF0ZShpbml0aWF0b3IsICRjb250cm9sbGVyLCBmbGFncywgc2NvcGUsICRjb250cm9sbGVyLmhvc3RTY29wZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMudmlldy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmlldyA9ICh2b2lkIDApO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy52aWV3Py5hY2NlcHQodmlzaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIGJpbmRhYmxlXG5dLCBXaXRoLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuV2l0aCA9IF9fZGVjb3JhdGUoW1xuICAgIHRlbXBsYXRlQ29udHJvbGxlcignd2l0aCcpLFxuICAgIF9fcGFyYW0oMCwgSVZpZXdGYWN0b3J5KSxcbiAgICBfX3BhcmFtKDEsIElSZW5kZXJMb2NhdGlvbilcbl0sIFdpdGgpO1xuZXhwb3J0IHsgV2l0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aC5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IERJIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IHZhbHVlQ29udmVydGVyIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5jb25zdCBTQ1JJUFRfUkVHRVggPSAvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naTtcbmV4cG9ydCBjb25zdCBJU2FuaXRpemVyID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJU2FuaXRpemVyJywgeCA9PiB4LnNpbmdsZXRvbihjbGFzcyB7XG4gICAgc2FuaXRpemUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoU0NSSVBUX1JFR0VYLCAnJyk7XG4gICAgfVxufSkpO1xuLyoqXG4gKiBTaW1wbGUgaHRtbCBzYW5pdGl6YXRpb24gY29udmVydGVyIHRvIHByZXNlcnZlIHdoaXRlbGlzdGVkIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIG9uIGEgYm91bmQgcHJvcGVydHkgY29udGFpbmluZyBodG1sLlxuICovXG5sZXQgU2FuaXRpemVWYWx1ZUNvbnZlcnRlciA9IGNsYXNzIFNhbml0aXplVmFsdWVDb252ZXJ0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNhbml0aXplcikge1xuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgcHJvdmlkZWQgbWFya3VwIHRoYXQgZmxvd3MgdG8gdGhlIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdW50cnVzdGVkTWFya3VwIC0gVGhlIHVudHJ1c3RlZCBtYXJrdXAgdG8gYmUgc2FuaXRpemVkLlxuICAgICAqL1xuICAgIHRvVmlldyh1bnRydXN0ZWRNYXJrdXApIHtcbiAgICAgICAgaWYgKHVudHJ1c3RlZE1hcmt1cCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zYW5pdGl6ZXIuc2FuaXRpemUodW50cnVzdGVkTWFya3VwKTtcbiAgICB9XG59O1xuU2FuaXRpemVWYWx1ZUNvbnZlcnRlciA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgSVNhbml0aXplcilcbl0sIFNhbml0aXplVmFsdWVDb252ZXJ0ZXIpO1xuZXhwb3J0IHsgU2FuaXRpemVWYWx1ZUNvbnZlcnRlciB9O1xudmFsdWVDb252ZXJ0ZXIoJ3Nhbml0aXplJykoU2FuaXRpemVWYWx1ZUNvbnZlcnRlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW5pdGl6ZS5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IElWaWV3TG9jYXRvciB9IGZyb20gJy4uLy4uL3RlbXBsYXRpbmcvdmlldy5qcyc7XG5pbXBvcnQgeyB2YWx1ZUNvbnZlcnRlciB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xubGV0IFZpZXdWYWx1ZUNvbnZlcnRlciA9IGNsYXNzIFZpZXdWYWx1ZUNvbnZlcnRlciB7XG4gICAgY29uc3RydWN0b3Iodmlld0xvY2F0b3IpIHtcbiAgICAgICAgdGhpcy52aWV3TG9jYXRvciA9IHZpZXdMb2NhdG9yO1xuICAgIH1cbiAgICB0b1ZpZXcob2JqZWN0LCB2aWV3TmFtZU9yU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0xvY2F0b3IuZ2V0Vmlld0NvbXBvbmVudEZvck9iamVjdChvYmplY3QsIHZpZXdOYW1lT3JTZWxlY3Rvcik7XG4gICAgfVxufTtcblZpZXdWYWx1ZUNvbnZlcnRlciA9IF9fZGVjb3JhdGUoW1xuICAgIF9fcGFyYW0oMCwgSVZpZXdMb2NhdG9yKVxuXSwgVmlld1ZhbHVlQ29udmVydGVyKTtcbmV4cG9ydCB7IFZpZXdWYWx1ZUNvbnZlcnRlciB9O1xudmFsdWVDb252ZXJ0ZXIoJ3ZpZXcnKShWaWV3VmFsdWVDb252ZXJ0ZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCJpbXBvcnQgeyBrZWJhYkNhc2UgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQmluZGluZ01vZGUgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmV4cG9ydCB2YXIgU3ltYm9sRmxhZ3M7XG4oZnVuY3Rpb24gKFN5bWJvbEZsYWdzKSB7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJ0eXBlXCJdID0gMTAyM10gPSBcInR5cGVcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImlzVGVtcGxhdGVDb250cm9sbGVyXCJdID0gMV0gPSBcImlzVGVtcGxhdGVDb250cm9sbGVyXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJpc1Byb2plY3Rpb25cIl0gPSAyXSA9IFwiaXNQcm9qZWN0aW9uXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJpc0N1c3RvbUF0dHJpYnV0ZVwiXSA9IDRdID0gXCJpc0N1c3RvbUF0dHJpYnV0ZVwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaXNQbGFpbkF0dHJpYnV0ZVwiXSA9IDhdID0gXCJpc1BsYWluQXR0cmlidXRlXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJpc0N1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcImlzQ3VzdG9tRWxlbWVudFwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaXNMZXRFbGVtZW50XCJdID0gMzJdID0gXCJpc0xldEVsZW1lbnRcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImlzUGxhaW5FbGVtZW50XCJdID0gNjRdID0gXCJpc1BsYWluRWxlbWVudFwiO1xuICAgIFN5bWJvbEZsYWdzW1N5bWJvbEZsYWdzW1wiaXNUZXh0XCJdID0gMTI4XSA9IFwiaXNUZXh0XCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJpc0JpbmRpbmdcIl0gPSAyNTZdID0gXCJpc0JpbmRpbmdcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImlzQXVTbG90XCJdID0gNTEyXSA9IFwiaXNBdVNsb3RcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImhhc01hcmtlclwiXSA9IDEwMjRdID0gXCJoYXNNYXJrZXJcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImhhc1RlbXBsYXRlXCJdID0gMjA0OF0gPSBcImhhc1RlbXBsYXRlXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJoYXNBdHRyaWJ1dGVzXCJdID0gNDA5Nl0gPSBcImhhc0F0dHJpYnV0ZXNcIjtcbiAgICBTeW1ib2xGbGFnc1tTeW1ib2xGbGFnc1tcImhhc0JpbmRpbmdzXCJdID0gODE5Ml0gPSBcImhhc0JpbmRpbmdzXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJoYXNDaGlsZE5vZGVzXCJdID0gMTYzODRdID0gXCJoYXNDaGlsZE5vZGVzXCI7XG4gICAgU3ltYm9sRmxhZ3NbU3ltYm9sRmxhZ3NbXCJoYXNQcm9qZWN0aW9uc1wiXSA9IDMyNzY4XSA9IFwiaGFzUHJvamVjdGlvbnNcIjtcbn0pKFN5bWJvbEZsYWdzIHx8IChTeW1ib2xGbGFncyA9IHt9KSk7XG5mdW5jdGlvbiBjcmVhdGVNYXJrZXIocCkge1xuICAgIGNvbnN0IG1hcmtlciA9IHAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXUtbScpO1xuICAgIG1hcmtlci5jbGFzc05hbWUgPSAnYXUnO1xuICAgIHJldHVybiBtYXJrZXI7XG59XG4vKipcbiAqIEEgaHRtbCBhdHRyaWJ1dGUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHJlc291cmNlLCBzcGVjaWZpY2FsbHkgYSB0ZW1wbGF0ZSBjb250cm9sbGVyLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVDb250cm9sbGVyU3ltYm9sIHtcbiAgICBjb25zdHJ1Y3RvcihwLCBzeW50YXgsIGluZm8sIHJlcyA9IGluZm8ubmFtZSkge1xuICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheDtcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAxIC8qIGlzVGVtcGxhdGVDb250cm9sbGVyICovIHwgMTAyNCAvKiBoYXNNYXJrZXIgKi87XG4gICAgICAgIHRoaXMucGh5c2ljYWxOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGVtcGxhdGVDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLm1hcmtlciA9IGNyZWF0ZU1hcmtlcihwKTtcbiAgICB9XG4gICAgZ2V0IGJpbmRpbmdzKCkge1xuICAgICAgICBpZiAodGhpcy5fYmluZGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDgxOTIgLyogaGFzQmluZGluZ3MgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQcm9qZWN0aW9uU3ltYm9sIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAyIC8qIGlzUHJvamVjdGlvbiAqLztcbiAgICB9XG59XG4vKipcbiAqIEEgaHRtbCBhdHRyaWJ1dGUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHJlc291cmNlLCBidXQgbm90IGEgdGVtcGxhdGUgY29udHJvbGxlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEN1c3RvbUF0dHJpYnV0ZVN5bWJvbCB7XG4gICAgY29uc3RydWN0b3Ioc3ludGF4LCBpbmZvLCByZXMgPSBpbmZvLm5hbWUpIHtcbiAgICAgICAgdGhpcy5zeW50YXggPSBzeW50YXg7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLmZsYWdzID0gNCAvKiBpc0N1c3RvbUF0dHJpYnV0ZSAqLztcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgYmluZGluZ3MoKSB7XG4gICAgICAgIGlmICh0aGlzLl9iaW5kaW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gODE5MiAvKiBoYXNCaW5kaW5ncyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3M7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBhdHRyaWJ1dGUsIHdpdGggZWl0aGVyIGEgYmluZGluZyBjb21tYW5kIG9yIGFuIGludGVycG9sYXRpb24sIHdob3NlIHRhcmdldCBpcyB0aGUgaHRtbFxuICogYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgd2lsbCBuZXZlciB0YXJnZXQgYSBiaW5kYWJsZSBwcm9wZXJ0eSBvZiBhIGN1c3RvbSBhdHRyaWJ1dGUgb3IgZWxlbWVudDtcbiAqL1xuZXhwb3J0IGNsYXNzIFBsYWluQXR0cmlidXRlU3ltYm9sIHtcbiAgICBjb25zdHJ1Y3RvcihzeW50YXgsIGNvbW1hbmQsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zeW50YXggPSBzeW50YXg7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuZmxhZ3MgPSA4IC8qIGlzUGxhaW5BdHRyaWJ1dGUgKi87XG4gICAgfVxufVxuLyoqXG4gKiBFaXRoZXIgYW4gYXR0cmlidXRlIG9uIGFuIGN1c3RvbSBlbGVtZW50IHRoYXQgbWFwcyB0byBhIGRlY2xhcmVkIGJpbmRhYmxlIHByb3BlcnR5IG9mIHRoYXQgZWxlbWVudCxcbiAqIGEgc2luZ2xlLXZhbHVlIGJvdW5kIGN1c3RvbSBhdHRyaWJ1dGUsIG9yIG9uZSBvZiBzZXZlcmFsIGJpbmRhYmxlcyB0aGF0IHdlcmUgZXh0cmFjdGVkIGZyb20gdGhlIGF0dHJpYnV0ZVxuICogdmFsdWUgb2YgYSBjdXN0b20gYXR0cmlidXRlIHdpdGggbXVsdGlwbGUgYmluZGluZ3MgdXNhZ2UuXG4gKlxuICogVGhpcyB3aWxsIGFsd2F5cyB0YXJnZXQgYSBiaW5kYWJsZSBwcm9wZXJ0eSBvZiBhIGN1c3RvbSBhdHRyaWJ1dGUgb3IgZWxlbWVudDtcbiAqL1xuZXhwb3J0IGNsYXNzIEJpbmRpbmdTeW1ib2wge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQsIGJpbmRhYmxlLCBleHByZXNzaW9uLCByYXdWYWx1ZSwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgIHRoaXMuYmluZGFibGUgPSBiaW5kYWJsZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5yYXdWYWx1ZSA9IHJhd1ZhbHVlO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5mbGFncyA9IDI1NiAvKiBpc0JpbmRpbmcgKi87XG4gICAgfVxufVxuLyoqXG4gKiBBIGh0bWwgZWxlbWVudCB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhIHJlZ2lzdGVyZWQgcmVzb3VyY2UgZWl0aGVyIHZpYSBpdHMgKGxvd2VyQ2FzZSkgYG5vZGVOYW1lYFxuICogb3IgdGhlIHZhbHVlIG9mIGl0cyBgYXMtZWxlbWVudGAgYXR0cmlidXRlLlxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tRWxlbWVudFN5bWJvbCB7XG4gICAgY29uc3RydWN0b3IocCwgcGh5c2ljYWxOb2RlLCBpbmZvLCByZXMgPSBpbmZvLm5hbWUsIGJpbmRhYmxlcyA9IGluZm8uYmluZGFibGVzKSB7XG4gICAgICAgIHRoaXMucGh5c2ljYWxOb2RlID0gcGh5c2ljYWxOb2RlO1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgdGhpcy5iaW5kYWJsZXMgPSBiaW5kYWJsZXM7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAxNiAvKiBpc0N1c3RvbUVsZW1lbnQgKi87XG4gICAgICAgIHRoaXMuaXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1c3RvbUF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wbGFpbkF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoaWxkTm9kZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm9qZWN0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmIChpbmZvLmNvbnRhaW5lcmxlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb250YWluZXJsZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWFya2VyID0gY3JlYXRlTWFya2VyKHApO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSAxMDI0IC8qIGhhc01hcmtlciAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb250YWluZXJsZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1c3RvbUF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXN0b21BdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXN0b21BdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQwOTYgLyogaGFzQXR0cmlidXRlcyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tQXR0cmlidXRlcztcbiAgICB9XG4gICAgZ2V0IHBsYWluQXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsYWluQXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGxhaW5BdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQwOTYgLyogaGFzQXR0cmlidXRlcyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGxhaW5BdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBnZXQgYmluZGluZ3MoKSB7XG4gICAgICAgIGlmICh0aGlzLl9iaW5kaW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gODE5MiAvKiBoYXNCaW5kaW5ncyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3M7XG4gICAgfVxuICAgIGdldCBjaGlsZE5vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5fY2hpbGROb2RlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSAxNjM4NCAvKiBoYXNDaGlsZE5vZGVzICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBnZXQgcHJvamVjdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gMzI3NjggLyogaGFzUHJvamVjdGlvbnMgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMZXRFbGVtZW50U3ltYm9sIHtcbiAgICBjb25zdHJ1Y3RvcihwLCBwaHlzaWNhbE5vZGUsIG1hcmtlciA9IGNyZWF0ZU1hcmtlcihwKSkge1xuICAgICAgICB0aGlzLnBoeXNpY2FsTm9kZSA9IHBoeXNpY2FsTm9kZTtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBtYXJrZXI7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAzMiAvKiBpc0xldEVsZW1lbnQgKi8gfCAxMDI0IC8qIGhhc01hcmtlciAqLztcbiAgICAgICAgdGhpcy50b0JpbmRpbmdDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdzID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGJpbmRpbmdzKCkge1xuICAgICAgICBpZiAodGhpcy5fYmluZGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDgxOTIgLyogaGFzQmluZGluZ3MgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzO1xuICAgIH1cbn1cbi8qKlxuICogQSBub3JtYWwgaHRtbCBlbGVtZW50IHRoYXQgbWF5IG9yIG1heSBub3QgaGF2ZSBhdHRyaWJ1dGUgYmVoYXZpb3JzIGFuZC9vciBjaGlsZCBub2RlIGJlaGF2aW9ycy5cbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSBmb3IgYSBQbGFpbkVsZW1lbnRTeW1ib2wgdG8gbm90IHlpZWxkIGFueSBpbnN0cnVjdGlvbnMgZHVyaW5nIGNvbXBpbGF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgUGxhaW5FbGVtZW50U3ltYm9sIHtcbiAgICBjb25zdHJ1Y3RvcihwaHlzaWNhbE5vZGUpIHtcbiAgICAgICAgdGhpcy5waHlzaWNhbE5vZGUgPSBwaHlzaWNhbE5vZGU7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSA2NCAvKiBpc1BsYWluRWxlbWVudCAqLztcbiAgICAgICAgdGhpcy5pc1RhcmdldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzU2xvdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VzdG9tQXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BsYWluQXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoaWxkTm9kZXMgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgY3VzdG9tQXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1c3RvbUF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1c3RvbUF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gNDA5NiAvKiBoYXNBdHRyaWJ1dGVzICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXN0b21BdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBnZXQgcGxhaW5BdHRyaWJ1dGVzKCkge1xuICAgICAgICBpZiAodGhpcy5fcGxhaW5BdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGFpbkF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gNDA5NiAvKiBoYXNBdHRyaWJ1dGVzICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGFpbkF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGdldCBjaGlsZE5vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5fY2hpbGROb2RlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSAxNjM4NCAvKiBoYXNDaGlsZE5vZGVzICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZE5vZGVzO1xuICAgIH1cbn1cbi8qKlxuICogQSBzdGFuZGFsb25lIHRleHQgbm9kZSB0aGF0IGhhcyBhbiBpbnRlcnBvbGF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFN5bWJvbCB7XG4gICAgY29uc3RydWN0b3IocCwgcGh5c2ljYWxOb2RlLCBpbnRlcnBvbGF0aW9uLCBtYXJrZXIgPSBjcmVhdGVNYXJrZXIocCkpIHtcbiAgICAgICAgdGhpcy5waHlzaWNhbE5vZGUgPSBwaHlzaWNhbE5vZGU7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMubWFya2VyID0gbWFya2VyO1xuICAgICAgICB0aGlzLmZsYWdzID0gMTI4IC8qIGlzVGV4dCAqLyB8IDEwMjQgLyogaGFzTWFya2VyICovO1xuICAgIH1cbn1cbi8qKlxuICogQSBwcmUtcHJvY2Vzc2VkIHBpZWNlIG9mIGluZm9ybWF0aW9uIGFib3V0IGEgZGVmaW5lZCBiaW5kYWJsZSBwcm9wZXJ0eSBvbiBhIGN1c3RvbVxuICogZWxlbWVudCBvciBhdHRyaWJ1dGUsIG9wdGltaXplZCBmb3IgY29uc3VtcHRpb24gYnkgdGhlIHRlbXBsYXRlIGNvbXBpbGVyLlxuICovXG5leHBvcnQgY2xhc3MgQmluZGFibGVJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgcHJlLXByb2Nlc3NlZCAqcHJvcGVydHkqIChub3QgYXR0cmlidXRlKSBuYW1lIG9mIHRoZSBiaW5kYWJsZSwgd2hpY2ggaXNcbiAgICAgKiAoaW4gb3JkZXIgb2YgcHJpb3JpdHkpOlxuICAgICAqXG4gICAgICogMS4gVGhlIGBwcm9wZXJ0eWAgZnJvbSB0aGUgZGVzY3JpcHRpb24gKGlmIGRlZmluZWQpXG4gICAgICogMi4gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IG9mIHRoZSBiaW5kYWJsZSBpdHNlbGZcbiAgICAgKi9cbiAgICBwcm9wTmFtZSwgXG4gICAgLyoqXG4gICAgICogVGhlIHByZS1wcm9jZXNzZWQgKGRlZmF1bHQpIGJpbmRpbmdNb2RlIG9mIHRoZSBiaW5kYWJsZSwgd2hpY2ggaXMgKGluIG9yZGVyIG9mIHByaW9yaXR5KTpcbiAgICAgKlxuICAgICAqIDEuIFRoZSBgbW9kZWAgZnJvbSB0aGUgYmluZGFibGUgKGlmIGRlZmluZWQgYW5kIG5vdCBiaW5kaW5nTW9kZS5kZWZhdWx0KVxuICAgICAqIDIuIFRoZSBgZGVmYXVsdEJpbmRpbmdNb2RlYCAoaWYgaXQncyBhbiBhdHRyaWJ1dGUsIGRlZmluZWQsIGFuZCBub3QgYmluZGluZ01vZGUuZGVmYXVsdClcbiAgICAgKiAzLiBgYmluZGluZ01vZGUudG9WaWV3YFxuICAgICAqL1xuICAgIG1vZGUpIHtcbiAgICAgICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIH1cbn1cbmNvbnN0IGVsZW1lbnRJbmZvTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogUHJlLXByb2Nlc3NlZCBpbmZvcm1hdGlvbiBhYm91dCBhIGN1c3RvbSBlbGVtZW50IHJlc291cmNlLCBvcHRpbWl6ZWRcbiAqIGZvciBjb25zdW1wdGlvbiBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbGVtZW50SW5mbyB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYWxpYXMsIGNvbnRhaW5lcmxlc3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmNvbnRhaW5lcmxlc3MgPSBjb250YWluZXJsZXNzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsb29rdXAgb2YgdGhlIGJpbmRhYmxlcyBvZiB0aGlzIGVsZW1lbnQsIGluZGV4ZWQgYnkgdGhlIChwcmUtcHJvY2Vzc2VkKVxuICAgICAgICAgKiBhdHRyaWJ1dGUgbmFtZXMgYXMgdGhleSB3b3VsZCBiZSBmb3VuZCBpbiBwYXJzZWQgbWFya3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kYWJsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShkZWYsIGFsaWFzKSB7XG4gICAgICAgIGlmIChkZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWMgPSBlbGVtZW50SW5mb0xvb2t1cC5nZXQoZGVmKTtcbiAgICAgICAgaWYgKHJlYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBlbGVtZW50SW5mb0xvb2t1cC5zZXQoZGVmLCByZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5mbyA9IHJlY1thbGlhc107XG4gICAgICAgIGlmIChpbmZvID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGluZm8gPSByZWNbYWxpYXNdID0gbmV3IEVsZW1lbnRJbmZvKGRlZi5uYW1lLCBhbGlhcyA9PT0gZGVmLm5hbWUgPyB2b2lkIDAgOiBhbGlhcywgZGVmLmNvbnRhaW5lcmxlc3MpO1xuICAgICAgICAgICAgY29uc3QgYmluZGFibGVzID0gZGVmLmJpbmRhYmxlcztcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRCaW5kaW5nTW9kZSA9IEJpbmRpbmdNb2RlLnRvVmlldztcbiAgICAgICAgICAgIGxldCBiaW5kYWJsZTtcbiAgICAgICAgICAgIGxldCBwcm9wO1xuICAgICAgICAgICAgbGV0IGF0dHI7XG4gICAgICAgICAgICBsZXQgbW9kZTtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBiaW5kYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBiaW5kYWJsZSA9IGJpbmRhYmxlc1twcm9wXTtcbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnR5IG5hbWUgaGFzIHByaW9yaXR5IG92ZXIgdGhlIGltcGxpY2l0IHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBpZiAoYmluZGFibGUucHJvcGVydHkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wID0gYmluZGFibGUucHJvcGVydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkgcHJvdmlkZWQgYXR0cmlidXRlIG5hbWUgaGFzIHByaW9yaXR5IG92ZXIgdGhlIGRlcml2ZWQgaW1wbGljaXQgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAoYmluZGFibGUuYXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGJpbmRhYmxlLmF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgYXR0cmlidXRlIG5hbWUgZnJvbSB0aGUgcmVzb2x2ZWQgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgICAgICBhdHRyID0ga2ViYWJDYXNlKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmluZGFibGUubW9kZSAhPT0gdm9pZCAwICYmIGJpbmRhYmxlLm1vZGUgIT09IEJpbmRpbmdNb2RlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IGJpbmRhYmxlLm1vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gZGVmYXVsdEJpbmRpbmdNb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmZvLmJpbmRhYmxlc1thdHRyXSA9IG5ldyBCaW5kYWJsZUluZm8ocHJvcCwgbW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxufVxuY29uc3QgYXR0ckluZm9Mb29rdXAgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBQcmUtcHJvY2Vzc2VkIGluZm9ybWF0aW9uIGFib3V0IGEgY3VzdG9tIGF0dHJpYnV0ZSByZXNvdXJjZSwgb3B0aW1pemVkXG4gKiBmb3IgY29uc3VtcHRpb24gYnkgdGhlIHRlbXBsYXRlIGNvbXBpbGVyLlxuICovXG5leHBvcnQgY2xhc3MgQXR0ckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFsaWFzLCBpc1RlbXBsYXRlQ29udHJvbGxlciwgbm9NdWx0aUJpbmRpbmdzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5pc1RlbXBsYXRlQ29udHJvbGxlciA9IGlzVGVtcGxhdGVDb250cm9sbGVyO1xuICAgICAgICB0aGlzLm5vTXVsdGlCaW5kaW5ncyA9IG5vTXVsdGlCaW5kaW5ncztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbG9va3VwIG9mIHRoZSBiaW5kYWJsZXMgb2YgdGhpcyBhdHRyaWJ1dGUsIGluZGV4ZWQgYnkgdGhlIChwcmUtcHJvY2Vzc2VkKVxuICAgICAgICAgKiBiaW5kYWJsZSBuYW1lcyBhcyB0aGV5IHdvdWxkIGJlIGZvdW5kIGluIHRoZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYXBwbGljYWJsZSB0byBtdWx0aSBhdHRyaWJ1dGUgYmluZGluZ3MgKHNlbWljb2xvbi1zZXBhcmF0ZWQpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kYWJsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpbmdsZSBvciBmaXJzdCBiaW5kYWJsZSBvZiB0aGlzIGF0dHJpYnV0ZSwgb3IgYSBkZWZhdWx0ICd2YWx1ZSdcbiAgICAgICAgICogYmluZGFibGUgaWYgbm8gYmluZGFibGVzIHdlcmUgZGVmaW5lZCBvbiB0aGUgYXR0cmlidXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmx5IGFwcGxpY2FibGUgdG8gc2luZ2xlIGF0dHJpYnV0ZSBiaW5kaW5ncyAod2hlcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgKiBjb250YWlucyBubyBzZW1pY29sb25zKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kYWJsZSA9IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGRlZiwgYWxpYXMpIHtcbiAgICAgICAgaWYgKGRlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlYyA9IGF0dHJJbmZvTG9va3VwLmdldChkZWYpO1xuICAgICAgICBpZiAocmVjID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGF0dHJJbmZvTG9va3VwLnNldChkZWYsIHJlYyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmZvID0gcmVjW2FsaWFzXTtcbiAgICAgICAgaWYgKGluZm8gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaW5mbyA9IHJlY1thbGlhc10gPSBuZXcgQXR0ckluZm8oZGVmLm5hbWUsIGFsaWFzID09PSBkZWYubmFtZSA/IHZvaWQgMCA6IGFsaWFzLCBkZWYuaXNUZW1wbGF0ZUNvbnRyb2xsZXIsIGRlZi5ub011bHRpQmluZGluZ3MpO1xuICAgICAgICAgICAgY29uc3QgYmluZGFibGVzID0gZGVmLmJpbmRhYmxlcztcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRCaW5kaW5nTW9kZSA9IGRlZi5kZWZhdWx0QmluZGluZ01vZGUgIT09IHZvaWQgMCAmJiBkZWYuZGVmYXVsdEJpbmRpbmdNb2RlICE9PSBCaW5kaW5nTW9kZS5kZWZhdWx0XG4gICAgICAgICAgICAgICAgPyBkZWYuZGVmYXVsdEJpbmRpbmdNb2RlXG4gICAgICAgICAgICAgICAgOiBCaW5kaW5nTW9kZS50b1ZpZXc7XG4gICAgICAgICAgICBsZXQgYmluZGFibGU7XG4gICAgICAgICAgICBsZXQgcHJvcDtcbiAgICAgICAgICAgIGxldCBtb2RlO1xuICAgICAgICAgICAgbGV0IGhhc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBiaW5kYWJsZUluZm87XG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gYmluZGFibGVzKSB7XG4gICAgICAgICAgICAgICAgYmluZGFibGUgPSBiaW5kYWJsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgLy8gZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0eSBuYW1lIGhhcyBwcmlvcml0eSBvdmVyIHRoZSBpbXBsaWNpdCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKGJpbmRhYmxlLnByb3BlcnR5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGJpbmRhYmxlLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmluZGFibGUubW9kZSAhPT0gdm9pZCAwICYmIGJpbmRhYmxlLm1vZGUgIT09IEJpbmRpbmdNb2RlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IGJpbmRhYmxlLm1vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gZGVmYXVsdEJpbmRpbmdNb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1ByaW1hcnkgPSBiaW5kYWJsZS5wcmltYXJ5ID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIGJpbmRhYmxlSW5mbyA9IGluZm8uYmluZGFibGVzW3Byb3BdID0gbmV3IEJpbmRhYmxlSW5mbyhwcm9wLCBtb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaW1hcnkgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYXNQcmltYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5iaW5kYWJsZSA9IGJpbmRhYmxlSW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRvIGZpcnN0IGJpbmRhYmxlIGJ5IGNvbnZlbnRpb25cbiAgICAgICAgICAgICAgICBpZiAoaW5mby5iaW5kYWJsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLmJpbmRhYmxlID0gYmluZGFibGVJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vIGJpbmRhYmxlcyBhcmUgcHJlc2VudCwgZGVmYXVsdCB0byBcInZhbHVlXCJcbiAgICAgICAgICAgIGlmIChpbmZvLmJpbmRhYmxlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5mby5iaW5kYWJsZSA9IG5ldyBCaW5kYWJsZUluZm8oJ3ZhbHVlJywgZGVmYXVsdEJpbmRpbmdNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZW1hbnRpYy1tb2RlbC5qcy5tYXAiLCJpbXBvcnQgeyBjYW1lbENhc2UsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEJpbmRpbmdNb2RlLCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUnO1xuaW1wb3J0IHsgQmluZGluZ0NvbW1hbmQgfSBmcm9tICcuL3Jlc291cmNlcy9iaW5kaW5nLWNvbW1hbmQuanMnO1xuaW1wb3J0IHsgQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgQmluZGluZ1N5bWJvbCwgQ3VzdG9tQXR0cmlidXRlU3ltYm9sLCBDdXN0b21FbGVtZW50U3ltYm9sLCBMZXRFbGVtZW50U3ltYm9sLCBQbGFpbkF0dHJpYnV0ZVN5bWJvbCwgUGxhaW5FbGVtZW50U3ltYm9sLCBUZW1wbGF0ZUNvbnRyb2xsZXJTeW1ib2wsIFRleHRTeW1ib2wsIFByb2plY3Rpb25TeW1ib2wsIEF0dHJJbmZvLCBFbGVtZW50SW5mbywgQmluZGFibGVJbmZvLCB9IGZyb20gJy4vc2VtYW50aWMtbW9kZWwuanMnO1xuY29uc3QgaW52YWxpZFN1cnJvZ2F0ZUF0dHJpYnV0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICdpZCc6IHRydWUsXG4gICAgJ2F1LXNsb3QnOiB0cnVlLFxufSk7XG5jb25zdCBhdHRyaWJ1dGVzVG9JZ25vcmUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAnYXMtZWxlbWVudCc6IHRydWUsXG59KTtcbmZ1bmN0aW9uIGhhc0lubGluZUJpbmRpbmdzKHJhd1ZhbHVlKSB7XG4gICAgY29uc3QgbGVuID0gcmF3VmFsdWUubGVuZ3RoO1xuICAgIGxldCBjaCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjaCA9IHJhd1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaCA9PT0gOTIgLyogQmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAvLyBJZ25vcmUgd2hhdGV2ZXIgY29tZXMgbmV4dCBiZWNhdXNlIGl0J3MgZXNjYXBlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSA1OCAvKiBDb2xvbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDM2IC8qIERvbGxhciAqLyAmJiByYXdWYWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTIzIC8qIE9wZW5CcmFjZSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NJbnRlcnBvbGF0aW9uVGV4dChzeW1ib2wpIHtcbiAgICBjb25zdCBub2RlID0gc3ltYm9sLnBoeXNpY2FsTm9kZTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlLm5leHRTaWJsaW5nICE9PSBudWxsICYmIG5vZGUubmV4dFNpYmxpbmcubm9kZVR5cGUgPT09IDMgLyogVGV4dCAqLykge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICBub2RlLnRleHRDb250ZW50ID0gJyc7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3ltYm9sLm1hcmtlciwgbm9kZSk7XG59XG5mdW5jdGlvbiBpc1RlbXBsYXRlQ29udHJvbGxlck9mKHByb3h5LCBtYW5pZmVzdCkge1xuICAgIHJldHVybiBwcm94eSAhPT0gbWFuaWZlc3Q7XG59XG4vKipcbiAqIEEgKHRlbXBvcmFyeSkgc3RhbmRhbG9uZSBmdW5jdGlvbiB0aGF0IHB1cmVseSBkb2VzIHRoZSBET00gcHJvY2Vzc2luZyAobGlmdGluZykgcmVsYXRlZCB0byB0ZW1wbGF0ZSBjb250cm9sbGVycy5cbiAqIEl0J3MgYSBmaXJzdCByZWZhY3RvcmluZyBzdGVwIHRvd2FyZHMgc2VwYXJhdGluZyBET00gcGFyc2luZy9iaW5kaW5nIGZyb20gbXV0YXRpb25zLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzVGVtcGxhdGVDb250cm9sbGVycyhwLCBtYW5pZmVzdFByb3h5LCBtYW5pZmVzdCkge1xuICAgIGNvbnN0IG1hbmlmZXN0Tm9kZSA9IG1hbmlmZXN0LnBoeXNpY2FsTm9kZTtcbiAgICBsZXQgY3VycmVudCA9IG1hbmlmZXN0UHJveHk7XG4gICAgbGV0IGN1cnJlbnRUZW1wbGF0ZTtcbiAgICB3aGlsZSAoaXNUZW1wbGF0ZUNvbnRyb2xsZXJPZihjdXJyZW50LCBtYW5pZmVzdCkpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQudGVtcGxhdGUgPT09IG1hbmlmZXN0KSB7XG4gICAgICAgICAgICAvLyB0aGUgRE9NIGxpbmthZ2UgaXMgc3RpbGwgaW4gaXRzIG9yaWdpbmFsIHN0YXRlIGhlcmUgc28gd2UgY2FuIHNhZmVseSBhc3N1bWUgdGhlIHBhcmVudE5vZGUgaXMgbm9uLW51bGxcbiAgICAgICAgICAgIG1hbmlmZXN0Tm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjdXJyZW50Lm1hcmtlciwgbWFuaWZlc3ROb2RlKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBtYW5pZmVzdCBpcyBhIHRlbXBsYXRlIGVsZW1lbnQgKGUuZy4gPHRlbXBsYXRlIHJlcGVhdC5mb3I9XCIuLi5cIj4pIHRoZW4gd2UgY2FuIHNraXAgb25lIGxpZnQgb3BlcmF0aW9uXG4gICAgICAgICAgICAvLyBhbmQgc2ltcGx5IHVzZSB0aGUgdGVtcGxhdGUgZGlyZWN0bHksIHNhdmluZyBhIGJpdCBvZiB3b3JrXG4gICAgICAgICAgICBpZiAobWFuaWZlc3ROb2RlLm5vZGVOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5waHlzaWNhbE5vZGUgPSBtYW5pZmVzdE5vZGU7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRlbXBsYXRlIGNvdWxkIHNhZmVseSBzdGF5IHdpdGhvdXQgYWZmZWN0aW5nIGFueXRoaW5nIHZpc2libGUsIGJ1dCBsZXQncyBrZWVwIHRoZSBET00gdGlkeVxuICAgICAgICAgICAgICAgIG1hbmlmZXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBtYW5pZmVzdCBpcyBub3QgYSB0ZW1wbGF0ZSBlbGVtZW50IHNvIHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBvbmVcbiAgICAgICAgICAgICAgICBjdXJyZW50VGVtcGxhdGUgPSBjdXJyZW50LnBoeXNpY2FsTm9kZSA9IHAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChtYW5pZmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFRlbXBsYXRlID0gY3VycmVudC5waHlzaWNhbE5vZGUgPSBwLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICBjdXJyZW50VGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChjdXJyZW50Lm1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgbWFuaWZlc3ROb2RlLnJlbW92ZUF0dHJpYnV0ZShjdXJyZW50LnN5bnRheC5yYXdOYW1lKTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQudGVtcGxhdGU7XG4gICAgfVxufVxuLyoqXG4gKiBUZW1wbGF0ZUJpbmRlci4gVG9kbzogZGVzY3JpYmUgZ29hbCBvZiB0aGlzIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZUJpbmRlciB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm0sIGNvbnRhaW5lciwgYXR0clBhcnNlciwgZXhwclBhcnNlciwgYXR0clN5bnRheFRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuYXR0clBhcnNlciA9IGF0dHJQYXJzZXI7XG4gICAgICAgIHRoaXMuZXhwclBhcnNlciA9IGV4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuYXR0clN5bnRheFRyYW5zZm9ybWVyID0gYXR0clN5bnRheFRyYW5zZm9ybWVyO1xuICAgICAgICB0aGlzLmNvbW1hbmRMb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBiaW5kKG5vZGUpIHtcbiAgICAgICAgY29uc3Qgc3Vycm9nYXRlID0gbmV3IFBsYWluRWxlbWVudFN5bWJvbChub2RlKTtcbiAgICAgICAgY29uc3QgYXR0clN5bnRheFRyYW5zZm9ybWVyID0gdGhpcy5hdHRyU3ludGF4VHJhbnNmb3JtZXI7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICBjb25zdCBhdHRyU3ludGF4ID0gdGhpcy5hdHRyUGFyc2VyLnBhcnNlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaW52YWxpZFN1cnJvZ2F0ZUF0dHJpYnV0ZVthdHRyU3ludGF4LnRhcmdldF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3Vycm9nYXRlIGF0dHJpYnV0ZTogJHthdHRyU3ludGF4LnRhcmdldH1gKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB1c2UgcmVwb3J0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdDb21tYW5kID0gdGhpcy5nZXRCaW5kaW5nQ29tbWFuZChhdHRyU3ludGF4LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nQ29tbWFuZCA9PT0gbnVsbCB8fCAoYmluZGluZ0NvbW1hbmQuYmluZGluZ1R5cGUgJiA0MDk2IC8qIElnbm9yZUN1c3RvbUF0dHIgKi8pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ckluZm8gPSBBdHRySW5mby5mcm9tKHRoaXMuY29udGFpbmVyLmZpbmQoQ3VzdG9tQXR0cmlidXRlLCBhdHRyU3ludGF4LnRhcmdldCksIGF0dHJTeW50YXgudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ckluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFwIHNwZWNpYWwgaHRtbCBhdHRyaWJ1dGVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBhdHRyU3ludGF4VHJhbnNmb3JtZXIudHJhbnNmb3JtKG5vZGUsIGF0dHJTeW50YXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBhIGN1c3RvbSBhdHRyaWJ1dGUgYnV0IG1pZ2h0IGJlIGEgcmVndWxhciBib3VuZCBhdHRyaWJ1dGUgb3IgaW50ZXJwb2xhdGlvbiAoaXQgbWlnaHQgYWxzbyBiZSBub3RoaW5nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRQbGFpbkF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgLyogYXR0clN5bnRheCAqLyBhdHRyU3ludGF4LCBcbiAgICAgICAgICAgICAgICAgICAgLyogYXR0ciAgICAgICAqLyBhdHRyLCBcbiAgICAgICAgICAgICAgICAgICAgLyogc3Vycm9nYXRlICAqLyBzdXJyb2dhdGUsIFxuICAgICAgICAgICAgICAgICAgICAvKiBtYW5pZmVzdCAgICovIHN1cnJvZ2F0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHJJbmZvLmlzVGVtcGxhdGVDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgdGVtcGxhdGUgY29udHJvbGxlciBvbiBzdXJyb2dhdGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdXNlIHJlcG9ydGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRDdXN0b21BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJTeW50YXggKi8gYXR0clN5bnRheCwgXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJJbmZvICAgKi8gYXR0ckluZm8sIFxuICAgICAgICAgICAgICAgICAgICAvKiBjb21tYW5kICAgICovIGJpbmRpbmdDb21tYW5kLCBcbiAgICAgICAgICAgICAgICAgICAgLyogbWFuaWZlc3QgICAqLyBzdXJyb2dhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1hcCBzcGVjaWFsIGh0bWwgYXR0cmlidXRlcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBhdHRyU3ludGF4VHJhbnNmb3JtZXIudHJhbnNmb3JtKG5vZGUsIGF0dHJTeW50YXgpO1xuICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IGEgY3VzdG9tIGF0dHJpYnV0ZSBidXQgbWlnaHQgYmUgYSByZWd1bGFyIGJvdW5kIGF0dHJpYnV0ZSBvciBpbnRlcnBvbGF0aW9uIChpdCBtaWdodCBhbHNvIGJlIG5vdGhpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kUGxhaW5BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgLyogYXR0clN5bnRheCAqLyBhdHRyU3ludGF4LCBcbiAgICAgICAgICAgICAgICAvKiBhdHRyICAgICAgICovIGF0dHIsIFxuICAgICAgICAgICAgICAgIC8qIHN1cnJvZ2F0ZSAgKi8gc3Vycm9nYXRlLCBcbiAgICAgICAgICAgICAgICAvKiBtYW5pZmVzdCAgICovIHN1cnJvZ2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kQ2hpbGROb2RlcyhcbiAgICAgICAgLyogbm9kZSAgICAgICAgICAgICAgICovIG5vZGUsIFxuICAgICAgICAvKiBzdXJyb2dhdGUgICAgICAgICAgKi8gc3Vycm9nYXRlLCBcbiAgICAgICAgLyogbWFuaWZlc3QgICAgICAgICAgICovIHN1cnJvZ2F0ZSwgXG4gICAgICAgIC8qIG1hbmlmZXN0Um9vdCAgICAgICAqLyBudWxsLCBcbiAgICAgICAgLyogcGFyZW50TWFuaWZlc3RSb290ICovIG51bGwpO1xuICAgICAgICByZXR1cm4gc3Vycm9nYXRlO1xuICAgIH1cbiAgICBiaW5kTWFuaWZlc3QocGFyZW50TWFuaWZlc3QsIG5vZGUsIHN1cnJvZ2F0ZSwgbWFuaWZlc3QsIG1hbmlmZXN0Um9vdCwgcGFyZW50TWFuaWZlc3RSb290KSB7XG4gICAgICAgIGxldCBpc0F1U2xvdCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0xFVCc6XG4gICAgICAgICAgICAgICAgLy8gbGV0IGNhbm5vdCBoYXZlIGNoaWxkcmVuIGFuZCBoYXMgc29tZSBkaWZmZXJlbnQgcHJvY2Vzc2luZyBydWxlcywgc28gcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kTGV0RWxlbWVudChcbiAgICAgICAgICAgICAgICAvKiBwYXJlbnRNYW5pZmVzdCAqLyBwYXJlbnRNYW5pZmVzdCwgXG4gICAgICAgICAgICAgICAgLyogbm9kZSAgICAgICAgICAgKi8gbm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnU0xPVCc6XG4gICAgICAgICAgICAgICAgc3Vycm9nYXRlLmhhc1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0FVLVNMT1QnOlxuICAgICAgICAgICAgICAgIGlzQXVTbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdhcy1lbGVtZW50Jyk7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRJbmZvID0gRWxlbWVudEluZm8uZnJvbSh0aGlzLmNvbnRhaW5lci5maW5kKEN1c3RvbUVsZW1lbnQsIG5hbWUpLCBuYW1lKTtcbiAgICAgICAgaWYgKGVsZW1lbnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyByZWdpc3RlcmVkIGN1c3RvbSBlbGVtZW50IHdpdGggdGhpcyBuYW1lXG4gICAgICAgICAgICBtYW5pZmVzdCA9IG5ldyBQbGFpbkVsZW1lbnRTeW1ib2wobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpdCdzIGEgY3VzdG9tIGVsZW1lbnQgc28gd2Ugc2V0IHRoZSBtYW5pZmVzdFJvb3QgYXMgd2VsbCAoZm9yIHN0b3JpbmcgcmVwbGFjZXMpXG4gICAgICAgICAgICBwYXJlbnRNYW5pZmVzdFJvb3QgPSBtYW5pZmVzdFJvb3Q7XG4gICAgICAgICAgICBjb25zdCBjZVN5bWJvbCA9IG5ldyBDdXN0b21FbGVtZW50U3ltYm9sKHRoaXMucGxhdGZvcm0sIG5vZGUsIGVsZW1lbnRJbmZvKTtcbiAgICAgICAgICAgIGlmIChpc0F1U2xvdCkge1xuICAgICAgICAgICAgICAgIGNlU3ltYm9sLmZsYWdzID0gNTEyIC8qIGlzQXVTbG90ICovO1xuICAgICAgICAgICAgICAgIGNlU3ltYm9sLnNsb3ROYW1lID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID8/IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuaWZlc3RSb290ID0gbWFuaWZlc3QgPSBjZVN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBsaWZ0aW5nIG9wZXJhdGlvbnMgZG9uZSBieSB0ZW1wbGF0ZSBjb250cm9sbGVycyBhbmQgcmVwbGFjZXMgZWZmZWN0aXZlbHkgdW5saW5rIHRoZSBub2Rlcywgc28gc3RhcnQgYXQgdGhlIGJvdHRvbVxuICAgICAgICB0aGlzLmJpbmRDaGlsZE5vZGVzKFxuICAgICAgICAvKiBub2RlICAgICAgICAgICAgICAgKi8gbm9kZSwgXG4gICAgICAgIC8qIHN1cnJvZ2F0ZSAgICAgICAgICAqLyBzdXJyb2dhdGUsIFxuICAgICAgICAvKiBtYW5pZmVzdCAgICAgICAgICAgKi8gbWFuaWZlc3QsIFxuICAgICAgICAvKiBtYW5pZmVzdFJvb3QgICAgICAgKi8gbWFuaWZlc3RSb290LCBcbiAgICAgICAgLyogcGFyZW50TWFuaWZlc3RSb290ICovIHBhcmVudE1hbmlmZXN0Um9vdCk7XG4gICAgICAgIC8vIHRoZSBwYXJlbnRNYW5pZmVzdCB3aWxsIHJlY2VpdmUgZWl0aGVyIHRoZSBkaXJlY3QgY2hpbGQgbm9kZXMsIG9yIHRoZSB0ZW1wbGF0ZSBjb250cm9sbGVycyAvIHJlcGxhY2VzXG4gICAgICAgIC8vIHdyYXBwaW5nIHRoZW1cbiAgICAgICAgdGhpcy5iaW5kQXR0cmlidXRlcyhcbiAgICAgICAgLyogbm9kZSAgICAgICAgICAgICAgICovIG5vZGUsIFxuICAgICAgICAvKiBwYXJlbnRNYW5pZmVzdCAgICAgKi8gcGFyZW50TWFuaWZlc3QsIFxuICAgICAgICAvKiBzdXJyb2dhdGUgICAgICAgICAgKi8gc3Vycm9nYXRlLCBcbiAgICAgICAgLyogbWFuaWZlc3QgICAgICAgICAgICovIG1hbmlmZXN0LCBcbiAgICAgICAgLyogbWFuaWZlc3RSb290ICAgICAgICovIG1hbmlmZXN0Um9vdCwgXG4gICAgICAgIC8qIHBhcmVudE1hbmlmZXN0Um9vdCAqLyBwYXJlbnRNYW5pZmVzdFJvb3QpO1xuICAgICAgICBpZiAobWFuaWZlc3RSb290ID09PSBtYW5pZmVzdCAmJiBtYW5pZmVzdC5pc0NvbnRhaW5lcmxlc3MpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobWFuaWZlc3QubWFya2VyLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYW5pZmVzdC5pc1RhcmdldCkge1xuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdhdScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRMZXRFbGVtZW50KHBhcmVudE1hbmlmZXN0LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IG5ldyBMZXRFbGVtZW50U3ltYm9sKHRoaXMucGxhdGZvcm0sIG5vZGUpO1xuICAgICAgICBwYXJlbnRNYW5pZmVzdC5jaGlsZE5vZGVzLnB1c2goc3ltYm9sKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09ICd0by1iaW5kaW5nLWNvbnRleHQnKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3RvLWJpbmRpbmctY29udGV4dCcpO1xuICAgICAgICAgICAgICAgIHN5bWJvbC50b0JpbmRpbmdDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0dHJTeW50YXggPSB0aGlzLmF0dHJQYXJzZXIucGFyc2UoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmdldEJpbmRpbmdDb21tYW5kKGF0dHJTeW50YXgsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdUeXBlID0gY29tbWFuZCA9PT0gbnVsbCA/IDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyA6IGNvbW1hbmQuYmluZGluZ1R5cGU7XG4gICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5leHByUGFyc2VyLnBhcnNlKGF0dHJTeW50YXgucmF3VmFsdWUsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gY2FtZWxDYXNlKGF0dHJTeW50YXgudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBuZXcgQmluZGFibGVJbmZvKHRvLCBCaW5kaW5nTW9kZS50b1ZpZXcpO1xuICAgICAgICAgICAgc3ltYm9sLmJpbmRpbmdzLnB1c2gobmV3IEJpbmRpbmdTeW1ib2woY29tbWFuZCwgaW5mbywgZXhwciwgYXR0clN5bnRheC5yYXdWYWx1ZSwgdG8pKTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHN5bWJvbC5tYXJrZXIsIG5vZGUpO1xuICAgIH1cbiAgICBiaW5kQXR0cmlidXRlcyhub2RlLCBwYXJlbnRNYW5pZmVzdCwgc3Vycm9nYXRlLCBtYW5pZmVzdCwgbWFuaWZlc3RSb290LCBwYXJlbnRNYW5pZmVzdFJvb3QpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgdG9wLWxldmVsIHN5bWJvbCBmb3IgdGhlIGN1cnJlbnQgZGVwdGguXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyB0ZW1wbGF0ZSBjb250cm9sbGVycyBvciByZXBsYWNlcywgaXQgaXMgYWx3YXlzIHRoZSBtYW5pZmVzdCBpdHNlbGYuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSB0ZW1wbGF0ZSBjb250cm9sbGVycywgdGhlbiB0aGlzIHdpbGwgYmUgdGhlIG91dGVyLW1vc3QgVGVtcGxhdGVDb250cm9sbGVyU3ltYm9sLlxuICAgICAgICBsZXQgbWFuaWZlc3RQcm94eSA9IG1hbmlmZXN0O1xuICAgICAgICBsZXQgcHJldmlvdXNDb250cm9sbGVyID0gKHZvaWQgMCk7XG4gICAgICAgIGxldCBjdXJyZW50Q29udHJvbGxlciA9ICh2b2lkIDApO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNUb0lnbm9yZVthdHRyLm5hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdHRyU3ludGF4ID0gdGhpcy5hdHRyUGFyc2VyLnBhcnNlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nQ29tbWFuZCA9IHRoaXMuZ2V0QmluZGluZ0NvbW1hbmQoYXR0clN5bnRheCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoYmluZGluZ0NvbW1hbmQgPT09IG51bGwgfHwgKGJpbmRpbmdDb21tYW5kLmJpbmRpbmdUeXBlICYgNDA5NiAvKiBJZ25vcmVDdXN0b21BdHRyICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJJbmZvID0gQXR0ckluZm8uZnJvbSh0aGlzLmNvbnRhaW5lci5maW5kKEN1c3RvbUF0dHJpYnV0ZSwgYXR0clN5bnRheC50YXJnZXQpLCBhdHRyU3ludGF4LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcCBzcGVjaWFsIGh0bWwgYXR0cmlidXRlcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyU3ludGF4VHJhbnNmb3JtZXIudHJhbnNmb3JtKG5vZGUsIGF0dHJTeW50YXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBhIGN1c3RvbSBhdHRyaWJ1dGUgYnV0IG1pZ2h0IGJlIGEgcmVndWxhciBib3VuZCBhdHRyaWJ1dGUgb3IgaW50ZXJwb2xhdGlvbiAoaXQgbWlnaHQgYWxzbyBiZSBub3RoaW5nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRQbGFpbkF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgLyogYXR0clN5bnRheCAqLyBhdHRyU3ludGF4LCBcbiAgICAgICAgICAgICAgICAgICAgLyogYXR0ciAgICAgICAqLyBhdHRyLCBcbiAgICAgICAgICAgICAgICAgICAgLyogc3Vycm9nYXRlICAqLyBzdXJyb2dhdGUsIFxuICAgICAgICAgICAgICAgICAgICAvKiBtYW5pZmVzdCAgICovIG1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ckluZm8uaXNUZW1wbGF0ZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1hbmlmZXN0IGlzIHdyYXBwZWQgYnkgdGhlIGlubmVyLW1vc3QgdGVtcGxhdGUgY29udHJvbGxlciAoaWYgdGhlcmUgYXJlIG11bHRpcGxlIG9uIHRoZSBzYW1lIGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGtlZXAgc2V0dGluZyBtYW5pZmVzdC50ZW1wbGF0ZUNvbnRyb2xsZXIgdG8gdGhlIGxhdGVzdCB0ZW1wbGF0ZSBjb250cm9sbGVyIHdlIGZpbmRcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIgPSBtYW5pZmVzdC50ZW1wbGF0ZUNvbnRyb2xsZXIgPSB0aGlzLmRlY2xhcmVUZW1wbGF0ZUNvbnRyb2xsZXIoXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJTeW50YXggKi8gYXR0clN5bnRheCwgXG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dHJJbmZvICAgKi8gYXR0ckluZm8pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJveHkgYW5kIHRoZSBtYW5pZmVzdCBhcmUgb25seSBpZGVudGljYWwgd2hlbiB3ZSdyZSBhdCB0aGUgZmlyc3QgdGVtcGxhdGUgY29udHJvbGxlciAoc2luY2UgdGhlIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYXNzaWduZWQgdG8gdGhlIHByb3h5KSwgc28gdGhpcyBldmFsdWF0ZXMgdG8gdHJ1ZSBhdCBtb3N0IG9uY2UgcGVyIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmlmZXN0UHJveHkgPT09IG1hbmlmZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci50ZW1wbGF0ZSA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3RQcm94eSA9IGN1cnJlbnRDb250cm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudGVtcGxhdGVDb250cm9sbGVyID0gcHJldmlvdXNDb250cm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudGVtcGxhdGUgPSBwcmV2aW91c0NvbnRyb2xsZXIudGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NvbnRyb2xsZXIudGVtcGxhdGUgPSBjdXJyZW50Q29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NvbnRyb2xsZXIgPSBjdXJyZW50Q29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcmVndWxhciBjdXN0b20gYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZEN1c3RvbUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgLyogYXR0clN5bnRheCAqLyBhdHRyU3ludGF4LCBcbiAgICAgICAgICAgICAgICAgICAgLyogYXR0ckluZm8gICAqLyBhdHRySW5mbywgXG4gICAgICAgICAgICAgICAgICAgIC8qIGNvbW1hbmQgICAgKi8gYmluZGluZ0NvbW1hbmQsIFxuICAgICAgICAgICAgICAgICAgICAvKiBtYW5pZmVzdCAgICovIG1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYXAgc3BlY2lhbCBodG1sIGF0dHJpYnV0ZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyU3ludGF4VHJhbnNmb3JtZXIudHJhbnNmb3JtKG5vZGUsIGF0dHJTeW50YXgpO1xuICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IGEgY3VzdG9tIGF0dHJpYnV0ZSBidXQgbWlnaHQgYmUgYSByZWd1bGFyIGJvdW5kIGF0dHJpYnV0ZSBvciBpbnRlcnBvbGF0aW9uIChpdCBtaWdodCBhbHNvIGJlIG5vdGhpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kUGxhaW5BdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgLyogYXR0clN5bnRheCAqLyBhdHRyU3ludGF4LCBcbiAgICAgICAgICAgICAgICAvKiBhdHRyICAgICAgICovIGF0dHIsIFxuICAgICAgICAgICAgICAgIC8qIHN1cnJvZ2F0ZSAgKi8gc3Vycm9nYXRlLCBcbiAgICAgICAgICAgICAgICAvKiBtYW5pZmVzdCAgICovIG1hbmlmZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlQXR0cmlidXRlT3JkZXIobWFuaWZlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcm9qZWN0aW9uID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2F1LXNsb3QnKTtcbiAgICAgICAgaWYgKHByb2plY3Rpb24gPT09ICcnKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1Byb2plY3Rpb24gPSBwcm9qZWN0aW9uICE9PSBudWxsO1xuICAgICAgICBpZiAoaGFzUHJvamVjdGlvbiAmJiBpc1RlbXBsYXRlQ29udHJvbGxlck9mKG1hbmlmZXN0UHJveHksIG1hbmlmZXN0KSkge1xuICAgICAgICAgICAgLy8gcHJldmVudHMgPHNvbWUtZWwgYXUtc2xvdCBURU1QTEFURS5DT05UUk9MTEVSPjwvc29tZS1lbD4uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVzYWdlIG9mIFthdS1zbG90PVwiJHtwcm9qZWN0aW9ufVwiXSBhbG9uZyB3aXRoIGEgdGVtcGxhdGUgY29udHJvbGxlciAoaWYsIGVsc2UsIHJlcGVhdC5mb3IgZXRjLikgZm91bmQgKGV4YW1wbGU6IDxzb21lLWVsIGF1LXNsb3QgaWYuYmluZD1cInRydWVcIj48L3NvbWUtZWw+KS5gKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVE9ETzogcHJldmVudCA8dGVtcGxhdGUgVEVNUExBVEUuQ09OVFJPTExFUj48c29tZS1lbCBhdS1zbG90Pjwvc29tZS1lbD48L3RlbXBsYXRlPi5cbiAgICAgICAgICAgICAqIEJ1dCB0aGVyZSBpcyBub3QgZWFzeSB3YXkgZm9yIG5vdywgYXMgdGhlIGF0dHJpYnV0ZSBiaW5kaW5nIGlzIGRvbmUgYWZ0ZXIgYmluZGluZyB0aGUgY2hpbGQgbm9kZXMuXG4gICAgICAgICAgICAgKiBUaGlzIG1lYW5zIGJ5IHRoZSB0aW1lIHRoZSB0ZW1wbGF0ZSBjb250cm9sbGVyIGluIHRoZSBhbmNlc3RvciBpcyBwcm9jZXNzZWQsIHRoZSBwcm9qZWN0aW9uIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBub2RlLnBhcmVudE5vZGU/Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChoYXNQcm9qZWN0aW9uXG4gICAgICAgICAgICAmJiAobWFuaWZlc3RSb290ID09PSBudWxsXG4gICAgICAgICAgICAgICAgfHwgcGFyZW50TmFtZSA9PT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5jb250YWluZXIuZmluZChDdXN0b21FbGVtZW50LCBwYXJlbnROYW1lKSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJldmVudHMgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgICAqIC0gPHRlbXBsYXRlPjxkaXYgYXUtc2xvdD48L2Rpdj48L3RlbXBsYXRlPlxuICAgICAgICAgICAgICogLSA8bXktY2U+PGRpdj48ZGl2IGF1LXNsb3Q+PC9kaXY+PC9kaXY+PC9teS1jZT5cbiAgICAgICAgICAgICAqIC0gPG15LWNlPjxkaXYgYXUtc2xvdD1cInMxXCI+PGRpdiBhdS1zbG90PVwiczJcIj48L2Rpdj48L2Rpdj48L215LWNlPlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVzYWdlIG9mIFthdS1zbG90PVwiJHtwcm9qZWN0aW9ufVwiXS4gSXQgc2VlbXMgdGhhdCBwcm9qZWN0aW9uIGlzIGF0dGVtcHRlZCwgYnV0IG5vdCBmb3IgYSBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzVGVtcGxhdGVDb250cm9sbGVycyh0aGlzLnBsYXRmb3JtLCBtYW5pZmVzdFByb3h5LCBtYW5pZmVzdCk7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25Pd25lciA9IG1hbmlmZXN0ID09PSBtYW5pZmVzdFJvb3QgPyBwYXJlbnRNYW5pZmVzdFJvb3QgOiBtYW5pZmVzdFJvb3Q7XG4gICAgICAgIGlmICghaGFzUHJvamVjdGlvbiB8fCBwcm9qZWN0aW9uT3duZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHRoZSBwcm94eSBpcyBlaXRoZXIgdGhlIG1hbmlmZXN0IGl0c2VsZiBvciB0aGUgb3V0ZXItbW9zdCBjb250cm9sbGVyOyBhZGQgaXQgZGlyZWN0bHkgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgcGFyZW50TWFuaWZlc3QuY2hpbGROb2Rlcy5wdXNoKG1hbmlmZXN0UHJveHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1Byb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25Pd25lci5wcm9qZWN0aW9ucy5wdXNoKG5ldyBQcm9qZWN0aW9uU3ltYm9sKHByb2plY3Rpb24sIG1hbmlmZXN0UHJveHkpKTtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhdS1zbG90Jyk7XG4gICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIHVzZSByZW5kZXIgcHJpb3JpdHkgc2xvdHMgKHRoaXMgbG9naWMgc2hvdWxkbid0IGJlIGluIHRoZSB0ZW1wbGF0ZSBiaW5kZXIpXG4gICAgZW5zdXJlQXR0cmlidXRlT3JkZXIobWFuaWZlc3QpIHtcbiAgICAgICAgLy8gc3dhcCB0aGUgb3JkZXIgb2YgY2hlY2tlZCBhbmQgbW9kZWwvdmFsdWUgYXR0cmlidXRlLCBzbyB0aGF0IHRoZSByZXF1aXJlZCBvYnNlcnZlcnMgYXJlIHByZXBhcmVkIGZvciBjaGVja2VkLW9ic2VydmVyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBtYW5pZmVzdC5wbGFpbkF0dHJpYnV0ZXM7XG4gICAgICAgIGxldCBtb2RlbE9yVmFsdWVJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgbGV0IGNoZWNrZWRJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgbGV0IGZvdW5kID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aCAmJiBmb3VuZCA8IDM7IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzW2ldLnN5bnRheC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb2RlbCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hdGNoZXInOlxuICAgICAgICAgICAgICAgICAgICBtb2RlbE9yVmFsdWVJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tlZEluZGV4ICE9PSB2b2lkIDAgJiYgbW9kZWxPclZhbHVlSW5kZXggIT09IHZvaWQgMCAmJiBjaGVja2VkSW5kZXggPCBtb2RlbE9yVmFsdWVJbmRleCkge1xuICAgICAgICAgICAgW2F0dHJpYnV0ZXNbbW9kZWxPclZhbHVlSW5kZXhdLCBhdHRyaWJ1dGVzW2NoZWNrZWRJbmRleF1dID0gW2F0dHJpYnV0ZXNbY2hlY2tlZEluZGV4XSwgYXR0cmlidXRlc1ttb2RlbE9yVmFsdWVJbmRleF1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRDaGlsZE5vZGVzKG5vZGUsIHN1cnJvZ2F0ZSwgbWFuaWZlc3QsIG1hbmlmZXN0Um9vdCwgcGFyZW50TWFuaWZlc3RSb290KSB7XG4gICAgICAgIGxldCBjaGlsZE5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dENoaWxkO1xuICAgICAgICB3aGlsZSAoY2hpbGROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoaWxkTm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBFbGVtZW50ICovOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hpbGQgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZE1hbmlmZXN0KFxuICAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnRNYW5pZmVzdCAgICAgKi8gbWFuaWZlc3QsIFxuICAgICAgICAgICAgICAgICAgICAvKiBub2RlICAgICAgICAgICAgICAgKi8gY2hpbGROb2RlLCBcbiAgICAgICAgICAgICAgICAgICAgLyogc3Vycm9nYXRlICAgICAgICAgICovIHN1cnJvZ2F0ZSwgXG4gICAgICAgICAgICAgICAgICAgIC8qIG1hbmlmZXN0ICAgICAgICAgICAqLyBtYW5pZmVzdCwgXG4gICAgICAgICAgICAgICAgICAgIC8qIG1hbmlmZXN0Um9vdCAgICAgICAqLyBtYW5pZmVzdFJvb3QsIFxuICAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnRNYW5pZmVzdFJvb3QgKi8gcGFyZW50TWFuaWZlc3RSb290KTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogVGV4dCAqLzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gdGhpcy5iaW5kVGV4dChcbiAgICAgICAgICAgICAgICAgICAgLyogdGV4dE5vZGUgKi8gY2hpbGROb2RlLCBcbiAgICAgICAgICAgICAgICAgICAgLyogbWFuaWZlc3QgKi8gbWFuaWZlc3QpLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogQ0RBVEFTZWN0aW9uICovOlxuICAgICAgICAgICAgICAgIGNhc2UgNyAvKiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gKi86XG4gICAgICAgICAgICAgICAgY2FzZSA4IC8qIENvbW1lbnQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBEb2N1bWVudFR5cGUgKi86XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5IC8qIERvY3VtZW50ICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZFRleHQodGV4dE5vZGUsIG1hbmlmZXN0KSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb24gPSB0aGlzLmV4cHJQYXJzZXIucGFyc2UodGV4dE5vZGUud2hvbGVUZXh0LCAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8pO1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gbmV3IFRleHRTeW1ib2wodGhpcy5wbGF0Zm9ybSwgdGV4dE5vZGUsIGludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgbWFuaWZlc3QuY2hpbGROb2Rlcy5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICBwcm9jZXNzSW50ZXJwb2xhdGlvblRleHQoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IHRleHROb2RlO1xuICAgICAgICB3aGlsZSAobmV4dC5uZXh0U2libGluZyAhPT0gbnVsbCAmJiBuZXh0Lm5leHRTaWJsaW5nLm5vZGVUeXBlID09PSAzIC8qIFRleHQgKi8pIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICBkZWNsYXJlVGVtcGxhdGVDb250cm9sbGVyKGF0dHJTeW50YXgsIGF0dHJJbmZvKSB7XG4gICAgICAgIGxldCBzeW1ib2w7XG4gICAgICAgIGNvbnN0IGF0dHJSYXdWYWx1ZSA9IGF0dHJTeW50YXgucmF3VmFsdWU7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmdldEJpbmRpbmdDb21tYW5kKGF0dHJTeW50YXgsIGZhbHNlKTtcbiAgICAgICAgLy8gbXVsdGktYmluZGluZ3MgbG9naWMgaGVyZSBpcyBzaW1pbGFyIHRvIChhbmQgZXhwbGFpbmVkIGluKSBiaW5kQ3VzdG9tQXR0cmlidXRlXG4gICAgICAgIGNvbnN0IGlzTXVsdGlCaW5kaW5ncyA9IGF0dHJJbmZvLm5vTXVsdGlCaW5kaW5ncyA9PT0gZmFsc2UgJiYgY29tbWFuZCA9PT0gbnVsbCAmJiBoYXNJbmxpbmVCaW5kaW5ncyhhdHRyUmF3VmFsdWUpO1xuICAgICAgICBpZiAoaXNNdWx0aUJpbmRpbmdzKSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBuZXcgVGVtcGxhdGVDb250cm9sbGVyU3ltYm9sKHRoaXMucGxhdGZvcm0sIGF0dHJTeW50YXgsIGF0dHJJbmZvKTtcbiAgICAgICAgICAgIHRoaXMuYmluZE11bHRpQXR0cmlidXRlKHN5bWJvbCwgYXR0ckluZm8sIGF0dHJSYXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBuZXcgVGVtcGxhdGVDb250cm9sbGVyU3ltYm9sKHRoaXMucGxhdGZvcm0sIGF0dHJTeW50YXgsIGF0dHJJbmZvKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdUeXBlID0gY29tbWFuZCA9PT0gbnVsbCA/IDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyA6IGNvbW1hbmQuYmluZGluZ1R5cGU7XG4gICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5leHByUGFyc2VyLnBhcnNlKGF0dHJSYXdWYWx1ZSwgYmluZGluZ1R5cGUpO1xuICAgICAgICAgICAgc3ltYm9sLmJpbmRpbmdzLnB1c2gobmV3IEJpbmRpbmdTeW1ib2woY29tbWFuZCwgYXR0ckluZm8uYmluZGFibGUsIGV4cHIsIGF0dHJSYXdWYWx1ZSwgYXR0clN5bnRheC50YXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH1cbiAgICBiaW5kQ3VzdG9tQXR0cmlidXRlKGF0dHJTeW50YXgsIGF0dHJJbmZvLCBjb21tYW5kLCBtYW5pZmVzdCkge1xuICAgICAgICBsZXQgc3ltYm9sO1xuICAgICAgICBjb25zdCBhdHRyUmF3VmFsdWUgPSBhdHRyU3ludGF4LnJhd1ZhbHVlO1xuICAgICAgICAvLyBDdXN0b20gYXR0cmlidXRlcyBhcmUgYWx3YXlzIGluIG11bHRpcGxlIGJpbmRpbmcgbW9kZSxcbiAgICAgICAgLy8gZXhjZXB0IHdoZW4gdGhleSBjYW4ndCBiZVxuICAgICAgICAvLyBXaGVuIHRoZXkgY2Fubm90IGJlOlxuICAgICAgICAvLyAgICAgICAgKiBoYXMgZXhwbGljaXQgY29uZmlndXJhdGlvbiBub011bHRpQmluZGluZ3M6IGZhbHNlXG4gICAgICAgIC8vICAgICAgICAqIGhhcyBiaW5kaW5nIGNvbW1hbmQsIGllOiA8ZGl2IG15LWF0dHIuYmluZD1cIi4uLlwiPi5cbiAgICAgICAgLy8gICAgICAgICAgSW4gdGhpcyBzY2VuYXJpbywgdGhlIHZhbHVlIG9mIHRoZSBjdXN0b20gYXR0cmlidXRlcyBpcyByZXF1aXJlZCB0byBiZSBhIHZhbGlkIGV4cHJlc3Npb25cbiAgICAgICAgLy8gICAgICAgICogaGFzIG5vIGNvbG9uOiBpZTogPGRpdiBteS1hdHRyPVwiYWJjZFwiPlxuICAgICAgICAvLyAgICAgICAgICBJbiB0aGlzIHNjZW5hcmlvLCBpdCdzIHNpbXBseSBpbnZhbGlkIHN5bnRheC4gQ29uc2lkZXIgc3R5bGUgYXR0cmlidXRlIHJ1bGUtdmFsdWUgcGFpcjogPGRpdiBzdHlsZT1cInJ1bGU6IHJ1bGVWYWx1ZVwiPlxuICAgICAgICBjb25zdCBpc011bHRpQmluZGluZ3MgPSBhdHRySW5mby5ub011bHRpQmluZGluZ3MgPT09IGZhbHNlICYmIGNvbW1hbmQgPT09IG51bGwgJiYgaGFzSW5saW5lQmluZGluZ3MoYXR0clJhd1ZhbHVlKTtcbiAgICAgICAgaWYgKGlzTXVsdGlCaW5kaW5ncykge1xuICAgICAgICAgICAgLy8gYSBtdWx0aXBsZS1iaW5kaW5ncyBhdHRyaWJ1dGUgdXNhZ2UgKHNlbWljb2xvbiBzZXBhcmF0ZWQgYmluZGluZykgaXMgb25seSB2YWxpZCB3aXRob3V0IGEgYmluZGluZyBjb21tYW5kO1xuICAgICAgICAgICAgLy8gdGhlIGJpbmRpbmcgY29tbWFuZHMgbXVzdCBiZSBkZWNsYXJlZCBpbiBlYWNoIG9mIHRoZSBwcm9wZXJ0eSBiaW5kaW5nc1xuICAgICAgICAgICAgc3ltYm9sID0gbmV3IEN1c3RvbUF0dHJpYnV0ZVN5bWJvbChhdHRyU3ludGF4LCBhdHRySW5mbyk7XG4gICAgICAgICAgICB0aGlzLmJpbmRNdWx0aUF0dHJpYnV0ZShzeW1ib2wsIGF0dHJJbmZvLCBhdHRyUmF3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ltYm9sID0gbmV3IEN1c3RvbUF0dHJpYnV0ZVN5bWJvbChhdHRyU3ludGF4LCBhdHRySW5mbyk7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nVHlwZSA9IGNvbW1hbmQgPT09IG51bGwgPyAyMDQ4IC8qIEludGVycG9sYXRpb24gKi8gOiBjb21tYW5kLmJpbmRpbmdUeXBlO1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZXhwclBhcnNlci5wYXJzZShhdHRyUmF3VmFsdWUsIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgIHN5bWJvbC5iaW5kaW5ncy5wdXNoKG5ldyBCaW5kaW5nU3ltYm9sKGNvbW1hbmQsIGF0dHJJbmZvLmJpbmRhYmxlLCBleHByLCBhdHRyUmF3VmFsdWUsIGF0dHJTeW50YXgudGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFuaWZlc3QuY3VzdG9tQXR0cmlidXRlcy5wdXNoKHN5bWJvbCk7XG4gICAgICAgIG1hbmlmZXN0LmlzVGFyZ2V0ID0gdHJ1ZTtcbiAgICB9XG4gICAgYmluZE11bHRpQXR0cmlidXRlKHN5bWJvbCwgYXR0ckluZm8sIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJpbmRhYmxlcyA9IGF0dHJJbmZvLmJpbmRhYmxlcztcbiAgICAgICAgY29uc3QgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGxldCBhdHRyTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgbGV0IGF0dHJWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGNoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjaCA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDkyIC8qIEJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgd2hhdGV2ZXIgY29tZXMgbmV4dCBiZWNhdXNlIGl0J3MgZXNjYXBlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDU4IC8qIENvbG9uICovKSB7XG4gICAgICAgICAgICAgICAgYXR0ck5hbWUgPSB2YWx1ZS5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIGNvbG9uXG4gICAgICAgICAgICAgICAgd2hpbGUgKHZhbHVlLmNoYXJDb2RlQXQoKytpKSA8PSAzMiAvKiBTcGFjZSAqLylcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHZhbHVlTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDkyIC8qIEJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHdoYXRldmVyIGNvbWVzIG5leHQgYmVjYXVzZSBpdCdzIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gNTkgLyogU2VtaWNvbG9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyVmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0clZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gc2VtaWNvbG9uIGZvdW5kLCBzbyBqdXN0IGdyYWIgdGhlIHJlc3Qgb2YgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0clN5bnRheCA9IHRoaXMuYXR0clBhcnNlci5wYXJzZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyVGFyZ2V0ID0gY2FtZWxDYXNlKGF0dHJTeW50YXgudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5nZXRCaW5kaW5nQ29tbWFuZChhdHRyU3ludGF4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ1R5cGUgPSBjb21tYW5kID09PSBudWxsID8gMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovIDogY29tbWFuZC5iaW5kaW5nVHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByID0gdGhpcy5leHByUGFyc2VyLnBhcnNlKGF0dHJWYWx1ZSwgYmluZGluZ1R5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBiaW5kYWJsZSA9IGJpbmRhYmxlc1thdHRyVGFyZ2V0XTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVyeXRoaW5nIGluIGEgbXVsdGktYmluZGluZ3MgZXhwcmVzc2lvbiBtdXN0IGJlIHVzZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGlmIGl0J3Mgbm90IGEgYmluZGFibGUgdGhlbiB3ZSBjcmVhdGUgb25lIG9uIHRoZSBzcG90XG4gICAgICAgICAgICAgICAgICAgIGJpbmRhYmxlID0gYmluZGFibGVzW2F0dHJUYXJnZXRdID0gbmV3IEJpbmRhYmxlSW5mbyhhdHRyVGFyZ2V0LCBCaW5kaW5nTW9kZS50b1ZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW1ib2wuYmluZGluZ3MucHVzaChuZXcgQmluZGluZ1N5bWJvbChjb21tYW5kLCBiaW5kYWJsZSwgZXhwciwgYXR0clZhbHVlLCBhdHRyVGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIHNlbWljb2xvblxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgdmFsdWVMZW5ndGggJiYgdmFsdWUuY2hhckNvZGVBdCgrK2kpIDw9IDMyIC8qIFNwYWNlICovKVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kUGxhaW5BdHRyaWJ1dGUoYXR0clN5bnRheCwgYXR0ciwgc3Vycm9nYXRlLCBtYW5pZmVzdCkge1xuICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5nZXRCaW5kaW5nQ29tbWFuZChhdHRyU3ludGF4LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdUeXBlID0gY29tbWFuZCA9PT0gbnVsbCA/IDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLyA6IGNvbW1hbmQuYmluZGluZ1R5cGU7XG4gICAgICAgIGNvbnN0IGF0dHJUYXJnZXQgPSBhdHRyU3ludGF4LnRhcmdldDtcbiAgICAgICAgY29uc3QgYXR0clJhd1ZhbHVlID0gYXR0clN5bnRheC5yYXdWYWx1ZTtcbiAgICAgICAgbGV0IGV4cHI7XG4gICAgICAgIGlmIChhdHRyUmF3VmFsdWUubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAmJiAoYmluZGluZ1R5cGUgJiA1MyAvKiBCaW5kQ29tbWFuZCAqLyB8IDQ5IC8qIE9uZVRpbWVDb21tYW5kICovIHwgNTAgLyogVG9WaWV3Q29tbWFuZCAqLyB8IDUyIC8qIFR3b1dheUNvbW1hbmQgKi8pID4gMCkge1xuICAgICAgICAgICAgaWYgKChiaW5kaW5nVHlwZSAmIDUzIC8qIEJpbmRDb21tYW5kICovIHwgNDkgLyogT25lVGltZUNvbW1hbmQgKi8gfCA1MCAvKiBUb1ZpZXdDb21tYW5kICovIHwgNTIgLyogVHdvV2F5Q29tbWFuZCAqLykgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgYXR0ciBmb3IgZW1wdHkgYmluZGluZyBjb21tYW5kc1xuICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmV4cHJQYXJzZXIucGFyc2UoY2FtZWxDYXNlKGF0dHJUYXJnZXQpLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHByID0gdGhpcy5leHByUGFyc2VyLnBhcnNlKGF0dHJSYXdWYWx1ZSwgYmluZGluZ1R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobWFuaWZlc3QuZmxhZ3MgJiAxNiAvKiBpc0N1c3RvbUVsZW1lbnQgKi8pID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYmluZGFibGUgPSBtYW5pZmVzdC5iaW5kYWJsZXNbYXR0clRhcmdldF07XG4gICAgICAgICAgICBpZiAoYmluZGFibGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgbmFtZSBtYXRjaGVzIGEgYmluZGFibGUgcHJvcGVydHkgbmFtZSwgYWRkIGl0IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCdzIGEgY29tbWFuZCwgaW50ZXJwb2xhdGlvbiwgb3IganVzdCBhIHBsYWluIHN0cmluZztcbiAgICAgICAgICAgICAgICAvLyB0aGUgdGVtcGxhdGUgY29tcGlsZXIgd2lsbCB0cmFuc2xhdGUgaXQgdG8gdGhlIGNvcnJlY3QgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICBtYW5pZmVzdC5iaW5kaW5ncy5wdXNoKG5ldyBCaW5kaW5nU3ltYm9sKGNvbW1hbmQsIGJpbmRhYmxlLCBleHByLCBhdHRyUmF3VmFsdWUsIGF0dHJUYXJnZXQpKTtcbiAgICAgICAgICAgICAgICBtYW5pZmVzdC5pc1RhcmdldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHByICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBkb2VzIG5vdCBtYXAgdG8gYSBiaW5kYWJsZSwgb25seSBhZGQgaXQgaWYgd2Ugd2VyZSBhYmxlIHRvIHBhcnNlIGFuIGV4cHJlc3Npb24gKGVpdGhlciBhIGNvbW1hbmQgb3IgaW50ZXJwb2xhdGlvbilcbiAgICAgICAgICAgICAgICBtYW5pZmVzdC5wbGFpbkF0dHJpYnV0ZXMucHVzaChuZXcgUGxhaW5BdHRyaWJ1dGVTeW1ib2woYXR0clN5bnRheCwgY29tbWFuZCwgZXhwcikpO1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0LmlzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGVpdGhlciBhIGJpbmRpbmcgY29tbWFuZCwgYW4gaW50ZXJwb2xhdGlvbiwgb3IgYSByZWZcbiAgICAgICAgICAgIG1hbmlmZXN0LnBsYWluQXR0cmlidXRlcy5wdXNoKG5ldyBQbGFpbkF0dHJpYnV0ZVN5bWJvbChhdHRyU3ludGF4LCBjb21tYW5kLCBleHByKSk7XG4gICAgICAgICAgICBtYW5pZmVzdC5pc1RhcmdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFuaWZlc3QgPT09IHN1cnJvZ2F0ZSkge1xuICAgICAgICAgICAgLy8gYW55IGF0dHJpYnV0ZXMsIGV2ZW4gaWYgdGhleSBhcmUgcGxhaW4gKG5vIGNvbW1hbmQvaW50ZXJwb2xhdGlvbiBldGMpLCBzaG91bGQgYmUgYWRkZWQgaWYgdGhleVxuICAgICAgICAgICAgLy8gYXJlIG9uIHRoZSBzdXJyb2dhdGUgZWxlbWVudFxuICAgICAgICAgICAgbWFuaWZlc3QucGxhaW5BdHRyaWJ1dGVzLnB1c2gobmV3IFBsYWluQXR0cmlidXRlU3ltYm9sKGF0dHJTeW50YXgsIGNvbW1hbmQsIGV4cHIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZCA9PSBudWxsICYmIGV4cHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaWYgaXQncyBhbiBpbnRlcnBvbGF0aW9uLCBjbGVhciB0aGUgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAgICBhdHRyLnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBiaW5kaW5nIGNvbW1hbmQgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBwYXJzZWQgYEF0dHJTeW50YXhgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUgY29tbWFuZCBpZiBpdCBleGlzdHMsIG9yIGBudWxsYCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBnZXRCaW5kaW5nQ29tbWFuZChzeW50YXgsIG9wdGlvbmFsKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBzeW50YXguY29tbWFuZDtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbW1hbmRMb29rdXBbbmFtZV07XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb250YWluZXIuY3JlYXRlKEJpbmRpbmdDb21tYW5kLCBuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBiaW5kaW5nIGNvbW1hbmQ6ICR7bmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbWFuZExvb2t1cFtuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWJpbmRlci5qcy5tYXAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmltcG9ydCB7IGVtcHR5QXJyYXksIFJlZ2lzdHJhdGlvbiwgbWVyZ2VBcnJheXMsIHRvQXJyYXksIElMb2dnZXIsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IElFeHByZXNzaW9uUGFyc2VyLCBCaW5kaW5nTW9kZSwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IElBdHRyU3ludGF4VHJhbnNmb3JtZXIgfSBmcm9tICcuL2F0dHJpYnV0ZS1zeW50YXgtdHJhbnNmb3JtZXIuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVCaW5kZXIgfSBmcm9tICcuL3RlbXBsYXRlLWJpbmRlci5qcyc7XG5pbXBvcnQgeyBJVGVtcGxhdGVFbGVtZW50RmFjdG9yeSB9IGZyb20gJy4vdGVtcGxhdGUtZWxlbWVudC1mYWN0b3J5LmpzJztcbmltcG9ydCB7IEh5ZHJhdGVBdHRyaWJ1dGVJbnN0cnVjdGlvbiwgSHlkcmF0ZUVsZW1lbnRJbnN0cnVjdGlvbiwgSHlkcmF0ZUxldEVsZW1lbnRJbnN0cnVjdGlvbiwgSHlkcmF0ZVRlbXBsYXRlQ29udHJvbGxlciwgSW50ZXJwb2xhdGlvbkluc3RydWN0aW9uLCBMZXRCaW5kaW5nSW5zdHJ1Y3Rpb24sIFNldEF0dHJpYnV0ZUluc3RydWN0aW9uLCBTZXRDbGFzc0F0dHJpYnV0ZUluc3RydWN0aW9uLCBTZXRQcm9wZXJ0eUluc3RydWN0aW9uLCBTZXRTdHlsZUF0dHJpYnV0ZUluc3RydWN0aW9uLCBUZXh0QmluZGluZ0luc3RydWN0aW9uLCBJVGVtcGxhdGVDb21waWxlciwgfSBmcm9tICcuL3JlbmRlcmVyLmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgQmluZGFibGUgfSBmcm9tICcuL2JpbmRhYmxlLmpzJztcbmltcG9ydCB7IElBdHRyaWJ1dGVQYXJzZXIgfSBmcm9tICcuL3Jlc291cmNlcy9hdHRyaWJ1dGUtcGF0dGVybi5qcyc7XG5pbXBvcnQgeyBBdVNsb3RDb250ZW50VHlwZSwgUHJvamVjdGlvbkNvbnRleHQsIFNsb3RJbmZvIH0gZnJvbSAnLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnRzL2F1LXNsb3QuanMnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudCwgQ3VzdG9tRWxlbWVudERlZmluaXRpb24gfSBmcm9tICcuL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5jbGFzcyBDdXN0b21FbGVtZW50Q29tcGlsYXRpb25Vbml0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJ0aWFsRGVmaW5pdGlvbiwgc3Vycm9nYXRlLCB0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnBhcnRpYWxEZWZpbml0aW9uID0gcGFydGlhbERlZmluaXRpb247XG4gICAgICAgIHRoaXMuc3Vycm9nYXRlID0gc3Vycm9nYXRlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuc3Vycm9nYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB0b0RlZmluaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMucGFydGlhbERlZmluaXRpb247XG4gICAgICAgIHJldHVybiBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBtZXJnZUFycmF5cyhkZWYuaW5zdHJ1Y3Rpb25zLCB0aGlzLmluc3RydWN0aW9ucyksXG4gICAgICAgICAgICBzdXJyb2dhdGVzOiBtZXJnZUFycmF5cyhkZWYuc3Vycm9nYXRlcywgdGhpcy5zdXJyb2dhdGVzKSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICAgICAgICAgICAgbmVlZHNDb21waWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGhhc1Nsb3RzOiB0aGlzLnN1cnJvZ2F0ZS5oYXNTbG90cyxcbiAgICAgICAgICAgIHByb2plY3Rpb25zTWFwOiB0aGlzLnByb2plY3Rpb25zTWFwLFxuICAgICAgICB9KTtcbiAgICB9XG59XG52YXIgTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlcztcbihmdW5jdGlvbiAoTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlcykge1xuICAgIExvY2FsVGVtcGxhdGVCaW5kYWJsZUF0dHJpYnV0ZXNbXCJwcm9wZXJ0eVwiXSA9IFwicHJvcGVydHlcIjtcbiAgICBMb2NhbFRlbXBsYXRlQmluZGFibGVBdHRyaWJ1dGVzW1wiYXR0cmlidXRlXCJdID0gXCJhdHRyaWJ1dGVcIjtcbiAgICBMb2NhbFRlbXBsYXRlQmluZGFibGVBdHRyaWJ1dGVzW1wibW9kZVwiXSA9IFwibW9kZVwiO1xufSkoTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlcyB8fCAoTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlcyA9IHt9KSk7XG5jb25zdCBhbGxvd2VkTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlcyA9IE9iamVjdC5mcmVlemUoW1xuICAgIFwicHJvcGVydHlcIiAvKiBwcm9wZXJ0eSAqLyxcbiAgICBcImF0dHJpYnV0ZVwiIC8qIGF0dHJpYnV0ZSAqLyxcbiAgICBcIm1vZGVcIiAvKiBtb2RlICovXG5dKTtcbmNvbnN0IGxvY2FsVGVtcGxhdGVJZGVudGlmaWVyID0gJ2FzLWN1c3RvbS1lbGVtZW50Jztcbi8qKlxuICogRGVmYXVsdCAocnVudGltZS1hZ25vc3RpYykgaW1wbGVtZW50YXRpb24gZm9yIGBJVGVtcGxhdGVDb21waWxlcmAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmxldCBUZW1wbGF0ZUNvbXBpbGVyID0gY2xhc3MgVGVtcGxhdGVDb21waWxlciB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSwgYXR0clBhcnNlciwgZXhwclBhcnNlciwgYXR0clN5bnRheE1vZGlmaWVyLCBsb2dnZXIsIHApIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5hdHRyUGFyc2VyID0gYXR0clBhcnNlcjtcbiAgICAgICAgdGhpcy5leHByUGFyc2VyID0gZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5hdHRyU3ludGF4TW9kaWZpZXIgPSBhdHRyU3ludGF4TW9kaWZpZXI7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLnNjb3BlVG8oJ1RlbXBsYXRlQ29tcGlsZXInKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCc7XG4gICAgfVxuICAgIHN0YXRpYyByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIFJlZ2lzdHJhdGlvbi5zaW5nbGV0b24oSVRlbXBsYXRlQ29tcGlsZXIsIHRoaXMpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIGNvbXBpbGUocGFydGlhbERlZmluaXRpb24sIGNvbnRleHQsIHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLmdldE9yQ3JlYXRlKHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24udGVtcGxhdGUgPT09IG51bGwgfHwgZGVmaW5pdGlvbi50ZW1wbGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGF0dHJQYXJzZXIsIGV4cHJQYXJzZXIsIGF0dHJTeW50YXhNb2RpZmllciwgZmFjdG9yeSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcCA9IGNvbnRleHQuZ2V0KElQbGF0Zm9ybSk7XG4gICAgICAgIGNvbnN0IGJpbmRlciA9IG5ldyBUZW1wbGF0ZUJpbmRlcihwLCBjb250ZXh0LCBhdHRyUGFyc2VyLCBleHByUGFyc2VyLCBhdHRyU3ludGF4TW9kaWZpZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRlZmluaXRpb24uZW5oYW5jZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBkZWZpbml0aW9uLnRlbXBsYXRlXG4gICAgICAgICAgICA6IGZhY3RvcnkuY3JlYXRlVGVtcGxhdGUoZGVmaW5pdGlvbi50ZW1wbGF0ZSk7XG4gICAgICAgIHByb2Nlc3NMb2NhbFRlbXBsYXRlcyh0ZW1wbGF0ZSwgZGVmaW5pdGlvbiwgY29udGV4dCwgcCwgdGhpcy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBzdXJyb2dhdGUgPSBiaW5kZXIuYmluZCh0ZW1wbGF0ZSk7XG4gICAgICAgIGNvbnN0IGNvbXBpbGF0aW9uID0gdGhpcy5jb21waWxhdGlvbiA9IG5ldyBDdXN0b21FbGVtZW50Q29tcGlsYXRpb25Vbml0KGRlZmluaXRpb24sIHN1cnJvZ2F0ZSwgdGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBjdXN0b21BdHRyaWJ1dGVzID0gc3Vycm9nYXRlLmN1c3RvbUF0dHJpYnV0ZXM7XG4gICAgICAgIGNvbnN0IHBsYWluQXR0cmlidXRlcyA9IHN1cnJvZ2F0ZS5wbGFpbkF0dHJpYnV0ZXM7XG4gICAgICAgIGNvbnN0IGN1c3RvbUF0dHJpYnV0ZUxlbmd0aCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBwbGFpbkF0dHJpYnV0ZUxlbmd0aCA9IHBsYWluQXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIGlmIChjdXN0b21BdHRyaWJ1dGVMZW5ndGggKyBwbGFpbkF0dHJpYnV0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGN1c3RvbUF0dHJpYnV0ZUxlbmd0aCA+IGk7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uLnN1cnJvZ2F0ZXNbb2Zmc2V0XSA9IHRoaXMuY29tcGlsZUN1c3RvbUF0dHJpYnV0ZShjdXN0b21BdHRyaWJ1dGVzW2ldKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW5BdHRyaWJ1dGVMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uLnN1cnJvZ2F0ZXNbb2Zmc2V0XSA9IHRoaXMuY29tcGlsZVBsYWluQXR0cmlidXRlKHBsYWluQXR0cmlidXRlc1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxlQ2hpbGROb2RlcyhzdXJyb2dhdGUsIGNvbXBpbGF0aW9uLmluc3RydWN0aW9ucywgY29tcGlsYXRpb24ucHJvamVjdGlvbnNNYXAsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICBjb25zdCBjb21waWxlZERlZmluaXRpb24gPSBjb21waWxhdGlvbi50b0RlZmluaXRpb24oKTtcbiAgICAgICAgdGhpcy5jb21waWxhdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiBjb21waWxlZERlZmluaXRpb247XG4gICAgfVxuICAgIGNvbXBpbGVDaGlsZE5vZGVzKHBhcmVudCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucykge1xuICAgICAgICBpZiAoKHBhcmVudC5mbGFncyAmIDE2Mzg0IC8qIGhhc0NoaWxkTm9kZXMgKi8pID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHBhcmVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgY29uc3QgaWkgPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoY2hpbGROb2RlLmZsYWdzICYgMTI4IC8qIGlzVGV4dCAqLykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uUm93cy5wdXNoKFtuZXcgVGV4dEJpbmRpbmdJbnN0cnVjdGlvbihjaGlsZE5vZGUuaW50ZXJwb2xhdGlvbildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGNoaWxkTm9kZS5mbGFncyAmIDMyIC8qIGlzTGV0RWxlbWVudCAqLykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzID0gY2hpbGROb2RlLmJpbmRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpqID0gYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmcgPSBiaW5kaW5nc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc1tqXSA9IG5ldyBMZXRCaW5kaW5nSW5zdHJ1Y3Rpb24oYmluZGluZy5leHByZXNzaW9uLCBiaW5kaW5nLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25Sb3dzLnB1c2goW25ldyBIeWRyYXRlTGV0RWxlbWVudEluc3RydWN0aW9uKGluc3RydWN0aW9ucywgY2hpbGROb2RlLnRvQmluZGluZ0NvbnRleHQpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVQYXJlbnROb2RlKGNoaWxkTm9kZSwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBpbGVDdXN0b21FbGVtZW50KHN5bWJvbCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucykge1xuICAgICAgICBjb25zdCBpc0F1U2xvdCA9IChzeW1ib2wuZmxhZ3MgJiA1MTIgLyogaXNBdVNsb3QgKi8pID4gMDtcbiAgICAgICAgLy8gb2Zmc2V0IDEgdG8gbGVhdmUgYSBzcG90IGZvciB0aGUgaHlkcmF0ZSBpbnN0cnVjdGlvbiBzbyB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSAyIGFycmF5cyB3aXRoIGEgc3ByZWFkIGV0Y1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvblJvdyA9IHRoaXMuY29tcGlsZUF0dHJpYnV0ZXMoc3ltYm9sLCAxKTtcbiAgICAgICAgY29uc3Qgc2xvdE5hbWUgPSBzeW1ib2wuc2xvdE5hbWU7XG4gICAgICAgIGxldCBzbG90SW5mbyA9IG51bGw7XG4gICAgICAgIGlmIChpc0F1U2xvdCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ZWRQcm9qZWN0aW9uID0gdGFyZ2V0ZWRQcm9qZWN0aW9ucz8ucHJvamVjdGlvbnM/LltzbG90TmFtZV07XG4gICAgICAgICAgICBzbG90SW5mbyA9IHRhcmdldGVkUHJvamVjdGlvbiAhPT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgPyBuZXcgU2xvdEluZm8oc2xvdE5hbWUsIEF1U2xvdENvbnRlbnRUeXBlLlByb2plY3Rpb24sIG5ldyBQcm9qZWN0aW9uQ29udGV4dCh0YXJnZXRlZFByb2plY3Rpb24sIHRhcmdldGVkUHJvamVjdGlvbnM/LnNjb3BlKSlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbG90SW5mbyhzbG90TmFtZSwgQXVTbG90Q29udGVudFR5cGUuRmFsbGJhY2ssIG5ldyBQcm9qZWN0aW9uQ29udGV4dCh0aGlzLmNvbXBpbGVQcm9qZWN0aW9uRmFsbGJhY2soc3ltYm9sLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucykpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uUm93WzBdID0gbmV3IEh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24oc3ltYm9sLnJlcywgc3ltYm9sLmluZm8uYWxpYXMsIHRoaXMuY29tcGlsZUJpbmRpbmdzKHN5bWJvbCksIHNsb3RJbmZvKTtcbiAgICAgICAgY29uc3QgY29tcGlsZWRQcm9qZWN0aW9ucyA9IHRoaXMuY29tcGlsZVByb2plY3Rpb25zKHN5bWJvbCwgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICBpZiAoY29tcGlsZWRQcm9qZWN0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvamVjdGlvbnMuc2V0KGluc3RydWN0aW9uLCBjb21waWxlZFByb2plY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0cnVjdGlvblJvd3MucHVzaChpbnN0cnVjdGlvblJvdyk7XG4gICAgICAgIGlmICghaXNBdVNsb3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZUNoaWxkTm9kZXMoc3ltYm9sLCBpbnN0cnVjdGlvblJvd3MsIHByb2plY3Rpb25zLCB0YXJnZXRlZFByb2plY3Rpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21waWxlUGxhaW5FbGVtZW50KHN5bWJvbCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5jb21waWxlQXR0cmlidXRlcyhzeW1ib2wsIDApO1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvblJvd3MucHVzaChhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBpbGVDaGlsZE5vZGVzKHN5bWJvbCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgfVxuICAgIGNvbXBpbGVQYXJlbnROb2RlKHN5bWJvbCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucykge1xuICAgICAgICBzd2l0Y2ggKHN5bWJvbC5mbGFncyAmIDEwMjMgLyogdHlwZSAqLykge1xuICAgICAgICAgICAgY2FzZSAxNiAvKiBpc0N1c3RvbUVsZW1lbnQgKi86XG4gICAgICAgICAgICBjYXNlIDUxMiAvKiBpc0F1U2xvdCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVDdXN0b21FbGVtZW50KHN5bWJvbCwgaW5zdHJ1Y3Rpb25Sb3dzLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY0IC8qIGlzUGxhaW5FbGVtZW50ICovOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZVBsYWluRWxlbWVudChzeW1ib2wsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIGlzVGVtcGxhdGVDb250cm9sbGVyICovOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZVRlbXBsYXRlQ29udHJvbGxlcihzeW1ib2wsIGluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBpbGVUZW1wbGF0ZUNvbnRyb2xsZXIoc3ltYm9sLCBpbnN0cnVjdGlvblJvd3MsIHByb2plY3Rpb25zLCB0YXJnZXRlZFByb2plY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5jb21waWxlQmluZGluZ3Moc3ltYm9sKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlckluc3RydWN0aW9uUm93cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBpbGVQYXJlbnROb2RlKHN5bWJvbC50ZW1wbGF0ZSwgY29udHJvbGxlckluc3RydWN0aW9uUm93cywgcHJvamVjdGlvbnMsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICBjb25zdCBkZWYgPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgbmFtZTogc3ltYm9sLmluZm8uYWxpYXMgPz8gc3ltYm9sLmluZm8ubmFtZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBzeW1ib2wucGh5c2ljYWxOb2RlLFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBjb250cm9sbGVySW5zdHJ1Y3Rpb25Sb3dzLFxuICAgICAgICAgICAgbmVlZHNDb21waWxlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGluc3RydWN0aW9uUm93cy5wdXNoKFtuZXcgSHlkcmF0ZVRlbXBsYXRlQ29udHJvbGxlcihkZWYsIHN5bWJvbC5yZXMsIHN5bWJvbC5pbmZvLmFsaWFzLCBiaW5kaW5ncyldKTtcbiAgICB9XG4gICAgY29tcGlsZUJpbmRpbmdzKHN5bWJvbCkge1xuICAgICAgICBsZXQgYmluZGluZ0luc3RydWN0aW9ucztcbiAgICAgICAgaWYgKChzeW1ib2wuZmxhZ3MgJiA4MTkyIC8qIGhhc0JpbmRpbmdzICovKSA+IDApIHtcbiAgICAgICAgICAgIC8vIGVpdGhlciBhIGN1c3RvbSBlbGVtZW50IHdpdGggYmluZGluZ3MsIGEgY3VzdG9tIGF0dHJpYnV0ZSAvIHRlbXBsYXRlIGNvbnRyb2xsZXIgd2l0aCBkeW5hbWljIG9wdGlvbnMsXG4gICAgICAgICAgICAvLyBvciBhIHNpbmdsZSB2YWx1ZSBjdXN0b20gYXR0cmlidXRlIGJpbmRpbmdcbiAgICAgICAgICAgIGNvbnN0IHsgYmluZGluZ3MgfSA9IHN5bWJvbDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgICAgIGJpbmRpbmdJbnN0cnVjdGlvbnMgPSBBcnJheShsZW4pO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdJbnN0cnVjdGlvbnNbaV0gPSB0aGlzLmNvbXBpbGVCaW5kaW5nKGJpbmRpbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJpbmRpbmdJbnN0cnVjdGlvbnMgPSBlbXB0eUFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nSW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBjb21waWxlQmluZGluZyhzeW1ib2wpIHtcbiAgICAgICAgaWYgKHN5bWJvbC5jb21tYW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYW4gaW50ZXJwb2xhdGlvbiBvciBhIG5vcm1hbCBzdHJpbmcgdmFsdWUgYXNzaWduZWQgdG8gYW4gZWxlbWVudCBvciBhdHRyaWJ1dGUgYmluZGluZ1xuICAgICAgICAgICAgaWYgKHN5bWJvbC5leHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRlbXBsYXRlIGJpbmRlciBhbHJlYWR5IGZpbHRlcmVkIG91dCBub24tYmluZGFibGVzLCBzbyB3ZSBrbm93IHdlIG5lZWQgYSBzZXRQcm9wZXJ0eSBoZXJlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRQcm9wZXJ0eUluc3RydWN0aW9uKHN5bWJvbC5yYXdWYWx1ZSwgc3ltYm9sLmJpbmRhYmxlLnByb3BOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciBhbiBlbGVtZW50IGJpbmRpbmcgaW50ZXJwb2xhdGlvbiBvciBhIGR5bmFtaWMgb3B0aW9ucyBhdHRyaWJ1dGUgYmluZGluZyBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uSW5zdHJ1Y3Rpb24oc3ltYm9sLmV4cHJlc3Npb24sIHN5bWJvbC5iaW5kYWJsZS5wcm9wTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYW4gZWxlbWVudCBiaW5kaW5nIGNvbW1hbmQsIGR5bmFtaWMgb3B0aW9ucyBhdHRyaWJ1dGUgYmluZGluZyBjb21tYW5kLFxuICAgICAgICAgICAgLy8gb3IgY3VzdG9tIGF0dHJpYnV0ZSAvIHRlbXBsYXRlIGNvbnRyb2xsZXIgKHNpbmdsZSB2YWx1ZSkgYmluZGluZyBjb21tYW5kXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sLmNvbW1hbmQuY29tcGlsZShzeW1ib2wpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBpbGVBdHRyaWJ1dGVzKHN5bWJvbCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhdHRyaWJ1dGVJbnN0cnVjdGlvbnM7XG4gICAgICAgIGlmICgoc3ltYm9sLmZsYWdzICYgNDA5NiAvKiBoYXNBdHRyaWJ1dGVzICovKSA+IDApIHtcbiAgICAgICAgICAgIC8vIGFueSBhdHRyaWJ1dGVzIG9uIGEgY3VzdG9tIGVsZW1lbnQgKHdoaWNoIGFyZSBub3QgYmluZGFibGVzKSBvciBhIHBsYWluIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUF0dHJpYnV0ZXMgPSBzeW1ib2wuY3VzdG9tQXR0cmlidXRlcztcbiAgICAgICAgICAgIGNvbnN0IHBsYWluQXR0cmlidXRlcyA9IHN5bWJvbC5wbGFpbkF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21BdHRyaWJ1dGVMZW5ndGggPSBjdXN0b21BdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHBsYWluQXR0cmlidXRlc0xlbmd0aCA9IHBsYWluQXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBhdHRyaWJ1dGVJbnN0cnVjdGlvbnMgPSBBcnJheShvZmZzZXQgKyBjdXN0b21BdHRyaWJ1dGVMZW5ndGggKyBwbGFpbkF0dHJpYnV0ZXNMZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGN1c3RvbUF0dHJpYnV0ZUxlbmd0aCA+IGk7ICsraSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUluc3RydWN0aW9uc1tvZmZzZXRdID0gdGhpcy5jb21waWxlQ3VzdG9tQXR0cmlidXRlKGN1c3RvbUF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IHBsYWluQXR0cmlidXRlc0xlbmd0aCA+IGk7ICsraSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUluc3RydWN0aW9uc1tvZmZzZXRdID0gdGhpcy5jb21waWxlUGxhaW5BdHRyaWJ1dGUocGxhaW5BdHRyaWJ1dGVzW2ldLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgYXR0cmlidXRlSW5zdHJ1Y3Rpb25zID0gQXJyYXkob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZUluc3RydWN0aW9ucyA9IGVtcHR5QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZUluc3RydWN0aW9ucztcbiAgICB9XG4gICAgY29tcGlsZUN1c3RvbUF0dHJpYnV0ZShzeW1ib2wpIHtcbiAgICAgICAgLy8gYSBub3JtYWwgY3VzdG9tIGF0dHJpYnV0ZSAobm90IHRlbXBsYXRlIGNvbnRyb2xsZXIpXG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5jb21waWxlQmluZGluZ3Moc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIeWRyYXRlQXR0cmlidXRlSW5zdHJ1Y3Rpb24oc3ltYm9sLnJlcywgc3ltYm9sLmluZm8uYWxpYXMsIGJpbmRpbmdzKTtcbiAgICB9XG4gICAgY29tcGlsZVBsYWluQXR0cmlidXRlKHN5bWJvbCwgaXNPblN1cnJvZ2F0ZSkge1xuICAgICAgICBpZiAoc3ltYm9sLmNvbW1hbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHN5bnRheCA9IHN5bWJvbC5zeW50YXg7XG4gICAgICAgICAgICBpZiAoc3ltYm9sLmV4cHJlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyUmF3VmFsdWUgPSBzeW50YXgucmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzT25TdXJyb2dhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzeW50YXgudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRDbGFzc0F0dHJpYnV0ZUluc3RydWN0aW9uKGF0dHJSYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRTdHlsZUF0dHJpYnV0ZUluc3RydWN0aW9uKGF0dHJSYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiAgZGVmaW5lIGhvdyB0byBtZXJnZSBvdGhlciBhdHRyaWJ1dGUgcGVhY2VmdWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMgaXMgYW4gZXhpc3RpbmcgZmVhdHVyZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYSBwbGFpbiBhdHRyaWJ1dGUgb24gYSBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldEF0dHJpYnV0ZUluc3RydWN0aW9uKGF0dHJSYXdWYWx1ZSwgc3ludGF4LnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhIHBsYWluIGF0dHJpYnV0ZSB3aXRoIGFuIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb25JbnN0cnVjdGlvbihzeW1ib2wuZXhwcmVzc2lvbiwgc3ludGF4LnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhIHBsYWluIGF0dHJpYnV0ZSB3aXRoIGEgYmluZGluZyBjb21tYW5kXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sLmNvbW1hbmQuY29tcGlsZShzeW1ib2wpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHByaXZhdGUgY29tcGlsZUF0dHJpYnV0ZShzeW1ib2w6IElBdHRyaWJ1dGVTeW1ib2wpOiBBdHRyaWJ1dGVJbnN0cnVjdGlvbiB7XG4gICAgLy8gICAvLyBhbnkgYXR0cmlidXRlIG9uIGEgY3VzdG9tIGVsZW1lbnQgKHdoaWNoIGlzIG5vdCBhIGJpbmRhYmxlKSBvciBhIHBsYWluIGVsZW1lbnRcbiAgICAvLyAgIGlmIChzeW1ib2wuZmxhZ3MgJiBTeW1ib2xGbGFncy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5jb21waWxlQ3VzdG9tQXR0cmlidXRlKHN5bWJvbCBhcyBDdXN0b21BdHRyaWJ1dGVTeW1ib2wpO1xuICAgIC8vICAgfSBlbHNlIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuY29tcGlsZVBsYWluQXR0cmlidXRlKHN5bWJvbCBhcyBQbGFpbkF0dHJpYnV0ZVN5bWJvbCk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIGNvbXBpbGVQcm9qZWN0aW9ucyhzeW1ib2wsIHByb2plY3Rpb25NYXAsIHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgaWYgKChzeW1ib2wuZmxhZ3MgJiAzMjc2OCAvKiBoYXNQcm9qZWN0aW9ucyAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnA7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgJHByb2plY3Rpb25zID0gc3ltYm9sLnByb2plY3Rpb25zO1xuICAgICAgICBjb25zdCBsZW4gPSAkcHJvamVjdGlvbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gJHByb2plY3Rpb25zW2ldO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHByb2plY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jb21waWxlUGFyZW50Tm9kZShwcm9qZWN0aW9uLnRlbXBsYXRlLCBpbnN0cnVjdGlvbnMsIHByb2plY3Rpb25NYXAsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHByb2plY3Rpb25zW25hbWVdO1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IHByb2plY3Rpb24udGVtcGxhdGUucGh5c2ljYWxOb2RlO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS50YWdOYW1lICE9PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF90ZW1wbGF0ZSA9IHAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IF90ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbnNbbmFtZV0gPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5jcmVhdGUoeyBuYW1lLCB0ZW1wbGF0ZSwgaW5zdHJ1Y3Rpb25zLCBuZWVkc0NvbXBpbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29saWRhdGUgdGhlIHByb2plY3Rpb25zIHRvIHNhbWUgc2xvdFxuICAgICAgICAgICAgICAgIGRlZmluaXRpb24udGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChwcm9qZWN0aW9uLnRlbXBsYXRlLnBoeXNpY2FsTm9kZSk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5pbnN0cnVjdGlvbnMucHVzaCguLi5pbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9ucztcbiAgICB9XG4gICAgY29tcGlsZVByb2plY3Rpb25GYWxsYmFjayhzeW1ib2wsIHByb2plY3Rpb25zLCB0YXJnZXRlZFByb2plY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBpbGVDaGlsZE5vZGVzKHN5bWJvbCwgaW5zdHJ1Y3Rpb25zLCBwcm9qZWN0aW9ucywgdGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5wLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kKC4uLnRvQXJyYXkoc3ltYm9sLnBoeXNpY2FsTm9kZS5jaGlsZE5vZGVzKSk7XG4gICAgICAgIHJldHVybiBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5jcmVhdGUoeyBuYW1lOiBDdXN0b21FbGVtZW50LmdlbmVyYXRlTmFtZSgpLCB0ZW1wbGF0ZSwgaW5zdHJ1Y3Rpb25zLCBuZWVkc0NvbXBpbGU6IGZhbHNlIH0pO1xuICAgIH1cbn07XG5UZW1wbGF0ZUNvbXBpbGVyID0gX19kZWNvcmF0ZShbXG4gICAgX19wYXJhbSgwLCBJVGVtcGxhdGVFbGVtZW50RmFjdG9yeSksXG4gICAgX19wYXJhbSgxLCBJQXR0cmlidXRlUGFyc2VyKSxcbiAgICBfX3BhcmFtKDIsIElFeHByZXNzaW9uUGFyc2VyKSxcbiAgICBfX3BhcmFtKDMsIElBdHRyU3ludGF4VHJhbnNmb3JtZXIpLFxuICAgIF9fcGFyYW0oNCwgSUxvZ2dlciksXG4gICAgX19wYXJhbSg1LCBJUGxhdGZvcm0pXG5dLCBUZW1wbGF0ZUNvbXBpbGVyKTtcbmV4cG9ydCB7IFRlbXBsYXRlQ29tcGlsZXIgfTtcbmZ1bmN0aW9uIHByb2Nlc3NUZW1wbGF0ZU5hbWUobG9jYWxUZW1wbGF0ZSwgbG9jYWxUZW1wbGF0ZU5hbWVzKSB7XG4gICAgY29uc3QgbmFtZSA9IGxvY2FsVGVtcGxhdGUuZ2V0QXR0cmlidXRlKGxvY2FsVGVtcGxhdGVJZGVudGlmaWVyKTtcbiAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImFzLWN1c3RvbS1lbGVtZW50XCIgYXR0cmlidXRlIGNhbm5vdCBiZSBlbXB0eSBmb3IgbG9jYWwgdGVtcGxhdGUnKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsVGVtcGxhdGVOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiB0aGUgbG9jYWwgdGVtcGxhdGUgbmFtZWQgJHtuYW1lfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9jYWxUZW1wbGF0ZU5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbG9jYWxUZW1wbGF0ZS5yZW1vdmVBdHRyaWJ1dGUobG9jYWxUZW1wbGF0ZUlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdNb2RlKGJpbmRhYmxlKSB7XG4gICAgc3dpdGNoIChiaW5kYWJsZS5nZXRBdHRyaWJ1dGUoXCJtb2RlXCIgLyogbW9kZSAqLykpIHtcbiAgICAgICAgY2FzZSAnb25lVGltZSc6XG4gICAgICAgICAgICByZXR1cm4gQmluZGluZ01vZGUub25lVGltZTtcbiAgICAgICAgY2FzZSAndG9WaWV3JzpcbiAgICAgICAgICAgIHJldHVybiBCaW5kaW5nTW9kZS50b1ZpZXc7XG4gICAgICAgIGNhc2UgJ2Zyb21WaWV3JzpcbiAgICAgICAgICAgIHJldHVybiBCaW5kaW5nTW9kZS5mcm9tVmlldztcbiAgICAgICAgY2FzZSAndHdvV2F5JzpcbiAgICAgICAgICAgIHJldHVybiBCaW5kaW5nTW9kZS50d29XYXk7XG4gICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEJpbmRpbmdNb2RlLmRlZmF1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0xvY2FsVGVtcGxhdGVzKHRlbXBsYXRlLCBkZWZpbml0aW9uLCBjb250ZXh0LCBwLCBsb2dnZXIpIHtcbiAgICBsZXQgcm9vdDtcbiAgICBpZiAodGVtcGxhdGUubm9kZU5hbWUgPT09ICdURU1QTEFURScpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmhhc0F0dHJpYnV0ZShsb2NhbFRlbXBsYXRlSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJvb3QgY2Fubm90IGJlIGEgbG9jYWwgdGVtcGxhdGUgaXRzZWxmLicpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdCA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFRlbXBsYXRlcyA9IHRvQXJyYXkocm9vdC5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZVthcy1jdXN0b20tZWxlbWVudF0nKSk7XG4gICAgY29uc3QgbnVtTG9jYWxUZW1wbGF0ZXMgPSBsb2NhbFRlbXBsYXRlcy5sZW5ndGg7XG4gICAgaWYgKG51bUxvY2FsVGVtcGxhdGVzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG51bUxvY2FsVGVtcGxhdGVzID09PSByb290LmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1c3RvbSBlbGVtZW50IGRvZXMgbm90IGhhdmUgYW55IGNvbnRlbnQgb3RoZXIgdGhhbiBsb2NhbCB0ZW1wbGF0ZShzKS4nKTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxUZW1wbGF0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbG9jYWxUZW1wbGF0ZSBvZiBsb2NhbFRlbXBsYXRlcykge1xuICAgICAgICBpZiAobG9jYWxUZW1wbGF0ZS5wYXJlbnROb2RlICE9PSByb290KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIHRlbXBsYXRlcyBuZWVkcyB0byBiZSBkZWZpbmVkIGRpcmVjdGx5IHVuZGVyIHJvb3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHByb2Nlc3NUZW1wbGF0ZU5hbWUobG9jYWxUZW1wbGF0ZSwgbG9jYWxUZW1wbGF0ZU5hbWVzKTtcbiAgICAgICAgY29uc3QgbG9jYWxUZW1wbGF0ZVR5cGUgPSBjbGFzcyBMb2NhbFRlbXBsYXRlIHtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGxvY2FsVGVtcGxhdGUuY29udGVudDtcbiAgICAgICAgY29uc3QgYmluZGFibGVFbHMgPSB0b0FycmF5KGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnYmluZGFibGUnKSk7XG4gICAgICAgIGNvbnN0IGJpbmRhYmxlSW5zdHJ1Y3Rpb25zID0gQmluZGFibGUuZm9yKGxvY2FsVGVtcGxhdGVUeXBlKTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBiaW5kYWJsZUVsIG9mIGJpbmRhYmxlRWxzKSB7XG4gICAgICAgICAgICBpZiAoYmluZGFibGVFbC5wYXJlbnROb2RlICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaW5kYWJsZSBwcm9wZXJ0aWVzIG9mIGxvY2FsIHRlbXBsYXRlcyBuZWVkcyB0byBiZSBkZWZpbmVkIGRpcmVjdGx5IHVuZGVyIHJvb3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGJpbmRhYmxlRWwuZ2V0QXR0cmlidXRlKFwicHJvcGVydHlcIiAvKiBwcm9wZXJ0eSAqLyk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBhdHRyaWJ1dGUgJ3Byb3BlcnR5JyBpcyBtaXNzaW5nIGluICR7YmluZGFibGVFbC5vdXRlckhUTUx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBiaW5kYWJsZUVsLmdldEF0dHJpYnV0ZShcImF0dHJpYnV0ZVwiIC8qIGF0dHJpYnV0ZSAqLyk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgJiYgYXR0cmlidXRlcy5oYXMoYXR0cmlidXRlKVxuICAgICAgICAgICAgICAgIHx8IHByb3BlcnRpZXMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluZGFibGUgcHJvcGVydHkgYW5kIGF0dHJpYnV0ZSBuZWVkcyB0byBiZSB1bmlxdWU7IGZvdW5kIHByb3BlcnR5OiAke3Byb3BlcnR5fSwgYXR0cmlidXRlOiAke2F0dHJpYnV0ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5hZGQoYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5hZGQocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZGFibGVJbnN0cnVjdGlvbnMuYWRkKHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSA/PyB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbW9kZTogZ2V0QmluZGluZ01vZGUoYmluZGFibGVFbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZWRBdHRyaWJ1dGVzID0gYmluZGFibGVFbC5nZXRBdHRyaWJ1dGVOYW1lcygpLmZpbHRlcigoYXR0ck5hbWUpID0+ICFhbGxvd2VkTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlcy5pbmNsdWRlcyhhdHRyTmFtZSkpO1xuICAgICAgICAgICAgaWYgKGlnbm9yZWRBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVGhlIGF0dHJpYnV0ZShzKSAke2lnbm9yZWRBdHRyaWJ1dGVzLmpvaW4oJywgJyl9IHdpbGwgYmUgaWdub3JlZCBmb3IgJHtiaW5kYWJsZUVsLm91dGVySFRNTH0uIE9ubHkgJHthbGxvd2VkTG9jYWxUZW1wbGF0ZUJpbmRhYmxlQXR0cmlidXRlcy5qb2luKCcsICcpfSBhcmUgcHJvY2Vzc2VkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudC5yZW1vdmVDaGlsZChiaW5kYWJsZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhbFRlbXBsYXRlRGVmaW5pdGlvbiA9IEN1c3RvbUVsZW1lbnQuZGVmaW5lKHsgbmFtZSwgdGVtcGxhdGU6IGxvY2FsVGVtcGxhdGUgfSwgbG9jYWxUZW1wbGF0ZVR5cGUpO1xuICAgICAgICAvLyB0aGUgY2FzdGluZyBpcyBuZWVkZWQgaGVyZSBhcyB0aGUgZGVwZW5kZW5jaWVzIGFyZSB0eXBlZCBhcyByZWFkb25seSBhcnJheVxuICAgICAgICBkZWZpbml0aW9uLmRlcGVuZGVuY2llcy5wdXNoKGxvY2FsVGVtcGxhdGVEZWZpbml0aW9uKTtcbiAgICAgICAgY29udGV4dC5yZWdpc3Rlcihsb2NhbFRlbXBsYXRlRGVmaW5pdGlvbik7XG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobG9jYWxUZW1wbGF0ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtY29tcGlsZXIuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBESSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBJUGxhdGZvcm0gfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmV4cG9ydCBjb25zdCBJVGVtcGxhdGVFbGVtZW50RmFjdG9yeSA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVRlbXBsYXRlRWxlbWVudEZhY3RvcnknLCB4ID0+IHguc2luZ2xldG9uKFRlbXBsYXRlRWxlbWVudEZhY3RvcnkpKTtcbmNvbnN0IG1hcmt1cENhY2hlID0ge307XG5sZXQgVGVtcGxhdGVFbGVtZW50RmFjdG9yeSA9IGNsYXNzIFRlbXBsYXRlRWxlbWVudEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKHApIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB9XG4gICAgY3JlYXRlVGVtcGxhdGUoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXJrdXBDYWNoZVtpbnB1dF07XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGlucHV0IGlzIGVpdGhlciBub3Qgd3JhcHBlZCBpbiBhIHRlbXBsYXRlIG9yIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgbm9kZSxcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHdob2xlIHRlbXBsYXRlIHRoYXQgd3JhcHMgaXQvdGhlbSAoYW5kIGNyZWF0ZSBhIG5ldyBvbmUgZm9yIHRoZSBuZXh0IGlucHV0KVxuICAgICAgICAgICAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS5ub2RlTmFtZSAhPT0gJ1RFTVBMQVRFJyB8fCBub2RlLm5leHRFbGVtZW50U2libGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLnAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbm9kZSB0byByZXR1cm4gaXMgYm90aCBhIHRlbXBsYXRlIGFuZCB0aGUgb25seSBub2RlLCBzbyByZXR1cm4ganVzdCB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY2xlYW4gdXAgdGhlIHRlbXBsYXRlIGZvciB0aGUgbmV4dCBpbnB1dFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXJrdXBDYWNoZVtpbnB1dF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQubm9kZU5hbWUgIT09ICdURU1QTEFURScpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGdldCBvbmUgbm9kZSB0aGF0IGlzIG5vdCBhIHRlbXBsYXRlLCB3cmFwIGl0IGluIG9uZVxuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnAuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGdvdCBhIHRlbXBsYXRlIGVsZW1lbnQsIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gaWYgaXQncyBwcmVzZW50IHRoZXJlIGFuZCBkb24ndFxuICAgICAgICAvLyBkbyBhbnkgb3RoZXIgcHJvY2Vzc2luZ1xuICAgICAgICBpbnB1dC5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfVxufTtcblRlbXBsYXRlRWxlbWVudEZhY3RvcnkgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElQbGF0Zm9ybSlcbl0sIFRlbXBsYXRlRWxlbWVudEZhY3RvcnkpO1xuZXhwb3J0IHsgVGVtcGxhdGVFbGVtZW50RmFjdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtZWxlbWVudC1mYWN0b3J5LmpzLm1hcCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBDaGlsZHJlbk9ic2VydmVyXzE7XG5pbXBvcnQgeyBQcm90b2NvbCwgTWV0YWRhdGEsIGZpcnN0RGVmaW5lZCwgZ2V0UHJvdG90eXBlQ2hhaW4gfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24gfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuKGNvbmZpZ09yVGFyZ2V0LCBwcm9wKSB7XG4gICAgbGV0IGNvbmZpZztcbiAgICBmdW5jdGlvbiBkZWNvcmF0b3IoJHRhcmdldCwgJHByb3ApIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBOb24gaW52b2NhdGlvbjpcbiAgICAgICAgICAgIC8vIC0gQGNoaWxkcmVuXG4gICAgICAgICAgICAvLyBJbnZvY2F0aW9uIHdpdGggb3Igdy9vIG9wdHM6XG4gICAgICAgICAgICAvLyAtIEBjaGlsZHJlbigpXG4gICAgICAgICAgICAvLyAtIEBjaGlsZHJlbih7Li4ub3B0c30pXG4gICAgICAgICAgICBjb25maWcucHJvcGVydHkgPSAkcHJvcDtcbiAgICAgICAgfVxuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ2hpbGRyZW4ubmFtZSwgQ2hpbGRyZW5EZWZpbml0aW9uLmNyZWF0ZSgkcHJvcCwgY29uZmlnKSwgJHRhcmdldC5jb25zdHJ1Y3RvciwgJHByb3ApO1xuICAgICAgICBQcm90b2NvbC5hbm5vdGF0aW9uLmFwcGVuZFRvKCR0YXJnZXQuY29uc3RydWN0b3IsIENoaWxkcmVuLmtleUZyb20oJHByb3ApKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIE5vbiBpbnZvY2F0aW9uOlxuICAgICAgICAvLyAtIEBjaGlsZHJlblxuICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgZGVjb3JhdG9yKGNvbmZpZ09yVGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnT3JUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIENsYXNzRGVjb3JhdG9yXG4gICAgICAgIC8vIC0gQGNoaWxkcmVuKCdiYXInKVxuICAgICAgICAvLyBEaXJlY3QgY2FsbDpcbiAgICAgICAgLy8gLSBAY2hpbGRyZW4oJ2JhcicpKEZvbylcbiAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3I7XG4gICAgfVxuICAgIC8vIEludm9jYXRpb24gd2l0aCBvciB3L28gb3B0czpcbiAgICAvLyAtIEBjaGlsZHJlbigpXG4gICAgLy8gLSBAY2hpbGRyZW4oey4uLm9wdHN9KVxuICAgIGNvbmZpZyA9IGNvbmZpZ09yVGFyZ2V0ID09PSB2b2lkIDAgPyB7fSA6IGNvbmZpZ09yVGFyZ2V0O1xuICAgIHJldHVybiBkZWNvcmF0b3I7XG59XG5mdW5jdGlvbiBpc0NoaWxkcmVuT2JzZXJ2ZXJBbm5vdGF0aW9uKGtleSkge1xuICAgIHJldHVybiBrZXkuc3RhcnRzV2l0aChDaGlsZHJlbi5uYW1lKTtcbn1cbmV4cG9ydCBjb25zdCBDaGlsZHJlbiA9IHtcbiAgICBuYW1lOiBQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcignY2hpbGRyZW4tb2JzZXJ2ZXInKSxcbiAgICBrZXlGcm9tKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke0NoaWxkcmVuLm5hbWV9OiR7bmFtZX1gO1xuICAgIH0sXG4gICAgZnJvbSguLi5jaGlsZHJlbk9ic2VydmVyTGlzdHMpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5PYnNlcnZlcnMgPSB7fTtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgICAgIGZ1bmN0aW9uIGFkZE5hbWUobmFtZSkge1xuICAgICAgICAgICAgY2hpbGRyZW5PYnNlcnZlcnNbbmFtZV0gPSBDaGlsZHJlbkRlZmluaXRpb24uY3JlYXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZERlc2NyaXB0aW9uKG5hbWUsIGRlZikge1xuICAgICAgICAgICAgY2hpbGRyZW5PYnNlcnZlcnNbbmFtZV0gPSBDaGlsZHJlbkRlZmluaXRpb24uY3JlYXRlKG5hbWUsIGRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkTGlzdChtYXliZUxpc3QpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1heWJlTGlzdCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZUxpc3QuZm9yRWFjaChhZGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1heWJlTGlzdCBpbnN0YW5jZW9mIENoaWxkcmVuRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuT2JzZXJ2ZXJzW21heWJlTGlzdC5wcm9wZXJ0eV0gPSBtYXliZUxpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXliZUxpc3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1heWJlTGlzdCkuZm9yRWFjaChuYW1lID0+IGFkZERlc2NyaXB0aW9uKG5hbWUsIG1heWJlTGlzdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuT2JzZXJ2ZXJMaXN0cy5mb3JFYWNoKGFkZExpc3QpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5PYnNlcnZlcnM7XG4gICAgfSxcbiAgICBnZXRBbGwoVHlwZSkge1xuICAgICAgICBjb25zdCBwcm9wU3RhcnQgPSBDaGlsZHJlbi5uYW1lLmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGRlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlQ2hhaW4gPSBnZXRQcm90b3R5cGVDaGFpbihUeXBlKTtcbiAgICAgICAgbGV0IGlQcm90byA9IHByb3RvdHlwZUNoYWluLmxlbmd0aDtcbiAgICAgICAgbGV0IGlEZWZzID0gMDtcbiAgICAgICAgbGV0IGtleXM7XG4gICAgICAgIGxldCBrZXlzTGVuO1xuICAgICAgICBsZXQgQ2xhc3M7XG4gICAgICAgIHdoaWxlICgtLWlQcm90byA+PSAwKSB7XG4gICAgICAgICAgICBDbGFzcyA9IHByb3RvdHlwZUNoYWluW2lQcm90b107XG4gICAgICAgICAgICBrZXlzID0gUHJvdG9jb2wuYW5ub3RhdGlvbi5nZXRLZXlzKENsYXNzKS5maWx0ZXIoaXNDaGlsZHJlbk9ic2VydmVyQW5ub3RhdGlvbik7XG4gICAgICAgICAgICBrZXlzTGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGRlZnNbaURlZnMrK10gPSBNZXRhZGF0YS5nZXRPd24oQ2hpbGRyZW4ubmFtZSwgQ2xhc3MsIGtleXNbaV0uc2xpY2UocHJvcFN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZnM7XG4gICAgfSxcbn07XG5jb25zdCBjaGlsZE9ic2VydmVyT3B0aW9ucyA9IHsgY2hpbGRMaXN0OiB0cnVlIH07XG5leHBvcnQgY2xhc3MgQ2hpbGRyZW5EZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgcHJvcGVydHksIG9wdGlvbnMsIHF1ZXJ5LCBmaWx0ZXIsIG1hcCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocHJvcCwgZGVmID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbkRlZmluaXRpb24oZmlyc3REZWZpbmVkKGRlZi5jYWxsYmFjaywgYCR7cHJvcH1DaGFuZ2VkYCksIGZpcnN0RGVmaW5lZChkZWYucHJvcGVydHksIHByb3ApLCBkZWYub3B0aW9ucyA/PyBjaGlsZE9ic2VydmVyT3B0aW9ucywgZGVmLnF1ZXJ5LCBkZWYuZmlsdGVyLCBkZWYubWFwKTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5sZXQgQ2hpbGRyZW5PYnNlcnZlciA9IENoaWxkcmVuT2JzZXJ2ZXJfMSA9IGNsYXNzIENoaWxkcmVuT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIsIG9iaiwgcHJvcGVydHlLZXksIGNiTmFtZSwgcXVlcnkgPSBkZWZhdWx0Q2hpbGRRdWVyeSwgZmlsdGVyID0gZGVmYXVsdENoaWxkRmlsdGVyLCBtYXAgPSBkZWZhdWx0Q2hpbGRNYXAsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMub2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSAodm9pZCAwKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9ialtjYk5hbWVdO1xuICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub2JqLCB0aGlzLnByb3BlcnR5S2V5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgICBzZXQ6ICgpID0+IHsgcmV0dXJuOyB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHRoaXMudHJ5U3RhcnRPYnNlcnZpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlKSB7IH1cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICB0aGlzLnRyeVN0YXJ0T2JzZXJ2aW5nKCk7XG4gICAgICAgIHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcik7XG4gICAgfVxuICAgIHRyeVN0YXJ0T2JzZXJ2aW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMub2JzZXJ2aW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gZmlsdGVyQ2hpbGRyZW4odGhpcy5jb250cm9sbGVyLCB0aGlzLnF1ZXJ5LCB0aGlzLmZpbHRlciwgdGhpcy5tYXApO1xuICAgICAgICAgICAgY29uc3Qgb2JzID0gbmV3IHRoaXMuY29udHJvbGxlci5ob3N0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7IHRoaXMub25DaGlsZHJlbkNoYW5nZWQoKTsgfSk7XG4gICAgICAgICAgICBvYnMub2JzZXJ2ZSh0aGlzLmNvbnRyb2xsZXIuaG9zdCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNoaWxkcmVuQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGZpbHRlckNoaWxkcmVuKHRoaXMuY29udHJvbGxlciwgdGhpcy5xdWVyeSwgdGhpcy5maWx0ZXIsIHRoaXMubWFwKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMub2JqKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnMubm90aWZ5KHRoaXMuY2hpbGRyZW4sIHVuZGVmaW5lZCwgOCAvKiB1cGRhdGVUYXJnZXQgKi8pO1xuICAgIH1cbn07XG5DaGlsZHJlbk9ic2VydmVyID0gQ2hpbGRyZW5PYnNlcnZlcl8xID0gX19kZWNvcmF0ZShbXG4gICAgc3Vic2NyaWJlckNvbGxlY3Rpb24oKVxuXSwgQ2hpbGRyZW5PYnNlcnZlcik7XG5leHBvcnQgeyBDaGlsZHJlbk9ic2VydmVyIH07XG5mdW5jdGlvbiBkZWZhdWx0Q2hpbGRRdWVyeShjb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuaG9zdC5jaGlsZE5vZGVzO1xufVxuZnVuY3Rpb24gZGVmYXVsdENoaWxkRmlsdGVyKG5vZGUsIGNvbnRyb2xsZXIsIHZpZXdNb2RlbCkge1xuICAgIHJldHVybiAhIXZpZXdNb2RlbDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDaGlsZE1hcChub2RlLCBjb250cm9sbGVyLCB2aWV3TW9kZWwpIHtcbiAgICByZXR1cm4gdmlld01vZGVsO1xufVxuY29uc3QgZm9yT3B0cyA9IHsgb3B0aW9uYWw6IHRydWUgfTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJDaGlsZHJlbihjb250cm9sbGVyLCBxdWVyeSwgZmlsdGVyLCBtYXApIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5KGNvbnRyb2xsZXIpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbm9kZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGNvbnN0ICRjb250cm9sbGVyID0gQ3VzdG9tRWxlbWVudC5mb3Iobm9kZSwgZm9yT3B0cyk7XG4gICAgICAgIGNvbnN0IHZpZXdNb2RlbCA9ICRjb250cm9sbGVyPy52aWV3TW9kZWwgPz8gbnVsbDtcbiAgICAgICAgaWYgKGZpbHRlcihub2RlLCAkY29udHJvbGxlciwgdmlld01vZGVsKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChtYXAobm9kZSwgJGNvbnRyb2xsZXIsIHZpZXdNb2RlbCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoaWxkcmVuLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvbiAqL1xuaW1wb3J0IHsgbmV4dElkLCBpc09iamVjdCwgSUxvZ2dlciwgTWV0YWRhdGEsIERJLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBBY2Nlc3NTY29wZUV4cHJlc3Npb24sIFNjb3BlLCBJT2JzZXJ2ZXJMb2NhdG9yLCBJRXhwcmVzc2lvblBhcnNlciwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmltcG9ydCB7IEJpbmRhYmxlT2JzZXJ2ZXIgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi9iaW5kYWJsZS1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9SZW5kZXJMb2NhdGlvbiB9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50RGVmaW5pdGlvbiwgQ3VzdG9tRWxlbWVudCB9IGZyb20gJy4uL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBDdXN0b21BdHRyaWJ1dGUgfSBmcm9tICcuLi9yZXNvdXJjZXMvY3VzdG9tLWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBnZXRSZW5kZXJDb250ZXh0IH0gZnJvbSAnLi9yZW5kZXItY29udGV4dC5qcyc7XG5pbXBvcnQgeyBDaGlsZHJlbk9ic2VydmVyIH0gZnJvbSAnLi9jaGlsZHJlbi5qcyc7XG5pbXBvcnQgeyBJQXBwUm9vdCB9IGZyb20gJy4uL2FwcC1yb290LmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IElTaGFkb3dET01HbG9iYWxTdHlsZXMsIElTaGFkb3dET01TdHlsZXMgfSBmcm9tICcuL3N0eWxlcy5qcyc7XG5pbXBvcnQgeyBDb21wdXRlZFdhdGNoZXIsIEV4cHJlc3Npb25XYXRjaGVyIH0gZnJvbSAnLi93YXRjaGVycy5qcyc7XG5mdW5jdGlvbiBjYWxsRGlzcG9zZShkaXNwb3NhYmxlKSB7XG4gICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG59XG5leHBvcnQgdmFyIE1vdW50VGFyZ2V0O1xuKGZ1bmN0aW9uIChNb3VudFRhcmdldCkge1xuICAgIE1vdW50VGFyZ2V0W01vdW50VGFyZ2V0W1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgTW91bnRUYXJnZXRbTW91bnRUYXJnZXRbXCJob3N0XCJdID0gMV0gPSBcImhvc3RcIjtcbiAgICBNb3VudFRhcmdldFtNb3VudFRhcmdldFtcInNoYWRvd1Jvb3RcIl0gPSAyXSA9IFwic2hhZG93Um9vdFwiO1xuICAgIE1vdW50VGFyZ2V0W01vdW50VGFyZ2V0W1wibG9jYXRpb25cIl0gPSAzXSA9IFwibG9jYXRpb25cIjtcbn0pKE1vdW50VGFyZ2V0IHx8IChNb3VudFRhcmdldCA9IHt9KSk7XG5jb25zdCBvcHRpb25hbCA9IHsgb3B0aW9uYWw6IHRydWUgfTtcbmNvbnN0IGNvbnRyb2xsZXJMb29rdXAgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNsYXNzIENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIGNvbnRhaW5lciwgdm1LaW5kLCBmbGFncywgZGVmaW5pdGlvbiwgXG4gICAgLyoqXG4gICAgICogVGhlIHZpZXdGYWN0b3J5LiBPbmx5IHByZXNlbnQgZm9yIHN5bnRoZXRpYyB2aWV3cy5cbiAgICAgKi9cbiAgICB2aWV3RmFjdG9yeSwgXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tpbmcgdmlld01vZGVsLiBPbmx5IHByZXNlbnQgZm9yIGN1c3RvbSBhdHRyaWJ1dGVzIGFuZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICB2aWV3TW9kZWwsIFxuICAgIC8qKlxuICAgICAqIFRoZSBwaHlzaWNhbCBob3N0IGRvbSBub2RlLlxuICAgICAqXG4gICAgICogRm9yIGNvbnRhaW5lcmxlc3MgZWxlbWVudHMsIHRoaXMgbm9kZSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGFuZCByZXBsYWNlZCBieSBhIGNvbW1lbnQsIHdoaWNoIGlzIGFzc2lnbmVkIHRvIHRoZSBgbG9jYXRpb25gIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogRm9yIFNoYWRvd0RPTSBlbGVtZW50cywgdGhpcyB3aWxsIGJlIHRoZSBvcmlnaW5hbCBkZWNsYXJpbmcgZWxlbWVudCwgTk9UIHRoZSBzaGFkb3cgcm9vdCAodGhlIHNoYWRvdyByb290IGlzIHN0b3JlZCBvbiB0aGUgYHNoYWRvd1Jvb3RgIHByb3BlcnR5KVxuICAgICAqL1xuICAgIGhvc3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMudm1LaW5kID0gdm1LaW5kO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgIHRoaXMudmlld0ZhY3RvcnkgPSB2aWV3RmFjdG9yeTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB2aWV3TW9kZWw7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SWQoJ2F1JGNvbXBvbmVudCcpO1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNMb2NrZWRTY29wZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RyaWN0QmluZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob3N0U2NvcGUgPSBudWxsO1xuICAgICAgICAvLyBJZiBhIGhvc3QgZnJvbSBhbm90aGVyIGN1c3RvbSBlbGVtZW50IHdhcyBwYXNzZWQgaW4sIHRoZW4gdGhpcyB3aWxsIGJlIHRoZSBjb250cm9sbGVyIGZvciB0aGF0IGN1c3RvbSBlbGVtZW50IChjb3VsZCBiZSBgYXUtdmlld3BvcnRgIGZvciBleGFtcGxlKS5cbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGlzIGNvbnRyb2xsZXIgd2lsbCBjcmVhdGUgYSBuZXcgaG9zdCBub2RlICh3aXRoIHRoZSBkZWZpbml0aW9uJ3MgbmFtZSkgYW5kIHVzZSB0aGF0IGFzIHRoZSB0YXJnZXQgaG9zdCBmb3IgdGhlIG5vZGVzIGluc3RlYWQuXG4gICAgICAgIC8vIFRoYXQgaG9zdCBub2RlIGlzIHNlcGFyYXRlbHkgbW91bnRlZCB0byB0aGUgaG9zdCBjb250cm9sbGVyJ3Mgb3JpZ2luYWwgaG9zdCBub2RlLlxuICAgICAgICB0aGlzLmhvc3RDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VudFRhcmdldCA9IDAgLyogbm9uZSAqLztcbiAgICAgICAgdGhpcy5zaGFkb3dSb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBub25lICovO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mdWxseU5hbWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGluaXRpYXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMuJGZsYWdzID0gMCAvKiBub25lICovO1xuICAgICAgICB0aGlzLiRyZXNvbHZlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLiRyZWplY3QgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuJHByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuYWN0aXZhdGluZ1N0YWNrID0gMDtcbiAgICAgICAgdGhpcy5kZXRhY2hpbmdTdGFjayA9IDA7XG4gICAgICAgIHRoaXMudW5iaW5kaW5nU3RhY2sgPSAwO1xuICAgICAgICBpZiAocm9vdCA9PT0gbnVsbCAmJiBjb250YWluZXIuaGFzKElBcHBSb290LCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gY29udGFpbmVyLmdldChJQXBwUm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IGNvbnRhaW5lci5nZXQoSVBsYXRmb3JtKTtcbiAgICAgICAgc3dpdGNoICh2bUtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBjdXN0b21BdHRyaWJ1dGUgKi86XG4gICAgICAgICAgICBjYXNlIDAgLyogY3VzdG9tRWxlbWVudCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzID0gbmV3IEhvb2tzRGVmaW5pdGlvbih2aWV3TW9kZWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIHN5bnRoZXRpYyAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzID0gSG9va3NEZWZpbml0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgJiAoMSAvKiBhY3RpdmF0aW5nICovIHwgMiAvKiBhY3RpdmF0ZWQgKi8pKSA+IDAgJiYgKHRoaXMuc3RhdGUgJiA0IC8qIGRlYWN0aXZhdGluZyAqLykgPT09IDA7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy52bUtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogY3VzdG9tQXR0cmlidXRlICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFske3RoaXMuZGVmaW5pdGlvbi5uYW1lfV1gO1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBjdXN0b21FbGVtZW50ICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIHN5bnRoZXRpYyAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld0ZhY3RvcnkubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMudm1LaW5kKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogY3VzdG9tQXR0cmlidXRlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBhcmVudC5uYW1lfT5bJHt0aGlzLmRlZmluaXRpb24ubmFtZX1dYDtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBjdXN0b21FbGVtZW50ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBhcmVudC5uYW1lfT4ke3RoaXMuZGVmaW5pdGlvbi5uYW1lfWA7XG4gICAgICAgICAgICBjYXNlIDIgLyogc3ludGhldGljICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdGYWN0b3J5Lm5hbWUgPT09IHRoaXMucGFyZW50LmRlZmluaXRpb24/Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBgJHt0aGlzLnBhcmVudC5uYW1lfVt2aWV3XWBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHt0aGlzLnBhcmVudC5uYW1lfVt2aWV3OiR7dGhpcy52aWV3RmFjdG9yeS5uYW1lfV1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDYWNoZWQodmlld01vZGVsKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyTG9va3VwLmdldCh2aWV3TW9kZWwpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2FjaGVkT3JUaHJvdyh2aWV3TW9kZWwpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IENvbnRyb2xsZXIuZ2V0Q2FjaGVkKHZpZXdNb2RlbCk7XG4gICAgICAgIGlmIChjb250cm9sbGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gY2FjaGVkIGNvbnRyb2xsZXIgZm9yIHRoZSBwcm92aWRlZCBWaWV3TW9kZWw6ICR7U3RyaW5nKHZpZXdNb2RlbCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JDdXN0b21FbGVtZW50KHJvb3QsIGNvbnRhaW5lciwgdmlld01vZGVsLCBob3N0LCBcbiAgICAvLyBwcm9qZWN0aW9ucyAqdGFyZ2V0ZWQqIGZvciB0aGlzIGN1c3RvbSBlbGVtZW50LiB0aGVzZSBhcmUgbm90IHRoZSBwcm9qZWN0aW9ucyAqcHJvdmlkZWQqIGJ5IHRoaXMgY3VzdG9tIGVsZW1lbnQuXG4gICAgdGFyZ2V0ZWRQcm9qZWN0aW9ucywgZmxhZ3MgPSAwIC8qIG5vbmUgKi8sIGh5ZHJhdGUgPSB0cnVlLCBcbiAgICAvLyBVc2UgdGhpcyB3aGVuIGBpbnN0YW5jZS5jb25zdHJ1Y3RvcmAgaXMgbm90IGEgY3VzdG9tIGVsZW1lbnQgdHlwZSB0byBwYXNzIG9uIHRoZSBDdXN0b21FbGVtZW50IGRlZmluaXRpb25cbiAgICBkZWZpbml0aW9uID0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyTG9va3VwLmhhcyh2aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlckxvb2t1cC5nZXQodmlld01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbiA/PyBDdXN0b21FbGVtZW50LmdldERlZmluaXRpb24odmlld01vZGVsLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKFxuICAgICAgICAvKiByb290ICAgICAgICAgICAqLyByb290LCBcbiAgICAgICAgLyogY29udGFpbmVyICAgICAgKi8gY29udGFpbmVyLCAwIC8qIGN1c3RvbUVsZW1lbnQgKi8sIFxuICAgICAgICAvKiBmbGFncyAgICAgICAgICAqLyBmbGFncywgXG4gICAgICAgIC8qIGRlZmluaXRpb24gICAgICovIGRlZmluaXRpb24sIFxuICAgICAgICAvKiB2aWV3RmFjdG9yeSAgICAqLyBudWxsLCBcbiAgICAgICAgLyogdmlld01vZGVsICAgICAgKi8gdmlld01vZGVsLCBcbiAgICAgICAgLyogaG9zdCAgICAgICAgICAgKi8gaG9zdCk7XG4gICAgICAgIGNvbnRyb2xsZXJMb29rdXAuc2V0KHZpZXdNb2RlbCwgY29udHJvbGxlcik7XG4gICAgICAgIGlmIChoeWRyYXRlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmh5ZHJhdGVDdXN0b21FbGVtZW50KGNvbnRhaW5lciwgdGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JDdXN0b21BdHRyaWJ1dGUocm9vdCwgY29udGFpbmVyLCB2aWV3TW9kZWwsIGhvc3QsIGZsYWdzID0gMCAvKiBub25lICovKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyTG9va3VwLmhhcyh2aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlckxvb2t1cC5nZXQodmlld01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tQXR0cmlidXRlLmdldERlZmluaXRpb24odmlld01vZGVsLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKFxuICAgICAgICAvKiByb290ICAgICAgICAgICAqLyByb290LCBcbiAgICAgICAgLyogY29udGFpbmVyICAgICAgKi8gY29udGFpbmVyLCAxIC8qIGN1c3RvbUF0dHJpYnV0ZSAqLywgXG4gICAgICAgIC8qIGZsYWdzICAgICAgICAgICovIGZsYWdzLCBcbiAgICAgICAgLyogZGVmaW5pdGlvbiAgICAgKi8gZGVmaW5pdGlvbiwgXG4gICAgICAgIC8qIHZpZXdGYWN0b3J5ICAgICovIG51bGwsIFxuICAgICAgICAvKiB2aWV3TW9kZWwgICAgICAqLyB2aWV3TW9kZWwsIFxuICAgICAgICAvKiBob3N0ICAgICAgICAgICAqLyBob3N0KTtcbiAgICAgICAgY29udHJvbGxlckxvb2t1cC5zZXQodmlld01vZGVsLCBjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5oeWRyYXRlQ3VzdG9tQXR0cmlidXRlKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yU3ludGhldGljVmlldyhyb290LCBjb250ZXh0LCB2aWV3RmFjdG9yeSwgZmxhZ3MgPSAwIC8qIG5vbmUgKi8sIHBhcmVudENvbnRyb2xsZXIgPSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKFxuICAgICAgICAvKiByb290ICAgICAgICAgICAqLyByb290LCBcbiAgICAgICAgLyogY29udGFpbmVyICAgICAgKi8gY29udGV4dCwgMiAvKiBzeW50aGV0aWMgKi8sIFxuICAgICAgICAvKiBmbGFncyAgICAgICAgICAqLyBmbGFncywgXG4gICAgICAgIC8qIGRlZmluaXRpb24gICAgICovIG51bGwsIFxuICAgICAgICAvKiB2aWV3RmFjdG9yeSAgICAqLyB2aWV3RmFjdG9yeSwgXG4gICAgICAgIC8qIHZpZXdNb2RlbCAgICAgICovIG51bGwsIFxuICAgICAgICAvKiBob3N0ICAgICAgICAgICAqLyBudWxsKTtcbiAgICAgICAgY29udHJvbGxlci5wYXJlbnQgPSBwYXJlbnRDb250cm9sbGVyID8/IG51bGw7XG4gICAgICAgIGNvbnRyb2xsZXIuaHlkcmF0ZVN5bnRoZXRpYyhjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBoeWRyYXRlQ3VzdG9tRWxlbWVudChwYXJlbnRDb250YWluZXIsIHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBwYXJlbnRDb250YWluZXIuZ2V0KElMb2dnZXIpLnJvb3Q7XG4gICAgICAgIHRoaXMuZGVidWcgPSB0aGlzLmxvZ2dlci5jb25maWcubGV2ZWwgPD0gMSAvKiBkZWJ1ZyAqLztcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gdGhpcy5sb2dnZXIuc2NvcGVUbyh0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZpbml0aW9uID0gdGhpcy5kZWZpbml0aW9uO1xuICAgICAgICBjb25zdCBmbGFncyA9IHRoaXMuZmxhZ3M7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy52aWV3TW9kZWw7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBTY29wZS5jcmVhdGUoaW5zdGFuY2UsIG51bGwsIHRydWUpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi53YXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXJzKHRoaXMsIHRoaXMuY29udGFpbmVyLCBkZWZpbml0aW9uLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlT2JzZXJ2ZXJzKHRoaXMsIGRlZmluaXRpb24sIGZsYWdzLCBpbnN0YW5jZSk7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuT2JzZXJ2ZXJzKHRoaXMsIGRlZmluaXRpb24sIGZsYWdzLCBpbnN0YW5jZSk7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0RlZmluZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgaW52b2tpbmcgZGVmaW5lKCkgaG9va2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5zdGFuY2UuZGVmaW5lKFxuICAgICAgICAgICAgLyogY29udHJvbGxlciAgICAgICovIHRoaXMsIFxuICAgICAgICAgICAgLyogcGFyZW50Q29udGFpbmVyICovIHBhcmVudENvbnRhaW5lciwgXG4gICAgICAgICAgICAvKiBkZWZpbml0aW9uICAgICAgKi8gZGVmaW5pdGlvbik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDAgJiYgcmVzdWx0ICE9PSBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLmdldE9yQ3JlYXRlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dCA9IGdldFJlbmRlckNvbnRleHQoZGVmaW5pdGlvbiwgcGFyZW50Q29udGFpbmVyLCB0YXJnZXRlZFByb2plY3Rpb25zPy5wcm9qZWN0aW9ucyk7XG4gICAgICAgIC8vIFN1cHBvcnQgUmVjdXJzaXZlIENvbXBvbmVudHMgYnkgYWRkaW5nIHNlbGYgdG8gb3duIGNvbnRleHRcbiAgICAgICAgZGVmaW5pdGlvbi5yZWdpc3Rlcihjb250ZXh0KTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uaW5qZWN0YWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZCBhcyBpbmplY3RhYmxlLCBzdXBwb3J0IGluamVjdGluZyB0aGUgaW5zdGFuY2UgaW50byBjaGlsZHJlblxuICAgICAgICAgICAgY29udGV4dC5iZWdpbkNoaWxkQ29tcG9uZW50T3BlcmF0aW9uKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSByb290IGNvbnRyb2xsZXIsIHRoZW4gdGhlIEFwcFJvb3Qgd2lsbCBpbnZva2UgdGhpbmdzIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4gICAgICAgIC8vIC0gQ29udHJvbGxlci5oeWRyYXRlQ3VzdG9tRWxlbWVudFxuICAgICAgICAvLyAtIHJ1bkFwcFRhc2tzKCdoeWRyYXRpbmcnKSAvLyBtYXkgcmV0dXJuIGEgcHJvbWlzZVxuICAgICAgICAvLyAtIENvbnRyb2xsZXIuY29tcGlsZVxuICAgICAgICAvLyAtIHJ1bkFwcFRhc2tzKCdoeWRyYXRlZCcpIC8vIG1heSByZXR1cm4gYSBwcm9taXNlXG4gICAgICAgIC8vIC0gQ29udHJvbGxlci5jb21waWxlQ2hpbGRyZW5cbiAgICAgICAgLy8gVGhpcyBrZWVwcyBoeWRyYXRpb24gc3luY2hyb25vdXMgd2hpbGUgc3RpbGwgYWxsb3dpbmcgdGhlIGNvbXBvc2l0aW9uIHJvb3QgY29tcGlsZSBob29rcyB0byBkbyBhc3luYyB3b3JrLlxuICAgICAgICBpZiAodGhpcy5yb290Py5jb250cm9sbGVyICE9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmh5ZHJhdGUodGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmh5ZHJhdGVDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBoeWRyYXRlKHRhcmdldGVkUHJvamVjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9va3MuaGFzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBpbnZva2luZyBoYXNIeWRyYXRpbmcoKSBob29rYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oeWRyYXRpbmcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcGlsZWRDb250ZXh0ID0gdGhpcy5jb250ZXh0LmNvbXBpbGUodGFyZ2V0ZWRQcm9qZWN0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbnNNYXAsIHNoYWRvd09wdGlvbnMsIGlzU3RyaWN0QmluZGluZywgaGFzU2xvdHMsIGNvbnRhaW5lcmxlc3MgfSA9IGNvbXBpbGVkQ29udGV4dC5jb21waWxlZERlZmluaXRpb247XG4gICAgICAgIGNvbXBpbGVkQ29udGV4dC5yZWdpc3RlclByb2plY3Rpb25zKHByb2plY3Rpb25zTWFwLCB0aGlzLnNjb3BlKTtcbiAgICAgICAgLy8gb25jZSB0aGUgcHJvamVjdGlvbnMgYXJlIHJlZ2lzdGVyZWQsIHdlIGNhbiBjbGVhbnVwIHRoZSBwcm9qZWN0aW9uIG1hcCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy5cbiAgICAgICAgcHJvamVjdGlvbnNNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pc1N0cmljdEJpbmRpbmcgPSBpc1N0cmljdEJpbmRpbmc7XG4gICAgICAgIGlmICgodGhpcy5ob3N0Q29udHJvbGxlciA9IEN1c3RvbUVsZW1lbnQuZm9yKHRoaXMuaG9zdCwgb3B0aW9uYWwpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5wbGF0Zm9ybS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuY29udGV4dC5kZWZpbml0aW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShDdXN0b21FbGVtZW50Lm5hbWUsIHRoaXMsIHRoaXMuaG9zdCk7XG4gICAgICAgIGlmIChzaGFkb3dPcHRpb25zICE9PSBudWxsIHx8IGhhc1Nsb3RzKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVybGVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBjb21iaW5lIHRoZSBjb250YWluZXJsZXNzIGN1c3RvbSBlbGVtZW50IG9wdGlvbiB3aXRoIFNoYWRvdyBET00uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ3VzdG9tRWxlbWVudC5uYW1lLCB0aGlzLCB0aGlzLnNoYWRvd1Jvb3QgPSB0aGlzLmhvc3QuYXR0YWNoU2hhZG93KHNoYWRvd09wdGlvbnMgPz8gZGVmYXVsdFNoYWRvd09wdGlvbnMpKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRUYXJnZXQgPSAyIC8qIHNoYWRvd1Jvb3QgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbmVybGVzcykge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUVsZW1lbnQubmFtZSwgdGhpcywgdGhpcy5sb2NhdGlvbiA9IGNvbnZlcnRUb1JlbmRlckxvY2F0aW9uKHRoaXMuaG9zdCkpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFRhcmdldCA9IDMgLyogbG9jYXRpb24gKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdW50VGFyZ2V0ID0gMSAvKiBob3N0ICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld01vZGVsLiRjb250cm9sbGVyID0gdGhpcztcbiAgICAgICAgdGhpcy5ub2RlcyA9IGNvbXBpbGVkQ29udGV4dC5jcmVhdGVOb2RlcygpO1xuICAgICAgICBpZiAodGhpcy5ob29rcy5oYXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgaW52b2tpbmcgaGFzSHlkcmF0ZWQoKSBob29rYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5oeWRyYXRlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaHlkcmF0ZUNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy5ub2Rlcy5maW5kVGFyZ2V0cygpO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVuZGVyKFxuICAgICAgICAvKiBmbGFncyAgICAgICovIHRoaXMuZmxhZ3MsIFxuICAgICAgICAvKiBjb250cm9sbGVyICovIHRoaXMsIFxuICAgICAgICAvKiB0YXJnZXRzICAgICovIHRhcmdldHMsIFxuICAgICAgICAvKiBkZWZpbml0aW9uICovIHRoaXMuY29udGV4dC5jb21waWxlZERlZmluaXRpb24sIFxuICAgICAgICAvKiBob3N0ICAgICAgICovIHRoaXMuaG9zdCk7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0NyZWF0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGludm9raW5nIGNyZWF0ZWQoKSBob29rYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jcmVhdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh5ZHJhdGVDdXN0b21BdHRyaWJ1dGUoKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmRlZmluaXRpb247XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy52aWV3TW9kZWw7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLndhdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcnModGhpcywgdGhpcy5jb250YWluZXIsIGRlZmluaXRpb24sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVPYnNlcnZlcnModGhpcywgZGVmaW5pdGlvbiwgdGhpcy5mbGFncywgaW5zdGFuY2UpO1xuICAgICAgICBpbnN0YW5jZS4kY29udHJvbGxlciA9IHRoaXM7XG4gICAgfVxuICAgIGh5ZHJhdGVTeW50aGV0aWMoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBjb25zdCBjb21waWxlZENvbnRleHQgPSBjb250ZXh0LmNvbXBpbGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVkRGVmaW5pdGlvbiA9IGNvbXBpbGVkQ29udGV4dC5jb21waWxlZERlZmluaXRpb247XG4gICAgICAgIHRoaXMuaXNTdHJpY3RCaW5kaW5nID0gY29tcGlsZWREZWZpbml0aW9uLmlzU3RyaWN0QmluZGluZztcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzID0gY29tcGlsZWRDb250ZXh0LmNyZWF0ZU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldHMgPSBub2Rlcy5maW5kVGFyZ2V0cygpO1xuICAgICAgICBjb21waWxlZENvbnRleHQucmVuZGVyKFxuICAgICAgICAvKiBmbGFncyAgICAgICovIHRoaXMuZmxhZ3MsIFxuICAgICAgICAvKiBjb250cm9sbGVyICovIHRoaXMsIFxuICAgICAgICAvKiB0YXJnZXRzICAgICovIHRhcmdldHMsIFxuICAgICAgICAvKiBkZWZpbml0aW9uICovIGNvbXBpbGVkRGVmaW5pdGlvbiwgXG4gICAgICAgIC8qIGhvc3QgICAgICAgKi8gdm9pZCAwKTtcbiAgICB9XG4gICAgYWN0aXZhdGUoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIG5vbmUgKi86XG4gICAgICAgICAgICBjYXNlIDggLyogZGVhY3RpdmF0ZWQgKi86XG4gICAgICAgICAgICAgICAgaWYgKCEocGFyZW50ID09PSBudWxsIHx8IHBhcmVudC5pc0FjdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIHJvb3QsIGFuZCB0aGUgcGFyZW50IGlzIGVpdGhlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gTm90IGFjdGl2YXRlZCwgb3IgYWN0aXZhdGluZyBjaGlsZHJlbiBPUlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBEZWFjdGl2YXRpbmcgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIC8vIGFib3J0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcHJvY2VlZCBub3JtYWxseS5cbiAgICAgICAgICAgICAgICAvLyAnZGVhY3RpdmF0ZWQnIGFuZCAnbm9uZScgYXJlIHRyZWF0ZWQgdGhlIHNhbWUgYmVjYXVzZSwgZnJvbSBhbiBhY3RpdmF0aW9uIHBlcnNwZWN0aXZlLCB0aGV5IG1lYW4gdGhlIHNhbWUgdGhpbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEgLyogYWN0aXZhdGluZyAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBhY3RpdmF0ZWQgKi86XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgYWxyZWFkeSBhY3RpdmF0ZWQsIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAzMiAvKiBkaXNwb3NlZCAqLzpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfSB0cnlpbmcgdG8gYWN0aXZhdGUgYSBjb250cm9sbGVyIHRoYXQgaXMgZGlzcG9zZWQuYCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9IHVuZXhwZWN0ZWQgc3RhdGU6ICR7c3RyaW5naWZ5U3RhdGUodGhpcy5zdGF0ZSl9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZyAmJiAhdGhpcy5mdWxseU5hbWVkKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGx5TmFtZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSB0aGlzLmNvbnRleHQuZ2V0KElMb2dnZXIpLnJvb3Quc2NvcGVUbyh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGFjdGl2YXRlKClgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvc3RTY29wZSA9IGhvc3RTY29wZSA/PyBudWxsO1xuICAgICAgICBmbGFncyB8PSAzMiAvKiBmcm9tQmluZCAqLztcbiAgICAgICAgc3dpdGNoICh0aGlzLnZtS2luZCkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIGN1c3RvbUVsZW1lbnQgKi86XG4gICAgICAgICAgICAgICAgLy8gQ3VzdG9tIGVsZW1lbnQgc2NvcGUgaXMgY3JlYXRlZCBhbmQgYXNzaWduZWQgZHVyaW5nIGh5ZHJhdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUucGFyZW50U2NvcGUgPSBzY29wZSA/PyBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIGN1c3RvbUF0dHJpYnV0ZSAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGUgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBzeW50aGV0aWMgKi86XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDAgfHwgc2NvcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY29wZSBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzTG9ja2VkU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1N0cmljdEJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDQgLyogaXNTdHJpY3RCaW5kaW5nU3RyYXRlZ3kgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaW5pdGlhdG9yID0gaW5pdGlhdG9yO1xuICAgICAgICB0aGlzLiRmbGFncyA9IGZsYWdzO1xuICAgICAgICAvLyBvcHBvc2luZyBsZWF2ZSBpcyBjYWxsZWQgaW4gYXR0YWNoKCkgKHdoaWNoIHdpbGwgdHJpZ2dlciBhdHRhY2hlZCgpKVxuICAgICAgICB0aGlzLmVudGVyQWN0aXZhdGluZygpO1xuICAgICAgICBpZiAodGhpcy5ob29rcy5oYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBiaW5kaW5nKClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMudmlld01vZGVsLmJpbmRpbmcodGhpcy4kaW5pdGlhdG9yLCB0aGlzLnBhcmVudCwgdGhpcy4kZmxhZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVByb21pc2UoKTtcbiAgICAgICAgICAgICAgICByZXQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRwcm9taXNlO1xuICAgIH1cbiAgICBiaW5kKCkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGJpbmQoKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmluZGluZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2ldLiRiaW5kKHRoaXMuJGZsYWdzLCB0aGlzLnNjb3BlLCB0aGlzLmhvc3RTY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9va3MuaGFzQm91bmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGJvdW5kKClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMudmlld01vZGVsLmJvdW5kKHRoaXMuJGluaXRpYXRvciwgdGhpcy5wYXJlbnQsIHRoaXMuJGZsYWdzKTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaCgpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0YWNoKCk7XG4gICAgfVxuICAgIGFwcGVuZCguLi5ub2Rlcykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW91bnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBob3N0ICovOlxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdC5hcHBlbmQoLi4ubm9kZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIHNoYWRvd1Jvb3QgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZCguLi5ub2Rlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogbG9jYXRpb24gKi86XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVzW2ldLCB0aGlzLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGF0dGFjaCgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9zdENvbnRyb2xsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tb3VudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBob3N0ICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBzaGFkb3dSb290ICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3RDb250cm9sbGVyLmFwcGVuZCh0aGlzLmhvc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogbG9jYXRpb24gKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdENvbnRyb2xsZXIuYXBwZW5kKHRoaXMubG9jYXRpb24uJHN0YXJ0LCB0aGlzLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vdW50VGFyZ2V0KSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogaG9zdCAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmFwcGVuZFRvKHRoaXMuaG9zdCwgdGhpcy5kZWZpbml0aW9uPy5lbmhhbmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBzaGFkb3dSb290ICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5jb250ZXh0LmhhcyhJU2hhZG93RE9NU3R5bGVzLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmNvbnRleHQuZ2V0KElTaGFkb3dET01TdHlsZXMpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5jb250ZXh0LmdldChJU2hhZG93RE9NR2xvYmFsU3R5bGVzKTtcbiAgICAgICAgICAgICAgICBzdHlsZXMuYXBwbHlUbyh0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuYXBwZW5kVG8odGhpcy5zaGFkb3dSb290KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMyAvKiBsb2NhdGlvbiAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmluc2VydEJlZm9yZSh0aGlzLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ob29rcy5oYXNBdHRhY2hpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGF0dGFjaGluZygpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLnZpZXdNb2RlbC5hdHRhY2hpbmcodGhpcy4kaW5pdGlhdG9yLCB0aGlzLnBhcmVudCwgdGhpcy4kZmxhZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVByb21pc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyQWN0aXZhdGluZygpO1xuICAgICAgICAgICAgICAgIHJldC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWF2ZUFjdGl2YXRpbmcoKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaGluZygpIGFuZCBjaGlsZCBhY3RpdmF0aW9uIHJ1biBpbiBwYXJhbGxlbCwgYW5kIGF0dGFjaGVkKCkgaXMgY2FsbGVkIHdoZW4gYm90aCBhcmUgZmluaXNoZWRcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIEFueSBwcm9taXNlcyByZXR1cm5lZCBmcm9tIGNoaWxkIGFjdGl2YXRpb24gYXJlIGN1bXVsYXRpdmVseSBhd2FpdGVkIGJlZm9yZSB0aGlzLiRwcm9taXNlIHJlc29sdmVzXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmNoaWxkcmVuW2ldLmFjdGl2YXRlKHRoaXMuJGluaXRpYXRvciwgdGhpcywgdGhpcy4kZmxhZ3MsIHRoaXMuc2NvcGUsIHRoaXMuaG9zdFNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2hlZCgpIGlzIGludm9rZWQgYnkgQ29udHJvbGxlciNsZWF2ZUFjdGl2YXRpbmcgd2hlbiBgYWN0aXZhdGluZ1N0YWNrYCByZWFjaGVzIDBcbiAgICAgICAgdGhpcy5sZWF2ZUFjdGl2YXRpbmcoKTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZShpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgc3dpdGNoICgodGhpcy5zdGF0ZSAmIH4xNiAvKiByZWxlYXNlZCAqLykpIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBhY3RpdmF0ZWQgKi86XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgZnVsbHkgYWN0aXZhdGVkLCBzbyBwcm9jZWVkIHdpdGggbm9ybWFsIGRlYWN0aXZhdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gNCAvKiBkZWFjdGl2YXRpbmcgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDAgLyogbm9uZSAqLzpcbiAgICAgICAgICAgIGNhc2UgOCAvKiBkZWFjdGl2YXRlZCAqLzpcbiAgICAgICAgICAgIGNhc2UgMzIgLyogZGlzcG9zZWQgKi86XG4gICAgICAgICAgICBjYXNlIDggLyogZGVhY3RpdmF0ZWQgKi8gfCAzMiAvKiBkaXNwb3NlZCAqLzpcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGRlYWN0aXZhdGVkIChvciBldmVuIGRpc3Bvc2VkKSwgb3IgbmV2ZXIgYWN0aXZhdGVkIGluIHRoZSBmaXJzdCBwbGFjZSwgbm8gbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9IHVuZXhwZWN0ZWQgc3RhdGU6ICR7c3RyaW5naWZ5U3RhdGUodGhpcy5zdGF0ZSl9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgZGVhY3RpdmF0ZSgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaW5pdGlhdG9yID0gaW5pdGlhdG9yO1xuICAgICAgICB0aGlzLiRmbGFncyA9IGZsYWdzO1xuICAgICAgICBpZiAoaW5pdGlhdG9yID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmVudGVyRGV0YWNoaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIENoaWxkIHByb21pc2UgcmVzdWx0cyBhcmUgdHJhY2tlZCBieSBlbnRlci9sZWF2ZSBjb21ibydzXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmNoaWxkcmVuW2ldLmRlYWN0aXZhdGUoaW5pdGlhdG9yLCB0aGlzLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9va3MuaGFzRGV0YWNoaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGBkZXRhY2hpbmcoKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy52aWV3TW9kZWwuZGV0YWNoaW5nKHRoaXMuJGluaXRpYXRvciwgdGhpcy5wYXJlbnQsIHRoaXMuJGZsYWdzKTtcbiAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgaW5pdGlhdG9yLmVudGVyRGV0YWNoaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWF0b3IubGVhdmVEZXRhY2hpbmcoKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWF0b3IucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogaWYgYSAzcmQgcGFydHkgcGx1Z2luIGhhcHBlbnMgdG8gZG8gYW55IGFzeW5jIHN0dWZmIGluIGEgdGVtcGxhdGUgY29udHJvbGxlciBiZWZvcmUgY2FsbGluZyBkZWFjdGl2YXRlIG9uIGl0cyB2aWV3LFxuICAgICAgICAvLyB0aGVuIHRoZSBsaW5raW5nIHdpbGwgYmVjb21lIG91dCBvZiBvcmRlci5cbiAgICAgICAgLy8gRm9yIGZyYW1ld29yayBjb21wb25lbnRzLCB0aGlzIHNob3VsZG4ndCBjYXVzZSBpc3N1ZXMuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IHByZXZlbnQgdGhhdCBieSBsaW5raW5nIHVwIGFmdGVyIGF3YWl0aW5nIHRoZSBkZXRhY2hpbmcgcHJvbWlzZSwgd2hpY2ggd291bGQgYWRkIGFuIGV4dHJhIHRpY2sgKyBhIGZhaXIgYml0IG9mXG4gICAgICAgIC8vIG92ZXJoZWFkIG9uIHRoaXMgaG90IHBhdGgsIHNvIGl0J3MgKGZvciBub3cpIGEgZGVsaWJlcmF0ZSBjaG9pY2UgdG8gbm90IGFjY291bnQgZm9yIHN1Y2ggc2l0dWF0aW9uLlxuICAgICAgICAvLyBKdXN0IGxlYXZpbmcgdGhlIG5vdGUgaGVyZSBzbyB0aGF0IHdlIGtub3cgdG8gbG9vayBoZXJlIGlmIGEgd2VpcmQgZGV0YWNoaW5nLXJlbGF0ZWQgdGltaW5nIGlzc3VlIGlzIGV2ZXIgcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpbml0aWF0b3IuaGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaW5pdGlhdG9yLmhlYWQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhdG9yLnRhaWwubmV4dCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhdG9yLnRhaWwgPSB0aGlzO1xuICAgICAgICBpZiAoaW5pdGlhdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRldGFjaGluZyBpcyBjYWxsZWQgKyB0aGUgbGlua2VkIGxpc3QgaXMgYnVpbHQgd2hlbiBhbnkgY29udHJvbGxlciB0aGF0IGlzIG5vdCB0aGUgaW5pdGlhdG9yLCBpcyBkZWFjdGl2YXRlZC5cbiAgICAgICAgICAgIC8vIFRoZSByZXN0IGlzIGhhbmRsZWQgYnkgdGhlIGluaXRpYXRvci5cbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBkZXNjZW5kYW50IGNvbnRyb2xsZXJzIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGF3YWl0IHRoZSBpbml0aWF0b3IncyBwcm9taXNlIGJlZm9yZSBkb2luZyBhbnkgc3Vic2VxdWVudFxuICAgICAgICAgICAgLy8gY29udHJvbGxlciBhcGkgY2FsbHMsIG9yIHJhY2UgY29uZGl0aW9ucyBtaWdodCBvY2N1ci5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlYXZlRGV0YWNoaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRwcm9taXNlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlcygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZtS2luZCkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIGN1c3RvbUVsZW1lbnQgKi86XG4gICAgICAgICAgICBjYXNlIDIgLyogc3ludGhldGljICovOlxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ob3N0Q29udHJvbGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vdW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIGhvc3QgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIHNoYWRvd1Jvb3QgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIGxvY2F0aW9uICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uLiRzdGFydC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5iaW5kKCkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYHVuYmluZCgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSB0aGlzLiRmbGFncyB8IDY0IC8qIGZyb21VbmJpbmQgKi87XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmluZGluZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2ldLiR1bmJpbmQoZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZtS2luZCkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIGN1c3RvbUF0dHJpYnV0ZSAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBzeW50aGV0aWMgKi86XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0xvY2tlZFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuc3RhdGUgJiAxNiAvKiByZWxlYXNlZCAqLykgPT09IDE2IC8qIHJlbGVhc2VkICovICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLnZpZXdGYWN0b3J5LnRyeVJldHVyblRvQ2FjaGUodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwIC8qIGN1c3RvbUVsZW1lbnQgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZS5wYXJlbnRTY29wZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmbGFncyAmIDUxMiAvKiBkaXNwb3NlICovKSA9PT0gNTEyIC8qIGRpc3Bvc2UgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAodGhpcy5zdGF0ZSAmIDMyIC8qIGRpc3Bvc2VkICovKSB8IDggLyogZGVhY3RpdmF0ZWQgKi87XG4gICAgICAgIHRoaXMuJGluaXRpYXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBlbnN1cmVQcm9taXNlKCkge1xuICAgICAgICBpZiAodGhpcy4kcHJvbWlzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLiRwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGluaXRpYXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmVuc3VyZVByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlKCkge1xuICAgICAgICBpZiAodGhpcy4kcHJvbWlzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy4kcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMuJHJlc29sdmUgPSB0aGlzLiRyZWplY3QgPSB0aGlzLiRwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlamVjdChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuJHByb21pc2UgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gdGhpcy4kcmVqZWN0O1xuICAgICAgICAgICAgdGhpcy4kcmVzb2x2ZSA9IHRoaXMuJHJlamVjdCA9IHRoaXMuJHByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kaW5pdGlhdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnRlckFjdGl2YXRpbmcoKSB7XG4gICAgICAgICsrdGhpcy5hY3RpdmF0aW5nU3RhY2s7XG4gICAgICAgIGlmICh0aGlzLiRpbml0aWF0b3IgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmVudGVyQWN0aXZhdGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxlYXZlQWN0aXZhdGluZygpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5hY3RpdmF0aW5nU3RhY2sgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYGF0dGFjaGVkKClgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy52aWV3TW9kZWwuYXR0YWNoZWQodGhpcy4kaW5pdGlhdG9yLCB0aGlzLiRmbGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIGFjdGl2YXRlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhpcy4kcHJvbWlzZSwgc2lnbmFsaW5nIHRoYXQgYWN0aXZhdGlvbiBpcyBkb25lIChwYXRoIDEgb2YgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJGluaXRpYXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlQWN0aXZhdGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMiAvKiBhY3RpdmF0ZWQgKi87XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHRoaXMuJHByb21pc2UgKGlmIHByZXNlbnQpLCBzaWduYWxpbmcgdGhhdCBhY3RpdmF0aW9uIGlzIGRvbmUgKHBhdGggMiBvZiAyKVxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGluaXRpYXRvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVhdmVBY3RpdmF0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW50ZXJEZXRhY2hpbmcoKSB7XG4gICAgICAgICsrdGhpcy5kZXRhY2hpbmdTdGFjaztcbiAgICB9XG4gICAgbGVhdmVEZXRhY2hpbmcoKSB7XG4gICAgICAgIGlmICgtLXRoaXMuZGV0YWNoaW5nU3RhY2sgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgY29udHJvbGxlciBpcyB0aGUgaW5pdGlhdG9yIChkZXRhY2ggaXMgb25seSBldmVyIGNhbGxlZCBvbiB0aGUgaW5pdGlhdG9yKVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgZGV0YWNoKClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW50ZXJVbmJpbmRpbmcoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZXMoKTtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLiRpbml0aWF0b3IuaGVhZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5sb2dnZXIudHJhY2UoYGRldGFjaCgpYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyLnJlbW92ZU5vZGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXIuaG9va3MuaGFzVW5iaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5sb2dnZXIudHJhY2UoJ3VuYmluZGluZygpJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gY3VyLnZpZXdNb2RlbC51bmJpbmRpbmcoY3VyLiRpbml0aWF0b3IsIGN1ci5wYXJlbnQsIGN1ci4kZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVudGVyVW5iaW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWF2ZVVuYmluZGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlYXZlVW5iaW5kaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW50ZXJVbmJpbmRpbmcoKSB7XG4gICAgICAgICsrdGhpcy51bmJpbmRpbmdTdGFjaztcbiAgICB9XG4gICAgbGVhdmVVbmJpbmRpbmcoKSB7XG4gICAgICAgIGlmICgtLXRoaXMudW5iaW5kaW5nU3RhY2sgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoYHVuYmluZCgpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy4kaW5pdGlhdG9yLmhlYWQ7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoY3VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBjdXIudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBjdXIubmV4dDtcbiAgICAgICAgICAgICAgICBjdXIubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJpbmRpbmcoYmluZGluZykge1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5ncyA9IFtiaW5kaW5nXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdGhpcy5iaW5kaW5ncy5sZW5ndGhdID0gYmluZGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRDb250cm9sbGVyKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbY29udHJvbGxlcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoXSA9IGNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXMobmFtZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudm1LaW5kKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogY3VzdG9tQXR0cmlidXRlICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmID0gQ3VzdG9tQXR0cmlidXRlLmdldERlZmluaXRpb24odGhpcy52aWV3TW9kZWwuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMCAvKiBjdXN0b21FbGVtZW50ICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmID0gQ3VzdG9tRWxlbWVudC5nZXREZWZpbml0aW9uKHRoaXMudmlld01vZGVsLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLm5hbWUgPT09IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDIgLyogc3ludGhldGljICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdGYWN0b3J5Lm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9ja1Njb3BlKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5oYXNMb2NrZWRTY29wZSA9IHRydWU7XG4gICAgfVxuICAgIHNldEhvc3QoaG9zdCkge1xuICAgICAgICBpZiAodGhpcy52bUtpbmQgPT09IDAgLyogY3VzdG9tRWxlbWVudCAqLykge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUVsZW1lbnQubmFtZSwgdGhpcywgaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5tb3VudFRhcmdldCA9IDEgLyogaG9zdCAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFNoYWRvd1Jvb3Qoc2hhZG93Um9vdCkge1xuICAgICAgICBpZiAodGhpcy52bUtpbmQgPT09IDAgLyogY3VzdG9tRWxlbWVudCAqLykge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEN1c3RvbUVsZW1lbnQubmFtZSwgdGhpcywgc2hhZG93Um9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFkb3dSb290ID0gc2hhZG93Um9vdDtcbiAgICAgICAgdGhpcy5tb3VudFRhcmdldCA9IDIgLyogc2hhZG93Um9vdCAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnZtS2luZCA9PT0gMCAvKiBjdXN0b21FbGVtZW50ICovKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQ3VzdG9tRWxlbWVudC5uYW1lLCB0aGlzLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLm1vdW50VGFyZ2V0ID0gMyAvKiBsb2NhdGlvbiAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgfD0gMTYgLyogcmVsZWFzZWQgKi87XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShgZGlzcG9zZSgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLnN0YXRlICYgMzIgLyogZGlzcG9zZWQgKi8pID09PSAzMiAvKiBkaXNwb3NlZCAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgfD0gMzIgLyogZGlzcG9zZWQgKi87XG4gICAgICAgIGlmICh0aGlzLmhvb2tzLmhhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNhbGxEaXNwb3NlKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG9zdENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXdGYWN0b3J5ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMudmlld01vZGVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyTG9va3VwLmRlbGV0ZSh0aGlzLnZpZXdNb2RlbCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICBpZiAodmlzaXRvcih0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9va3MuaGFzQWNjZXB0ICYmIHRoaXMudmlld01vZGVsLmFjY2VwdCh2aXNpdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmFjY2VwdCh2aXNpdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VGFyZ2V0QWNjZXNzb3IocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgYmluZGluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGlmIChiaW5kaW5ncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzLmZpbmQoYiA9PiBiLnRhcmdldFByb3BlcnR5ID09PSBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgaWYgKGJpbmRpbmcgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kaW5nLnRhcmdldE9ic2VydmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TG9va3VwKGluc3RhbmNlKSB7XG4gICAgbGV0IGxvb2t1cCA9IGluc3RhbmNlLiRvYnNlcnZlcnM7XG4gICAgaWYgKGxvb2t1cCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsICckb2JzZXJ2ZXJzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogbG9va3VwID0ge30sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbG9va3VwO1xufVxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXJzKGNvbnRyb2xsZXIsIGRlZmluaXRpb24sIFxuLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbl9mbGFncywgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBiaW5kYWJsZXMgPSBkZWZpbml0aW9uLmJpbmRhYmxlcztcbiAgICBjb25zdCBvYnNlcnZhYmxlTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiaW5kYWJsZXMpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG9ic2VydmFibGVOYW1lcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGxldCBiaW5kYWJsZTtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJzID0gZ2V0TG9va3VwKGluc3RhbmNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmFtZSA9IG9ic2VydmFibGVOYW1lc1tpXTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlcnNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGJpbmRhYmxlID0gYmluZGFibGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyc1tuYW1lXSA9IG5ldyBCaW5kYWJsZU9ic2VydmVyKGluc3RhbmNlLCBuYW1lLCBiaW5kYWJsZS5jYWxsYmFjaywgYmluZGFibGUuc2V0LCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuT2JzZXJ2ZXJzKGNvbnRyb2xsZXIsIGRlZmluaXRpb24sIFxuLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbl9mbGFncywgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBjaGlsZHJlbk9ic2VydmVycyA9IGRlZmluaXRpb24uY2hpbGRyZW5PYnNlcnZlcnM7XG4gICAgY29uc3QgY2hpbGRPYnNlcnZlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hpbGRyZW5PYnNlcnZlcnMpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkT2JzZXJ2ZXJOYW1lcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJzID0gZ2V0TG9va3VwKGluc3RhbmNlKTtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjaGlsZE9ic2VydmVyTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJzW25hbWVdID09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuRGVzY3JpcHRpb24gPSBjaGlsZHJlbk9ic2VydmVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnNbbmFtZV0gPSBuZXcgQ2hpbGRyZW5PYnNlcnZlcihjb250cm9sbGVyLCBpbnN0YW5jZSwgbmFtZSwgY2hpbGRyZW5EZXNjcmlwdGlvbi5jYWxsYmFjaywgY2hpbGRyZW5EZXNjcmlwdGlvbi5xdWVyeSwgY2hpbGRyZW5EZXNjcmlwdGlvbi5maWx0ZXIsIGNoaWxkcmVuRGVzY3JpcHRpb24ubWFwLCBjaGlsZHJlbkRlc2NyaXB0aW9uLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgQWNjZXNzU2NvcGVBc3QgPSB7XG4gICAgbWFwOiBuZXcgTWFwKCksXG4gICAgZm9yKGtleSkge1xuICAgICAgICBsZXQgYXN0ID0gQWNjZXNzU2NvcGVBc3QubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoYXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFzdCA9IG5ldyBBY2Nlc3NTY29wZUV4cHJlc3Npb24oa2V5LCAwKTtcbiAgICAgICAgICAgIEFjY2Vzc1Njb3BlQXN0Lm1hcC5zZXQoa2V5LCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVycyhjb250cm9sbGVyLCBjb250ZXh0LCBkZWZpbml0aW9uLCBpbnN0YW5jZSkge1xuICAgIGNvbnN0IG9ic2VydmVyTG9jYXRvciA9IGNvbnRleHQuZ2V0KElPYnNlcnZlckxvY2F0b3IpO1xuICAgIGNvbnN0IGV4cHJlc3Npb25QYXJzZXIgPSBjb250ZXh0LmdldChJRXhwcmVzc2lvblBhcnNlcik7XG4gICAgY29uc3Qgd2F0Y2hlcyA9IGRlZmluaXRpb24ud2F0Y2hlcztcbiAgICBsZXQgZXhwcmVzc2lvbjtcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gd2F0Y2hlcy5sZW5ndGg7IGlpID4gaTsgKytpKSB7XG4gICAgICAgICh7IGV4cHJlc3Npb24sIGNhbGxiYWNrIH0gPSB3YXRjaGVzW2ldKTtcbiAgICAgICAgY2FsbGJhY2sgPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2FsbGJhY2tcbiAgICAgICAgICAgIDogUmVmbGVjdC5nZXQoaW5zdGFuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNhbGxiYWNrIGZvciBAd2F0Y2ggZGVjb3JhdG9yOiAke1N0cmluZyhjYWxsYmFjayl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcobmV3IENvbXB1dGVkV2F0Y2hlcihpbnN0YW5jZSwgb2JzZXJ2ZXJMb2NhdG9yLCBleHByZXNzaW9uLCBjYWxsYmFjaywgXG4gICAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBmbGFnIHRvIHB1cnBvc2VseSBkaXNhYmxlIHByb3h5XG4gICAgICAgICAgICAvLyBBT1Q6IG5vdCB0cnVlIGZvciBJRTExXG4gICAgICAgICAgICB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhc3QgPSB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGV4cHJlc3Npb25QYXJzZXIucGFyc2UoZXhwcmVzc2lvbiwgNTMgLyogQmluZENvbW1hbmQgKi8pXG4gICAgICAgICAgICAgICAgOiBBY2Nlc3NTY29wZUFzdC5mb3IoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFkZEJpbmRpbmcobmV3IEV4cHJlc3Npb25XYXRjaGVyKGNvbnRyb2xsZXIuc2NvcGUsIGNvbnRleHQsIG9ic2VydmVyTG9jYXRvciwgYXN0LCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudENvbnRyb2xsZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDb250cm9sbGVyICYmIHZhbHVlLnZtS2luZCA9PT0gMCAvKiBjdXN0b21FbGVtZW50ICovO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudFZpZXdNb2RlbCh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgQ3VzdG9tRWxlbWVudC5pc1R5cGUodmFsdWUuY29uc3RydWN0b3IpO1xufVxuZXhwb3J0IGNsYXNzIEhvb2tzRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuaGFzRGVmaW5lID0gJ2RlZmluZScgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc0h5ZHJhdGluZyA9ICdoeWRyYXRpbmcnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNIeWRyYXRlZCA9ICdoeWRyYXRlZCcgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc0NyZWF0ZWQgPSAnY3JlYXRlZCcgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmcgPSAnYmluZGluZycgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc0JvdW5kID0gJ2JvdW5kJyBpbiB0YXJnZXQ7XG4gICAgICAgIHRoaXMuaGFzQXR0YWNoaW5nID0gJ2F0dGFjaGluZycgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc0F0dGFjaGVkID0gJ2F0dGFjaGVkJyBpbiB0YXJnZXQ7XG4gICAgICAgIHRoaXMuaGFzRGV0YWNoaW5nID0gJ2RldGFjaGluZycgaW4gdGFyZ2V0O1xuICAgICAgICB0aGlzLmhhc1VuYmluZGluZyA9ICd1bmJpbmRpbmcnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNEaXNwb3NlID0gJ2Rpc3Bvc2UnIGluIHRhcmdldDtcbiAgICAgICAgdGhpcy5oYXNBY2NlcHQgPSAnYWNjZXB0JyBpbiB0YXJnZXQ7XG4gICAgfVxufVxuSG9va3NEZWZpbml0aW9uLm5vbmUgPSBuZXcgSG9va3NEZWZpbml0aW9uKHt9KTtcbmNvbnN0IGRlZmF1bHRTaGFkb3dPcHRpb25zID0ge1xuICAgIG1vZGU6ICdvcGVuJ1xufTtcbmV4cG9ydCB2YXIgVmlld01vZGVsS2luZDtcbihmdW5jdGlvbiAoVmlld01vZGVsS2luZCkge1xuICAgIFZpZXdNb2RlbEtpbmRbVmlld01vZGVsS2luZFtcImN1c3RvbUVsZW1lbnRcIl0gPSAwXSA9IFwiY3VzdG9tRWxlbWVudFwiO1xuICAgIFZpZXdNb2RlbEtpbmRbVmlld01vZGVsS2luZFtcImN1c3RvbUF0dHJpYnV0ZVwiXSA9IDFdID0gXCJjdXN0b21BdHRyaWJ1dGVcIjtcbiAgICBWaWV3TW9kZWxLaW5kW1ZpZXdNb2RlbEtpbmRbXCJzeW50aGV0aWNcIl0gPSAyXSA9IFwic3ludGhldGljXCI7XG59KShWaWV3TW9kZWxLaW5kIHx8IChWaWV3TW9kZWxLaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgU3RhdGU7XG4oZnVuY3Rpb24gKFN0YXRlKSB7XG4gICAgU3RhdGVbU3RhdGVbXCJub25lXCJdID0gMF0gPSBcIm5vbmVcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcImFjdGl2YXRpbmdcIl0gPSAxXSA9IFwiYWN0aXZhdGluZ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiYWN0aXZhdGVkXCJdID0gMl0gPSBcImFjdGl2YXRlZFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiZGVhY3RpdmF0aW5nXCJdID0gNF0gPSBcImRlYWN0aXZhdGluZ1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiZGVhY3RpdmF0ZWRcIl0gPSA4XSA9IFwiZGVhY3RpdmF0ZWRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcInJlbGVhc2VkXCJdID0gMTZdID0gXCJyZWxlYXNlZFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiZGlzcG9zZWRcIl0gPSAzMl0gPSBcImRpc3Bvc2VkXCI7XG59KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeVN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICBpZiAoKHN0YXRlICYgMSAvKiBhY3RpdmF0aW5nICovKSA9PT0gMSAvKiBhY3RpdmF0aW5nICovKSB7XG4gICAgICAgIG5hbWVzLnB1c2goJ2FjdGl2YXRpbmcnKTtcbiAgICB9XG4gICAgaWYgKChzdGF0ZSAmIDIgLyogYWN0aXZhdGVkICovKSA9PT0gMiAvKiBhY3RpdmF0ZWQgKi8pIHtcbiAgICAgICAgbmFtZXMucHVzaCgnYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIGlmICgoc3RhdGUgJiA0IC8qIGRlYWN0aXZhdGluZyAqLykgPT09IDQgLyogZGVhY3RpdmF0aW5nICovKSB7XG4gICAgICAgIG5hbWVzLnB1c2goJ2RlYWN0aXZhdGluZycpO1xuICAgIH1cbiAgICBpZiAoKHN0YXRlICYgOCAvKiBkZWFjdGl2YXRlZCAqLykgPT09IDggLyogZGVhY3RpdmF0ZWQgKi8pIHtcbiAgICAgICAgbmFtZXMucHVzaCgnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gICAgaWYgKChzdGF0ZSAmIDE2IC8qIHJlbGVhc2VkICovKSA9PT0gMTYgLyogcmVsZWFzZWQgKi8pIHtcbiAgICAgICAgbmFtZXMucHVzaCgncmVsZWFzZWQnKTtcbiAgICB9XG4gICAgaWYgKChzdGF0ZSAmIDMyIC8qIGRpc3Bvc2VkICovKSA9PT0gMzIgLyogZGlzcG9zZWQgKi8pIHtcbiAgICAgICAgbmFtZXMucHVzaCgnZGlzcG9zZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IG5hbWVzLmpvaW4oJ3wnKTtcbn1cbmV4cG9ydCBjb25zdCBJQ29udHJvbGxlciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSUNvbnRyb2xsZXInKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyb2xsZXIuanMubWFwIiwiaW1wb3J0IHsgSW5zdGFuY2VQcm92aWRlciwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgRnJhZ21lbnROb2RlU2VxdWVuY2UsIElOb2RlLCBJUmVuZGVyTG9jYXRpb24gfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHsgSVJlbmRlcmVyLCBJVGVtcGxhdGVDb21waWxlciwgSUluc3RydWN0aW9uIH0gZnJvbSAnLi4vcmVuZGVyZXIuanMnO1xuaW1wb3J0IHsgQ3VzdG9tRWxlbWVudERlZmluaXRpb24gfSBmcm9tICcuLi9yZXNvdXJjZXMvY3VzdG9tLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgSVZpZXdGYWN0b3J5LCBWaWV3RmFjdG9yeSB9IGZyb20gJy4vdmlldy5qcyc7XG5pbXBvcnQgeyBJUHJvamVjdGlvblByb3ZpZGVyIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2N1c3RvbS1lbGVtZW50cy9hdS1zbG90LmpzJztcbmltcG9ydCB7IElQbGF0Zm9ybSB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCB7IElDb250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyLmpzJztcbmNvbnN0IGRlZmluaXRpb25Db250YWluZXJMb29rdXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgZGVmaW5pdGlvbkNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGZyYWdtZW50Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVuZGVyQ29udGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlbmRlckNvbnRleHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVuZGVyQ29udGV4dChwYXJ0aWFsRGVmaW5pdGlvbiwgcGFyZW50Q29udGFpbmVyLCBwcm9qZWN0aW9ucykge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBDdXN0b21FbGVtZW50RGVmaW5pdGlvbi5nZXRPckNyZWF0ZShwYXJ0aWFsRGVmaW5pdGlvbik7XG4gICAgLy8gaW5qZWN0YWJsZSBjb21wbGV0ZWx5IHByZXZlbnRzIGNhY2hpbmcsIGVuc3VyaW5nIHRoYXQgZWFjaCBpbnN0YW5jZSBnZXRzIGEgbmV3IGNvbnRleHQgY29udGV4dFxuICAgIGlmIChkZWZpbml0aW9uLmluamVjdGFibGUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJDb250ZXh0KGRlZmluaXRpb24sIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuICAgIGlmIChwcm9qZWN0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIGxldCBjb250YWluZXJMb29rdXAgPSBkZWZpbml0aW9uQ29udGFpbmVyTG9va3VwLmdldChkZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lckxvb2t1cCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uQ29udGFpbmVyTG9va3VwLnNldChkZWZpbml0aW9uLCBjb250YWluZXJMb29rdXAgPSBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGV4dCA9IGNvbnRhaW5lckxvb2t1cC5nZXQocGFyZW50Q29udGFpbmVyKTtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udGFpbmVyTG9va3VwLnNldChwYXJlbnRDb250YWluZXIsIGNvbnRleHQgPSBuZXcgUmVuZGVyQ29udGV4dChkZWZpbml0aW9uLCBwYXJlbnRDb250YWluZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgbGV0IGNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwID0gZGVmaW5pdGlvbkNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwLmdldChkZWZpbml0aW9uKTtcbiAgICBpZiAoY29udGFpbmVyUHJvamVjdGlvbnNMb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWZpbml0aW9uQ29udGFpbmVyUHJvamVjdGlvbnNMb29rdXAuc2V0KGRlZmluaXRpb24sIGNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgfVxuICAgIGxldCBwcm9qZWN0aW9uc0xvb2t1cCA9IGNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwLmdldChwYXJlbnRDb250YWluZXIpO1xuICAgIGlmIChwcm9qZWN0aW9uc0xvb2t1cCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRhaW5lclByb2plY3Rpb25zTG9va3VwLnNldChwYXJlbnRDb250YWluZXIsIHByb2plY3Rpb25zTG9va3VwID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgfVxuICAgIGxldCBjb250ZXh0ID0gcHJvamVjdGlvbnNMb29rdXAuZ2V0KHByb2plY3Rpb25zKTtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb2plY3Rpb25zTG9va3VwLnNldChwcm9qZWN0aW9ucywgY29udGV4dCA9IG5ldyBSZW5kZXJDb250ZXh0KGRlZmluaXRpb24sIHBhcmVudENvbnRhaW5lcikpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmNvbnN0IGVtcHR5Tm9kZUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBSZW5kZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihkZWZpbml0aW9uLCBwYXJlbnRDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnRDb250YWluZXIgPSBwYXJlbnRDb250YWluZXI7XG4gICAgICAgIHRoaXMudmlld01vZGVsUHJvdmlkZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuaXNDb21waWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuY29tcGlsZWREZWZpbml0aW9uID0gKHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyID0gcGFyZW50Q29udGFpbmVyLmNyZWF0ZUNoaWxkKCk7XG4gICAgICAgIC8vIFRPRE8oZmtsZXV2ZXIpOiBnZXQgY29udGV4dHVhbCArIHJvb3QgcmVuZGVyZXJzXG4gICAgICAgIGNvbnN0IHJlbmRlcmVycyA9IGNvbnRhaW5lci5nZXRBbGwoSVJlbmRlcmVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gcmVuZGVyZXJzW2ldO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlcnNbcmVuZGVyZXIuaW5zdHJ1Y3Rpb25UeXBlXSA9IHJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvamVjdGlvblByb3ZpZGVyID0gY29udGFpbmVyLmdldChJUHJvamVjdGlvblByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGxhdGZvcm0gPSBjb250YWluZXIuZ2V0KElQbGF0Zm9ybSk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKElWaWV3RmFjdG9yeSwgdGhpcy5mYWN0b3J5UHJvdmlkZXIgPSBuZXcgVmlld0ZhY3RvcnlQcm92aWRlcigpLCB0cnVlKTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoSUNvbnRyb2xsZXIsIHRoaXMucGFyZW50Q29udHJvbGxlclByb3ZpZGVyID0gbmV3IEluc3RhbmNlUHJvdmlkZXIoJ0lDb250cm9sbGVyJyksIHRydWUpO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihJSW5zdHJ1Y3Rpb24sIHRoaXMuaW5zdHJ1Y3Rpb25Qcm92aWRlciA9IG5ldyBJbnN0YW5jZVByb3ZpZGVyKCdJSW5zdHJ1Y3Rpb24nKSwgdHJ1ZSk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKElSZW5kZXJMb2NhdGlvbiwgdGhpcy5yZW5kZXJMb2NhdGlvblByb3ZpZGVyID0gbmV3IEluc3RhbmNlUHJvdmlkZXIoJ0lSZW5kZXJMb2NhdGlvbicpLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmVsZW1lbnRQcm92aWRlciA9IG5ldyBJbnN0YW5jZVByb3ZpZGVyKCdFbGVtZW50UmVzb2x2ZXInKTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIoSU5vZGUsIGVwKTtcbiAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyUmVzb2x2ZXIocC5Ob2RlLCBlcCk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKHAuRWxlbWVudCwgZXApO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihwLkhUTUxFbGVtZW50LCBlcCk7XG4gICAgICAgIGNvbnRhaW5lci5yZWdpc3RlciguLi5kZWZpbml0aW9uLmRlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIC8vICNyZWdpb24gSVNlcnZpY2VMb2NhdG9yIGFwaVxuICAgIGhhcyhrZXksIHNlYXJjaEFuY2VzdG9ycykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuaGFzKGtleSwgc2VhcmNoQW5jZXN0b3JzKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuZ2V0KGtleSk7XG4gICAgfVxuICAgIGdldEFsbChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmdldEFsbChrZXkpO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBJQ29udGFpbmVyIGFwaVxuICAgIHJlZ2lzdGVyKC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIucmVnaXN0ZXIoLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZXNvbHZlcihrZXksIHJlc29sdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5yZWdpc3RlclJlc29sdmVyKGtleSwgcmVzb2x2ZXIpO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZGVyZWdpc3RlclJlc29sdmVyRm9yPEsgZXh0ZW5kcyBLZXksIFQgPSBLPihrZXk6IEspOiB2b2lkIHtcbiAgICAvLyAgIHRoaXMuY29udGFpbmVyLmRlcmVnaXN0ZXJSZXNvbHZlckZvcihrZXkpO1xuICAgIC8vIH1cbiAgICByZWdpc3RlclRyYW5zZm9ybWVyKGtleSwgdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnJlZ2lzdGVyVHJhbnNmb3JtZXIoa2V5LCB0cmFuc2Zvcm1lcik7XG4gICAgfVxuICAgIGdldFJlc29sdmVyKGtleSwgYXV0b1JlZ2lzdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5nZXRSZXNvbHZlcihrZXksIGF1dG9SZWdpc3Rlcik7XG4gICAgfVxuICAgIGdldEZhY3Rvcnkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5nZXRGYWN0b3J5KGtleSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyRmFjdG9yeShrZXksIGZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVnaXN0ZXJGYWN0b3J5KGtleSwgZmFjdG9yeSk7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuY3JlYXRlQ2hpbGQoKTtcbiAgICB9XG4gICAgZmluZChraW5kLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5maW5kKGtpbmQsIG5hbWUpO1xuICAgIH1cbiAgICBjcmVhdGUoa2luZCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuY3JlYXRlKGtpbmQsIG5hbWUpO1xuICAgIH1cbiAgICBkaXNwb3NlUmVzb2x2ZXJzKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5kaXNwb3NlUmVzb2x2ZXJzKCk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIElSZW5kZXJDb250ZXh0IGFwaVxuICAgIGNvbXBpbGUodGFyZ2V0ZWRQcm9qZWN0aW9ucykge1xuICAgICAgICBsZXQgY29tcGlsZWREZWZpbml0aW9uO1xuICAgICAgICBpZiAodGhpcy5pc0NvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5kZWZpbml0aW9uO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5uZWVkc0NvbXBpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgY29uc3QgY29tcGlsZXIgPSBjb250YWluZXIuZ2V0KElUZW1wbGF0ZUNvbXBpbGVyKTtcbiAgICAgICAgICAgIGNvbXBpbGVkRGVmaW5pdGlvbiA9IHRoaXMuY29tcGlsZWREZWZpbml0aW9uID0gY29tcGlsZXIuY29tcGlsZShkZWZpbml0aW9uLCBjb250YWluZXIsIHRhcmdldGVkUHJvamVjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcGlsZWREZWZpbml0aW9uID0gdGhpcy5jb21waWxlZERlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1cHBvcnQgUmVjdXJzaXZlIENvbXBvbmVudHMgYnkgYWRkaW5nIHNlbGYgdG8gb3duIGNvbnRleHRcbiAgICAgICAgY29tcGlsZWREZWZpbml0aW9uLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICBpZiAoZnJhZ21lbnRDYWNoZS5oYXMoY29tcGlsZWREZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50Q2FjaGUuZ2V0KGNvbXBpbGVkRGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLnBsYXRmb3JtLmRvY3VtZW50O1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBjb21waWxlZERlZmluaXRpb24udGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGUgPT09IG51bGwgfHwgdGhpcy5kZWZpbml0aW9uLmVuaGFuY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgdGhpcy5wbGF0Zm9ybS5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlLm5vZGVOYW1lID09PSAnVEVNUExBVEUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBkb2MuYWRvcHROb2RlKHRlbXBsYXRlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZnJhZ21lbnQgPSBkb2MuYWRvcHROb2RlKGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpKS5hcHBlbmRDaGlsZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHBsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICAgZG9jLmFkb3B0Tm9kZSh0cGwuY29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHBsLmlubmVySFRNTCA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gdHBsLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFnbWVudENhY2hlLnNldChjb21waWxlZERlZmluaXRpb24sIHRoaXMuZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRWaWV3RmFjdG9yeShuYW1lLCBjb250ZW50VHlwZSwgcHJvamVjdGlvblNjb3BlKSB7XG4gICAgICAgIGxldCBmYWN0b3J5ID0gdGhpcy5mYWN0b3J5O1xuICAgICAgICBpZiAoZmFjdG9yeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZGVmaW5pdGlvbi5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFjdG9yeSA9IHRoaXMuZmFjdG9yeSA9IG5ldyBWaWV3RmFjdG9yeShuYW1lLCB0aGlzLCBjb250ZW50VHlwZSwgcHJvamVjdGlvblNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9XG4gICAgYmVnaW5DaGlsZENvbXBvbmVudE9wZXJhdGlvbihpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5kZWZpbml0aW9uO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5pbmplY3RhYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3TW9kZWxQcm92aWRlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVnaXN0ZXJSZXNvbHZlcihkZWZpbml0aW9uLmluamVjdGFibGUsIHRoaXMudmlld01vZGVsUHJvdmlkZXIgPSBuZXcgSW5zdGFuY2VQcm92aWRlcignZGVmaW5pdGlvbi5pbmplY3RhYmxlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWxQcm92aWRlci5wcmVwYXJlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gSUNvbXBpbGVkUmVuZGVyQ29udGV4dCBhcGlcbiAgICBjcmVhdGVOb2RlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGlsZWREZWZpbml0aW9uLmVuaGFuY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnROb2RlU2VxdWVuY2UodGhpcy5wbGF0Zm9ybSwgdGhpcy5jb21waWxlZERlZmluaXRpb24udGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZW1wdHlOb2RlcyA9IGVtcHR5Tm9kZUNhY2hlLmdldCh0aGlzLnBsYXRmb3JtKTtcbiAgICAgICAgICAgIGlmIChlbXB0eU5vZGVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBlbXB0eU5vZGVDYWNoZS5zZXQodGhpcy5wbGF0Zm9ybSwgZW1wdHlOb2RlcyA9IG5ldyBGcmFnbWVudE5vZGVTZXF1ZW5jZSh0aGlzLnBsYXRmb3JtLCB0aGlzLnBsYXRmb3JtLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Tm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudE5vZGVTZXF1ZW5jZSh0aGlzLnBsYXRmb3JtLCB0aGlzLmZyYWdtZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuICAgIC8vIFRPRE86IHNwbGl0IHVwIGludG8gMiBtZXRob2RzPyBnZXRDb21wb25lbnRGYWN0b3J5ICsgZ2V0U3ludGhldGljRmFjdG9yeSBvciBzb21ldGhpbmdcbiAgICBnZXRDb21wb25lbnRGYWN0b3J5KHBhcmVudENvbnRyb2xsZXIsIGhvc3QsIGluc3RydWN0aW9uLCB2aWV3RmFjdG9yeSwgbG9jYXRpb24pIHtcbiAgICAgICAgaWYgKHBhcmVudENvbnRyb2xsZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRDb250cm9sbGVyUHJvdmlkZXIucHJlcGFyZShwYXJlbnRDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggcHJvdmlkZXIgaW5wdXQgdHlwZSwgS2V5IGlzIHByb2JhYmx5IG5vdCBhIGdvb2QgY29uc3RyYWludFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50UHJvdmlkZXIucHJlcGFyZShob3N0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhpcy5pbnN0cnVjdGlvblByb3ZpZGVyLnByZXBhcmUoaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckxvY2F0aW9uUHJvdmlkZXIucHJlcGFyZShsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXdGYWN0b3J5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeVByb3ZpZGVyLnByZXBhcmUodmlld0ZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBJQ29tcG9uZW50RmFjdG9yeSBhcGlcbiAgICBjcmVhdGVDb21wb25lbnQocmVzb3VyY2VLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmdldChyZXNvdXJjZUtleSk7XG4gICAgfVxuICAgIHJlbmRlcihmbGFncywgY29udHJvbGxlciwgdGFyZ2V0cywgZGVmaW5pdGlvbiwgaG9zdCkge1xuICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggIT09IGRlZmluaXRpb24uaW5zdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY29tcGlsZWQgdGVtcGxhdGUgaXMgbm90IGFsaWduZWQgd2l0aCB0aGUgcmVuZGVyIGluc3RydWN0aW9ucy4gVGhlcmUgYXJlICR7dGFyZ2V0cy5sZW5ndGh9IHRhcmdldHMgYW5kICR7ZGVmaW5pdGlvbi5pbnN0cnVjdGlvbnMubGVuZ3RofSBpbnN0cnVjdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKFxuICAgICAgICAgICAgLyogZmxhZ3MgICAgICAgICovIGZsYWdzLCBcbiAgICAgICAgICAgIC8qIGluc3RydWN0aW9ucyAqLyBkZWZpbml0aW9uLmluc3RydWN0aW9uc1tpXSwgXG4gICAgICAgICAgICAvKiBjb250cm9sbGVyICAgKi8gY29udHJvbGxlciwgXG4gICAgICAgICAgICAvKiB0YXJnZXQgICAgICAgKi8gdGFyZ2V0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3QgIT09IHZvaWQgMCAmJiBob3N0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKFxuICAgICAgICAgICAgLyogZmxhZ3MgICAgICAgICovIGZsYWdzLCBcbiAgICAgICAgICAgIC8qIGluc3RydWN0aW9ucyAqLyBkZWZpbml0aW9uLnN1cnJvZ2F0ZXMsIFxuICAgICAgICAgICAgLyogY29udHJvbGxlciAgICovIGNvbnRyb2xsZXIsIFxuICAgICAgICAgICAgLyogdGFyZ2V0ICAgICAgICovIGhvc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGZsYWdzLCBpbnN0cnVjdGlvbnMsIGNvbnRyb2xsZXIsIHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2N1cnJlbnQudHlwZV0ucmVuZGVyKGZsYWdzLCB0aGlzLCBjb250cm9sbGVyLCB0YXJnZXQsIGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFByb3ZpZGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gSVByb2plY3Rpb25Qcm92aWRlciBhcGlcbiAgICByZWdpc3RlclByb2plY3Rpb25zKHByb2plY3Rpb25zLCBzY29wZSkge1xuICAgICAgICB0aGlzLnByb2plY3Rpb25Qcm92aWRlci5yZWdpc3RlclByb2plY3Rpb25zKHByb2plY3Rpb25zLCBzY29wZSk7XG4gICAgfVxuICAgIGdldFByb2plY3Rpb25Gb3IoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvblByb3ZpZGVyLmdldFByb2plY3Rpb25Gb3IoaW5zdHJ1Y3Rpb24pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBWaWV3RmFjdG9yeVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gbnVsbDtcbiAgICB9XG4gICAgcHJlcGFyZShmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgfVxuICAgIGdldCAkaXNSZXNvbHZlcigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZXNvbHZlKF9oYW5kbGVyLCBfcmVxdWVzdG9yKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmZhY3Rvcnk7XG4gICAgICAgIGlmIChmYWN0b3J5ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIFZpZXdGYWN0b3J5IGJlZm9yZSB0aGUgcHJvdmlkZXIgd2FzIHByZXBhcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeS5uYW1lICE9PSAnc3RyaW5nJyB8fCBmYWN0b3J5Lm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIFZpZXdGYWN0b3J5IHdpdGhvdXQgYSAodmFsaWQpIG5hbWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWNvbnRleHQuanMubWFwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG5pbXBvcnQgeyBJQ29udGFpbmVyLCBSZWdpc3RyYXRpb24sIERJLCBub29wIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IEFwcFRhc2sgfSBmcm9tICcuLi9hcHAtdGFzay5qcyc7XG5pbXBvcnQgeyBJTm9kZSB9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQgeyBnZXRDbGFzc2VzVG9BZGQgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi9jbGFzcy1hdHRyaWJ1dGUtYWNjZXNzb3IuanMnO1xuaW1wb3J0IHsgSVBsYXRmb3JtIH0gZnJvbSAnLi4vcGxhdGZvcm0uanMnO1xuaW1wb3J0IHsgQ3VzdG9tQXR0cmlidXRlIH0gZnJvbSAnLi4vcmVzb3VyY2VzL2N1c3RvbS1hdHRyaWJ1dGUuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNzc01vZHVsZXMoLi4ubW9kdWxlcykge1xuICAgIHJldHVybiBuZXcgQ1NTTW9kdWxlc1Byb2Nlc3NvclJlZ2lzdHJ5KG1vZHVsZXMpO1xufVxuZXhwb3J0IGNsYXNzIENTU01vZHVsZXNQcm9jZXNzb3JSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IobW9kdWxlcykge1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xuICAgIH1cbiAgICByZWdpc3Rlcihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjbGFzc0xvb2t1cCA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnRoaXMubW9kdWxlcyk7XG4gICAgICAgIGNvbnN0IENsYXNzQ3VzdG9tQXR0cmlidXRlID0gQ3VzdG9tQXR0cmlidXRlLmRlZmluZSh7XG4gICAgICAgICAgICBuYW1lOiAnY2xhc3MnLFxuICAgICAgICAgICAgYmluZGFibGVzOiBbJ3ZhbHVlJ10sXG4gICAgICAgIH0sIChfYSA9IGNsYXNzIEN1c3RvbUF0dHJpYnV0ZUNsYXNzIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmcoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IGdldENsYXNzZXNUb0FkZCh0aGlzLnZhbHVlKS5tYXAoeCA9PiBjbGFzc0xvb2t1cFt4XSB8fCB4KS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hLmluamVjdCA9IFtJTm9kZV0sXG4gICAgICAgICAgICBfYSkpO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoQ2xhc3NDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGFkb3dDU1MoLi4uY3NzKSB7XG4gICAgcmV0dXJuIG5ldyBTaGFkb3dET01SZWdpc3RyeShjc3MpO1xufVxuZXhwb3J0IGNvbnN0IElTaGFkb3dET01TdHlsZUZhY3RvcnkgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lTaGFkb3dET01TdHlsZUZhY3RvcnknLCB4ID0+IHguY2FjaGVkQ2FsbGJhY2soaGFuZGxlciA9PiB7XG4gICAgaWYgKEFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlcy5zdXBwb3J0ZWQoaGFuZGxlci5nZXQoSVBsYXRmb3JtKSkpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0KEFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlc0ZhY3RvcnkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5nZXQoU3R5bGVFbGVtZW50U3R5bGVzRmFjdG9yeSk7XG59KSk7XG5leHBvcnQgY2xhc3MgU2hhZG93RE9NUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKGNzcykge1xuICAgICAgICB0aGlzLmNzcyA9IGNzcztcbiAgICB9XG4gICAgcmVnaXN0ZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHNoYXJlZFN0eWxlcyA9IGNvbnRhaW5lci5nZXQoSVNoYWRvd0RPTUdsb2JhbFN0eWxlcyk7XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSBjb250YWluZXIuZ2V0KElTaGFkb3dET01TdHlsZUZhY3RvcnkpO1xuICAgICAgICBjb250YWluZXIucmVnaXN0ZXIoUmVnaXN0cmF0aW9uLmluc3RhbmNlKElTaGFkb3dET01TdHlsZXMsIGZhY3RvcnkuY3JlYXRlU3R5bGVzKHRoaXMuY3NzLCBzaGFyZWRTdHlsZXMpKSk7XG4gICAgfVxufVxubGV0IEFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlc0ZhY3RvcnkgPSBjbGFzcyBBZG9wdGVkU3R5bGVTaGVldHNTdHlsZXNGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihwKSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGNyZWF0ZVN0eWxlcyhsb2NhbFN0eWxlcywgc2hhcmVkU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRvcHRlZFN0eWxlU2hlZXRzU3R5bGVzKHRoaXMucCwgbG9jYWxTdHlsZXMsIHRoaXMuY2FjaGUsIHNoYXJlZFN0eWxlcyk7XG4gICAgfVxufTtcbkFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlc0ZhY3RvcnkgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElQbGF0Zm9ybSlcbl0sIEFkb3B0ZWRTdHlsZVNoZWV0c1N0eWxlc0ZhY3RvcnkpO1xubGV0IFN0eWxlRWxlbWVudFN0eWxlc0ZhY3RvcnkgPSBjbGFzcyBTdHlsZUVsZW1lbnRTdHlsZXNGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihwKSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgfVxuICAgIGNyZWF0ZVN0eWxlcyhsb2NhbFN0eWxlcywgc2hhcmVkU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3R5bGVFbGVtZW50U3R5bGVzKHRoaXMucCwgbG9jYWxTdHlsZXMsIHNoYXJlZFN0eWxlcyk7XG4gICAgfVxufTtcblN0eWxlRWxlbWVudFN0eWxlc0ZhY3RvcnkgPSBfX2RlY29yYXRlKFtcbiAgICBfX3BhcmFtKDAsIElQbGF0Zm9ybSlcbl0sIFN0eWxlRWxlbWVudFN0eWxlc0ZhY3RvcnkpO1xuZXhwb3J0IGNvbnN0IElTaGFkb3dET01TdHlsZXMgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lTaGFkb3dET01TdHlsZXMnKTtcbmV4cG9ydCBjb25zdCBJU2hhZG93RE9NR2xvYmFsU3R5bGVzID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJU2hhZG93RE9NR2xvYmFsU3R5bGVzJywgeCA9PiB4Lmluc3RhbmNlKHsgYXBwbHlUbzogbm9vcCB9KSk7XG5leHBvcnQgY2xhc3MgQWRvcHRlZFN0eWxlU2hlZXRzU3R5bGVzIHtcbiAgICBjb25zdHJ1Y3RvcihwLCBsb2NhbFN0eWxlcywgc3R5bGVTaGVldENhY2hlLCBzaGFyZWRTdHlsZXMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzID0gc2hhcmVkU3R5bGVzO1xuICAgICAgICB0aGlzLnN0eWxlU2hlZXRzID0gbG9jYWxTdHlsZXMubWFwKHggPT4ge1xuICAgICAgICAgICAgbGV0IHNoZWV0O1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBwLkNTU1N0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICBzaGVldCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGVldCA9IHN0eWxlU2hlZXRDYWNoZS5nZXQoeCk7XG4gICAgICAgICAgICAgICAgaWYgKHNoZWV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hlZXQgPSBuZXcgcC5DU1NTdHlsZVNoZWV0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNoZWV0LnJlcGxhY2VTeW5jKHgpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0Q2FjaGUuc2V0KHgsIHNoZWV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2hlZXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgc3VwcG9ydGVkKHApIHtcbiAgICAgICAgcmV0dXJuICdhZG9wdGVkU3R5bGVTaGVldHMnIGluIHAuU2hhZG93Um9vdC5wcm90b3R5cGU7XG4gICAgfVxuICAgIGFwcGx5VG8oc2hhZG93Um9vdCkge1xuICAgICAgICBpZiAodGhpcy5zaGFyZWRTdHlsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzLmFwcGx5VG8oc2hhZG93Um9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb25zdHJ1Y3Qtc3R5bGVzaGVldHMvXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTkvMDIvY29uc3RydWN0YWJsZS1zdHlsZXNoZWV0c1xuICAgICAgICBzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFtcbiAgICAgICAgICAgIC4uLnNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgLi4udGhpcy5zdHlsZVNoZWV0c1xuICAgICAgICBdO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTdHlsZUVsZW1lbnRTdHlsZXMge1xuICAgIGNvbnN0cnVjdG9yKHAsIGxvY2FsU3R5bGVzLCBzaGFyZWRTdHlsZXMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMubG9jYWxTdHlsZXMgPSBsb2NhbFN0eWxlcztcbiAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXMgPSBzaGFyZWRTdHlsZXM7XG4gICAgfVxuICAgIGFwcGx5VG8oc2hhZG93Um9vdCkge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLmxvY2FsU3R5bGVzO1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wO1xuICAgICAgICBmb3IgKGxldCBpID0gc3R5bGVzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBzdHlsZXNbaV07XG4gICAgICAgICAgICBzaGFkb3dSb290LnByZXBlbmQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hhcmVkU3R5bGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZFN0eWxlcy5hcHBseVRvKHNoYWRvd1Jvb3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IFN0eWxlQ29uZmlndXJhdGlvbiA9IHtcbiAgICBzaGFkb3dET00oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBBcHBUYXNrLndpdGgoSUNvbnRhaW5lcikuYmVmb3JlQ3JlYXRlKCkuY2FsbChjb250YWluZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5zaGFyZWRTdHlsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSBjb250YWluZXIuZ2V0KElTaGFkb3dET01TdHlsZUZhY3RvcnkpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlcihSZWdpc3RyYXRpb24uaW5zdGFuY2UoSVNoYWRvd0RPTUdsb2JhbFN0eWxlcywgZmFjdG9yeS5jcmVhdGVTdHlsZXMoY29uZmlnLnNoYXJlZFN0eWxlcywgbnVsbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiLCJpbXBvcnQgeyBESSwgTWV0YWRhdGEsIFByb3RvY29sIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZSc7XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50LCBDdXN0b21FbGVtZW50RGVmaW5pdGlvbiB9IGZyb20gJy4uL3Jlc291cmNlcy9jdXN0b20tZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyLmpzJztcbmV4cG9ydCBjb25zdCBJVmlld0ZhY3RvcnkgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lWaWV3RmFjdG9yeScpO1xuZXhwb3J0IGNsYXNzIFZpZXdGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250ZXh0LCBjb250ZW50VHlwZSwgcHJvamVjdGlvblNjb3BlID0gbnVsbCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gICAgICAgIHRoaXMucHJvamVjdGlvblNjb3BlID0gcHJvamVjdGlvblNjb3BlO1xuICAgICAgICB0aGlzLmlzQ2FjaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZVNpemUgPSAtMTtcbiAgICB9XG4gICAgc2V0Q2FjaGVTaXplKHNpemUsIGRvTm90T3ZlcnJpZGVJZkFscmVhZHlTZXQpIHtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gVmlld0ZhY3RvcnkubWF4Q2FjaGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlU2l6ZSA9PT0gLTEgfHwgIWRvTm90T3ZlcnJpZGVJZkFscmVhZHlTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVTaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhY2hpbmcgPSB0aGlzLmNhY2hlU2l6ZSA+IDA7XG4gICAgfVxuICAgIGNhblJldHVyblRvQ2FjaGUoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZSAhPSBudWxsICYmIHRoaXMuY2FjaGUubGVuZ3RoIDwgdGhpcy5jYWNoZVNpemU7XG4gICAgfVxuICAgIHRyeVJldHVyblRvQ2FjaGUoY29udHJvbGxlcikge1xuICAgICAgICBpZiAodGhpcy5jYW5SZXR1cm5Ub0NhY2hlKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnB1c2goY29udHJvbGxlcik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNyZWF0ZShmbGFncywgcGFyZW50Q29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgICAgIGxldCBjb250cm9sbGVyO1xuICAgICAgICBpZiAoY2FjaGUgIT0gbnVsbCAmJiBjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyID0gY2FjaGUucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyID0gQ29udHJvbGxlci5mb3JTeW50aGV0aWNWaWV3KG51bGwsIHRoaXMuY29udGV4dCwgdGhpcywgZmxhZ3MsIHBhcmVudENvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG59XG5WaWV3RmFjdG9yeS5tYXhDYWNoZVNpemUgPSAweEZGRkY7XG5jb25zdCBzZWVuVmlld3MgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gbm90WWV0U2Vlbigkdmlldykge1xuICAgIHJldHVybiAhc2VlblZpZXdzLmhhcygkdmlldyk7XG59XG5mdW5jdGlvbiB0b0N1c3RvbUVsZW1lbnREZWZpbml0aW9uKCR2aWV3KSB7XG4gICAgc2VlblZpZXdzLmFkZCgkdmlldyk7XG4gICAgcmV0dXJuIEN1c3RvbUVsZW1lbnREZWZpbml0aW9uLmNyZWF0ZSgkdmlldyk7XG59XG5leHBvcnQgY29uc3QgVmlld3MgPSB7XG4gICAgbmFtZTogUHJvdG9jb2wucmVzb3VyY2Uua2V5Rm9yKCd2aWV3cycpLFxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIChNZXRhZGF0YS5oYXNPd24oVmlld3MubmFtZSwgdmFsdWUpIHx8ICckdmlld3MnIGluIHZhbHVlKTtcbiAgICB9LFxuICAgIGdldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICckdmlld3MnIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBhIGBnZXRgIG9wZXJhdGlvbiB3aXRoIHNpZGUgZWZmZWN0cyBpcyBub3QgYSBnb29kIHRoaW5nLiBTaG91bGQgcmVmYWN0b3IgdGhpcyB0byBhIHByb3BlciByZXNvdXJjZSBraW5kLlxuICAgICAgICAgICAgY29uc3QgJHZpZXdzID0gdmFsdWUuJHZpZXdzO1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbnMgPSAkdmlld3MuZmlsdGVyKG5vdFlldFNlZW4pLm1hcCh0b0N1c3RvbUVsZW1lbnREZWZpbml0aW9uKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgVmlld3MuYWRkKHZhbHVlLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cyA9IE1ldGFkYXRhLmdldE93bihWaWV3cy5uYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2aWV3cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBNZXRhZGF0YS5kZWZpbmUoVmlld3MubmFtZSwgdmlld3MgPSBbXSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cztcbiAgICB9LFxuICAgIGFkZChUeXBlLCBwYXJ0aWFsRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQ3VzdG9tRWxlbWVudERlZmluaXRpb24uY3JlYXRlKHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgbGV0IHZpZXdzID0gTWV0YWRhdGEuZ2V0T3duKFZpZXdzLm5hbWUsIFR5cGUpO1xuICAgICAgICBpZiAodmlld3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgTWV0YWRhdGEuZGVmaW5lKFZpZXdzLm5hbWUsIHZpZXdzID0gW2RlZmluaXRpb25dLCBUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdzLnB1c2goZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdzO1xuICAgIH0sXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHZpZXcodikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIFZpZXdzLmFkZCh0YXJnZXQsIHYpO1xuICAgIH07XG59XG5leHBvcnQgY29uc3QgSVZpZXdMb2NhdG9yID0gREkuY3JlYXRlSW50ZXJmYWNlKCdJVmlld0xvY2F0b3InLCB4ID0+IHguc2luZ2xldG9uKFZpZXdMb2NhdG9yKSk7XG5leHBvcnQgY2xhc3MgVmlld0xvY2F0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vZGVsSW5zdGFuY2VUb0JvdW5kQ29tcG9uZW50ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5tb2RlbFR5cGVUb1VuYm91bmRDb21wb25lbnQgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldFZpZXdDb21wb25lbnRGb3JPYmplY3Qob2JqZWN0LCB2aWV3TmFtZU9yU2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlVmlld3MgPSBWaWV3cy5oYXMob2JqZWN0LmNvbnN0cnVjdG9yKSA/IFZpZXdzLmdldChvYmplY3QuY29uc3RydWN0b3IpIDogW107XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFZpZXdOYW1lID0gdHlwZW9mIHZpZXdOYW1lT3JTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gdmlld05hbWVPclNlbGVjdG9yKG9iamVjdCwgYXZhaWxhYmxlVmlld3MpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmdldFZpZXdOYW1lKGF2YWlsYWJsZVZpZXdzLCB2aWV3TmFtZU9yU2VsZWN0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JDcmVhdGVCb3VuZENvbXBvbmVudChvYmplY3QsIGF2YWlsYWJsZVZpZXdzLCByZXNvbHZlZFZpZXdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0T3JDcmVhdGVCb3VuZENvbXBvbmVudChvYmplY3QsIGF2YWlsYWJsZVZpZXdzLCByZXNvbHZlZFZpZXdOYW1lKSB7XG4gICAgICAgIGxldCBsb29rdXAgPSB0aGlzLm1vZGVsSW5zdGFuY2VUb0JvdW5kQ29tcG9uZW50LmdldChvYmplY3QpO1xuICAgICAgICBsZXQgQm91bmRDb21wb25lbnQ7XG4gICAgICAgIGlmIChsb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbG9va3VwID0ge307XG4gICAgICAgICAgICB0aGlzLm1vZGVsSW5zdGFuY2VUb0JvdW5kQ29tcG9uZW50LnNldChvYmplY3QsIGxvb2t1cCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBCb3VuZENvbXBvbmVudCA9IGxvb2t1cFtyZXNvbHZlZFZpZXdOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQm91bmRDb21wb25lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgVW5ib3VuZENvbXBvbmVudCA9IHRoaXMuZ2V0T3JDcmVhdGVVbmJvdW5kQ29tcG9uZW50KG9iamVjdCwgYXZhaWxhYmxlVmlld3MsIHJlc29sdmVkVmlld05hbWUpO1xuICAgICAgICAgICAgQm91bmRDb21wb25lbnQgPSBDdXN0b21FbGVtZW50LmRlZmluZShDdXN0b21FbGVtZW50LmdldERlZmluaXRpb24oVW5ib3VuZENvbXBvbmVudCksIGNsYXNzIGV4dGVuZHMgVW5ib3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb29rdXBbcmVzb2x2ZWRWaWV3TmFtZV0gPSBCb3VuZENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm91bmRDb21wb25lbnQ7XG4gICAgfVxuICAgIGdldE9yQ3JlYXRlVW5ib3VuZENvbXBvbmVudChvYmplY3QsIGF2YWlsYWJsZVZpZXdzLCByZXNvbHZlZFZpZXdOYW1lKSB7XG4gICAgICAgIGxldCBsb29rdXAgPSB0aGlzLm1vZGVsVHlwZVRvVW5ib3VuZENvbXBvbmVudC5nZXQob2JqZWN0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgbGV0IFVuYm91bmRDb21wb25lbnQ7XG4gICAgICAgIGlmIChsb29rdXAgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbG9va3VwID0ge307XG4gICAgICAgICAgICB0aGlzLm1vZGVsVHlwZVRvVW5ib3VuZENvbXBvbmVudC5zZXQob2JqZWN0LmNvbnN0cnVjdG9yLCBsb29rdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgVW5ib3VuZENvbXBvbmVudCA9IGxvb2t1cFtyZXNvbHZlZFZpZXdOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVW5ib3VuZENvbXBvbmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBVbmJvdW5kQ29tcG9uZW50ID0gQ3VzdG9tRWxlbWVudC5kZWZpbmUodGhpcy5nZXRWaWV3KGF2YWlsYWJsZVZpZXdzLCByZXNvbHZlZFZpZXdOYW1lKSwgY2xhc3Mge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmaW5lKGNvbnRyb2xsZXIsIHBhcmVudENvbnRhaW5lciwgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bSA9IHRoaXMudmlld01vZGVsO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNjb3BlID0gU2NvcGUuZnJvbVBhcmVudChjb250cm9sbGVyLnNjb3BlLCB2bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2bS5kZWZpbmUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZtLmRlZmluZShjb250cm9sbGVyLCBwYXJlbnRDb250YWluZXIsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm90byA9IFVuYm91bmRDb21wb25lbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgaWYgKCdoeWRyYXRpbmcnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLmh5ZHJhdGluZyA9IGZ1bmN0aW9uIGh5ZHJhdGluZyhjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmh5ZHJhdGluZyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdoeWRyYXRlZCcgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uaHlkcmF0ZWQgPSBmdW5jdGlvbiBoeWRyYXRlZChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmh5ZHJhdGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2NyZWF0ZWQnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLmNyZWF0ZWQgPSBmdW5jdGlvbiBjcmVhdGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY3JlYXRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdiaW5kaW5nJyBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm90by5iaW5kaW5nID0gZnVuY3Rpb24gYmluZGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld01vZGVsLmJpbmRpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdib3VuZCcgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uYm91bmQgPSBmdW5jdGlvbiBib3VuZChpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld01vZGVsLmJvdW5kKGluaXRpYXRvciwgcGFyZW50LCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnYXR0YWNoaW5nJyBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm90by5hdHRhY2hpbmcgPSBmdW5jdGlvbiBhdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdNb2RlbC5hdHRhY2hpbmcoaW5pdGlhdG9yLCBwYXJlbnQsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdhdHRhY2hlZCcgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uYXR0YWNoZWQgPSBmdW5jdGlvbiBhdHRhY2hlZChpbml0aWF0b3IsIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdNb2RlbC5hdHRhY2hlZChpbml0aWF0b3IsIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdkZXRhY2hpbmcnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHByb3RvLmRldGFjaGluZyA9IGZ1bmN0aW9uIGRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld01vZGVsLmRldGFjaGluZyhpbml0aWF0b3IsIHBhcmVudCwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3VuYmluZGluZycgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8udW5iaW5kaW5nID0gZnVuY3Rpb24gdW5iaW5kaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3TW9kZWwudW5iaW5kaW5nKGluaXRpYXRvciwgcGFyZW50LCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnZGlzcG9zZScgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9va3VwW3Jlc29sdmVkVmlld05hbWVdID0gVW5ib3VuZENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVW5ib3VuZENvbXBvbmVudDtcbiAgICB9XG4gICAgZ2V0Vmlld05hbWUodmlld3MsIHJlcXVlc3RlZE5hbWUpIHtcbiAgICAgICAgaWYgKHJlcXVlc3RlZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3c1swXS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZGVmYXVsdC12aWV3JztcbiAgICB9XG4gICAgZ2V0Vmlldyh2aWV3cywgbmFtZSkge1xuICAgICAgICBjb25zdCB2ID0gdmlld3MuZmluZCh4ID0+IHgubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgIGlmICh2ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdmlldzogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXcuanMubWFwIiwiaW1wb3J0IHsgY29ubmVjdGFibGUsIENvbm5lY3RhYmxlU3dpdGNoZXIsIFByb3h5T2JzZXJ2YWJsZSwgfSBmcm9tICdAYXVyZWxpYS9ydW50aW1lJztcbmNvbnN0IHsgZW50ZXIsIGV4aXQgfSA9IENvbm5lY3RhYmxlU3dpdGNoZXI7XG5jb25zdCB7IHdyYXAsIHVud3JhcCB9ID0gUHJveHlPYnNlcnZhYmxlO1xuZXhwb3J0IGNsYXNzIENvbXB1dGVkV2F0Y2hlciB7XG4gICAgY29uc3RydWN0b3Iob2JqLCBvYnNlcnZlckxvY2F0b3IsIGdldCwgY2IsIHVzZVByb3h5KSB7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5nZXQgPSBnZXQ7XG4gICAgICAgIHRoaXMuY2IgPSBjYjtcbiAgICAgICAgdGhpcy51c2VQcm94eSA9IHVzZVByb3h5O1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIC8vIHRvZG86IG1heWJlIHVzZSBhIGNvdW50ZXIgYWxsb3cgcmVjdXJzaXZlIGNhbGwgdG8gYSBjZXJ0YWluIGxldmVsXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0YWJsZS5hc3NpZ25JZFRvKHRoaXMpO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuICAgICRiaW5kKCkge1xuICAgICAgICBpZiAodGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21wdXRlKCk7XG4gICAgfVxuICAgICR1bmJpbmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzLmNsZWFyKHRydWUpO1xuICAgIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kIHx8IHRoaXMucnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqO1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBvcHRpb25hbGx5IHF1ZXVlXG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwob2JqLCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZSgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnMudmVyc2lvbisrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZW50ZXIodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHVud3JhcCh0aGlzLmdldC5jYWxsKHZvaWQgMCwgdGhpcy51c2VQcm94eSA/IHdyYXAodGhpcy5vYmopIDogdGhpcy5vYmosIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub2JzLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZXhpdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uV2F0Y2hlciB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUsIGxvY2F0b3IsIG9ic2VydmVyTG9jYXRvciwgZXhwcmVzc2lvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmxvY2F0b3IgPSBsb2NhdG9yO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JqID0gc2NvcGUuYmluZGluZ0NvbnRleHQ7XG4gICAgICAgIGNvbm5lY3RhYmxlLmFzc2lnbklkVG8odGhpcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBleHByID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLm9iajtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBjYW5PcHRpbWl6ZSA9IGV4cHIuJGtpbmQgPT09IDEwMDgyIC8qIEFjY2Vzc1Njb3BlICovICYmIHRoaXMub2JzLmNvdW50ID09PSAxO1xuICAgICAgICBpZiAoIWNhbk9wdGltaXplKSB7XG4gICAgICAgICAgICB0aGlzLm9icy52ZXJzaW9uKys7XG4gICAgICAgICAgICB2YWx1ZSA9IGV4cHIuZXZhbHVhdGUoMCwgdGhpcy5zY29wZSwgbnVsbCwgdGhpcy5sb2NhdG9yLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2JzLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBzaG91bGQgb3B0aW9uYWxseSBxdWV1ZSBmb3IgYmF0Y2ggc3luY2hyb25vdXNcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2suY2FsbChvYmosIHZhbHVlLCBvbGRWYWx1ZSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzLnZlcnNpb24rKztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSgwIC8qIG5vbmUgKi8sIHRoaXMuc2NvcGUsIG51bGwsIHRoaXMubG9jYXRvciwgdGhpcyk7XG4gICAgICAgIHRoaXMub2JzLmNsZWFyKGZhbHNlKTtcbiAgICB9XG4gICAgJHVuYmluZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnMuY2xlYXIodHJ1ZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgfVxufVxuY29ubmVjdGFibGUoQ29tcHV0ZWRXYXRjaGVyKTtcbmNvbm5lY3RhYmxlKEV4cHJlc3Npb25XYXRjaGVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhdGNoZXJzLmpzLm1hcCIsImltcG9ydCB7IFByb3RvY29sLCBNZXRhZGF0YSwgZW1wdHlBcnJheSB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgZnVuY3Rpb24gd2F0Y2goZXhwcmVzc2lvbk9yUHJvcGVydHlBY2Nlc3NGbiwgY2hhbmdlSGFuZGxlck9yQ2FsbGJhY2spIHtcbiAgICBpZiAoIWV4cHJlc3Npb25PclByb3BlcnR5QWNjZXNzRm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdhdGNoIGNvbmZpZy4gRXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBvciBhIGZuJyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3QgaXNDbGFzc0RlY29yYXRvciA9IGtleSA9PSBudWxsO1xuICAgICAgICBjb25zdCBUeXBlID0gaXNDbGFzc0RlY29yYXRvciA/IHRhcmdldCA6IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gYmFzaWMgdmFsaWRhdGlvblxuICAgICAgICBpZiAoaXNDbGFzc0RlY29yYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VIYW5kbGVyT3JDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICYmIChjaGFuZ2VIYW5kbGVyT3JDYWxsYmFjayA9PSBudWxsIHx8ICEoY2hhbmdlSGFuZGxlck9yQ2FsbGJhY2sgaW4gVHlwZS5wcm90b3R5cGUpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFuZ2UgaGFuZGxlciBjb25maWcuIE1ldGhvZCBcIiR7U3RyaW5nKGNoYW5nZUhhbmRsZXJPckNhbGxiYWNrKX1cIiBub3QgZm91bmQgaW4gY2xhc3MgJHtUeXBlLm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlc2NyaXB0b3I/LnZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRlY29yYXRlZCB0YXJnZXQgJHtTdHJpbmcoa2V5KX0gaXMgbm90IGEgY2xhc3MgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIFdhdGNoLmFkZChUeXBlLCBuZXcgV2F0Y2hEZWZpbml0aW9uKGV4cHJlc3Npb25PclByb3BlcnR5QWNjZXNzRm4sIGlzQ2xhc3NEZWNvcmF0b3IgPyBjaGFuZ2VIYW5kbGVyT3JDYWxsYmFjayA6IGRlc2NyaXB0b3IudmFsdWUpKTtcbiAgICB9O1xufVxuY2xhc3MgV2F0Y2hEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihleHByZXNzaW9uLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxufVxuY29uc3Qgbm9EZWZpbml0aW9ucyA9IGVtcHR5QXJyYXk7XG5leHBvcnQgY29uc3QgV2F0Y2ggPSB7XG4gICAgbmFtZTogUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IoJ3dhdGNoJyksXG4gICAgYWRkKFR5cGUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgbGV0IHdhdGNoRGVmaW5pdGlvbnMgPSBNZXRhZGF0YS5nZXRPd24oV2F0Y2gubmFtZSwgVHlwZSk7XG4gICAgICAgIGlmICh3YXRjaERlZmluaXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShXYXRjaC5uYW1lLCB3YXRjaERlZmluaXRpb25zID0gW10sIFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHdhdGNoRGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcbiAgICB9LFxuICAgIGdldEFubm90YXRpb24oVHlwZSkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGEuZ2V0T3duKFdhdGNoLm5hbWUsIFR5cGUpID8/IG5vRGVmaW5pdGlvbnM7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXRjaC5qcy5tYXAiLCJpbXBvcnQgeyBQcm90b2NvbCwgTWV0YWRhdGEsIFJlZ2lzdHJhdGlvbiB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgZnVuY3Rpb24gYWxpYXMoLi4uYWxpYXNlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFByb3RvY29sLmFubm90YXRpb24ua2V5Rm9yKCdhbGlhc2VzJyk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTWV0YWRhdGEuZ2V0T3duKGtleSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlZmluZShrZXksIGFsaWFzZXMsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZy5wdXNoKC4uLmFsaWFzZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckFsaWFzZXMoYWxpYXNlcywgcmVzb3VyY2UsIGtleSwgY29udGFpbmVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYWxpYXNlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5hbGlhc1RvKGtleSwgcmVzb3VyY2Uua2V5RnJvbShhbGlhc2VzW2ldKSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGlhcy5qcy5tYXAiLCJpbXBvcnQgeyBSZWdpc3RyYXRpb24sIE1ldGFkYXRhLCBQcm90b2NvbCwgbWVyZ2VBcnJheXMsIGZpcnN0RGVmaW5lZCwgREksIGZyb21Bbm5vdGF0aW9uT3JEZWZpbml0aW9uT3JUeXBlT3JEZWZhdWx0LCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyByZWdpc3RlckFsaWFzZXMgfSBmcm9tICcuL2FsaWFzLmpzJztcbmV4cG9ydCB2YXIgQmluZGluZ0JlaGF2aW9yU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5KSB7XG4gICAgQmluZGluZ0JlaGF2aW9yU3RyYXRlZ3lbQmluZGluZ0JlaGF2aW9yU3RyYXRlZ3lbXCJzaW5nbGV0b25cIl0gPSAxXSA9IFwic2luZ2xldG9uXCI7XG4gICAgQmluZGluZ0JlaGF2aW9yU3RyYXRlZ3lbQmluZGluZ0JlaGF2aW9yU3RyYXRlZ3lbXCJpbnRlcmNlcHRvclwiXSA9IDJdID0gXCJpbnRlcmNlcHRvclwiO1xufSkoQmluZGluZ0JlaGF2aW9yU3RyYXRlZ3kgfHwgKEJpbmRpbmdCZWhhdmlvclN0cmF0ZWd5ID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBiaW5kaW5nQmVoYXZpb3IobmFtZU9yRGVmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIEJpbmRpbmdCZWhhdmlvci5kZWZpbmUobmFtZU9yRGVmLCB0YXJnZXQpO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgQmluZGluZ0JlaGF2aW9yRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoVHlwZSwgbmFtZSwgYWxpYXNlcywga2V5LCBzdHJhdGVneSkge1xuICAgICAgICB0aGlzLlR5cGUgPSBUeXBlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsaWFzZXMgPSBhbGlhc2VzO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgbGV0IGRlZjtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JEZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRGVmO1xuICAgICAgICAgICAgZGVmID0geyBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRGVmLm5hbWU7XG4gICAgICAgICAgICBkZWYgPSBuYW1lT3JEZWY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5oZXJpdHNGcm9tSW50ZXJjZXB0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVHlwZSkgPT09IEJpbmRpbmdJbnRlcmNlcHRvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nQmVoYXZpb3JEZWZpbml0aW9uKFR5cGUsIGZpcnN0RGVmaW5lZChCaW5kaW5nQmVoYXZpb3IuZ2V0QW5ub3RhdGlvbihUeXBlLCAnbmFtZScpLCBuYW1lKSwgbWVyZ2VBcnJheXMoQmluZGluZ0JlaGF2aW9yLmdldEFubm90YXRpb24oVHlwZSwgJ2FsaWFzZXMnKSwgZGVmLmFsaWFzZXMsIFR5cGUuYWxpYXNlcyksIEJpbmRpbmdCZWhhdmlvci5rZXlGcm9tKG5hbWUpLCBmcm9tQW5ub3RhdGlvbk9yRGVmaW5pdGlvbk9yVHlwZU9yRGVmYXVsdCgnc3RyYXRlZ3knLCBkZWYsIFR5cGUsICgpID0+IGluaGVyaXRzRnJvbUludGVyY2VwdG9yID8gMiAvKiBpbnRlcmNlcHRvciAqLyA6IDEgLyogc2luZ2xldG9uICovKSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCB7IFR5cGUsIGtleSwgYWxpYXNlcywgc3RyYXRlZ3kgfSA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBzaW5nbGV0b24gKi86XG4gICAgICAgICAgICAgICAgUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogaW50ZXJjZXB0b3IgKi86XG4gICAgICAgICAgICAgICAgUmVnaXN0cmF0aW9uLmluc3RhbmNlKGtleSwgbmV3IEJpbmRpbmdCZWhhdmlvckZhY3RvcnkoY29udGFpbmVyLCBUeXBlKSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBSZWdpc3RyYXRpb24uYWxpYXNUbyhrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIHJlZ2lzdGVyQWxpYXNlcyhhbGlhc2VzLCBCaW5kaW5nQmVoYXZpb3IsIGtleSwgY29udGFpbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmluZGluZ0JlaGF2aW9yRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBUeXBlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLlR5cGUgPSBUeXBlO1xuICAgICAgICB0aGlzLmRlcHMgPSBESS5nZXREZXBlbmRlbmNpZXMoVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdChiaW5kaW5nLCBleHByKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBkZXBzID0gdGhpcy5kZXBzO1xuICAgICAgICBzd2l0Y2ggKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhma2xldXZlcik6IGZpeCB0aGlzIGNhc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuVHlwZShiaW5kaW5nLCBleHByKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuVHlwZShjb250YWluZXIuZ2V0KGRlcHNbMF0pLCBiaW5kaW5nLCBleHByKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuVHlwZShjb250YWluZXIuZ2V0KGRlcHNbMF0pLCBjb250YWluZXIuZ2V0KGRlcHNbMV0pLCBiaW5kaW5nLCBleHByKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlR5cGUoLi4uZGVwcy5tYXAoZCA9PiBjb250YWluZXIuZ2V0KGQpKSwgYmluZGluZywgZXhwcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmluZGluZ0ludGVyY2VwdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nLCBleHByKSB7XG4gICAgICAgIHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3IgPSB0aGlzO1xuICAgICAgICBsZXQgaW50ZXJjZXB0b3I7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nLmludGVyY2VwdG9yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBpbnRlcmNlcHRvciA9IGJpbmRpbmcuaW50ZXJjZXB0b3I7XG4gICAgICAgICAgICBiaW5kaW5nLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgICAgIGJpbmRpbmcgPSBpbnRlcmNlcHRvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcuaWQ7XG4gICAgfVxuICAgIGdldCBvYnNlcnZlckxvY2F0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcub2JzZXJ2ZXJMb2NhdG9yO1xuICAgIH1cbiAgICBnZXQgbG9jYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZy5sb2NhdG9yO1xuICAgIH1cbiAgICBnZXQgJHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nLiRzY29wZTtcbiAgICB9XG4gICAgZ2V0ICRob3N0U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcuJGhvc3RTY29wZTtcbiAgICB9XG4gICAgZ2V0IGlzQm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcuaXNCb3VuZDtcbiAgICB9XG4gICAgZ2V0IG9icygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZy5vYnM7XG4gICAgfVxuICAgIHVwZGF0ZVRhcmdldCh2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nLnVwZGF0ZVRhcmdldCh2YWx1ZSwgZmxhZ3MpO1xuICAgIH1cbiAgICB1cGRhdGVTb3VyY2UodmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZy51cGRhdGVTb3VyY2UodmFsdWUsIGZsYWdzKTtcbiAgICB9XG4gICAgY2FsbFNvdXJjZShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcuY2FsbFNvdXJjZShhcmdzKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncykge1xuICAgICAgICB0aGlzLmJpbmRpbmcuaGFuZGxlQ2hhbmdlKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlLCBmbGFncyk7XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoaW5kZXhNYXAsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZy5oYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncyk7XG4gICAgfVxuICAgIG9ic2VydmVQcm9wZXJ0eShvYmosIGtleSkge1xuICAgICAgICB0aGlzLmJpbmRpbmcub2JzZXJ2ZVByb3BlcnR5KG9iaiwga2V5KTtcbiAgICB9XG4gICAgb2JzZXJ2ZUNvbGxlY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nLm9ic2VydmVDb2xsZWN0aW9uKG9ic2VydmVyKTtcbiAgICB9XG4gICAgJGJpbmQoZmxhZ3MsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nLiRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlKTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICB0aGlzLmJpbmRpbmcuJHVuYmluZChmbGFncyk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEJpbmRpbmdCZWhhdmlvciA9IHtcbiAgICBuYW1lOiBQcm90b2NvbC5yZXNvdXJjZS5rZXlGb3IoJ2JpbmRpbmctYmVoYXZpb3InKSxcbiAgICBrZXlGcm9tKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke0JpbmRpbmdCZWhhdmlvci5uYW1lfToke25hbWV9YDtcbiAgICB9LFxuICAgIGlzVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIE1ldGFkYXRhLmhhc093bihCaW5kaW5nQmVoYXZpb3IubmFtZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZGVmaW5lKG5hbWVPckRlZiwgVHlwZSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gQmluZGluZ0JlaGF2aW9yRGVmaW5pdGlvbi5jcmVhdGUobmFtZU9yRGVmLCBUeXBlKTtcbiAgICAgICAgTWV0YWRhdGEuZGVmaW5lKEJpbmRpbmdCZWhhdmlvci5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLlR5cGUpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoQmluZGluZ0JlaGF2aW9yLm5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICBQcm90b2NvbC5yZXNvdXJjZS5hcHBlbmRUbyhUeXBlLCBCaW5kaW5nQmVoYXZpb3IubmFtZSk7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLlR5cGU7XG4gICAgfSxcbiAgICBnZXREZWZpbml0aW9uKFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmID0gTWV0YWRhdGEuZ2V0T3duKEJpbmRpbmdCZWhhdmlvci5uYW1lLCBUeXBlKTtcbiAgICAgICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlZmluaXRpb24gZm91bmQgZm9yIHR5cGUgJHtUeXBlLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9LFxuICAgIGFubm90YXRlKFR5cGUsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcihwcm9wKSwgdmFsdWUsIFR5cGUpO1xuICAgIH0sXG4gICAgZ2V0QW5ub3RhdGlvbihUeXBlLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5nZXRPd24oUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIFR5cGUpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGluZy1iZWhhdmlvci5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucyAqL1xuaW1wb3J0IHsgZW1wdHlBcnJheSwgaXNOdW1iZXJPckJpZ0ludCwgaXNTdHJpbmdPckRhdGUgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQmluZGluZ0NvbnRleHQgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi9iaW5kaW5nLWNvbnRleHQuanMnO1xuaW1wb3J0IHsgSVNpZ25hbGVyIH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24vc2lnbmFsZXIuanMnO1xuaW1wb3J0IHsgQmluZGluZ0JlaGF2aW9yLCBCaW5kaW5nQmVoYXZpb3JGYWN0b3J5IH0gZnJvbSAnLi4vYmluZGluZy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBWYWx1ZUNvbnZlcnRlciB9IGZyb20gJy4uL3ZhbHVlLWNvbnZlcnRlci5qcyc7XG5leHBvcnQgdmFyIEV4cHJlc3Npb25LaW5kO1xuKGZ1bmN0aW9uIChFeHByZXNzaW9uS2luZCkge1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQ29ubmVjdHNcIl0gPSAzMl0gPSBcIkNvbm5lY3RzXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJPYnNlcnZlc1wiXSA9IDY0XSA9IFwiT2JzZXJ2ZXNcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkNhbGxzRnVuY3Rpb25cIl0gPSAxMjhdID0gXCJDYWxsc0Z1bmN0aW9uXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJIYXNBbmNlc3RvclwiXSA9IDI1Nl0gPSBcIkhhc0FuY2VzdG9yXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJJc1ByaW1hcnlcIl0gPSA1MTJdID0gXCJJc1ByaW1hcnlcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIklzTGVmdEhhbmRTaWRlXCJdID0gMTAyNF0gPSBcIklzTGVmdEhhbmRTaWRlXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJIYXNCaW5kXCJdID0gMjA0OF0gPSBcIkhhc0JpbmRcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkhhc1VuYmluZFwiXSA9IDQwOTZdID0gXCJIYXNVbmJpbmRcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIklzQXNzaWduYWJsZVwiXSA9IDgxOTJdID0gXCJJc0Fzc2lnbmFibGVcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIklzTGl0ZXJhbFwiXSA9IDE2Mzg0XSA9IFwiSXNMaXRlcmFsXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJJc1Jlc291cmNlXCJdID0gMzI3NjhdID0gXCJJc1Jlc291cmNlXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJJc0ZvckRlY2xhcmF0aW9uXCJdID0gNjU1MzZdID0gXCJJc0ZvckRlY2xhcmF0aW9uXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJUeXBlXCJdID0gMzFdID0gXCJUeXBlXCI7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJBY2Nlc3NUaGlzXCJdID0gMTc5M10gPSBcIkFjY2Vzc1RoaXNcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkFjY2Vzc1Njb3BlXCJdID0gMTAwODJdID0gXCJBY2Nlc3NTY29wZVwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQXJyYXlMaXRlcmFsXCJdID0gMTc5NTVdID0gXCJBcnJheUxpdGVyYWxcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIk9iamVjdExpdGVyYWxcIl0gPSAxNzk1Nl0gPSBcIk9iamVjdExpdGVyYWxcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIlByaW1pdGl2ZUxpdGVyYWxcIl0gPSAxNzkyNV0gPSBcIlByaW1pdGl2ZUxpdGVyYWxcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIlRlbXBsYXRlXCJdID0gMTc5NThdID0gXCJUZW1wbGF0ZVwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiVW5hcnlcIl0gPSAzOV0gPSBcIlVuYXJ5XCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJDYWxsU2NvcGVcIl0gPSAxNDQ4XSA9IFwiQ2FsbFNjb3BlXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJDYWxsTWVtYmVyXCJdID0gMTE2MV0gPSBcIkNhbGxNZW1iZXJcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkNhbGxGdW5jdGlvblwiXSA9IDExNjJdID0gXCJDYWxsRnVuY3Rpb25cIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkFjY2Vzc01lbWJlclwiXSA9IDkzMjNdID0gXCJBY2Nlc3NNZW1iZXJcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkFjY2Vzc0tleWVkXCJdID0gOTMyNF0gPSBcIkFjY2Vzc0tleWVkXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJUYWdnZWRUZW1wbGF0ZVwiXSA9IDExOTddID0gXCJUYWdnZWRUZW1wbGF0ZVwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQmluYXJ5XCJdID0gNDZdID0gXCJCaW5hcnlcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkNvbmRpdGlvbmFsXCJdID0gNjNdID0gXCJDb25kaXRpb25hbFwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiQXNzaWduXCJdID0gODIwOF0gPSBcIkFzc2lnblwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiVmFsdWVDb252ZXJ0ZXJcIl0gPSAzNjkxM10gPSBcIlZhbHVlQ29udmVydGVyXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJCaW5kaW5nQmVoYXZpb3JcIl0gPSAzODk2Ml0gPSBcIkJpbmRpbmdCZWhhdmlvclwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiSHRtbExpdGVyYWxcIl0gPSA1MV0gPSBcIkh0bWxMaXRlcmFsXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJBcnJheUJpbmRpbmdQYXR0ZXJuXCJdID0gNjU1NTZdID0gXCJBcnJheUJpbmRpbmdQYXR0ZXJuXCI7XG4gICAgRXhwcmVzc2lvbktpbmRbRXhwcmVzc2lvbktpbmRbXCJPYmplY3RCaW5kaW5nUGF0dGVyblwiXSA9IDY1NTU3XSA9IFwiT2JqZWN0QmluZGluZ1BhdHRlcm5cIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkJpbmRpbmdJZGVudGlmaWVyXCJdID0gNjU1NThdID0gXCJCaW5kaW5nSWRlbnRpZmllclwiO1xuICAgIEV4cHJlc3Npb25LaW5kW0V4cHJlc3Npb25LaW5kW1wiRm9yT2ZTdGF0ZW1lbnRcIl0gPSA2MTk5XSA9IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbiAgICBFeHByZXNzaW9uS2luZFtFeHByZXNzaW9uS2luZFtcIkludGVycG9sYXRpb25cIl0gPSAyNF0gPSBcIkludGVycG9sYXRpb25cIjsgLy9cbn0pKEV4cHJlc3Npb25LaW5kIHx8IChFeHByZXNzaW9uS2luZCA9IHt9KSk7XG5leHBvcnQgY2xhc3MgVW5wYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRleHQgPSAnJztcbiAgICB9XG4gICAgc3RhdGljIHVucGFyc2UoZXhwcikge1xuICAgICAgICBjb25zdCB2aXNpdG9yID0gbmV3IFVucGFyc2VyKCk7XG4gICAgICAgIGV4cHIuYWNjZXB0KHZpc2l0b3IpO1xuICAgICAgICByZXR1cm4gdmlzaXRvci50ZXh0O1xuICAgIH1cbiAgICB2aXNpdEFjY2Vzc01lbWJlcihleHByKSB7XG4gICAgICAgIGV4cHIub2JqZWN0LmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9IGAuJHtleHByLm5hbWV9YDtcbiAgICB9XG4gICAgdmlzaXRBY2Nlc3NLZXllZChleHByKSB7XG4gICAgICAgIGV4cHIub2JqZWN0LmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICdbJztcbiAgICAgICAgZXhwci5rZXkuYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJ10nO1xuICAgIH1cbiAgICB2aXNpdEFjY2Vzc1RoaXMoZXhwcikge1xuICAgICAgICBpZiAoZXhwci5hbmNlc3RvciA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICckdGhpcyc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ICs9ICckcGFyZW50JztcbiAgICAgICAgbGV0IGkgPSBleHByLmFuY2VzdG9yIC0gMTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICcuJHBhcmVudCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRBY2Nlc3NTY29wZShleHByKSB7XG4gICAgICAgIGxldCBpID0gZXhwci5hbmNlc3RvcjtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICckcGFyZW50Lic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ICs9IGV4cHIubmFtZTtcbiAgICB9XG4gICAgdmlzaXRBcnJheUxpdGVyYWwoZXhwcikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGV4cHIuZWxlbWVudHM7XG4gICAgICAgIHRoaXMudGV4dCArPSAnWyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHNbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSAnXSc7XG4gICAgfVxuICAgIHZpc2l0T2JqZWN0TGl0ZXJhbChleHByKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBleHByLmtleXM7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGV4cHIudmFsdWVzO1xuICAgICAgICB0aGlzLnRleHQgKz0gJ3snO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGAnJHtrZXlzW2ldfSc6YDtcbiAgICAgICAgICAgIHZhbHVlc1tpXS5hY2NlcHQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ICs9ICd9JztcbiAgICB9XG4gICAgdmlzaXRQcmltaXRpdmVMaXRlcmFsKGV4cHIpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICcoJztcbiAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgZXNjYXBlZCA9IGV4cHIudmFsdWUucmVwbGFjZSgvJy9nLCAnXFxcXFxcJycpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGAnJHtlc2NhcGVkfSdgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGAke2V4cHIudmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbiAgICB2aXNpdENhbGxGdW5jdGlvbihleHByKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKCc7XG4gICAgICAgIGV4cHIuZnVuYy5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMud3JpdGVBcmdzKGV4cHIuYXJncyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKSc7XG4gICAgfVxuICAgIHZpc2l0Q2FsbE1lbWJlcihleHByKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKCc7XG4gICAgICAgIGV4cHIub2JqZWN0LmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9IGAuJHtleHByLm5hbWV9YDtcbiAgICAgICAgdGhpcy53cml0ZUFyZ3MoZXhwci5hcmdzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICcpJztcbiAgICB9XG4gICAgdmlzaXRDYWxsU2NvcGUoZXhwcikge1xuICAgICAgICB0aGlzLnRleHQgKz0gJygnO1xuICAgICAgICBsZXQgaSA9IGV4cHIuYW5jZXN0b3I7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSAnJHBhcmVudC4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSBleHByLm5hbWU7XG4gICAgICAgIHRoaXMud3JpdGVBcmdzKGV4cHIuYXJncyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKSc7XG4gICAgfVxuICAgIHZpc2l0VGVtcGxhdGUoZXhwcikge1xuICAgICAgICBjb25zdCB7IGNvb2tlZCwgZXhwcmVzc2lvbnMgfSA9IGV4cHI7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICdgJztcbiAgICAgICAgdGhpcy50ZXh0ICs9IGNvb2tlZFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnNbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGNvb2tlZFtpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ICs9ICdgJztcbiAgICB9XG4gICAgdmlzaXRUYWdnZWRUZW1wbGF0ZShleHByKSB7XG4gICAgICAgIGNvbnN0IHsgY29va2VkLCBleHByZXNzaW9ucyB9ID0gZXhwcjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICBleHByLmZ1bmMuYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJ2AnO1xuICAgICAgICB0aGlzLnRleHQgKz0gY29va2VkWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uc1tpXS5hY2NlcHQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gY29va2VkW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gJ2AnO1xuICAgIH1cbiAgICB2aXNpdFVuYXJ5KGV4cHIpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9IGAoJHtleHByLm9wZXJhdGlvbn1gO1xuICAgICAgICBpZiAoZXhwci5vcGVyYXRpb24uY2hhckNvZGVBdCgwKSA+PSAvKiBhICovIDk3KSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIuZXhwcmVzc2lvbi5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKSc7XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5KGV4cHIpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICcoJztcbiAgICAgICAgZXhwci5sZWZ0LmFjY2VwdCh0aGlzKTtcbiAgICAgICAgaWYgKGV4cHIub3BlcmF0aW9uLmNoYXJDb2RlQXQoMCkgPT09IC8qIGkgKi8gMTA1KSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gYCAke2V4cHIub3BlcmF0aW9ufSBgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGV4cHIub3BlcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmlnaHQuYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbiAgICB2aXNpdENvbmRpdGlvbmFsKGV4cHIpIHtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICcoJztcbiAgICAgICAgZXhwci5jb25kaXRpb24uYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJz8nO1xuICAgICAgICBleHByLnllcy5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnOic7XG4gICAgICAgIGV4cHIubm8uYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbiAgICB2aXNpdEFzc2lnbihleHByKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKCc7XG4gICAgICAgIGV4cHIudGFyZ2V0LmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9ICc9JztcbiAgICAgICAgZXhwci52YWx1ZS5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKSc7XG4gICAgfVxuICAgIHZpc2l0VmFsdWVDb252ZXJ0ZXIoZXhwcikge1xuICAgICAgICBjb25zdCBhcmdzID0gZXhwci5hcmdzO1xuICAgICAgICBleHByLmV4cHJlc3Npb24uYWNjZXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnRleHQgKz0gYHwke2V4cHIubmFtZX1gO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICc6JztcbiAgICAgICAgICAgIGFyZ3NbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QmluZGluZ0JlaGF2aW9yKGV4cHIpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGV4cHIuYXJncztcbiAgICAgICAgZXhwci5leHByZXNzaW9uLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0ICs9IGAmJHtleHByLm5hbWV9YDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSAnOic7XG4gICAgICAgICAgICBhcmdzW2ldLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEFycmF5QmluZGluZ1BhdHRlcm4oZXhwcikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGV4cHIuZWxlbWVudHM7XG4gICAgICAgIHRoaXMudGV4dCArPSAnWyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHNbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSAnXSc7XG4gICAgfVxuICAgIHZpc2l0T2JqZWN0QmluZGluZ1BhdHRlcm4oZXhwcikge1xuICAgICAgICBjb25zdCBrZXlzID0gZXhwci5rZXlzO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBleHByLnZhbHVlcztcbiAgICAgICAgdGhpcy50ZXh0ICs9ICd7JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBgJyR7a2V5c1tpXX0nOmA7XG4gICAgICAgICAgICB2YWx1ZXNbaV0uYWNjZXB0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSAnfSc7XG4gICAgfVxuICAgIHZpc2l0QmluZGluZ0lkZW50aWZpZXIoZXhwcikge1xuICAgICAgICB0aGlzLnRleHQgKz0gZXhwci5uYW1lO1xuICAgIH1cbiAgICB2aXNpdEh0bWxMaXRlcmFsKGV4cHIpIHsgdGhyb3cgbmV3IEVycm9yKCd2aXNpdEh0bWxMaXRlcmFsJyk7IH1cbiAgICB2aXNpdEZvck9mU3RhdGVtZW50KGV4cHIpIHtcbiAgICAgICAgZXhwci5kZWNsYXJhdGlvbi5hY2NlcHQodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dCArPSAnIG9mICc7XG4gICAgICAgIGV4cHIuaXRlcmFibGUuYWNjZXB0KHRoaXMpO1xuICAgIH1cbiAgICB2aXNpdEludGVycG9sYXRpb24oZXhwcikge1xuICAgICAgICBjb25zdCB7IHBhcnRzLCBleHByZXNzaW9ucyB9ID0gZXhwcjtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICB0aGlzLnRleHQgKz0gJyR7JztcbiAgICAgICAgdGhpcy50ZXh0ICs9IHBhcnRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uc1tpXS5hY2NlcHQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gcGFydHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCArPSAnfSc7XG4gICAgfVxuICAgIHdyaXRlQXJncyhhcmdzKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSAnKCc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzW2ldLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gJyknO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNob29zZVNjb3BlKGFjY2Vzc0hvc3RTY29wZSwgcywgaHMpIHtcbiAgICBpZiAoYWNjZXNzSG9zdFNjb3BlKSB7XG4gICAgICAgIGlmIChocyA9PT0gbnVsbCB8fCBocyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvc3Qgc2NvcGUgaXMgbWlzc2luZy4gQXJlIHlvdSB1c2luZyBgJGhvc3RgIG91dHNpZGUgdGhlIGBhdS1zbG90YD8gT3IgbWlzc2luZyB0aGUgYGF1LXNsb3RgIGF0dHJpYnV0ZT8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHM7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZXhwb3J0IGNsYXNzIEN1c3RvbUV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZXZhbHVhdGUoX2YsIF9zLCBfaHMsIF9sLCBfYykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmluZGluZ0JlaGF2aW9yRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZXhwcmVzc2lvbiwgbmFtZSwgYXJncykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmJlaGF2aW9yS2V5ID0gQmluZGluZ0JlaGF2aW9yLmtleUZyb20obmFtZSk7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDM4OTYyIC8qIEJpbmRpbmdCZWhhdmlvciAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgfVxuICAgIGFzc2lnbihmLCBzLCBocywgbCwgdmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uYXNzaWduKGYsIHMsIGhzLCBsLCB2YWwpO1xuICAgIH1cbiAgICBiaW5kKGYsIHMsIGhzLCBiKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb24uaGFzQmluZCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLmJpbmQoZiwgcywgaHMsIGIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJlaGF2aW9yID0gYi5sb2NhdG9yLmdldCh0aGlzLmJlaGF2aW9yS2V5KTtcbiAgICAgICAgaWYgKGJlaGF2aW9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluZGluZ0JlaGF2aW9yIG5hbWVkICcke3RoaXMubmFtZX0nIGNvdWxkIG5vdCBiZSBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gcmVnaXN0ZXIgaXQgYXMgYSBkZXBlbmRlbmN5P2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGJlaGF2aW9yIGluc3RhbmNlb2YgQmluZGluZ0JlaGF2aW9yRmFjdG9yeSkpIHtcbiAgICAgICAgICAgIGlmIChiW3RoaXMuYmVoYXZpb3JLZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBiW3RoaXMuYmVoYXZpb3JLZXldID0gYmVoYXZpb3I7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3IuYmluZC5jYWxsKGJlaGF2aW9yLCBmLCBzLCBocywgYiwgLi4udGhpcy5hcmdzLm1hcChhID0+IGEuZXZhbHVhdGUoZiwgcywgaHMsIGIubG9jYXRvciwgbnVsbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluZGluZ0JlaGF2aW9yIG5hbWVkICcke3RoaXMubmFtZX0nIGFscmVhZHkgYXBwbGllZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmJpbmQoZiwgcywgaHMsIGIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5iZWhhdmlvcktleTtcbiAgICAgICAgY29uc3QgJGIgPSBiO1xuICAgICAgICBpZiAoJGJba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICRiW2tleV0udW5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgJGJba2V5XS51bmJpbmQoZiwgcywgaHMsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJGJba2V5XSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uLmhhc1VuYmluZCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLnVuYmluZChmLCBzLCBocywgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5kaW5nQmVoYXZpb3IodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmFsdWVDb252ZXJ0ZXJFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihleHByZXNzaW9uLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY29udmVydGVyS2V5ID0gVmFsdWVDb252ZXJ0ZXIua2V5RnJvbShuYW1lKTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gMzY5MTMgLyogVmFsdWVDb252ZXJ0ZXIgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBjb25zdCB2YyA9IGwuZ2V0KHRoaXMuY29udmVydGVyS2V5KTtcbiAgICAgICAgaWYgKHZjID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWVDb252ZXJ0ZXIgbmFtZWQgJyR7dGhpcy5uYW1lfScgY291bGQgbm90IGJlIGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byByZWdpc3RlciBpdCBhcyBhIGRlcGVuZGVuY3k/YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZTogdGhlIGNhc3QgaXMgZXhwZWN0ZWQuIFRvIGNvbm5lY3QsIGl0IGp1c3QgbmVlZHMgdG8gYmUgYSBJQ29ubmVjdGFibGVcbiAgICAgICAgLy8gdGhvdWdoIHRvIHdvcmsgd2l0aCBzaWduYWwsIGl0IG5lZWRzIHRvIGhhdmUgYGhhbmRsZUNoYW5nZWBcbiAgICAgICAgLy8gc28gaGF2aW5nIGBoYW5kbGVDaGFuZ2VgIGFzIGEgZ3VhcmQgaW4gdGhlIGNvbm5lY3RhYmxlIGFzIGEgc2FmZSBtZWFzdXJlIGlzIG5lZWRlZFxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgc2lnbmFsZXIgd29ya3NcbiAgICAgICAgaWYgKGMgIT09IG51bGwgJiYgKCdoYW5kbGVDaGFuZ2UnIGluIGMpKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxzID0gdmMuc2lnbmFscztcbiAgICAgICAgICAgIGlmIChzaWduYWxzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxlciA9IGwuZ2V0KElTaWduYWxlcik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2lnbmFscy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbGVyLmFkZFNpZ25hbExpc3RlbmVyKHNpZ25hbHNbaV0sIGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3RvVmlldycgaW4gdmMpIHtcbiAgICAgICAgICAgIHJldHVybiB2Yy50b1ZpZXcodGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSwgLi4udGhpcy5hcmdzLm1hcChhID0+IGEuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgfVxuICAgIGFzc2lnbihmLCBzLCBocywgbCwgdmFsKSB7XG4gICAgICAgIGNvbnN0IHZjID0gbC5nZXQodGhpcy5jb252ZXJ0ZXJLZXkpO1xuICAgICAgICBpZiAodmMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZUNvbnZlcnRlciBuYW1lZCAnJHt0aGlzLm5hbWV9JyBjb3VsZCBub3QgYmUgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIHJlZ2lzdGVyIGl0IGFzIGEgZGVwZW5kZW5jeT9gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2Zyb21WaWV3JyBpbiB2Yykge1xuICAgICAgICAgICAgdmFsID0gdmMuZnJvbVZpZXcodmFsLCAuLi50aGlzLmFyZ3MubWFwKGEgPT4gYS5ldmFsdWF0ZShmLCBzLCBocywgbCwgbnVsbCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmFzc2lnbihmLCBzLCBocywgbCwgdmFsKTtcbiAgICB9XG4gICAgdW5iaW5kKF9mLCBfcywgX2hzLCBiKSB7XG4gICAgICAgIGNvbnN0IHZjID0gYi5sb2NhdG9yLmdldCh0aGlzLmNvbnZlcnRlcktleSk7XG4gICAgICAgIGlmICh2Yy5zaWduYWxzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYWxlciA9IGIubG9jYXRvci5nZXQoSVNpZ25hbGVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Yy5zaWduYWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0aGUgY2FzdCBpcyBjb3JyZWN0LCBhcyB0aGUgdmFsdWUgY29udmVydGVyIGV4cHJlc3Npb24gd291bGQgb25seSBhZGRcbiAgICAgICAgICAgIC8vIGEgSUNvbm5lY3RhYmxlIHRoYXQgYWxzbyBpbXBsZW1lbnRzIGBJU3Vic2NyaWJlcmAgaW50ZXJmYWNlIHRvIHRoZSBzaWduYWxlclxuICAgICAgICAgICAgc2lnbmFsZXIucmVtb3ZlU2lnbmFsTGlzdGVuZXIodmMuc2lnbmFsc1tpXSwgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYWx1ZUNvbnZlcnRlcih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBc3NpZ25FeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDgyMDggLyogQXNzaWduICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldC5hc3NpZ24oZiwgcywgaHMsIGwsIHRoaXMudmFsdWUuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpKTtcbiAgICB9XG4gICAgYXNzaWduKGYsIHMsIGhzLCBsLCB2YWwpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5hc3NpZ24oZiwgcywgaHMsIGwsIHZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldC5hc3NpZ24oZiwgcywgaHMsIGwsIHZhbCk7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXNzaWduKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbmRpdGlvbmFsRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCB5ZXMsIG5vKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnllcyA9IHllcztcbiAgICAgICAgdGhpcy5ubyA9IG5vO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA2MyAvKiBDb25kaXRpb25hbCAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpID8gdGhpcy55ZXMuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIDogdGhpcy5uby5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBY2Nlc3NUaGlzRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoYW5jZXN0b3IgPSAwKSB7XG4gICAgICAgIHRoaXMuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gMTc5MyAvKiBBY2Nlc3NUaGlzICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKF9mLCBzLCBocywgX2wsIF9jKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBBY2Nlc3NUaGlzRXhwcmVzc2lvbi4kaG9zdCkge1xuICAgICAgICAgICAgcyA9IGNob29zZVNjb3BlKHRydWUsIHMsIGhzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2MgPSBzLm92ZXJyaWRlQ29udGV4dDtcbiAgICAgICAgbGV0IGN1cnJlbnRTY29wZSA9IHM7XG4gICAgICAgIGxldCBpID0gdGhpcy5hbmNlc3RvcjtcbiAgICAgICAgd2hpbGUgKGktLSAmJiBvYykge1xuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gY3VycmVudFNjb3BlLnBhcmVudFNjb3BlO1xuICAgICAgICAgICAgb2MgPSBjdXJyZW50U2NvcGU/Lm92ZXJyaWRlQ29udGV4dCA/PyBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpIDwgMSAmJiBvYyA/IG9jLmJpbmRpbmdDb250ZXh0IDogdm9pZCAwO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QWNjZXNzVGhpcyh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbkFjY2Vzc1RoaXNFeHByZXNzaW9uLiR0aGlzID0gbmV3IEFjY2Vzc1RoaXNFeHByZXNzaW9uKDApO1xuLy8gJGhvc3QgYW5kICR0aGlzIGFyZSBsb29zZWx5IHRoZSBzYW1lIHRoaW5nLiAkaG9zdCBpcyB1c2VkIGluIHRoZSBjb250ZXh0IG9mIGBhdS1zbG90YCB3aXRoIHRoZSBwcmltYXJ5IG9iamVjdGl2ZSBvZiBkZXRlcm1pbmluZyB0aGUgcy5cbkFjY2Vzc1RoaXNFeHByZXNzaW9uLiRob3N0ID0gbmV3IEFjY2Vzc1RoaXNFeHByZXNzaW9uKDApO1xuQWNjZXNzVGhpc0V4cHJlc3Npb24uJHBhcmVudCA9IG5ldyBBY2Nlc3NUaGlzRXhwcmVzc2lvbigxKTtcbmV4cG9ydCBjbGFzcyBBY2Nlc3NTY29wZUV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFuY2VzdG9yID0gMCwgYWNjZXNzSG9zdFNjb3BlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbmNlc3RvciA9IGFuY2VzdG9yO1xuICAgICAgICB0aGlzLmFjY2Vzc0hvc3RTY29wZSA9IGFjY2Vzc0hvc3RTY29wZTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gMTAwODIgLyogQWNjZXNzU2NvcGUgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIF9sLCBjKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IEJpbmRpbmdDb250ZXh0LmdldChjaG9vc2VTY29wZSh0aGlzLmFjY2Vzc0hvc3RTY29wZSwgcywgaHMpLCB0aGlzLm5hbWUsIHRoaXMuYW5jZXN0b3IsIGYsIGhzKTtcbiAgICAgICAgaWYgKGMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGMub2JzZXJ2ZVByb3BlcnR5KG9iaiwgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmFsdWF0ZWRWYWx1ZSA9IG9ialt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoZiAmIDQgLyogaXNTdHJpY3RCaW5kaW5nU3RyYXRlZ3kgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZhbHVhdGVkVmFsdWUgPT0gbnVsbCA/ICcnIDogZXZhbHVhdGVkVmFsdWU7XG4gICAgfVxuICAgIGFzc2lnbihmLCBzLCBocywgX2wsIHZhbCkge1xuICAgICAgICBjb25zdCBvYmogPSBCaW5kaW5nQ29udGV4dC5nZXQoY2hvb3NlU2NvcGUodGhpcy5hY2Nlc3NIb3N0U2NvcGUsIHMsIGhzKSwgdGhpcy5uYW1lLCB0aGlzLmFuY2VzdG9yLCBmLCBocyk7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmouJG9ic2VydmVycz8uW3RoaXMubmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9iai4kb2JzZXJ2ZXJzW3RoaXMubmFtZV0uc2V0VmFsdWUodmFsLCBmKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialt0aGlzLm5hbWVdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QWNjZXNzU2NvcGUodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWNjZXNzTWVtYmVyRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob2JqZWN0LCBuYW1lKSB7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA5MzIzIC8qIEFjY2Vzc01lbWJlciAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCAoZiAmIDIwNDggLyogb2JzZXJ2ZUxlYWZQcm9wZXJ0aWVzT25seSAqLykgPiAwID8gbnVsbCA6IGMpO1xuICAgICAgICBpZiAoZiAmIDQgLyogaXNTdHJpY3RCaW5kaW5nU3RyYXRlZ3kgKi8pIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjLm9ic2VydmVQcm9wZXJ0eShpbnN0YW5jZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVt0aGlzLm5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjICE9PSBudWxsICYmIGluc3RhbmNlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBjLm9ic2VydmVQcm9wZXJ0eShpbnN0YW5jZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2UgPyBpbnN0YW5jZVt0aGlzLm5hbWVdIDogJyc7XG4gICAgfVxuICAgIGFzc2lnbihmLCBzLCBocywgbCwgdmFsKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBudWxsKTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iai4kb2JzZXJ2ZXJzICE9PSB2b2lkIDAgJiYgb2JqLiRvYnNlcnZlcnNbdGhpcy5uYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgb2JqLiRvYnNlcnZlcnNbdGhpcy5uYW1lXS5zZXRWYWx1ZSh2YWwsIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW3RoaXMubmFtZV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5hc3NpZ24oZiwgcywgaHMsIGwsIHsgW3RoaXMubmFtZV06IHZhbCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFjY2Vzc01lbWJlcih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBY2Nlc3NLZXllZEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG9iamVjdCwga2V5KSB7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gOTMyNCAvKiBBY2Nlc3NLZXllZCAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMub2JqZWN0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCAoZiAmIDIwNDggLyogb2JzZXJ2ZUxlYWZQcm9wZXJ0aWVzT25seSAqLykgPiAwID8gbnVsbCA6IGMpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCAoZiAmIDIwNDggLyogb2JzZXJ2ZUxlYWZQcm9wZXJ0aWVzT25seSAqLykgPiAwID8gbnVsbCA6IGMpO1xuICAgICAgICAgICAgaWYgKGMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjLm9ic2VydmVQcm9wZXJ0eShpbnN0YW5jZSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFzc2lnbihmLCBzLCBocywgbCwgdmFsKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5vYmplY3QuZXZhbHVhdGUoZiwgcywgaHMsIGwsIG51bGwpO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleS5ldmFsdWF0ZShmLCBzLCBocywgbCwgbnVsbCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZVtrZXldID0gdmFsO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFjY2Vzc0tleWVkKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxTY29wZUV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIGFuY2VzdG9yID0gMCwgYWNjZXNzSG9zdFNjb3BlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5hbmNlc3RvciA9IGFuY2VzdG9yO1xuICAgICAgICB0aGlzLmFjY2Vzc0hvc3RTY29wZSA9IGFjY2Vzc0hvc3RTY29wZTtcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gMTQ0OCAvKiBDYWxsU2NvcGUgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgcyA9IGNob29zZVNjb3BlKHRoaXMuYWNjZXNzSG9zdFNjb3BlLCBzLCBocyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3MubWFwKGEgPT4gYS5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gQmluZGluZ0NvbnRleHQuZ2V0KHMsIHRoaXMubmFtZSwgdGhpcy5hbmNlc3RvciwgZiwgaHMpO1xuICAgICAgICAvLyBpZGVhbGx5LCBzaG91bGQgb2JzZXJ2ZSBwcm9wZXJ0eSByZXByZXNlbnRzIGJ5IHRoaXMubmFtZSBhcyB3ZWxsXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgY291bGQgYmUgY2hhbmdlZFxuICAgICAgICAvLyB0b2RvOiBkaWQgaXQgZXZlciBzdXJwcmlzZSBhbnlvbmU/XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBnZXRGdW5jdGlvbihmLCBjb250ZXh0LCB0aGlzLm5hbWUpO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhbGxTY29wZSh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsTWVtYmVyRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAxMTYxIC8qIENhbGxNZW1iZXIgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLm9iamVjdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgKGYgJiAyMDQ4IC8qIG9ic2VydmVMZWFmUHJvcGVydGllc09ubHkgKi8pID4gMCA/IG51bGwgOiBjKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuYXJncy5tYXAoYSA9PiBhLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSk7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBnZXRGdW5jdGlvbihmLCBpbnN0YW5jZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2FsbE1lbWJlcih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsRnVuY3Rpb25FeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmdW5jLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDExNjIgLyogQ2FsbEZ1bmN0aW9uICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmZ1bmMuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKC4uLnRoaXMuYXJncy5tYXAoYSA9PiBhLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGYgJiAxMjggLyogbXVzdEV2YWx1YXRlICovKSAmJiAoZnVuYyA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cHJlc3Npb24gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYWxsRnVuY3Rpb24odGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmluYXJ5RXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA0NiAvKiBCaW5hcnkgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSAmJiB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgfHwgdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgPT0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpID09PSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSAhPSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgIT09IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnaW5zdGFuY2VvZic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmlnaHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgaW5zdGFuY2VvZiByaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW4nOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgaW4gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vdGU6IGF1dG9Db252ZXJ0QWRkIChhbmQgdGhlIG51bGwgY2hlY2spIGlzIHJlbW92ZWQgYmVjYXVzZSB0aGUgZGVmYXVsdCBzcGVjIGJlaGF2aW9yIGlzIGFscmVhZHkgbGFyZ2VseSBzaW1pbGFyXG4gICAgICAgICAgICAvLyBhbmQgd2hlcmUgaXQgaXNuJ3QsIHlvdSBraW5kIG9mIHdhbnQgaXQgdG8gYmVoYXZlIGxpa2UgdGhlIHNwZWMgYW55d2F5IChlLmcuIHJldHVybiBOYU4gd2hlbiBhZGRpbmcgYSBudW1iZXIgdG8gdW5kZWZpbmVkKVxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBidWdzIGluIHVzZXIgY29kZSBlYXNpZXIgdG8gdHJhY2sgZG93biBmb3IgZW5kIHVzZXJzXG4gICAgICAgICAgICAvLyBhbHNvLCBza2lwcGluZyB0aGVzZSBjaGVja3MgYW5kIGxlYXZpbmcgaXQgdG8gdGhlIHJ1bnRpbWUgaXMgYSBuaWNlIGxpdHRsZSBwZXJmIGJvb3N0IGFuZCBzaW1wbGlmaWVzIG91ciBjb2RlXG4gICAgICAgICAgICBjYXNlICcrJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICAgICAgaWYgKChmICYgNCAvKiBpc1N0cmljdEJpbmRpbmdTdHJhdGVneSAqLykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICBpZiAoIWxlZnQgfHwgIXJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlck9yQmlnSW50KGxlZnQpIHx8IGlzTnVtYmVyT3JCaWdJbnQocmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGxlZnQgfHwgMCkgKyAocmlnaHQgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nT3JEYXRlKGxlZnQpIHx8IGlzU3RyaW5nT3JEYXRlKHJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsZWZ0IHx8ICcnKSArIChyaWdodCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIC0gdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSAqIHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgLyB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpICUgdGhpcy5yaWdodC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSA8IHRoaXMucmlnaHQuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykgPiB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSA8PSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSA+PSB0aGlzLnJpZ2h0LmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGJpbmFyeSBvcGVyYXRvcjogJyR7dGhpcy5vcGVyYXRpb259J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnkodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5hcnlFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcGVyYXRpb24sIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDM5IC8qIFVuYXJ5ICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZvaWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICd0eXBlb2YnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKGYgfCA0IC8qIGlzU3RyaWN0QmluZGluZ1N0cmF0ZWd5ICovLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gLXRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gK3RoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB1bmFyeSBvcGVyYXRvcjogJyR7dGhpcy5vcGVyYXRpb259J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRVbmFyeSh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAxNzkyNSAvKiBQcmltaXRpdmVMaXRlcmFsICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKF9mLCBfcywgX2hzLCBfbCwgX2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmltaXRpdmVMaXRlcmFsKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJHVuZGVmaW5lZCA9IG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbih2b2lkIDApO1xuUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJG51bGwgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24obnVsbCk7XG5QcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbi4kdHJ1ZSA9IG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbih0cnVlKTtcblByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uLiRmYWxzZSA9IG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbihmYWxzZSk7XG5QcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbi4kZW1wdHkgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24oJycpO1xuZXhwb3J0IGNsYXNzIEh0bWxMaXRlcmFsRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocGFydHMpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA1MSAvKiBIdG1sTGl0ZXJhbCAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMucGFydHNbaV0uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaiwgX3Byb2plY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRIdG1sTGl0ZXJhbCh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJheUxpdGVyYWxFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDE3OTU1IC8qIEFycmF5TGl0ZXJhbCAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShmLCBzLCBocywgbCwgYykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5tYXAoZSA9PiBlLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSk7XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheUxpdGVyYWwodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5BcnJheUxpdGVyYWxFeHByZXNzaW9uLiRlbXB0eSA9IG5ldyBBcnJheUxpdGVyYWxFeHByZXNzaW9uKGVtcHR5QXJyYXkpO1xuZXhwb3J0IGNsYXNzIE9iamVjdExpdGVyYWxFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXlzLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDE3OTU2IC8qIE9iamVjdExpdGVyYWwgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGluc3RhbmNlW3RoaXMua2V5c1tpXV0gPSB0aGlzLnZhbHVlc1tpXS5ldmFsdWF0ZShmLCBzLCBocywgbCwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0T2JqZWN0TGl0ZXJhbCh0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbk9iamVjdExpdGVyYWxFeHByZXNzaW9uLiRlbXB0eSA9IG5ldyBPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihlbXB0eUFycmF5LCBlbXB0eUFycmF5KTtcbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZUV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvb2tlZCwgZXhwcmVzc2lvbnMgPSBlbXB0eUFycmF5KSB7XG4gICAgICAgIHRoaXMuY29va2VkID0gY29va2VkO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDE3OTU4IC8qIFRlbXBsYXRlICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvb2tlZFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nKHRoaXMuZXhwcmVzc2lvbnNbaV0uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmNvb2tlZFtpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRlbXBsYXRlKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuVGVtcGxhdGVFeHByZXNzaW9uLiRlbXB0eSA9IG5ldyBUZW1wbGF0ZUV4cHJlc3Npb24oWycnXSk7XG5leHBvcnQgY2xhc3MgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb29rZWQsIHJhdywgZnVuYywgZXhwcmVzc2lvbnMgPSBlbXB0eUFycmF5KSB7XG4gICAgICAgIHRoaXMuY29va2VkID0gY29va2VkO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIGNvb2tlZC5yYXcgPSByYXc7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDExOTcgLyogVGFnZ2VkVGVtcGxhdGUgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuZXhwcmVzc2lvbnMubWFwKGUgPT4gZS5ldmFsdWF0ZShmLCBzLCBocywgbCwgYykpO1xuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5mdW5jLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlZnQtaGFuZCBzaWRlIG9mIHRhZ2dlZCB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKHRoaXMuY29va2VkLCAuLi5yZXN1bHRzKTtcbiAgICB9XG4gICAgYXNzaWduKF9mLCBfcywgX2hzLCBfbCwgX29iaikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRhZ2dlZFRlbXBsYXRlKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFycmF5QmluZGluZ1BhdHRlcm4ge1xuICAgIC8vIFdlJ2xsIGVpdGhlciBoYXZlIGVsZW1lbnRzLCBvciBrZXlzK3ZhbHVlcywgYnV0IG5ldmVyIGFsbCAzXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA2NTU1NiAvKiBBcnJheUJpbmRpbmdQYXR0ZXJuICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKF9mLCBfcywgX2hzLCBfbCwgX2MpIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQgY29tZSBhZnRlciBiYXRjaFxuICAgICAgICAvLyBhcyBhIGRlc3RydWN0dXJpbmcgZXhwcmVzc2lvbiBsaWtlIFt4LCB5XSA9IHZhbHVlXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IHRyaWdnZXIgY2hhbmdlIG9ubHkgb25jZTpcbiAgICAgICAgLy8gYmF0Y2goKCkgPT4ge1xuICAgICAgICAvLyAgIG9iamVjdC54ID0gdmFsdWVbMF1cbiAgICAgICAgLy8gICBvYmplY3QueSA9IHZhbHVlWzFdXG4gICAgICAgIC8vIH0pXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGluc3RlYWQgb2YgdHdpY2U6XG4gICAgICAgIC8vIG9iamVjdC54ID0gdmFsdWVbMF1cbiAgICAgICAgLy8gb2JqZWN0LnkgPSB2YWx1ZVsxXVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheUJpbmRpbmdQYXR0ZXJuKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9iamVjdEJpbmRpbmdQYXR0ZXJuIHtcbiAgICAvLyBXZSdsbCBlaXRoZXIgaGF2ZSBlbGVtZW50cywgb3Iga2V5cyt2YWx1ZXMsIGJ1dCBuZXZlciBhbGwgM1xuICAgIGNvbnN0cnVjdG9yKGtleXMsIHZhbHVlcykge1xuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZ2V0ICRraW5kKCkgeyByZXR1cm4gNjU1NTcgLyogT2JqZWN0QmluZGluZ1BhdHRlcm4gKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoX2YsIF9zLCBfaHMsIF9sLCBfYykge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIHNpbWlsYXIgdG8gYXJyYXkgYmluZGluZyBhc3QsIHRoaXMgc2hvdWxkIG9ubHkgY29tZSBhZnRlciBiYXRjaFxuICAgICAgICAvLyBmb3IgYSBzaW5nbGUgbm90aWZpY2F0aW9uIHBlciBkZXN0cnVjdGluZyxcbiAgICAgICAgLy8gcmVnYXJkbGVzcyBudW1iZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudHMgb24gdGhlIHNjb3BlIGJpbmRpbmcgY29udGV4dFxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRPYmplY3RCaW5kaW5nUGF0dGVybih0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBVbnBhcnNlci51bnBhcnNlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCaW5kaW5nSWRlbnRpZmllciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiA2NTU1OCAvKiBCaW5kaW5nSWRlbnRpZmllciAqLzsgfVxuICAgIGdldCBoYXNCaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaGFzVW5iaW5kKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBldmFsdWF0ZShfZiwgX3MsIF9ocywgX2wsIF9jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluZGluZ0lkZW50aWZpZXIodGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gVW5wYXJzZXIudW5wYXJzZSh0aGlzKTtcbiAgICB9XG59XG5jb25zdCB0b1N0cmluZ1RhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRpb24tc3RhdGVtZW50c1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZm9yLWluLWFuZC1mb3Itb2Ytc3RhdGVtZW50c1xuZXhwb3J0IGNsYXNzIEZvck9mU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkZWNsYXJhdGlvbiwgaXRlcmFibGUpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIGdldCAka2luZCgpIHsgcmV0dXJuIDYxOTkgLyogRm9yT2ZTdGF0ZW1lbnQgKi87IH1cbiAgICBnZXQgaGFzQmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGhhc1VuYmluZCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmFibGUuZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpO1xuICAgIH1cbiAgICBhc3NpZ24oX2YsIF9zLCBfaHMsIF9sLCBfb2JqKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvdW50KF9mLCByZXN1bHQpIHtcbiAgICAgICAgc3dpdGNoICh0b1N0cmluZ1RhZy5jYWxsKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzogcmV0dXJuIHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE1hcF0nOiByZXR1cm4gcmVzdWx0LnNpemU7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IFNldF0nOiByZXR1cm4gcmVzdWx0LnNpemU7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOiByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBOdWxsXSc6IHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBVbmRlZmluZWRdJzogcmV0dXJuIDA7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3VudCAke3RvU3RyaW5nVGFnLmNhbGwocmVzdWx0KX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHQtbGluZVxuICAgIGl0ZXJhdGUoZiwgcmVzdWx0LCBmdW5jKSB7XG4gICAgICAgIHN3aXRjaCAodG9TdHJpbmdUYWcuY2FsbChyZXN1bHQpKSB7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiAkYXJyYXkocmVzdWx0LCBmdW5jKTtcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgTWFwXSc6IHJldHVybiAkbWFwKHJlc3VsdCwgZnVuYyk7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IFNldF0nOiByZXR1cm4gJHNldChyZXN1bHQsIGZ1bmMpO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzogcmV0dXJuICRudW1iZXIocmVzdWx0LCBmdW5jKTtcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOiByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOiByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpdGVyYXRlIG92ZXIgJHt0b1N0cmluZ1RhZy5jYWxsKHJlc3VsdCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZChmLCBzLCBocywgYikge1xuICAgICAgICBpZiAodGhpcy5pdGVyYWJsZS5oYXNCaW5kKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJhYmxlLmJpbmQoZiwgcywgaHMsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZChmLCBzLCBocywgYikge1xuICAgICAgICBpZiAodGhpcy5pdGVyYWJsZS5oYXNVbmJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlcmFibGUudW5iaW5kKGYsIHMsIGhzLCBiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZvck9mU3RhdGVtZW50KHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuLypcbiogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBmYXIgc2ltcGxlciB0aGFuIHRoZSBvbmUgaW4gdkN1cnJlbnQgYW5kIG1pZ2h0IGJlIG1pc3NpbmcgaW1wb3J0YW50IHN0dWZmIChub3Qgc3VyZSB5ZXQpXG4qIHNvIHdoaWxlIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgaWRlbnRpY2FsIHRvIFRlbXBsYXRlIGFuZCB3ZSBjb3VsZCByZXVzZSB0aGF0IG9uZSwgd2UgZG9uJ3Qgd2FudCB0byBsb2NrIG91dHNlbHZlcyBpbiB0byBwb3RlbnRpYWxseSB0aGUgd3JvbmcgYWJzdHJhY3Rpb25cbiogYnV0IHRoaXMgY2xhc3MgbWlnaHQgYmUgYSBjYW5kaWRhdGUgZm9yIHJlbW92YWwgaWYgaXQgdHVybnMgb3V0IGl0IGRvZXMgcHJvdmlkZSBhbGwgd2UgbmVlZFxuKi9cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJ0cywgZXhwcmVzc2lvbnMgPSBlbXB0eUFycmF5KSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLmlzTXVsdGkgPSBleHByZXNzaW9ucy5sZW5ndGggPiAxO1xuICAgICAgICB0aGlzLmZpcnN0RXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zWzBdO1xuICAgIH1cbiAgICBnZXQgJGtpbmQoKSB7IHJldHVybiAyNCAvKiBJbnRlcnBvbGF0aW9uICovOyB9XG4gICAgZ2V0IGhhc0JpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBoYXNVbmJpbmQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXVsdGkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnRzWzBdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZyh0aGlzLmV4cHJlc3Npb25zW2ldLmV2YWx1YXRlKGYsIHMsIGhzLCBsLCBjKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMucGFydHNbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBhcnRzWzBdfSR7dGhpcy5maXJzdEV4cHJlc3Npb24uZXZhbHVhdGUoZiwgcywgaHMsIGwsIGMpfSR7dGhpcy5wYXJ0c1sxXX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2lnbihfZiwgX3MsIF9ocywgX2wsIF9vYmopIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFVucGFyc2VyLnVucGFyc2UodGhpcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RnVuY3Rpb24oZiwgb2JqLCBuYW1lKSB7XG4gICAgY29uc3QgZnVuYyA9IG9iaiA9PSBudWxsID8gbnVsbCA6IG9ialtuYW1lXTtcbiAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIGlmICghKGYgJiAxMjggLyogbXVzdEV2YWx1YXRlICovKSAmJiBmdW5jID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJyR7bmFtZX0nIHRvIGJlIGEgZnVuY3Rpb25gKTtcbn1cbmZ1bmN0aW9uICRhcnJheShyZXN1bHQsIGZ1bmMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSByZXN1bHQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBmdW5jKHJlc3VsdCwgaSwgcmVzdWx0W2ldKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkbWFwKHJlc3VsdCwgZnVuYykge1xuICAgIGNvbnN0IGFyciA9IEFycmF5KHJlc3VsdC5zaXplKTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVzdWx0LmVudHJpZXMoKSkge1xuICAgICAgICBhcnJbKytpXSA9IGVudHJ5O1xuICAgIH1cbiAgICAkYXJyYXkoYXJyLCBmdW5jKTtcbn1cbmZ1bmN0aW9uICRzZXQocmVzdWx0LCBmdW5jKSB7XG4gICAgY29uc3QgYXJyID0gQXJyYXkocmVzdWx0LnNpemUpO1xuICAgIGxldCBpID0gLTE7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcmVzdWx0LmtleXMoKSkge1xuICAgICAgICBhcnJbKytpXSA9IGtleTtcbiAgICB9XG4gICAgJGFycmF5KGFyciwgZnVuYyk7XG59XG5mdW5jdGlvbiAkbnVtYmVyKHJlc3VsdCwgZnVuYykge1xuICAgIGNvbnN0IGFyciA9IEFycmF5KHJlc3VsdCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQ7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBpO1xuICAgIH1cbiAgICAkYXJyYXkoYXJyLCBmdW5jKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC5qcy5tYXAiLCJpbXBvcnQgeyBkZWYsIGRlZmluZUhpZGRlblByb3AsIGVuc3VyZVByb3RvIH0gZnJvbSAnLi4vdXRpbGl0aWVzLW9iamVjdHMuanMnO1xuaW1wb3J0IHsgZ2V0QXJyYXlPYnNlcnZlciB9IGZyb20gJy4uL29ic2VydmF0aW9uL2FycmF5LW9ic2VydmVyLmpzJztcbmltcG9ydCB7IGdldFNldE9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24vc2V0LW9ic2VydmVyLmpzJztcbmltcG9ydCB7IGdldE1hcE9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2YXRpb24vbWFwLW9ic2VydmVyLmpzJztcbi8vIFRPRE86IGFkZCBjb25uZWN0LXF1ZXVlIChvciBzb21ldGhpbmcgc2ltaWxhcikgYmFjayBpbiB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBpcyB3b3JraW5nLCB0byBpbXByb3ZlIHN0YXJ0dXAgdGltZVxuY29uc3Qgc2xvdE5hbWVzID0gW107XG5jb25zdCB2ZXJzaW9uU2xvdE5hbWVzID0gW107XG5sZXQgbGFzdFNsb3QgPSAtMTtcbmZ1bmN0aW9uIGVuc3VyZUVub3VnaFNsb3ROYW1lcyhjdXJyZW50U2xvdCkge1xuICAgIGlmIChjdXJyZW50U2xvdCA9PT0gbGFzdFNsb3QpIHtcbiAgICAgICAgbGFzdFNsb3QgKz0gNTtcbiAgICAgICAgY29uc3QgaWkgPSBzbG90TmFtZXMubGVuZ3RoID0gdmVyc2lvblNsb3ROYW1lcy5sZW5ndGggPSBsYXN0U2xvdCArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSBjdXJyZW50U2xvdCArIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBzbG90TmFtZXNbaV0gPSBgX28ke2l9YDtcbiAgICAgICAgICAgIHZlcnNpb25TbG90TmFtZXNbaV0gPSBgX3Yke2l9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmVuc3VyZUVub3VnaFNsb3ROYW1lcygtMSk7XG5mdW5jdGlvbiBvYnNlcnZlUHJvcGVydHkob2JqLCBrZXkpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJMb2NhdG9yLmdldE9ic2VydmVyKG9iaiwga2V5KTtcbiAgICAvKiBOb3RlOiB3ZSBuZWVkIHRvIGNhc3QgaGVyZSBiZWNhdXNlIHdlIGNhbiBpbmRlZWQgZ2V0IGFuIGFjY2Vzc29yIGluc3RlYWQgb2YgYW4gb2JzZXJ2ZXIsXG4gICAgICogIGluIHdoaWNoIGNhc2UgdGhlIGNhbGwgdG8gb2JzZXJ2ZXIuc3Vic2NyaWJlIHdpbGwgdGhyb3cuIEl0J3Mgbm90IHZlcnkgY2xlYW4gYW5kIHdlIGNhbiBzb2x2ZSB0aGlzIGluIDIgd2F5czpcbiAgICAgKiAgMS4gRmFpbCBlYXJsaWVyOiBvbmx5IGxldCB0aGUgbG9jYXRvciByZXNvbHZlIG9ic2VydmVycyBmcm9tIC5nZXRPYnNlcnZlciwgYW5kIHRocm93IGlmIG5vIGJyYW5jaGVzIGFyZSBsZWZ0IChlLmcuIGl0IHdvdWxkIG90aGVyd2lzZSByZXR1cm4gYW4gYWNjZXNzb3IpXG4gICAgICogIDIuIEZhaWwgc2lsZW50bHkgKHdpdGhvdXQgdGhyb3dpbmcpOiBnaXZlIGFsbCBhY2Nlc3NvcnMgYSBuby1vcCBzdWJzY3JpYmUgbWV0aG9kXG4gICAgICpcbiAgICAgKiBXZSdsbCBwcm9iYWJseSB3YW50IHRvIGltcGxlbWVudCBzb21lIGdsb2JhbCBjb25maWd1cmF0aW9uIChsaWtlIGEgXCJzdHJpY3RcIiB0b2dnbGUpIHNvIHVzZXJzIGNhbiBwaWNrIGJldHdlZW4gZW5mb3JjZWQgY29ycmVjdG5lc3MgdnMuIGVhc2Utb2YtdXNlXG4gICAgICovXG4gICAgdGhpcy5vYnMuYWRkKG9ic2VydmVyKTtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyUmVjb3JkKCkge1xuICAgIGNvbnN0IHJlY29yZCA9IG5ldyBCaW5kaW5nT2JzZXJ2ZXJSZWNvcmQodGhpcyk7XG4gICAgZGVmaW5lSGlkZGVuUHJvcCh0aGlzLCAnb2JzJywgcmVjb3JkKTtcbiAgICByZXR1cm4gcmVjb3JkO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZUNvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICAgIGxldCBvYnM7XG4gICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBvYnMgPSBnZXRBcnJheU9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG9icyA9IGdldFNldE9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG9icyA9IGdldE1hcE9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbmlzZWQgY29sbGVjdGlvbiB0eXBlLicpO1xuICAgIH1cbiAgICB0aGlzLm9icy5hZGQob2JzKTtcbn1cbmZ1bmN0aW9uIG5vb3BIYW5kbGVDaGFuZ2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgXCJoYW5kbGVDaGFuZ2VcIiBub3QgaW1wbGVtZW50ZWQnKTtcbn1cbmZ1bmN0aW9uIG5vb3BIYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIFwiaGFuZGxlQ29sbGVjdGlvbkNoYW5nZVwiIG5vdCBpbXBsZW1lbnRlZCcpO1xufVxuZXhwb3J0IGNsYXNzIEJpbmRpbmdPYnNlcnZlclJlY29yZCB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZykge1xuICAgICAgICB0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgY29ubmVjdGFibGUuYXNzaWduSWRUbyh0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZy5pbnRlcmNlcHRvci5oYW5kbGVDaGFuZ2UodmFsdWUsIG9sZFZhbHVlLCBmbGFncyk7XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoaW5kZXhNYXAsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZy5pbnRlcmNlcHRvci5oYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCwgYW5kIHN1YnNjcmliZSB0byBhIGdpdmVuIG9ic2VydmVyXG4gICAgICovXG4gICAgYWRkKG9ic2VydmVyKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIG9ic2VydmVyLlxuICAgICAgICBjb25zdCBvYnNlcnZlclNsb3RzID0gdGhpcy5jb3VudCA9PSBudWxsID8gMCA6IHRoaXMuY291bnQ7XG4gICAgICAgIGxldCBpID0gb2JzZXJ2ZXJTbG90cztcbiAgICAgICAgd2hpbGUgKGktLSAmJiB0aGlzW3Nsb3ROYW1lc1tpXV0gIT09IG9ic2VydmVyKVxuICAgICAgICAgICAgO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGFscmVhZHkgb2JzZXJ2aW5nLCBwdXQgdGhlIG9ic2VydmVyIGluIGFuIG9wZW4gc2xvdCBhbmQgc3Vic2NyaWJlLlxuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXNbc2xvdE5hbWVzW2ldXSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbc2xvdE5hbWVzW2ldXSA9IG9ic2VydmVyO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJbdGhpcy5pZF0gfD0gOCAvKiB1cGRhdGVUYXJnZXQgKi87XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHNsb3QgY291bnQuXG4gICAgICAgICAgICBpZiAoaSA9PT0gb2JzZXJ2ZXJTbG90cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzW3ZlcnNpb25TbG90TmFtZXNbaV1dID0gdGhpcy52ZXJzaW9uO1xuICAgICAgICBlbnN1cmVFbm91Z2hTbG90TmFtZXMoaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIHRoZSBvYnNlcnZlcnMgdGhhdCBhcmUgbm90IHVwIHRvIGRhdGUgd2l0aCB0aGUgcmVjb3JkIHZlcnNpb25cbiAgICAgKi9cbiAgICBjbGVhcihhbGwpIHtcbiAgICAgICAgY29uc3Qgc2xvdENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgbGV0IHNsb3ROYW1lO1xuICAgICAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgaWYgKGFsbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBzbG90Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gc2xvdE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyID0gdGhpc1tzbG90TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzbG90TmFtZV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLnVuc3Vic2NyaWJlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlclt0aGlzLmlkXSAmPSB+OCAvKiB1cGRhdGVUYXJnZXQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHNsb3RDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbdmVyc2lvblNsb3ROYW1lc1tpXV0gIT09IHRoaXMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBzbG90TmFtZSA9IHNsb3ROYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIgPSB0aGlzW3Nsb3ROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbc2xvdE5hbWVdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlclt0aGlzLmlkXSAmPSB+OCAvKiB1cGRhdGVUYXJnZXQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb25uZWN0YWJsZURlY29yYXRvcih0YXJnZXQpIHtcbiAgICBjb25zdCBwcm90byA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgZW5zdXJlUHJvdG8ocHJvdG8sICdvYnNlcnZlUHJvcGVydHknLCBvYnNlcnZlUHJvcGVydHksIHRydWUpO1xuICAgIGVuc3VyZVByb3RvKHByb3RvLCAnb2JzZXJ2ZUNvbGxlY3Rpb24nLCBvYnNlcnZlQ29sbGVjdGlvbiwgdHJ1ZSk7XG4gICAgZGVmKHByb3RvLCAnb2JzJywgeyBnZXQ6IGdldE9ic2VydmVyUmVjb3JkIH0pO1xuICAgIC8vIG9wdGlvbmFsbHkgYWRkIHRoZXNlIHR3byBtZXRob2RzIHRvIG5vcm1hbGl6ZSBhIGNvbm5lY3RhYmxlIGltcGxcbiAgICBlbnN1cmVQcm90byhwcm90bywgJ2hhbmRsZUNoYW5nZScsIG5vb3BIYW5kbGVDaGFuZ2UpO1xuICAgIGVuc3VyZVByb3RvKHByb3RvLCAnaGFuZGxlQ29sbGVjdGlvbkNoYW5nZScsIG5vb3BIYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RhYmxlKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgPT0gbnVsbCA/IGNvbm5lY3RhYmxlRGVjb3JhdG9yIDogY29ubmVjdGFibGVEZWNvcmF0b3IodGFyZ2V0KTtcbn1cbmxldCBpZFZhbHVlID0gMDtcbmNvbm5lY3RhYmxlLmFzc2lnbklkVG8gPSAoaW5zdGFuY2UpID0+IHtcbiAgICBpbnN0YW5jZS5pZCA9ICsraWRWYWx1ZTtcbn07XG4vLyBAY29ubmVjdGFibGVcbmV4cG9ydCBjbGFzcyBCaW5kaW5nTWVkaWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGtleSwgYmluZGluZywgb2JzZXJ2ZXJMb2NhdG9yLCBsb2NhdG9yKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuICAgICAgICB0aGlzLm9ic2VydmVyTG9jYXRvciA9IG9ic2VydmVyTG9jYXRvcjtcbiAgICAgICAgdGhpcy5sb2NhdG9yID0gbG9jYXRvcjtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvciA9IHRoaXM7XG4gICAgICAgIGNvbm5lY3RhYmxlLmFzc2lnbklkVG8odGhpcyk7XG4gICAgfVxuICAgICRiaW5kKGZsYWdzLCBzY29wZSwgaG9zdFNjb3BlLCBwcm9qZWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgJHVuYmluZChmbGFncykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nW3RoaXMua2V5XShuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSwgZmxhZ3MpO1xuICAgIH1cbn1cbmNvbm5lY3RhYmxlRGVjb3JhdG9yKEJpbmRpbmdNZWRpYXRvcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0YWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBESSwgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgQWNjZXNzS2V5ZWRFeHByZXNzaW9uLCBBY2Nlc3NNZW1iZXJFeHByZXNzaW9uLCBBY2Nlc3NTY29wZUV4cHJlc3Npb24sIEFjY2Vzc1RoaXNFeHByZXNzaW9uLCBBcnJheUJpbmRpbmdQYXR0ZXJuLCBBcnJheUxpdGVyYWxFeHByZXNzaW9uLCBBc3NpZ25FeHByZXNzaW9uLCBCaW5hcnlFeHByZXNzaW9uLCBCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uLCBCaW5kaW5nSWRlbnRpZmllciwgQ2FsbEZ1bmN0aW9uRXhwcmVzc2lvbiwgQ2FsbE1lbWJlckV4cHJlc3Npb24sIENhbGxTY29wZUV4cHJlc3Npb24sIENvbmRpdGlvbmFsRXhwcmVzc2lvbiwgQ3VzdG9tRXhwcmVzc2lvbiwgRm9yT2ZTdGF0ZW1lbnQsIEludGVycG9sYXRpb24sIE9iamVjdEJpbmRpbmdQYXR0ZXJuLCBPYmplY3RMaXRlcmFsRXhwcmVzc2lvbiwgUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24sIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiwgVGVtcGxhdGVFeHByZXNzaW9uLCBVbmFyeUV4cHJlc3Npb24sIFZhbHVlQ29udmVydGVyRXhwcmVzc2lvbiwgfSBmcm9tICcuL2FzdC5qcyc7XG5leHBvcnQgY29uc3QgSUV4cHJlc3Npb25QYXJzZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lFeHByZXNzaW9uUGFyc2VyJywgeCA9PiB4LnNpbmdsZXRvbihFeHByZXNzaW9uUGFyc2VyKSk7XG5leHBvcnQgY2xhc3MgRXhwcmVzc2lvblBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbkxvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuZm9yT2ZMb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmludGVycG9sYXRpb25Mb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBwYXJzZShleHByZXNzaW9uLCBiaW5kaW5nVHlwZSkge1xuICAgICAgICBzd2l0Y2ggKGJpbmRpbmdUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLzoge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuaW50ZXJwb2xhdGlvbkxvb2t1cFtleHByZXNzaW9uXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuaW50ZXJwb2xhdGlvbkxvb2t1cFtleHByZXNzaW9uXSA9IHRoaXMuJHBhcnNlKGV4cHJlc3Npb24sIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA1MzkgLyogRm9yQ29tbWFuZCAqLzoge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHRoaXMuZm9yT2ZMb29rdXBbZXhwcmVzc2lvbl07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmZvck9mTG9va3VwW2V4cHJlc3Npb25dID0gdGhpcy4kcGFyc2UoZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgZW1wdHkgc3RyaW5ncyBmb3Igbm9ybWFsIGJpbmRpbmdzIGFuZCB0aG9zZSB0aGF0IGFyZSBlbXB0eSBieSBkZWZhdWx0IChzdWNoIGFzIGEgY3VzdG9tIGF0dHJpYnV0ZSB3aXRob3V0IGFuIGVxdWFscyBzaWduKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCBkb24ndCBjYWNoZSBpdCwgYmVjYXVzZSBlbXB0eSBzdHJpbmdzIGFyZSBhbHdheXMgaW52YWxpZCBmb3IgYW55IG90aGVyIHR5cGUgb2YgYmluZGluZ1xuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMCAmJiAoYmluZGluZ1R5cGUgJiAoNTMgLyogQmluZENvbW1hbmQgKi8gfCA0OSAvKiBPbmVUaW1lQ29tbWFuZCAqLyB8IDUwIC8qIFRvVmlld0NvbW1hbmQgKi8pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJpbWl0aXZlTGl0ZXJhbEV4cHJlc3Npb24uJGVtcHR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmV4cHJlc3Npb25Mb29rdXBbZXhwcmVzc2lvbl07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmV4cHJlc3Npb25Mb29rdXBbZXhwcmVzc2lvbl0gPSB0aGlzLiRwYXJzZShleHByZXNzaW9uLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAkcGFyc2UoZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUpIHtcbiAgICAgICAgJHN0YXRlLmlucHV0ID0gZXhwcmVzc2lvbjtcbiAgICAgICAgJHN0YXRlLmxlbmd0aCA9IGV4cHJlc3Npb24ubGVuZ3RoO1xuICAgICAgICAkc3RhdGUuaW5kZXggPSAwO1xuICAgICAgICAkc3RhdGUuY3VycmVudENoYXIgPSBleHByZXNzaW9uLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBwYXJzZSgkc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYxIC8qIFZhcmlhZGljICovLCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwID8gNTMgLyogQmluZENvbW1hbmQgKi8gOiBiaW5kaW5nVHlwZSk7XG4gICAgfVxufVxuZXhwb3J0IHZhciBDaGFyO1xuKGZ1bmN0aW9uIChDaGFyKSB7XG4gICAgQ2hhcltDaGFyW1wiTnVsbFwiXSA9IDBdID0gXCJOdWxsXCI7XG4gICAgQ2hhcltDaGFyW1wiQmFja3NwYWNlXCJdID0gOF0gPSBcIkJhY2tzcGFjZVwiO1xuICAgIENoYXJbQ2hhcltcIlRhYlwiXSA9IDldID0gXCJUYWJcIjtcbiAgICBDaGFyW0NoYXJbXCJMaW5lRmVlZFwiXSA9IDEwXSA9IFwiTGluZUZlZWRcIjtcbiAgICBDaGFyW0NoYXJbXCJWZXJ0aWNhbFRhYlwiXSA9IDExXSA9IFwiVmVydGljYWxUYWJcIjtcbiAgICBDaGFyW0NoYXJbXCJGb3JtRmVlZFwiXSA9IDEyXSA9IFwiRm9ybUZlZWRcIjtcbiAgICBDaGFyW0NoYXJbXCJDYXJyaWFnZVJldHVyblwiXSA9IDEzXSA9IFwiQ2FycmlhZ2VSZXR1cm5cIjtcbiAgICBDaGFyW0NoYXJbXCJTcGFjZVwiXSA9IDMyXSA9IFwiU3BhY2VcIjtcbiAgICBDaGFyW0NoYXJbXCJFeGNsYW1hdGlvblwiXSA9IDMzXSA9IFwiRXhjbGFtYXRpb25cIjtcbiAgICBDaGFyW0NoYXJbXCJEb3VibGVRdW90ZVwiXSA9IDM0XSA9IFwiRG91YmxlUXVvdGVcIjtcbiAgICBDaGFyW0NoYXJbXCJEb2xsYXJcIl0gPSAzNl0gPSBcIkRvbGxhclwiO1xuICAgIENoYXJbQ2hhcltcIlBlcmNlbnRcIl0gPSAzN10gPSBcIlBlcmNlbnRcIjtcbiAgICBDaGFyW0NoYXJbXCJBbXBlcnNhbmRcIl0gPSAzOF0gPSBcIkFtcGVyc2FuZFwiO1xuICAgIENoYXJbQ2hhcltcIlNpbmdsZVF1b3RlXCJdID0gMzldID0gXCJTaW5nbGVRdW90ZVwiO1xuICAgIENoYXJbQ2hhcltcIk9wZW5QYXJlblwiXSA9IDQwXSA9IFwiT3BlblBhcmVuXCI7XG4gICAgQ2hhcltDaGFyW1wiQ2xvc2VQYXJlblwiXSA9IDQxXSA9IFwiQ2xvc2VQYXJlblwiO1xuICAgIENoYXJbQ2hhcltcIkFzdGVyaXNrXCJdID0gNDJdID0gXCJBc3Rlcmlza1wiO1xuICAgIENoYXJbQ2hhcltcIlBsdXNcIl0gPSA0M10gPSBcIlBsdXNcIjtcbiAgICBDaGFyW0NoYXJbXCJDb21tYVwiXSA9IDQ0XSA9IFwiQ29tbWFcIjtcbiAgICBDaGFyW0NoYXJbXCJNaW51c1wiXSA9IDQ1XSA9IFwiTWludXNcIjtcbiAgICBDaGFyW0NoYXJbXCJEb3RcIl0gPSA0Nl0gPSBcIkRvdFwiO1xuICAgIENoYXJbQ2hhcltcIlNsYXNoXCJdID0gNDddID0gXCJTbGFzaFwiO1xuICAgIENoYXJbQ2hhcltcIlNlbWljb2xvblwiXSA9IDU5XSA9IFwiU2VtaWNvbG9uXCI7XG4gICAgQ2hhcltDaGFyW1wiQmFja3RpY2tcIl0gPSA5Nl0gPSBcIkJhY2t0aWNrXCI7XG4gICAgQ2hhcltDaGFyW1wiT3BlbkJyYWNrZXRcIl0gPSA5MV0gPSBcIk9wZW5CcmFja2V0XCI7XG4gICAgQ2hhcltDaGFyW1wiQmFja3NsYXNoXCJdID0gOTJdID0gXCJCYWNrc2xhc2hcIjtcbiAgICBDaGFyW0NoYXJbXCJDbG9zZUJyYWNrZXRcIl0gPSA5M10gPSBcIkNsb3NlQnJhY2tldFwiO1xuICAgIENoYXJbQ2hhcltcIkNhcmV0XCJdID0gOTRdID0gXCJDYXJldFwiO1xuICAgIENoYXJbQ2hhcltcIlVuZGVyc2NvcmVcIl0gPSA5NV0gPSBcIlVuZGVyc2NvcmVcIjtcbiAgICBDaGFyW0NoYXJbXCJPcGVuQnJhY2VcIl0gPSAxMjNdID0gXCJPcGVuQnJhY2VcIjtcbiAgICBDaGFyW0NoYXJbXCJCYXJcIl0gPSAxMjRdID0gXCJCYXJcIjtcbiAgICBDaGFyW0NoYXJbXCJDbG9zZUJyYWNlXCJdID0gMTI1XSA9IFwiQ2xvc2VCcmFjZVwiO1xuICAgIENoYXJbQ2hhcltcIkNvbG9uXCJdID0gNThdID0gXCJDb2xvblwiO1xuICAgIENoYXJbQ2hhcltcIkxlc3NUaGFuXCJdID0gNjBdID0gXCJMZXNzVGhhblwiO1xuICAgIENoYXJbQ2hhcltcIkVxdWFsc1wiXSA9IDYxXSA9IFwiRXF1YWxzXCI7XG4gICAgQ2hhcltDaGFyW1wiR3JlYXRlclRoYW5cIl0gPSA2Ml0gPSBcIkdyZWF0ZXJUaGFuXCI7XG4gICAgQ2hhcltDaGFyW1wiUXVlc3Rpb25cIl0gPSA2M10gPSBcIlF1ZXN0aW9uXCI7XG4gICAgQ2hhcltDaGFyW1wiWmVyb1wiXSA9IDQ4XSA9IFwiWmVyb1wiO1xuICAgIENoYXJbQ2hhcltcIk9uZVwiXSA9IDQ5XSA9IFwiT25lXCI7XG4gICAgQ2hhcltDaGFyW1wiVHdvXCJdID0gNTBdID0gXCJUd29cIjtcbiAgICBDaGFyW0NoYXJbXCJUaHJlZVwiXSA9IDUxXSA9IFwiVGhyZWVcIjtcbiAgICBDaGFyW0NoYXJbXCJGb3VyXCJdID0gNTJdID0gXCJGb3VyXCI7XG4gICAgQ2hhcltDaGFyW1wiRml2ZVwiXSA9IDUzXSA9IFwiRml2ZVwiO1xuICAgIENoYXJbQ2hhcltcIlNpeFwiXSA9IDU0XSA9IFwiU2l4XCI7XG4gICAgQ2hhcltDaGFyW1wiU2V2ZW5cIl0gPSA1NV0gPSBcIlNldmVuXCI7XG4gICAgQ2hhcltDaGFyW1wiRWlnaHRcIl0gPSA1Nl0gPSBcIkVpZ2h0XCI7XG4gICAgQ2hhcltDaGFyW1wiTmluZVwiXSA9IDU3XSA9IFwiTmluZVwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyQVwiXSA9IDY1XSA9IFwiVXBwZXJBXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJCXCJdID0gNjZdID0gXCJVcHBlckJcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlckNcIl0gPSA2N10gPSBcIlVwcGVyQ1wiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyRFwiXSA9IDY4XSA9IFwiVXBwZXJEXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJFXCJdID0gNjldID0gXCJVcHBlckVcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlckZcIl0gPSA3MF0gPSBcIlVwcGVyRlwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyR1wiXSA9IDcxXSA9IFwiVXBwZXJHXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJIXCJdID0gNzJdID0gXCJVcHBlckhcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlcklcIl0gPSA3M10gPSBcIlVwcGVySVwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVySlwiXSA9IDc0XSA9IFwiVXBwZXJKXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJLXCJdID0gNzVdID0gXCJVcHBlcktcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlckxcIl0gPSA3Nl0gPSBcIlVwcGVyTFwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyTVwiXSA9IDc3XSA9IFwiVXBwZXJNXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJOXCJdID0gNzhdID0gXCJVcHBlck5cIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlck9cIl0gPSA3OV0gPSBcIlVwcGVyT1wiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyUFwiXSA9IDgwXSA9IFwiVXBwZXJQXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJRXCJdID0gODFdID0gXCJVcHBlclFcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlclJcIl0gPSA4Ml0gPSBcIlVwcGVyUlwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyU1wiXSA9IDgzXSA9IFwiVXBwZXJTXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJUXCJdID0gODRdID0gXCJVcHBlclRcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlclVcIl0gPSA4NV0gPSBcIlVwcGVyVVwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyVlwiXSA9IDg2XSA9IFwiVXBwZXJWXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJXXCJdID0gODddID0gXCJVcHBlcldcIjtcbiAgICBDaGFyW0NoYXJbXCJVcHBlclhcIl0gPSA4OF0gPSBcIlVwcGVyWFwiO1xuICAgIENoYXJbQ2hhcltcIlVwcGVyWVwiXSA9IDg5XSA9IFwiVXBwZXJZXCI7XG4gICAgQ2hhcltDaGFyW1wiVXBwZXJaXCJdID0gOTBdID0gXCJVcHBlclpcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckFcIl0gPSA5N10gPSBcIkxvd2VyQVwiO1xuICAgIENoYXJbQ2hhcltcIkxvd2VyQlwiXSA9IDk4XSA9IFwiTG93ZXJCXCI7XG4gICAgQ2hhcltDaGFyW1wiTG93ZXJDXCJdID0gOTldID0gXCJMb3dlckNcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckRcIl0gPSAxMDBdID0gXCJMb3dlckRcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckVcIl0gPSAxMDFdID0gXCJMb3dlckVcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckZcIl0gPSAxMDJdID0gXCJMb3dlckZcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckdcIl0gPSAxMDNdID0gXCJMb3dlckdcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckhcIl0gPSAxMDRdID0gXCJMb3dlckhcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlcklcIl0gPSAxMDVdID0gXCJMb3dlcklcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckpcIl0gPSAxMDZdID0gXCJMb3dlckpcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlcktcIl0gPSAxMDddID0gXCJMb3dlcktcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlckxcIl0gPSAxMDhdID0gXCJMb3dlckxcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlck1cIl0gPSAxMDldID0gXCJMb3dlck1cIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlck5cIl0gPSAxMTBdID0gXCJMb3dlck5cIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlck9cIl0gPSAxMTFdID0gXCJMb3dlck9cIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclBcIl0gPSAxMTJdID0gXCJMb3dlclBcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclFcIl0gPSAxMTNdID0gXCJMb3dlclFcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclJcIl0gPSAxMTRdID0gXCJMb3dlclJcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclNcIl0gPSAxMTVdID0gXCJMb3dlclNcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclRcIl0gPSAxMTZdID0gXCJMb3dlclRcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclVcIl0gPSAxMTddID0gXCJMb3dlclVcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclZcIl0gPSAxMThdID0gXCJMb3dlclZcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlcldcIl0gPSAxMTldID0gXCJMb3dlcldcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclhcIl0gPSAxMjBdID0gXCJMb3dlclhcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlcllcIl0gPSAxMjFdID0gXCJMb3dlcllcIjtcbiAgICBDaGFyW0NoYXJbXCJMb3dlclpcIl0gPSAxMjJdID0gXCJMb3dlclpcIjtcbn0pKENoYXIgfHwgKENoYXIgPSB7fSkpO1xuZnVuY3Rpb24gdW5lc2NhcGVDb2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSA5OCAvKiBMb3dlckIgKi86IHJldHVybiA4IC8qIEJhY2tzcGFjZSAqLztcbiAgICAgICAgY2FzZSAxMTYgLyogTG93ZXJUICovOiByZXR1cm4gOSAvKiBUYWIgKi87XG4gICAgICAgIGNhc2UgMTEwIC8qIExvd2VyTiAqLzogcmV0dXJuIDEwIC8qIExpbmVGZWVkICovO1xuICAgICAgICBjYXNlIDExOCAvKiBMb3dlclYgKi86IHJldHVybiAxMSAvKiBWZXJ0aWNhbFRhYiAqLztcbiAgICAgICAgY2FzZSAxMDIgLyogTG93ZXJGICovOiByZXR1cm4gMTIgLyogRm9ybUZlZWQgKi87XG4gICAgICAgIGNhc2UgMTE0IC8qIExvd2VyUiAqLzogcmV0dXJuIDEzIC8qIENhcnJpYWdlUmV0dXJuICovO1xuICAgICAgICBjYXNlIDM0IC8qIERvdWJsZVF1b3RlICovOiByZXR1cm4gMzQgLyogRG91YmxlUXVvdGUgKi87XG4gICAgICAgIGNhc2UgMzkgLyogU2luZ2xlUXVvdGUgKi86IHJldHVybiAzOSAvKiBTaW5nbGVRdW90ZSAqLztcbiAgICAgICAgY2FzZSA5MiAvKiBCYWNrc2xhc2ggKi86IHJldHVybiA5MiAvKiBCYWNrc2xhc2ggKi87XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgQWNjZXNzO1xuKGZ1bmN0aW9uIChBY2Nlc3MpIHtcbiAgICBBY2Nlc3NbQWNjZXNzW1wiUmVzZXRcIl0gPSAwXSA9IFwiUmVzZXRcIjtcbiAgICBBY2Nlc3NbQWNjZXNzW1wiQW5jZXN0b3JcIl0gPSA1MTFdID0gXCJBbmNlc3RvclwiO1xuICAgIEFjY2Vzc1tBY2Nlc3NbXCJUaGlzXCJdID0gNTEyXSA9IFwiVGhpc1wiO1xuICAgIEFjY2Vzc1tBY2Nlc3NbXCJTY29wZVwiXSA9IDEwMjRdID0gXCJTY29wZVwiO1xuICAgIEFjY2Vzc1tBY2Nlc3NbXCJNZW1iZXJcIl0gPSAyMDQ4XSA9IFwiTWVtYmVyXCI7XG4gICAgQWNjZXNzW0FjY2Vzc1tcIktleWVkXCJdID0gNDA5Nl0gPSBcIktleWVkXCI7XG59KShBY2Nlc3MgfHwgKEFjY2VzcyA9IHt9KSk7XG5leHBvcnQgdmFyIFByZWNlZGVuY2U7XG4oZnVuY3Rpb24gKFByZWNlZGVuY2UpIHtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJWYXJpYWRpY1wiXSA9IDYxXSA9IFwiVmFyaWFkaWNcIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJBc3NpZ25cIl0gPSA2Ml0gPSBcIkFzc2lnblwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIkNvbmRpdGlvbmFsXCJdID0gNjNdID0gXCJDb25kaXRpb25hbFwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIkxvZ2ljYWxPUlwiXSA9IDY0XSA9IFwiTG9naWNhbE9SXCI7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiTG9naWNhbEFORFwiXSA9IDEyOF0gPSBcIkxvZ2ljYWxBTkRcIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJFcXVhbGl0eVwiXSA9IDE5Ml0gPSBcIkVxdWFsaXR5XCI7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiUmVsYXRpb25hbFwiXSA9IDI1Nl0gPSBcIlJlbGF0aW9uYWxcIjtcbiAgICBQcmVjZWRlbmNlW1ByZWNlZGVuY2VbXCJBZGRpdGl2ZVwiXSA9IDMyMF0gPSBcIkFkZGl0aXZlXCI7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiTXVsdGlwbGljYXRpdmVcIl0gPSAzODRdID0gXCJNdWx0aXBsaWNhdGl2ZVwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIkJpbmFyeVwiXSA9IDQ0OF0gPSBcIkJpbmFyeVwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIkxlZnRIYW5kU2lkZVwiXSA9IDQ0OV0gPSBcIkxlZnRIYW5kU2lkZVwiO1xuICAgIFByZWNlZGVuY2VbUHJlY2VkZW5jZVtcIlByaW1hcnlcIl0gPSA0NTBdID0gXCJQcmltYXJ5XCI7XG4gICAgUHJlY2VkZW5jZVtQcmVjZWRlbmNlW1wiVW5hcnlcIl0gPSA0NTFdID0gXCJVbmFyeVwiO1xufSkoUHJlY2VkZW5jZSB8fCAoUHJlY2VkZW5jZSA9IHt9KSk7XG52YXIgVG9rZW47XG4oZnVuY3Rpb24gKFRva2VuKSB7XG4gICAgVG9rZW5bVG9rZW5bXCJFT0ZcIl0gPSAxNTcyODY0XSA9IFwiRU9GXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJFeHByZXNzaW9uVGVybWluYWxcIl0gPSAxMDQ4NTc2XSA9IFwiRXhwcmVzc2lvblRlcm1pbmFsXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJBY2Nlc3NTY29wZVRlcm1pbmFsXCJdID0gNTI0Mjg4XSA9IFwiQWNjZXNzU2NvcGVUZXJtaW5hbFwiO1xuICAgIFRva2VuW1Rva2VuW1wiQ2xvc2luZ1Rva2VuXCJdID0gMjYyMTQ0XSA9IFwiQ2xvc2luZ1Rva2VuXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJPcGVuaW5nVG9rZW5cIl0gPSAxMzEwNzJdID0gXCJPcGVuaW5nVG9rZW5cIjtcbiAgICBUb2tlbltUb2tlbltcIkJpbmFyeU9wXCJdID0gNjU1MzZdID0gXCJCaW5hcnlPcFwiO1xuICAgIFRva2VuW1Rva2VuW1wiVW5hcnlPcFwiXSA9IDMyNzY4XSA9IFwiVW5hcnlPcFwiO1xuICAgIFRva2VuW1Rva2VuW1wiTGVmdEhhbmRTaWRlXCJdID0gMTYzODRdID0gXCJMZWZ0SGFuZFNpZGVcIjtcbiAgICBUb2tlbltUb2tlbltcIlN0cmluZ09yTnVtZXJpY0xpdGVyYWxcIl0gPSAxMjI4OF0gPSBcIlN0cmluZ09yTnVtZXJpY0xpdGVyYWxcIjtcbiAgICBUb2tlbltUb2tlbltcIk51bWVyaWNMaXRlcmFsXCJdID0gODE5Ml0gPSBcIk51bWVyaWNMaXRlcmFsXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJTdHJpbmdMaXRlcmFsXCJdID0gNDA5Nl0gPSBcIlN0cmluZ0xpdGVyYWxcIjtcbiAgICBUb2tlbltUb2tlbltcIklkZW50aWZpZXJOYW1lXCJdID0gMzA3Ml0gPSBcIklkZW50aWZpZXJOYW1lXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJLZXl3b3JkXCJdID0gMjA0OF0gPSBcIktleXdvcmRcIjtcbiAgICBUb2tlbltUb2tlbltcIklkZW50aWZpZXJcIl0gPSAxMDI0XSA9IFwiSWRlbnRpZmllclwiO1xuICAgIFRva2VuW1Rva2VuW1wiQ29udGV4dHVhbFwiXSA9IDUxMl0gPSBcIkNvbnRleHR1YWxcIjtcbiAgICBUb2tlbltUb2tlbltcIlByZWNlZGVuY2VcIl0gPSA0NDhdID0gXCJQcmVjZWRlbmNlXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJUeXBlXCJdID0gNjNdID0gXCJUeXBlXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJGYWxzZUtleXdvcmRcIl0gPSAyMDQ4XSA9IFwiRmFsc2VLZXl3b3JkXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJUcnVlS2V5d29yZFwiXSA9IDIwNDldID0gXCJUcnVlS2V5d29yZFwiO1xuICAgIFRva2VuW1Rva2VuW1wiTnVsbEtleXdvcmRcIl0gPSAyMDUwXSA9IFwiTnVsbEtleXdvcmRcIjtcbiAgICBUb2tlbltUb2tlbltcIlVuZGVmaW5lZEtleXdvcmRcIl0gPSAyMDUxXSA9IFwiVW5kZWZpbmVkS2V5d29yZFwiO1xuICAgIFRva2VuW1Rva2VuW1wiVGhpc1Njb3BlXCJdID0gMzA3Nl0gPSBcIlRoaXNTY29wZVwiO1xuICAgIFRva2VuW1Rva2VuW1wiSG9zdFNjb3BlXCJdID0gMzA3N10gPSBcIkhvc3RTY29wZVwiO1xuICAgIFRva2VuW1Rva2VuW1wiUGFyZW50U2NvcGVcIl0gPSAzMDc4XSA9IFwiUGFyZW50U2NvcGVcIjtcbiAgICBUb2tlbltUb2tlbltcIk9wZW5QYXJlblwiXSA9IDY3MTc1MV0gPSBcIk9wZW5QYXJlblwiO1xuICAgIFRva2VuW1Rva2VuW1wiT3BlbkJyYWNlXCJdID0gMTMxMDgwXSA9IFwiT3BlbkJyYWNlXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJEb3RcIl0gPSAxNjM5M10gPSBcIkRvdFwiO1xuICAgIFRva2VuW1Rva2VuW1wiQ2xvc2VCcmFjZVwiXSA9IDE4MzUwMThdID0gXCJDbG9zZUJyYWNlXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJDbG9zZVBhcmVuXCJdID0gMTgzNTAxOV0gPSBcIkNsb3NlUGFyZW5cIjtcbiAgICBUb2tlbltUb2tlbltcIkNvbW1hXCJdID0gMTU3Mjg3Nl0gPSBcIkNvbW1hXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJPcGVuQnJhY2tldFwiXSA9IDY3MTc1N10gPSBcIk9wZW5CcmFja2V0XCI7XG4gICAgVG9rZW5bVG9rZW5bXCJDbG9zZUJyYWNrZXRcIl0gPSAxODM1MDIyXSA9IFwiQ2xvc2VCcmFja2V0XCI7XG4gICAgVG9rZW5bVG9rZW5bXCJDb2xvblwiXSA9IDE1NzI4NzldID0gXCJDb2xvblwiO1xuICAgIFRva2VuW1Rva2VuW1wiUXVlc3Rpb25cIl0gPSAxNTcyODgwXSA9IFwiUXVlc3Rpb25cIjtcbiAgICBUb2tlbltUb2tlbltcIkFtcGVyc2FuZFwiXSA9IDE1NzI4ODNdID0gXCJBbXBlcnNhbmRcIjtcbiAgICBUb2tlbltUb2tlbltcIkJhclwiXSA9IDE1NzI4ODRdID0gXCJCYXJcIjtcbiAgICBUb2tlbltUb2tlbltcIkJhckJhclwiXSA9IDE2Mzg1NDldID0gXCJCYXJCYXJcIjtcbiAgICBUb2tlbltUb2tlbltcIkFtcGVyc2FuZEFtcGVyc2FuZFwiXSA9IDE2Mzg2MTRdID0gXCJBbXBlcnNhbmRBbXBlcnNhbmRcIjtcbiAgICBUb2tlbltUb2tlbltcIkVxdWFsc0VxdWFsc1wiXSA9IDE2Mzg2NzldID0gXCJFcXVhbHNFcXVhbHNcIjtcbiAgICBUb2tlbltUb2tlbltcIkV4Y2xhbWF0aW9uRXF1YWxzXCJdID0gMTYzODY4MF0gPSBcIkV4Y2xhbWF0aW9uRXF1YWxzXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJFcXVhbHNFcXVhbHNFcXVhbHNcIl0gPSAxNjM4NjgxXSA9IFwiRXF1YWxzRXF1YWxzRXF1YWxzXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJFeGNsYW1hdGlvbkVxdWFsc0VxdWFsc1wiXSA9IDE2Mzg2ODJdID0gXCJFeGNsYW1hdGlvbkVxdWFsc0VxdWFsc1wiO1xuICAgIFRva2VuW1Rva2VuW1wiTGVzc1RoYW5cIl0gPSAxNjM4NzQ3XSA9IFwiTGVzc1RoYW5cIjtcbiAgICBUb2tlbltUb2tlbltcIkdyZWF0ZXJUaGFuXCJdID0gMTYzODc0OF0gPSBcIkdyZWF0ZXJUaGFuXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJMZXNzVGhhbkVxdWFsc1wiXSA9IDE2Mzg3NDldID0gXCJMZXNzVGhhbkVxdWFsc1wiO1xuICAgIFRva2VuW1Rva2VuW1wiR3JlYXRlclRoYW5FcXVhbHNcIl0gPSAxNjM4NzUwXSA9IFwiR3JlYXRlclRoYW5FcXVhbHNcIjtcbiAgICBUb2tlbltUb2tlbltcIkluS2V5d29yZFwiXSA9IDE2NDA3OTldID0gXCJJbktleXdvcmRcIjtcbiAgICBUb2tlbltUb2tlbltcIkluc3RhbmNlT2ZLZXl3b3JkXCJdID0gMTY0MDgwMF0gPSBcIkluc3RhbmNlT2ZLZXl3b3JkXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJQbHVzXCJdID0gNjIzMDA5XSA9IFwiUGx1c1wiO1xuICAgIFRva2VuW1Rva2VuW1wiTWludXNcIl0gPSA2MjMwMTBdID0gXCJNaW51c1wiO1xuICAgIFRva2VuW1Rva2VuW1wiVHlwZW9mS2V5d29yZFwiXSA9IDM0ODUxXSA9IFwiVHlwZW9mS2V5d29yZFwiO1xuICAgIFRva2VuW1Rva2VuW1wiVm9pZEtleXdvcmRcIl0gPSAzNDg1Ml0gPSBcIlZvaWRLZXl3b3JkXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJBc3Rlcmlza1wiXSA9IDE2Mzg4ODVdID0gXCJBc3Rlcmlza1wiO1xuICAgIFRva2VuW1Rva2VuW1wiUGVyY2VudFwiXSA9IDE2Mzg4ODZdID0gXCJQZXJjZW50XCI7XG4gICAgVG9rZW5bVG9rZW5bXCJTbGFzaFwiXSA9IDE2Mzg4ODddID0gXCJTbGFzaFwiO1xuICAgIFRva2VuW1Rva2VuW1wiRXF1YWxzXCJdID0gMTA0ODYxNl0gPSBcIkVxdWFsc1wiO1xuICAgIFRva2VuW1Rva2VuW1wiRXhjbGFtYXRpb25cIl0gPSAzMjgwOV0gPSBcIkV4Y2xhbWF0aW9uXCI7XG4gICAgVG9rZW5bVG9rZW5bXCJUZW1wbGF0ZVRhaWxcIl0gPSA1NDA3MTRdID0gXCJUZW1wbGF0ZVRhaWxcIjtcbiAgICBUb2tlbltUb2tlbltcIlRlbXBsYXRlQ29udGludWF0aW9uXCJdID0gNTQwNzE1XSA9IFwiVGVtcGxhdGVDb250aW51YXRpb25cIjtcbiAgICBUb2tlbltUb2tlbltcIk9mS2V5d29yZFwiXSA9IDEwNTExODBdID0gXCJPZktleXdvcmRcIjtcbn0pKFRva2VuIHx8IChUb2tlbiA9IHt9KSk7XG5jb25zdCAkZmFsc2UgPSBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbi4kZmFsc2U7XG5jb25zdCAkdHJ1ZSA9IFByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uLiR0cnVlO1xuY29uc3QgJG51bGwgPSBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbi4kbnVsbDtcbmNvbnN0ICR1bmRlZmluZWQgPSBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbi4kdW5kZWZpbmVkO1xuY29uc3QgJHRoaXMgPSBBY2Nlc3NUaGlzRXhwcmVzc2lvbi4kdGhpcztcbmNvbnN0ICRob3N0ID0gQWNjZXNzVGhpc0V4cHJlc3Npb24uJGhvc3Q7XG5jb25zdCAkcGFyZW50ID0gQWNjZXNzVGhpc0V4cHJlc3Npb24uJHBhcmVudDtcbmV4cG9ydCB2YXIgQmluZGluZ1R5cGU7XG4oZnVuY3Rpb24gKEJpbmRpbmdUeXBlKSB7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIklnbm9yZUN1c3RvbUF0dHJcIl0gPSA0MDk2XSA9IFwiSWdub3JlQ3VzdG9tQXR0clwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSW50ZXJwb2xhdGlvblwiXSA9IDIwNDhdID0gXCJJbnRlcnBvbGF0aW9uXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJc1JlZlwiXSA9IDUzNzZdID0gXCJJc1JlZlwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSXNJdGVyYXRvclwiXSA9IDUxMl0gPSBcIklzSXRlcmF0b3JcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIklzQ3VzdG9tXCJdID0gMjU2XSA9IFwiSXNDdXN0b21cIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIklzRnVuY3Rpb25cIl0gPSAxMjhdID0gXCJJc0Z1bmN0aW9uXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJc0V2ZW50XCJdID0gNjRdID0gXCJJc0V2ZW50XCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJc1Byb3BlcnR5XCJdID0gMzJdID0gXCJJc1Byb3BlcnR5XCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJc0NvbW1hbmRcIl0gPSAxNl0gPSBcIklzQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiSXNQcm9wZXJ0eUNvbW1hbmRcIl0gPSA0OF0gPSBcIklzUHJvcGVydHlDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJJc0V2ZW50Q29tbWFuZFwiXSA9IDgwXSA9IFwiSXNFdmVudENvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIkRlbGVnYXRpb25TdHJhdGVneURlbHRhXCJdID0gNl0gPSBcIkRlbGVnYXRpb25TdHJhdGVneURlbHRhXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJDb21tYW5kXCJdID0gMTVdID0gXCJDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJPbmVUaW1lQ29tbWFuZFwiXSA9IDQ5XSA9IFwiT25lVGltZUNvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIlRvVmlld0NvbW1hbmRcIl0gPSA1MF0gPSBcIlRvVmlld0NvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIkZyb21WaWV3Q29tbWFuZFwiXSA9IDUxXSA9IFwiRnJvbVZpZXdDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJUd29XYXlDb21tYW5kXCJdID0gNTJdID0gXCJUd29XYXlDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJCaW5kQ29tbWFuZFwiXSA9IDUzXSA9IFwiQmluZENvbW1hbmRcIjtcbiAgICBCaW5kaW5nVHlwZVtCaW5kaW5nVHlwZVtcIlRyaWdnZXJDb21tYW5kXCJdID0gNDE4Ml0gPSBcIlRyaWdnZXJDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJDYXB0dXJlQ29tbWFuZFwiXSA9IDQxODNdID0gXCJDYXB0dXJlQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiRGVsZWdhdGVDb21tYW5kXCJdID0gNDE4NF0gPSBcIkRlbGVnYXRlQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiQ2FsbENvbW1hbmRcIl0gPSAxNTNdID0gXCJDYWxsQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiT3B0aW9uc0NvbW1hbmRcIl0gPSAyNl0gPSBcIk9wdGlvbnNDb21tYW5kXCI7XG4gICAgQmluZGluZ1R5cGVbQmluZGluZ1R5cGVbXCJGb3JDb21tYW5kXCJdID0gNTM5XSA9IFwiRm9yQ29tbWFuZFwiO1xuICAgIEJpbmRpbmdUeXBlW0JpbmRpbmdUeXBlW1wiQ3VzdG9tQ29tbWFuZFwiXSA9IDI4NF0gPSBcIkN1c3RvbUNvbW1hbmRcIjtcbn0pKEJpbmRpbmdUeXBlIHx8IChCaW5kaW5nVHlwZSA9IHt9KSk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9pbmRlbnQgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBQYXJzZXJTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IDE1NzI4NjQgLyogRU9GICovO1xuICAgICAgICB0aGlzLnRva2VuVmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5hc3NpZ25hYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuY3VycmVudENoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBnZXQgdG9rZW5SYXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnRJbmRleCwgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuY29uc3QgJHN0YXRlID0gbmV3IFBhcnNlclN0YXRlKCcnKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oaW5wdXQsIGJpbmRpbmdUeXBlKSB7XG4gICAgJHN0YXRlLmlucHV0ID0gaW5wdXQ7XG4gICAgJHN0YXRlLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAkc3RhdGUuaW5kZXggPSAwO1xuICAgICRzdGF0ZS5jdXJyZW50Q2hhciA9IGlucHV0LmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIHBhcnNlKCRzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjEgLyogVmFyaWFkaWMgKi8sIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgPyA1MyAvKiBCaW5kQ29tbWFuZCAqLyA6IGJpbmRpbmdUeXBlKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8vIFRoaXMgaXMgcGVyZm9ybWFuY2UtY3JpdGljYWwgY29kZSB3aGljaCBmb2xsb3dzIGEgc3Vic2V0IG9mIHRoZSB3ZWxsLWtub3duIEVTIHNwZWMuXG4vLyBLbm93aW5nIHRoZSBzcGVjLCBvciBwYXJzZXJzIGluIGdlbmVyYWwsIHdpbGwgaGVscCB3aXRoIHVuZGVyc3RhbmRpbmcgdGhpcyBjb2RlIGFuZCBpdCBpcyB0aGVyZWZvcmUgbm90IHRoZVxuLy8gc2luZ2xlIHNvdXJjZSBvZiBpbmZvcm1hdGlvbiBmb3IgYmVpbmcgYWJsZSB0byBmaWd1cmUgaXQgb3V0LlxuLy8gSXQgZ2VuZXJhbGx5IGRvZXMgbm90IG5lZWQgdG8gY2hhbmdlIHVubGVzcyB0aGUgc3BlYyBjaGFuZ2VzIG9yIHNwZWMgdmlvbGF0aW9ucyBhcmUgZm91bmQsIG9yIG9wdGltaXphdGlvblxuLy8gb3Bwb3J0dW5pdGllcyBhcmUgZm91bmQgKHdoaWNoIHdvdWxkIGxpa2VseSBub3QgZml4IHRoZXNlIHdhcm5pbmdzIGluIGFueSBjYXNlKS5cbi8vIEl0J3MgdGhlcmVmb3JlIG5vdCBjb25zaWRlcmVkIHRvIGhhdmUgYW55IHRhbmdpYmxlIGltcGFjdCBvbiB0aGUgbWFpbnRhaW5hYmlsaXR5IG9mIHRoZSBjb2RlIGJhc2UuXG4vLyBGb3IgcmVmZXJlbmNlLCBtb3N0IG9mIHRoZSBwYXJzaW5nIGxvZ2ljIGlzIGJhc2VkIG9uOiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLWV4cHJlc3Npb25zXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0YXRlLCBhY2Nlc3MsIG1pblByZWNlZGVuY2UsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSAyODQgLyogQ3VzdG9tQ29tbWFuZCAqLykge1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUV4cHJlc3Npb24oc3RhdGUuaW5wdXQpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaW5kZXggPT09IDApIHtcbiAgICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50ZXJwb2xhdGlvbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDEwNDg1NzYgLyogRXhwcmVzc2lvblRlcm1pbmFsICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhcnQgb2YgZXhwcmVzc2lvbjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmFzc2lnbmFibGUgPSA0NDggLyogQmluYXJ5ICovID4gbWluUHJlY2VkZW5jZTtcbiAgICBsZXQgcmVzdWx0ID0gdm9pZCAwO1xuICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gJiAzMjc2OCAvKiBVbmFyeU9wICovKSB7XG4gICAgICAgIC8qKiBwYXJzZVVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11bmFyeS1vcGVyYXRvcnNcbiAgICAgICAgICpcbiAgICAgICAgICogVW5hcnlFeHByZXNzaW9uIDpcbiAgICAgICAgICogMS4gTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuICAgICAgICAgKiAyLiB2b2lkIFVuYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKiAzLiB0eXBlb2YgVW5hcnlFeHByZXNzaW9uXG4gICAgICAgICAqIDQuICsgVW5hcnlFeHByZXNzaW9uXG4gICAgICAgICAqIDUuIC0gVW5hcnlFeHByZXNzaW9uXG4gICAgICAgICAqIDYuICEgVW5hcnlFeHByZXNzaW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIElzVmFsaWRBc3NpZ25tZW50VGFyZ2V0XG4gICAgICAgICAqIDIsMyw0LDUsNiA9IGZhbHNlXG4gICAgICAgICAqIDEgPSBzZWUgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IHRlY2huaWNhbGx5IHdlIHNob3VsZCB0aHJvdyBvbiArKyAvIC0tIC8gKysrIC8gLS0tLCBidXQgdGhlcmUncyBub3RoaW5nIHRvIGdhaW4gZnJvbSB0aGF0XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvcCA9IFRva2VuVmFsdWVzW3N0YXRlLmN1cnJlbnRUb2tlbiAmIDYzIC8qIFR5cGUgKi9dO1xuICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICByZXN1bHQgPSBuZXcgVW5hcnlFeHByZXNzaW9uKG9wLCBwYXJzZShzdGF0ZSwgYWNjZXNzLCA0NDkgLyogTGVmdEhhbmRTaWRlICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiogcGFyc2VQcmltYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcmltYXJ5LWV4cHJlc3Npb25cbiAgICAgICAgICpcbiAgICAgICAgICogUHJpbWFyeUV4cHJlc3Npb24gOlxuICAgICAgICAgKiAxLiB0aGlzXG4gICAgICAgICAqIDIuIElkZW50aWZpZXJOYW1lXG4gICAgICAgICAqIDMuIExpdGVyYWxcbiAgICAgICAgICogNC4gQXJyYXlMaXRlcmFsRXhwcmVzc2lvblxuICAgICAgICAgKiA1LiBPYmplY3RMaXRlcmFsRXhwcmVzc2lvblxuICAgICAgICAgKiA2LiBUZW1wbGF0ZUxpdGVyYWxcbiAgICAgICAgICogNy4gUGFyZW50aGVzaXplZEV4cHJlc3Npb25cbiAgICAgICAgICpcbiAgICAgICAgICogTGl0ZXJhbCA6XG4gICAgICAgICAqIE51bGxMaXRlcmFsXG4gICAgICAgICAqIEJvb2xlYW5MaXRlcmFsXG4gICAgICAgICAqIE51bWVyaWNMaXRlcmFsXG4gICAgICAgICAqIFN0cmluZ0xpdGVyYWxcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyZW50aGVzaXplZEV4cHJlc3Npb24gOlxuICAgICAgICAgKiAoIEFzc2lnbm1lbnRFeHByZXNzaW9uIClcbiAgICAgICAgICpcbiAgICAgICAgICogSXNWYWxpZEFzc2lnbm1lbnRUYXJnZXRcbiAgICAgICAgICogMSwzLDQsNSw2LDcgPSBmYWxzZVxuICAgICAgICAgKiAyID0gdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJpbWFyeTogc3dpdGNoIChzdGF0ZS5jdXJyZW50VG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgMzA3OCAvKiBQYXJlbnRTY29wZSAqLzogLy8gJHBhcmVudFxuICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VzcysrOyAvLyBhbmNlc3RvclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3VtZU9wdChzdGF0ZSwgMTYzOTMgLyogRG90ICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiA9PT0gMTYzOTMgLyogRG90ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb3VibGUgZG90IGFuZCBzcHJlYWQgb3BlcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IDE1NzI4NjQgLyogRU9GICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuY3VycmVudFRva2VuICYgNTI0Mjg4IC8qIEFjY2Vzc1Njb3BlVGVybWluYWwgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9yID0gYWNjZXNzICYgNTExIC8qIEFuY2VzdG9yICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYW5jZXN0b3IgPT09IDAgPyAkdGhpcyA6IGFuY2VzdG9yID09PSAxID8gJHBhcmVudCA6IG5ldyBBY2Nlc3NUaGlzRXhwcmVzc2lvbihhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3MgPSA1MTIgLyogVGhpcyAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHByaW1hcnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVtYmVyIGV4cHJlc3Npb246ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHN0YXRlLmN1cnJlbnRUb2tlbiA9PT0gMzA3OCAvKiBQYXJlbnRTY29wZSAqLyk7XG4gICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIDEwMjQgLyogSWRlbnRpZmllciAqLzogLy8gaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nVHlwZSAmIDUxMiAvKiBJc0l0ZXJhdG9yICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5kaW5nSWRlbnRpZmllcihzdGF0ZS50b2tlblZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBY2Nlc3NTY29wZUV4cHJlc3Npb24oc3RhdGUudG9rZW5WYWx1ZSwgYWNjZXNzICYgNTExIC8qIEFuY2VzdG9yICovKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMTAyNCAvKiBTY29wZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzA3NiAvKiBUaGlzU2NvcGUgKi86IC8vICR0aGlzXG4gICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJHRoaXM7XG4gICAgICAgICAgICAgICAgYWNjZXNzID0gNTEyIC8qIFRoaXMgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMwNzcgLyogSG9zdFNjb3BlICovOiAvLyAkaG9zdFxuICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICRob3N0O1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDUxMiAvKiBUaGlzICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2NzE3NTEgLyogT3BlblBhcmVuICovOiAvLyBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlKHN0YXRlLCAwIC8qIFJlc2V0ICovLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxODM1MDE5IC8qIENsb3NlUGFyZW4gKi8pO1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY3MTc1NyAvKiBPcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUFycmF5TGl0ZXJhbEV4cHJlc3Npb24oc3RhdGUsIGFjY2VzcywgYmluZGluZ1R5cGUpO1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzMTA4MCAvKiBPcGVuQnJhY2UgKi86XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihzdGF0ZSwgYmluZGluZ1R5cGUpO1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU0MDcxNCAvKiBUZW1wbGF0ZVRhaWwgKi86XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRlbXBsYXRlRXhwcmVzc2lvbihbc3RhdGUudG9rZW5WYWx1ZV0pO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU0MDcxNSAvKiBUZW1wbGF0ZUNvbnRpbnVhdGlvbiAqLzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZVRlbXBsYXRlKHN0YXRlLCBhY2Nlc3MsIGJpbmRpbmdUeXBlLCByZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhY2Nlc3MgPSAwIC8qIFJlc2V0ICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MDk2IC8qIFN0cmluZ0xpdGVyYWwgKi86XG4gICAgICAgICAgICBjYXNlIDgxOTIgLyogTnVtZXJpY0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uKHN0YXRlLnRva2VuVmFsdWUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIGFjY2VzcyA9IDAgLyogUmVzZXQgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIwNTAgLyogTnVsbEtleXdvcmQgKi86XG4gICAgICAgICAgICBjYXNlIDIwNTEgLyogVW5kZWZpbmVkS2V5d29yZCAqLzpcbiAgICAgICAgICAgIGNhc2UgMjA0OSAvKiBUcnVlS2V5d29yZCAqLzpcbiAgICAgICAgICAgIGNhc2UgMjA0OCAvKiBGYWxzZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gVG9rZW5WYWx1ZXNbc3RhdGUuY3VycmVudFRva2VuICYgNjMgLyogVHlwZSAqL107XG4gICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgYWNjZXNzID0gMCAvKiBSZXNldCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb246ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5jb25zdW1lZCB0b2tlbjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZGluZ1R5cGUgJiA1MTIgLyogSXNJdGVyYXRvciAqLykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZvck9mU3RhdGVtZW50KHN0YXRlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICg0NDkgLyogTGVmdEhhbmRTaWRlICovIDwgbWluUHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIHBhcnNlTWVtYmVyRXhwcmVzc2lvbiAoVG9rZW4uRG90LCBUb2tlbi5PcGVuQnJhY2tldCwgVG9rZW4uVGVtcGxhdGVDb250aW51YXRpb24pXG4gICAgICAgICAqIE1lbWJlckV4cHJlc3Npb24gOlxuICAgICAgICAgKiAxLiBQcmltYXJ5RXhwcmVzc2lvblxuICAgICAgICAgKiAyLiBNZW1iZXJFeHByZXNzaW9uIFsgQXNzaWdubWVudEV4cHJlc3Npb24gXVxuICAgICAgICAgKiAzLiBNZW1iZXJFeHByZXNzaW9uIC4gSWRlbnRpZmllck5hbWVcbiAgICAgICAgICogNC4gTWVtYmVyRXhwcmVzc2lvbiBUZW1wbGF0ZUxpdGVyYWxcbiAgICAgICAgICpcbiAgICAgICAgICogSXNWYWxpZEFzc2lnbm1lbnRUYXJnZXRcbiAgICAgICAgICogMSw0ID0gZmFsc2VcbiAgICAgICAgICogMiwzID0gdHJ1ZVxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBwYXJzZUNhbGxFeHByZXNzaW9uIChUb2tlbi5PcGVuUGFyZW4pXG4gICAgICAgICAqIENhbGxFeHByZXNzaW9uIDpcbiAgICAgICAgICogMS4gTWVtYmVyRXhwcmVzc2lvbiBBcmd1bWVudHNcbiAgICAgICAgICogMi4gQ2FsbEV4cHJlc3Npb24gQXJndW1lbnRzXG4gICAgICAgICAqIDMuIENhbGxFeHByZXNzaW9uIFsgQXNzaWdubWVudEV4cHJlc3Npb24gXVxuICAgICAgICAgKiA0LiBDYWxsRXhwcmVzc2lvbiAuIElkZW50aWZpZXJOYW1lXG4gICAgICAgICAqIDUuIENhbGxFeHByZXNzaW9uIFRlbXBsYXRlTGl0ZXJhbFxuICAgICAgICAgKlxuICAgICAgICAgKiBJc1ZhbGlkQXNzaWdubWVudFRhcmdldFxuICAgICAgICAgKiAxLDIsNSA9IGZhbHNlXG4gICAgICAgICAqIDMsNCA9IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIGxldCBuYW1lID0gc3RhdGUudG9rZW5WYWx1ZTtcbiAgICAgICAgd2hpbGUgKChzdGF0ZS5jdXJyZW50VG9rZW4gJiAxNjM4NCAvKiBMZWZ0SGFuZFNpZGUgKi8pID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgbGV0IHN0cmluZ3M7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLmN1cnJlbnRUb2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTYzOTMgLyogRG90ICovOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5jdXJyZW50VG9rZW4gJiAzMDcyIC8qIElkZW50aWZpZXJOYW1lICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHN0YXRlLnRva2VuVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSAkVGhpcyB0byAkU2NvcGUsIGNoYW5nZSAkU2NvcGUgdG8gJE1lbWJlciwga2VlcCAkTWVtYmVyIGFzLWlzLCBjaGFuZ2UgJEtleWVkIHRvICRNZW1iZXIsIGRpc3JlZ2FyZCBvdGhlciBmbGFnc1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3MgPSAoKGFjY2VzcyAmICg1MTIgLyogVGhpcyAqLyB8IDEwMjQgLyogU2NvcGUgKi8pKSA8PCAxKSB8IChhY2Nlc3MgJiAyMDQ4IC8qIE1lbWJlciAqLykgfCAoKGFjY2VzcyAmIDQwOTYgLyogS2V5ZWQgKi8pID4+IDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSA2NzE3NTEgLyogT3BlblBhcmVuICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWNjZXNzID09PSAwIC8qIFJlc2V0ICovKSB7IC8vIGlmIHRoZSBsZWZ0IGhhbmQgc2lkZSBpcyBhIGxpdGVyYWwsIG1ha2Ugc3VyZSB3ZSBwYXJzZSBhIENhbGxNZW1iZXJFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMjA0OCAvKiBNZW1iZXIgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjZXNzICYgMTAyNCAvKiBTY29wZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFjY2Vzc1Njb3BlRXhwcmVzc2lvbihuYW1lLCByZXN1bHQuYW5jZXN0b3IsIHJlc3VsdCA9PT0gJGhvc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBpZiBpdCdzIG5vdCAkU2NvcGUsIGl0J3MgJE1lbWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFjY2Vzc01lbWJlckV4cHJlc3Npb24ocmVzdWx0LCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDY3MTc1NyAvKiBPcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VzcyA9IDQwOTYgLyogS2V5ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBY2Nlc3NLZXllZEV4cHJlc3Npb24ocmVzdWx0LCBwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxODM1MDIyIC8qIENsb3NlQnJhY2tldCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjcxNzUxIC8qIE9wZW5QYXJlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxODM1MDE5IC8qIENsb3NlUGFyZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZShzdGF0ZSwgMCAvKiBSZXNldCAqLywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc2IC8qIENvbW1hICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWUoc3RhdGUsIDE4MzUwMTkgLyogQ2xvc2VQYXJlbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2Nlc3MgJiAxMDI0IC8qIFNjb3BlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ2FsbFNjb3BlRXhwcmVzc2lvbihuYW1lLCBhcmdzLCByZXN1bHQuYW5jZXN0b3IsIHJlc3VsdCA9PT0gJGhvc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VzcyAmIDIwNDggLyogTWVtYmVyICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ2FsbE1lbWJlckV4cHJlc3Npb24ocmVzdWx0LCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDYWxsRnVuY3Rpb25FeHByZXNzaW9uKHJlc3VsdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1NDA3MTQgLyogVGVtcGxhdGVUYWlsICovOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hc3NpZ25hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3MgPSBbc3RhdGUudG9rZW5WYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oc3RyaW5ncywgc3RyaW5ncywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1NDA3MTUgLyogVGVtcGxhdGVDb250aW51YXRpb24gKi86XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVGVtcGxhdGUoc3RhdGUsIGFjY2VzcywgYmluZGluZ1R5cGUsIHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoNDQ4IC8qIEJpbmFyeSAqLyA8IG1pblByZWNlZGVuY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIHBhcnNlQmluYXJ5RXhwcmVzc2lvblxuICAgICAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW11bHRpcGxpY2F0aXZlLW9wZXJhdG9yc1xuICAgICAqXG4gICAgICogTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uIDogKGxvY2FsIHByZWNlZGVuY2UgNilcbiAgICAgKiBVbmFyeUV4cHJlc3Npb25cbiAgICAgKiBNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24gKiAvICUgVW5hcnlFeHByZXNzaW9uXG4gICAgICpcbiAgICAgKiBBZGRpdGl2ZUV4cHJlc3Npb24gOiAobG9jYWwgcHJlY2VkZW5jZSA1KVxuICAgICAqIE11bHRpcGxpY2F0aXZlRXhwcmVzc2lvblxuICAgICAqIEFkZGl0aXZlRXhwcmVzc2lvbiArIC0gTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uXG4gICAgICpcbiAgICAgKiBSZWxhdGlvbmFsRXhwcmVzc2lvbiA6IChsb2NhbCBwcmVjZWRlbmNlIDQpXG4gICAgICogQWRkaXRpdmVFeHByZXNzaW9uXG4gICAgICogUmVsYXRpb25hbEV4cHJlc3Npb24gPCA+IDw9ID49IGluc3RhbmNlb2YgaW4gQWRkaXRpdmVFeHByZXNzaW9uXG4gICAgICpcbiAgICAgKiBFcXVhbGl0eUV4cHJlc3Npb24gOiAobG9jYWwgcHJlY2VkZW5jZSAzKVxuICAgICAqIFJlbGF0aW9uYWxFeHByZXNzaW9uXG4gICAgICogRXF1YWxpdHlFeHByZXNzaW9uID09ICE9ID09PSAhPT0gUmVsYXRpb25hbEV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIExvZ2ljYWxBTkRFeHByZXNzaW9uIDogKGxvY2FsIHByZWNlZGVuY2UgMilcbiAgICAgKiBFcXVhbGl0eUV4cHJlc3Npb25cbiAgICAgKiBMb2dpY2FsQU5ERXhwcmVzc2lvbiAmJiBFcXVhbGl0eUV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIExvZ2ljYWxPUkV4cHJlc3Npb24gOiAobG9jYWwgcHJlY2VkZW5jZSAxKVxuICAgICAqIExvZ2ljYWxBTkRFeHByZXNzaW9uXG4gICAgICogTG9naWNhbE9SRXhwcmVzc2lvbiB8fCBMb2dpY2FsQU5ERXhwcmVzc2lvblxuICAgICAqL1xuICAgIHdoaWxlICgoc3RhdGUuY3VycmVudFRva2VuICYgNjU1MzYgLyogQmluYXJ5T3AgKi8pID4gMCkge1xuICAgICAgICBjb25zdCBvcFRva2VuID0gc3RhdGUuY3VycmVudFRva2VuO1xuICAgICAgICBpZiAoKG9wVG9rZW4gJiA0NDggLyogUHJlY2VkZW5jZSAqLykgPD0gbWluUHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeUV4cHJlc3Npb24oVG9rZW5WYWx1ZXNbb3BUb2tlbiAmIDYzIC8qIFR5cGUgKi9dLCByZXN1bHQsIHBhcnNlKHN0YXRlLCBhY2Nlc3MsIG9wVG9rZW4gJiA0NDggLyogUHJlY2VkZW5jZSAqLywgYmluZGluZ1R5cGUpKTtcbiAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoNjMgLyogQ29uZGl0aW9uYWwgKi8gPCBtaW5QcmVjZWRlbmNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4gICAgICogaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNwcm9kLUNvbmRpdGlvbmFsRXhwcmVzc2lvblxuICAgICAqXG4gICAgICogQ29uZGl0aW9uYWxFeHByZXNzaW9uIDpcbiAgICAgKiAxLiBCaW5hcnlFeHByZXNzaW9uXG4gICAgICogMi4gQmluYXJ5RXhwcmVzc2lvbiA/IEFzc2lnbm1lbnRFeHByZXNzaW9uIDogQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIElzVmFsaWRBc3NpZ25tZW50VGFyZ2V0XG4gICAgICogMSwyID0gZmFsc2VcbiAgICAgKi9cbiAgICBpZiAoY29uc3VtZU9wdChzdGF0ZSwgMTU3Mjg4MCAvKiBRdWVzdGlvbiAqLykpIHtcbiAgICAgICAgY29uc3QgeWVzID0gcGFyc2Uoc3RhdGUsIGFjY2VzcywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSk7XG4gICAgICAgIGNvbnN1bWUoc3RhdGUsIDE1NzI4NzkgLyogQ29sb24gKi8pO1xuICAgICAgICByZXN1bHQgPSBuZXcgQ29uZGl0aW9uYWxFeHByZXNzaW9uKHJlc3VsdCwgeWVzLCBwYXJzZShzdGF0ZSwgYWNjZXNzLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlKSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKDYyIC8qIEFzc2lnbiAqLyA8IG1pblByZWNlZGVuY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICAgKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3Byb2QtQXNzaWdubWVudEV4cHJlc3Npb25cbiAgICAgKiBOb3RlOiBBc3NpZ25tZW50RXhwcmVzc2lvbiBoZXJlIGlzIGVxdWl2YWxlbnQgdG8gRVMgRXhwcmVzc2lvbiBiZWNhdXNlIHdlIGRvbid0IHBhcnNlIHRoZSBjb21tYSBvcGVyYXRvclxuICAgICAqXG4gICAgICogQXNzaWdubWVudEV4cHJlc3Npb24gOlxuICAgICAqIDEuIENvbmRpdGlvbmFsRXhwcmVzc2lvblxuICAgICAqIDIuIExlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgICAqXG4gICAgICogSXNWYWxpZEFzc2lnbm1lbnRUYXJnZXRcbiAgICAgKiAxLDIgPSBmYWxzZVxuICAgICAqL1xuICAgIGlmIChjb25zdW1lT3B0KHN0YXRlLCAxMDQ4NjE2IC8qIEVxdWFscyAqLykpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5hc3NpZ25hYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlZnQgaGFuZCBzaWRlIG9mIGV4cHJlc3Npb24gaXMgbm90IGFzc2lnbmFibGU6ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBuZXcgQXNzaWduRXhwcmVzc2lvbihyZXN1bHQsIHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpKTtcbiAgICB9XG4gICAgaWYgKDYxIC8qIFZhcmlhZGljICovIDwgbWluUHJlY2VkZW5jZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKiogcGFyc2VWYWx1ZUNvbnZlcnRlclxuICAgICAqL1xuICAgIHdoaWxlIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODg0IC8qIEJhciAqLykpIHtcbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiA9PT0gMTU3Mjg2NCAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllciB0byBjb21lIGFmdGVyIFZhbHVlQ29udmVydGVyIG9wZXJhdG9yOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHN0YXRlLnRva2VuVmFsdWU7XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgd2hpbGUgKGNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4NzkgLyogQ29sb24gKi8pKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gocGFyc2Uoc3RhdGUsIGFjY2VzcywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5ldyBWYWx1ZUNvbnZlcnRlckV4cHJlc3Npb24ocmVzdWx0LCBuYW1lLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqIHBhcnNlQmluZGluZ0JlaGF2aW9yXG4gICAgICovXG4gICAgd2hpbGUgKGNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4ODMgLyogQW1wZXJzYW5kICovKSkge1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuID09PSAxNTcyODY0IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyIHRvIGNvbWUgYWZ0ZXIgQmluZGluZ0JlaGF2aW9yIG9wZXJhdG9yOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHN0YXRlLnRva2VuVmFsdWU7XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgd2hpbGUgKGNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4NzkgLyogQ29sb24gKi8pKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gocGFyc2Uoc3RhdGUsIGFjY2VzcywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5ldyBCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uKHJlc3VsdCwgbmFtZSwgYXJncyk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gIT09IDE1NzI4NjQgLyogRU9GICovKSB7XG4gICAgICAgIGlmIChiaW5kaW5nVHlwZSAmIDIwNDggLyogSW50ZXJwb2xhdGlvbiAqLykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnRva2VuUmF3ID09PSAnb2YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQga2V5d29yZCBcIm9mXCI6ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuY29uc3VtZWQgdG9rZW46ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBwYXJzZUFycmF5TGl0ZXJhbEV4cHJlc3Npb25cbiAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jcHJvZC1BcnJheUxpdGVyYWxFeHByZXNzaW9uXG4gKlxuICogQXJyYXlMaXRlcmFsRXhwcmVzc2lvbiA6XG4gKiBbIEVsaXNpb24ob3B0KSBdXG4gKiBbIEVsZW1lbnRMaXN0IF1cbiAqIFsgRWxlbWVudExpc3QsIEVsaXNpb24ob3B0KSBdXG4gKlxuICogRWxlbWVudExpc3QgOlxuICogRWxpc2lvbihvcHQpIEFzc2lnbm1lbnRFeHByZXNzaW9uXG4gKiBFbGVtZW50TGlzdCwgRWxpc2lvbihvcHQpIEFzc2lnbm1lbnRFeHByZXNzaW9uXG4gKlxuICogRWxpc2lvbiA6XG4gKiAsXG4gKiBFbGlzaW9uICxcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcnJheUxpdGVyYWxFeHByZXNzaW9uKHN0YXRlLCBhY2Nlc3MsIGJpbmRpbmdUeXBlKSB7XG4gICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBBcnJheSgpO1xuICAgIHdoaWxlIChzdGF0ZS5jdXJyZW50VG9rZW4gIT09IDE4MzUwMjIgLyogQ2xvc2VCcmFja2V0ICovKSB7XG4gICAgICAgIGlmIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc2IC8qIENvbW1hICovKSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCgkdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IDE4MzUwMjIgLyogQ2xvc2VCcmFja2V0ICovKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUgJiB+NTEyIC8qIElzSXRlcmF0b3IgKi8pKTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lT3B0KHN0YXRlLCAxNTcyODc2IC8qIENvbW1hICovKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IDE4MzUwMjIgLyogQ2xvc2VCcmFja2V0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN1bWUoc3RhdGUsIDE4MzUwMjIgLyogQ2xvc2VCcmFja2V0ICovKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA1MTIgLyogSXNJdGVyYXRvciAqLykge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5QmluZGluZ1BhdHRlcm4oZWxlbWVudHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5TGl0ZXJhbEV4cHJlc3Npb24oZWxlbWVudHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRm9yT2ZTdGF0ZW1lbnQoc3RhdGUsIHJlc3VsdCkge1xuICAgIGlmICgocmVzdWx0LiRraW5kICYgNjU1MzYgLyogSXNGb3JEZWNsYXJhdGlvbiAqLykgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpbmRpbmdJZGVudGlmaWVyIGF0IGxlZnQgaGFuZCBzaWRlIG9mIFwib2ZcIjogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxMDUxMTgwIC8qIE9mS2V5d29yZCAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmluZGluZ0lkZW50aWZpZXIgYXQgbGVmdCBoYW5kIHNpZGUgb2YgXCJvZlwiOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgfVxuICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSByZXN1bHQ7XG4gICAgY29uc3Qgc3RhdGVtZW50ID0gcGFyc2Uoc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYxIC8qIFZhcmlhZGljICovLCAwIC8qIE5vbmUgKi8pO1xuICAgIHJldHVybiBuZXcgRm9yT2ZTdGF0ZW1lbnQoZGVjbGFyYXRpb24sIHN0YXRlbWVudCk7XG59XG4vKipcbiAqIHBhcnNlT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb25cbiAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jcHJvZC1MaXRlcmFsXG4gKlxuICogT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24gOlxuICogeyB9XG4gKiB7IFByb3BlcnR5RGVmaW5pdGlvbkxpc3QgfVxuICpcbiAqIFByb3BlcnR5RGVmaW5pdGlvbkxpc3QgOlxuICogUHJvcGVydHlEZWZpbml0aW9uXG4gKiBQcm9wZXJ0eURlZmluaXRpb25MaXN0LCBQcm9wZXJ0eURlZmluaXRpb25cbiAqXG4gKiBQcm9wZXJ0eURlZmluaXRpb24gOlxuICogSWRlbnRpZmllck5hbWVcbiAqIFByb3BlcnR5TmFtZSA6IEFzc2lnbm1lbnRFeHByZXNzaW9uXG4gKlxuICogUHJvcGVydHlOYW1lIDpcbiAqIElkZW50aWZpZXJOYW1lXG4gKiBTdHJpbmdMaXRlcmFsXG4gKiBOdW1lcmljTGl0ZXJhbFxuICovXG5mdW5jdGlvbiBwYXJzZU9iamVjdExpdGVyYWxFeHByZXNzaW9uKHN0YXRlLCBiaW5kaW5nVHlwZSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5jdXJyZW50VG9rZW4gIT09IDE4MzUwMTggLyogQ2xvc2VCcmFjZSAqLykge1xuICAgICAgICBrZXlzLnB1c2goc3RhdGUudG9rZW5WYWx1ZSk7XG4gICAgICAgIC8vIExpdGVyYWwgPSBtYW5kYXRvcnkgY29sb25cbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRUb2tlbiAmIDEyMjg4IC8qIFN0cmluZ09yTnVtZXJpY0xpdGVyYWwgKi8pIHtcbiAgICAgICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgICAgICBjb25zdW1lKHN0YXRlLCAxNTcyODc5IC8qIENvbG9uICovKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlKHN0YXRlLCAwIC8qIFJlc2V0ICovLCA2MiAvKiBBc3NpZ24gKi8sIGJpbmRpbmdUeXBlICYgfjUxMiAvKiBJc0l0ZXJhdG9yICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuY3VycmVudFRva2VuICYgMzA3MiAvKiBJZGVudGlmaWVyTmFtZSAqLykge1xuICAgICAgICAgICAgLy8gSWRlbnRpZmllck5hbWUgPSBvcHRpb25hbCBjb2xvblxuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50Q2hhciwgY3VycmVudFRva2VuLCBpbmRleCB9ID0gc3RhdGU7XG4gICAgICAgICAgICBuZXh0VG9rZW4oc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVPcHQoc3RhdGUsIDE1NzI4NzkgLyogQ29sb24gKi8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2Uoc3RhdGUsIDAgLyogUmVzZXQgKi8sIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUgJiB+NTEyIC8qIElzSXRlcmF0b3IgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNob3J0aGFuZFxuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRDaGFyID0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudFRva2VuID0gY3VycmVudFRva2VuO1xuICAgICAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2Uoc3RhdGUsIDAgLyogUmVzZXQgKi8sIDQ1MCAvKiBQcmltYXJ5ICovLCBiaW5kaW5nVHlwZSAmIH41MTIgLyogSXNJdGVyYXRvciAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHByb3BlcnR5IGRlZmluaXRpb24gaW4gb2JqZWN0IGxpdGVyYWw6ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuY3VycmVudFRva2VuICE9PSAxODM1MDE4IC8qIENsb3NlQnJhY2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnN1bWUoc3RhdGUsIDE1NzI4NzYgLyogQ29tbWEgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN1bWUoc3RhdGUsIDE4MzUwMTggLyogQ2xvc2VCcmFjZSAqLyk7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgNTEyIC8qIElzSXRlcmF0b3IgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RCaW5kaW5nUGF0dGVybihrZXlzLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdExpdGVyYWxFeHByZXNzaW9uKGtleXMsIHZhbHVlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbnRlcnBvbGF0aW9uKHN0YXRlKSB7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgd2hpbGUgKHN0YXRlLmluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUuY3VycmVudENoYXIpIHtcbiAgICAgICAgICAgIGNhc2UgMzYgLyogRG9sbGFyICovOlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLmluZGV4ICsgMSkgPT09IDEyMyAvKiBPcGVuQnJhY2UgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudENoYXIgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKHN0YXRlLCAwIC8qIFJlc2V0ICovLCA2MSAvKiBWYXJpYWRpYyAqLywgMjA0OCAvKiBJbnRlcnBvbGF0aW9uICovKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTIgLyogQmFja3NsYXNoICovOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlQ29kZShuZXh0Q2hhcihzdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhdGUuY3VycmVudENoYXIpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRDaGFyKHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbihwYXJ0cywgZXhwcmVzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogcGFyc2VUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uXG4gKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3Byb2QtTGl0ZXJhbFxuICpcbiAqIFRlbXBsYXRlRXhwcmVzc2lvbiA6XG4gKiBOb1N1YnN0aXR1dGlvblRlbXBsYXRlXG4gKiBUZW1wbGF0ZUhlYWRcbiAqXG4gKiBOb1N1YnN0aXR1dGlvblRlbXBsYXRlIDpcbiAqIGAgVGVtcGxhdGVDaGFyYWN0ZXJzKG9wdCkgYFxuICpcbiAqIFRlbXBsYXRlSGVhZCA6XG4gKiBgIFRlbXBsYXRlQ2hhcmFjdGVycyhvcHQpICR7XG4gKlxuICogVGVtcGxhdGVTdWJzdGl0dXRpb25UYWlsIDpcbiAqIFRlbXBsYXRlTWlkZGxlXG4gKiBUZW1wbGF0ZVRhaWxcbiAqXG4gKiBUZW1wbGF0ZU1pZGRsZSA6XG4gKiB9IFRlbXBsYXRlQ2hhcmFjdGVycyhvcHQpICR7XG4gKlxuICogVGVtcGxhdGVUYWlsIDpcbiAqIH0gVGVtcGxhdGVDaGFyYWN0ZXJzKG9wdCkgYFxuICpcbiAqIFRlbXBsYXRlQ2hhcmFjdGVycyA6XG4gKiBUZW1wbGF0ZUNoYXJhY3RlciBUZW1wbGF0ZUNoYXJhY3RlcnMob3B0KVxuICpcbiAqIFRlbXBsYXRlQ2hhcmFjdGVyIDpcbiAqICQgW2xvb2thaGVhZCDiiaAge11cbiAqIFxcIEVzY2FwZVNlcXVlbmNlXG4gKiBTb3VyY2VDaGFyYWN0ZXIgKGJ1dCBub3Qgb25lIG9mIGAgb3IgXFwgb3IgJClcbiAqL1xuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZShzdGF0ZSwgYWNjZXNzLCBiaW5kaW5nVHlwZSwgcmVzdWx0LCB0YWdnZWQpIHtcbiAgICBjb25zdCBjb29rZWQgPSBbc3RhdGUudG9rZW5WYWx1ZV07XG4gICAgLy8gVE9ETzogcHJvcGVybHkgaW1wbGVtZW50IHJhdyBwYXJ0cyAvIGRlY2lkZSB3aGV0aGVyIHdlIHdhbnQgdGhpc1xuICAgIGNvbnN1bWUoc3RhdGUsIDU0MDcxNSAvKiBUZW1wbGF0ZUNvbnRpbnVhdGlvbiAqLyk7XG4gICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbcGFyc2Uoc3RhdGUsIGFjY2VzcywgNjIgLyogQXNzaWduICovLCBiaW5kaW5nVHlwZSldO1xuICAgIHdoaWxlICgoc3RhdGUuY3VycmVudFRva2VuID0gc2NhblRlbXBsYXRlVGFpbChzdGF0ZSkpICE9PSA1NDA3MTQgLyogVGVtcGxhdGVUYWlsICovKSB7XG4gICAgICAgIGNvb2tlZC5wdXNoKHN0YXRlLnRva2VuVmFsdWUpO1xuICAgICAgICBjb25zdW1lKHN0YXRlLCA1NDA3MTUgLyogVGVtcGxhdGVDb250aW51YXRpb24gKi8pO1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlKHN0YXRlLCBhY2Nlc3MsIDYyIC8qIEFzc2lnbiAqLywgYmluZGluZ1R5cGUpKTtcbiAgICB9XG4gICAgY29va2VkLnB1c2goc3RhdGUudG9rZW5WYWx1ZSk7XG4gICAgc3RhdGUuYXNzaWduYWJsZSA9IGZhbHNlO1xuICAgIGlmICh0YWdnZWQpIHtcbiAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oY29va2VkLCBjb29rZWQsIHJlc3VsdCwgZXhwcmVzc2lvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmV4dFRva2VuKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUV4cHJlc3Npb24oY29va2VkLCBleHByZXNzaW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFRva2VuKHN0YXRlKSB7XG4gICAgd2hpbGUgKHN0YXRlLmluZGV4IDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLnN0YXJ0SW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgaWYgKChzdGF0ZS5jdXJyZW50VG9rZW4gPSAoQ2hhclNjYW5uZXJzW3N0YXRlLmN1cnJlbnRDaGFyXShzdGF0ZSkpKSAhPSBudWxsKSB7IC8vIGEgbnVsbCB0b2tlbiBtZWFucyB0aGUgY2hhcmFjdGVyIG11c3QgYmUgc2tpcHBlZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmN1cnJlbnRUb2tlbiA9IDE1NzI4NjQgLyogRU9GICovO1xufVxuZnVuY3Rpb24gbmV4dENoYXIoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuY3VycmVudENoYXIgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUuaW5kZXgpO1xufVxuZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoc3RhdGUpIHtcbiAgICAvLyBydW4gdG8gdGhlIG5leHQgbm9uLWlkUGFydFxuICAgIHdoaWxlIChJZFBhcnRzW25leHRDaGFyKHN0YXRlKV0pXG4gICAgICAgIDtcbiAgICBjb25zdCB0b2tlbiA9IEtleXdvcmRMb29rdXBbc3RhdGUudG9rZW5WYWx1ZSA9IHN0YXRlLnRva2VuUmF3XTtcbiAgICByZXR1cm4gdG9rZW4gPT09IHVuZGVmaW5lZCA/IDEwMjQgLyogSWRlbnRpZmllciAqLyA6IHRva2VuO1xufVxuZnVuY3Rpb24gc2Nhbk51bWJlcihzdGF0ZSwgaXNGbG9hdCkge1xuICAgIGxldCBjaGFyID0gc3RhdGUuY3VycmVudENoYXI7XG4gICAgaWYgKGlzRmxvYXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoYXIgPSBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICAgIH0gd2hpbGUgKGNoYXIgPD0gNTcgLyogTmluZSAqLyAmJiBjaGFyID49IDQ4IC8qIFplcm8gKi8pO1xuICAgICAgICBpZiAoY2hhciAhPT0gNDYgLyogRG90ICovKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlblZhbHVlID0gcGFyc2VJbnQoc3RhdGUudG9rZW5SYXcsIDEwKTtcbiAgICAgICAgICAgIHJldHVybiA4MTkyIC8qIE51bWVyaWNMaXRlcmFsICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhc3QgdGhpcyBwb2ludCBpdCdzIGFsd2F5cyBhIGZsb2F0XG4gICAgICAgIGNoYXIgPSBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5pbmRleCA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHVubGVzcyB0aGUgbnVtYmVyIGVuZHMgd2l0aCBhIGRvdCAtIHRoYXQgYmVoYXZlcyBhIGxpdHRsZSBkaWZmZXJlbnQgaW4gbmF0aXZlIEVTIGV4cHJlc3Npb25zXG4gICAgICAgICAgICAvLyBidXQgaW4gb3VyIEFTVCB0aGF0IGJlaGF2aW9yIGhhcyBubyBlZmZlY3QgYmVjYXVzZSBudW1iZXJzIGFyZSBhbHdheXMgc3RvcmVkIGluIHZhcmlhYmxlc1xuICAgICAgICAgICAgc3RhdGUudG9rZW5WYWx1ZSA9IHBhcnNlSW50KHN0YXRlLnRva2VuUmF3LnNsaWNlKDAsIC0xKSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIDgxOTIgLyogTnVtZXJpY0xpdGVyYWwgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYXIgPD0gNTcgLyogTmluZSAqLyAmJiBjaGFyID49IDQ4IC8qIFplcm8gKi8pIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2hhciA9IG5leHRDaGFyKHN0YXRlKTtcbiAgICAgICAgfSB3aGlsZSAoY2hhciA8PSA1NyAvKiBOaW5lICovICYmIGNoYXIgPj0gNDggLyogWmVybyAqLyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGF0ZS5jdXJyZW50Q2hhciA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoLS1zdGF0ZS5pbmRleCk7XG4gICAgfVxuICAgIHN0YXRlLnRva2VuVmFsdWUgPSBwYXJzZUZsb2F0KHN0YXRlLnRva2VuUmF3KTtcbiAgICByZXR1cm4gODE5MiAvKiBOdW1lcmljTGl0ZXJhbCAqLztcbn1cbmZ1bmN0aW9uIHNjYW5TdHJpbmcoc3RhdGUpIHtcbiAgICBjb25zdCBxdW90ZSA9IHN0YXRlLmN1cnJlbnRDaGFyO1xuICAgIG5leHRDaGFyKHN0YXRlKTsgLy8gU2tpcCBpbml0aWFsIHF1b3RlLlxuICAgIGxldCB1bmVzY2FwZWQgPSAwO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheSgpO1xuICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5pbmRleDtcbiAgICB3aGlsZSAoc3RhdGUuY3VycmVudENoYXIgIT09IHF1b3RlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50Q2hhciA9PT0gOTIgLyogQmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICBidWZmZXIucHVzaChzdGF0ZS5pbnB1dC5zbGljZShtYXJrZXIsIHN0YXRlLmluZGV4KSk7XG4gICAgICAgICAgICBuZXh0Q2hhcihzdGF0ZSk7XG4gICAgICAgICAgICB1bmVzY2FwZWQgPSB1bmVzY2FwZUNvZGUoc3RhdGUuY3VycmVudENoYXIpO1xuICAgICAgICAgICAgbmV4dENoYXIoc3RhdGUpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZWQpKTtcbiAgICAgICAgICAgIG1hcmtlciA9IHN0YXRlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnRlcm1pbmF0ZWQgcXVvdGUgaW4gc3RyaW5nIGxpdGVyYWw6ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRDaGFyKHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gc3RhdGUuaW5wdXQuc2xpY2UobWFya2VyLCBzdGF0ZS5pbmRleCk7XG4gICAgbmV4dENoYXIoc3RhdGUpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxuICAgIC8vIENvbXB1dGUgdGhlIHVuZXNjYXBlZCBzdHJpbmcgdmFsdWUuXG4gICAgYnVmZmVyLnB1c2gobGFzdCk7XG4gICAgY29uc3QgdW5lc2NhcGVkU3RyID0gYnVmZmVyLmpvaW4oJycpO1xuICAgIHN0YXRlLnRva2VuVmFsdWUgPSB1bmVzY2FwZWRTdHI7XG4gICAgcmV0dXJuIDQwOTYgLyogU3RyaW5nTGl0ZXJhbCAqLztcbn1cbmZ1bmN0aW9uIHNjYW5UZW1wbGF0ZShzdGF0ZSkge1xuICAgIGxldCB0YWlsID0gdHJ1ZTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgd2hpbGUgKG5leHRDaGFyKHN0YXRlKSAhPT0gOTYgLyogQmFja3RpY2sgKi8pIHtcbiAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRDaGFyID09PSAzNiAvKiBEb2xsYXIgKi8pIHtcbiAgICAgICAgICAgIGlmICgoc3RhdGUuaW5kZXggKyAxKSA8IHN0YXRlLmxlbmd0aCAmJiBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLmluZGV4ICsgMSkgPT09IDEyMyAvKiBPcGVuQnJhY2UgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbmRleCsrO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuY3VycmVudENoYXIgPT09IDkyIC8qIEJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5lc2NhcGVDb2RlKG5leHRDaGFyKHN0YXRlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW50ZXJtaW5hdGVkIHRlbXBsYXRlIHN0cmluZzogJyR7c3RhdGUuaW5wdXR9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhdGUuY3VycmVudENoYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRDaGFyKHN0YXRlKTtcbiAgICBzdGF0ZS50b2tlblZhbHVlID0gcmVzdWx0O1xuICAgIGlmICh0YWlsKSB7XG4gICAgICAgIHJldHVybiA1NDA3MTQgLyogVGVtcGxhdGVUYWlsICovO1xuICAgIH1cbiAgICByZXR1cm4gNTQwNzE1IC8qIFRlbXBsYXRlQ29udGludWF0aW9uICovO1xufVxuZnVuY3Rpb24gc2NhblRlbXBsYXRlVGFpbChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5pbmRleCA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgc3RyaW5nOiAnJHtzdGF0ZS5pbnB1dH0nYCk7XG4gICAgfVxuICAgIHN0YXRlLmluZGV4LS07XG4gICAgcmV0dXJuIHNjYW5UZW1wbGF0ZShzdGF0ZSk7XG59XG5mdW5jdGlvbiBjb25zdW1lT3B0KHN0YXRlLCB0b2tlbikge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IHRva2VuKSB7XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb25zdW1lKHN0YXRlLCB0b2tlbikge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50VG9rZW4gPT09IHRva2VuKSB7XG4gICAgICAgIG5leHRUb2tlbihzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZXhwZWN0ZWQgdG9rZW46ICcke3N0YXRlLmlucHV0fSdgKTtcbiAgICB9XG59XG4vKipcbiAqIEFycmF5IGZvciBtYXBwaW5nIHRva2VucyB0byB0b2tlbiB2YWx1ZXMuIFRoZSBpbmRpY2VzIG9mIHRoZSB2YWx1ZXNcbiAqIGNvcnJlc3BvbmQgdG8gdGhlIHRva2VuIGJpdHMgMC0zOC5cbiAqIEZvciB0aGlzIHRvIHdvcmsgcHJvcGVybHksIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IG11c3QgYmUga2VwdCBpblxuICogdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHRva2VuIGJpdHMuXG4gKiBVc2FnZTogVG9rZW5WYWx1ZXNbdG9rZW4gJiBUb2tlbi5UeXBlXVxuICovXG5jb25zdCBUb2tlblZhbHVlcyA9IFtcbiAgICAkZmFsc2UsICR0cnVlLCAkbnVsbCwgJHVuZGVmaW5lZCwgJyR0aGlzJywgJyRob3N0JywgJyRwYXJlbnQnLFxuICAgICcoJywgJ3snLCAnLicsICd9JywgJyknLCAnLCcsICdbJywgJ10nLCAnOicsICc/JywgJ1xcJycsICdcIicsXG4gICAgJyYnLCAnfCcsICd8fCcsICcmJicsICc9PScsICchPScsICc9PT0nLCAnIT09JywgJzwnLCAnPicsXG4gICAgJzw9JywgJz49JywgJ2luJywgJ2luc3RhbmNlb2YnLCAnKycsICctJywgJ3R5cGVvZicsICd2b2lkJywgJyonLCAnJScsICcvJywgJz0nLCAnIScsXG4gICAgNTQwNzE0IC8qIFRlbXBsYXRlVGFpbCAqLywgNTQwNzE1IC8qIFRlbXBsYXRlQ29udGludWF0aW9uICovLFxuICAgICdvZidcbl07XG5jb25zdCBLZXl3b3JkTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbktleXdvcmRMb29rdXAudHJ1ZSA9IDIwNDkgLyogVHJ1ZUtleXdvcmQgKi87XG5LZXl3b3JkTG9va3VwLm51bGwgPSAyMDUwIC8qIE51bGxLZXl3b3JkICovO1xuS2V5d29yZExvb2t1cC5mYWxzZSA9IDIwNDggLyogRmFsc2VLZXl3b3JkICovO1xuS2V5d29yZExvb2t1cC51bmRlZmluZWQgPSAyMDUxIC8qIFVuZGVmaW5lZEtleXdvcmQgKi87XG5LZXl3b3JkTG9va3VwLiR0aGlzID0gMzA3NiAvKiBUaGlzU2NvcGUgKi87XG5LZXl3b3JkTG9va3VwLiRob3N0ID0gMzA3NyAvKiBIb3N0U2NvcGUgKi87XG5LZXl3b3JkTG9va3VwLiRwYXJlbnQgPSAzMDc4IC8qIFBhcmVudFNjb3BlICovO1xuS2V5d29yZExvb2t1cC5pbiA9IDE2NDA3OTkgLyogSW5LZXl3b3JkICovO1xuS2V5d29yZExvb2t1cC5pbnN0YW5jZW9mID0gMTY0MDgwMCAvKiBJbnN0YW5jZU9mS2V5d29yZCAqLztcbktleXdvcmRMb29rdXAudHlwZW9mID0gMzQ4NTEgLyogVHlwZW9mS2V5d29yZCAqLztcbktleXdvcmRMb29rdXAudm9pZCA9IDM0ODUyIC8qIFZvaWRLZXl3b3JkICovO1xuS2V5d29yZExvb2t1cC5vZiA9IDEwNTExODAgLyogT2ZLZXl3b3JkICovO1xuLyoqXG4gKiBSYW5nZXMgb2YgY29kZSBwb2ludHMgaW4gcGFpcnMgb2YgMiAoZWcgMHg0MS0weDVCLCAweDYxLTB4N0IsIC4uLikgd2hlcmUgdGhlIHNlY29uZCB2YWx1ZSBpcyBub3QgaW5jbHVzaXZlICg1LTcgbWVhbnMgNSBhbmQgNilcbiAqIFNpbmdsZSB2YWx1ZXMgYXJlIGRlbm90ZWQgYnkgdGhlIHNlY29uZCB2YWx1ZSBiZWluZyBhIDBcbiAqXG4gKiBDb3BpZWQgZnJvbSBvdXRwdXQgZ2VuZXJhdGVkIHdpdGggXCJub2RlIGJ1aWxkL2dlbmVyYXRlLXVuaWNvZGUuanNcIlxuICpcbiAqIFNlZSBhbHNvOiBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9Vbmljb2RlL0NoYXJhY3Rlcl9yZWZlcmVuY2UvMDAwMC0wRkZGXG4gKi9cbmNvbnN0IGNvZGVzID0ge1xuICAgIC8qIFskMC05QS1aYV9hLXpdICovXG4gICAgQXNjaWlJZFBhcnQ6IFsweDI0LCAwLCAweDMwLCAweDNBLCAweDQxLCAweDVCLCAweDVGLCAwLCAweDYxLCAweDdCXSxcbiAgICBJZFN0YXJ0OiAvKiBJZGVudGlmaWVyU3RhcnQgKi8gWzB4MjQsIDAsIDB4NDEsIDB4NUIsIDB4NUYsIDAsIDB4NjEsIDB4N0IsIDB4QUEsIDAsIDB4QkEsIDAsIDB4QzAsIDB4RDcsIDB4RDgsIDB4RjcsIDB4RjgsIDB4MkI5LCAweDJFMCwgMHgyRTUsIDB4MUQwMCwgMHgxRDI2LCAweDFEMkMsIDB4MUQ1RCwgMHgxRDYyLCAweDFENjYsIDB4MUQ2QiwgMHgxRDc4LCAweDFENzksIDB4MURCRiwgMHgxRTAwLCAweDFGMDAsIDB4MjA3MSwgMCwgMHgyMDdGLCAwLCAweDIwOTAsIDB4MjA5RCwgMHgyMTJBLCAweDIxMkMsIDB4MjEzMiwgMCwgMHgyMTRFLCAwLCAweDIxNjAsIDB4MjE4OSwgMHgyQzYwLCAweDJDODAsIDB4QTcyMiwgMHhBNzg4LCAweEE3OEIsIDB4QTdBRiwgMHhBN0IwLCAweEE3QjgsIDB4QTdGNywgMHhBODAwLCAweEFCMzAsIDB4QUI1QiwgMHhBQjVDLCAweEFCNjUsIDB4RkIwMCwgMHhGQjA3LCAweEZGMjEsIDB4RkYzQiwgMHhGRjQxLCAweEZGNUJdLFxuICAgIERpZ2l0OiAvKiBEZWNpbWFsTnVtYmVyICovIFsweDMwLCAweDNBXSxcbiAgICBTa2lwOiAvKiBTa2lwcGFibGUgKi8gWzAsIDB4MjEsIDB4N0YsIDB4QTFdXG59O1xuLyoqXG4gKiBEZWNvbXByZXNzIHRoZSByYW5nZXMgaW50byBhbiBhcnJheSBvZiBudW1iZXJzIHNvIHRoYXQgdGhlIGNoYXIgY29kZVxuICogY2FuIGJlIHVzZWQgYXMgYW4gaW5kZXggdG8gdGhlIGxvb2t1cFxuICovXG5mdW5jdGlvbiBkZWNvbXByZXNzKGxvb2t1cCwgJHNldCwgY29tcHJlc3NlZCwgdmFsdWUpIHtcbiAgICBjb25zdCByYW5nZUNvdW50ID0gY29tcHJlc3NlZC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpICs9IDIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBjb21wcmVzc2VkW2ldO1xuICAgICAgICBsZXQgZW5kID0gY29tcHJlc3NlZFtpICsgMV07XG4gICAgICAgIGVuZCA9IGVuZCA+IDAgPyBlbmQgOiBzdGFydCArIDE7XG4gICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgIGxvb2t1cC5maWxsKHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHNldCkge1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggPSBzdGFydDsgY2ggPCBlbmQ7IGNoKyspIHtcbiAgICAgICAgICAgICAgICAkc2V0LmFkZChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDaGFyRnVuY0xvb2t1cCBmdW5jdGlvbnNcbmZ1bmN0aW9uIHJldHVyblRva2VuKHRva2VuKSB7XG4gICAgcmV0dXJuIHMgPT4ge1xuICAgICAgICBuZXh0Q2hhcihzKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG59XG5jb25zdCB1bmV4cGVjdGVkQ2hhcmFjdGVyID0gcyA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogJyR7cy5pbnB1dH0nYCk7XG59O1xudW5leHBlY3RlZENoYXJhY3Rlci5ub3RNYXBwZWQgPSB0cnVlO1xuLy8gQVNDSUkgSWRlbnRpZmllclBhcnQgbG9va3VwXG5jb25zdCBBc2NpaUlkUGFydHMgPSBuZXcgU2V0KCk7XG5kZWNvbXByZXNzKG51bGwsIEFzY2lpSWRQYXJ0cywgY29kZXMuQXNjaWlJZFBhcnQsIHRydWUpO1xuLy8gSWRlbnRpZmllclBhcnQgbG9va3VwXG5jb25zdCBJZFBhcnRzID0gbmV3IFVpbnQ4QXJyYXkoMHhGRkZGKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5kZWNvbXByZXNzKElkUGFydHMsIG51bGwsIGNvZGVzLklkU3RhcnQsIDEpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmRlY29tcHJlc3MoSWRQYXJ0cywgbnVsbCwgY29kZXMuRGlnaXQsIDEpO1xuLy8gQ2hhcmFjdGVyIHNjYW5uaW5nIGZ1bmN0aW9uIGxvb2t1cFxuY29uc3QgQ2hhclNjYW5uZXJzID0gbmV3IEFycmF5KDB4RkZGRik7XG5DaGFyU2Nhbm5lcnMuZmlsbCh1bmV4cGVjdGVkQ2hhcmFjdGVyLCAwLCAweEZGRkYpO1xuZGVjb21wcmVzcyhDaGFyU2Nhbm5lcnMsIG51bGwsIGNvZGVzLlNraXAsIHMgPT4ge1xuICAgIG5leHRDaGFyKHMpO1xuICAgIHJldHVybiBudWxsO1xufSk7XG5kZWNvbXByZXNzKENoYXJTY2FubmVycywgbnVsbCwgY29kZXMuSWRTdGFydCwgc2NhbklkZW50aWZpZXIpO1xuZGVjb21wcmVzcyhDaGFyU2Nhbm5lcnMsIG51bGwsIGNvZGVzLkRpZ2l0LCBzID0+IHNjYW5OdW1iZXIocywgZmFsc2UpKTtcbkNoYXJTY2FubmVyc1szNCAvKiBEb3VibGVRdW90ZSAqL10gPVxuICAgIENoYXJTY2FubmVyc1szOSAvKiBTaW5nbGVRdW90ZSAqL10gPSBzID0+IHtcbiAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmcocyk7XG4gICAgfTtcbkNoYXJTY2FubmVyc1s5NiAvKiBCYWNrdGljayAqL10gPSBzID0+IHtcbiAgICByZXR1cm4gc2NhblRlbXBsYXRlKHMpO1xufTtcbi8vICEsICE9LCAhPT1cbkNoYXJTY2FubmVyc1szMyAvKiBFeGNsYW1hdGlvbiAqL10gPSBzID0+IHtcbiAgICBpZiAobmV4dENoYXIocykgIT09IDYxIC8qIEVxdWFscyAqLykge1xuICAgICAgICByZXR1cm4gMzI4MDkgLyogRXhjbGFtYXRpb24gKi87XG4gICAgfVxuICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgIHJldHVybiAxNjM4NjgwIC8qIEV4Y2xhbWF0aW9uRXF1YWxzICovO1xuICAgIH1cbiAgICBuZXh0Q2hhcihzKTtcbiAgICByZXR1cm4gMTYzODY4MiAvKiBFeGNsYW1hdGlvbkVxdWFsc0VxdWFscyAqLztcbn07XG4vLyA9LCA9PSwgPT09XG5DaGFyU2Nhbm5lcnNbNjEgLyogRXF1YWxzICovXSA9IHMgPT4ge1xuICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgIHJldHVybiAxMDQ4NjE2IC8qIEVxdWFscyAqLztcbiAgICB9XG4gICAgaWYgKG5leHRDaGFyKHMpICE9PSA2MSAvKiBFcXVhbHMgKi8pIHtcbiAgICAgICAgcmV0dXJuIDE2Mzg2NzkgLyogRXF1YWxzRXF1YWxzICovO1xuICAgIH1cbiAgICBuZXh0Q2hhcihzKTtcbiAgICByZXR1cm4gMTYzODY4MSAvKiBFcXVhbHNFcXVhbHNFcXVhbHMgKi87XG59O1xuLy8gJiwgJiZcbkNoYXJTY2FubmVyc1szOCAvKiBBbXBlcnNhbmQgKi9dID0gcyA9PiB7XG4gICAgaWYgKG5leHRDaGFyKHMpICE9PSAzOCAvKiBBbXBlcnNhbmQgKi8pIHtcbiAgICAgICAgcmV0dXJuIDE1NzI4ODMgLyogQW1wZXJzYW5kICovO1xuICAgIH1cbiAgICBuZXh0Q2hhcihzKTtcbiAgICByZXR1cm4gMTYzODYxNCAvKiBBbXBlcnNhbmRBbXBlcnNhbmQgKi87XG59O1xuLy8gfCwgfHxcbkNoYXJTY2FubmVyc1sxMjQgLyogQmFyICovXSA9IHMgPT4ge1xuICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gMTI0IC8qIEJhciAqLykge1xuICAgICAgICByZXR1cm4gMTU3Mjg4NCAvKiBCYXIgKi87XG4gICAgfVxuICAgIG5leHRDaGFyKHMpO1xuICAgIHJldHVybiAxNjM4NTQ5IC8qIEJhckJhciAqLztcbn07XG4vLyAuXG5DaGFyU2Nhbm5lcnNbNDYgLyogRG90ICovXSA9IHMgPT4ge1xuICAgIGlmIChuZXh0Q2hhcihzKSA8PSA1NyAvKiBOaW5lICovICYmIHMuY3VycmVudENoYXIgPj0gNDggLyogWmVybyAqLykge1xuICAgICAgICByZXR1cm4gc2Nhbk51bWJlcihzLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIDE2MzkzIC8qIERvdCAqLztcbn07XG4vLyA8LCA8PVxuQ2hhclNjYW5uZXJzWzYwIC8qIExlc3NUaGFuICovXSA9IHMgPT4ge1xuICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgIHJldHVybiAxNjM4NzQ3IC8qIExlc3NUaGFuICovO1xuICAgIH1cbiAgICBuZXh0Q2hhcihzKTtcbiAgICByZXR1cm4gMTYzODc0OSAvKiBMZXNzVGhhbkVxdWFscyAqLztcbn07XG4vLyA+LCA+PVxuQ2hhclNjYW5uZXJzWzYyIC8qIEdyZWF0ZXJUaGFuICovXSA9IHMgPT4ge1xuICAgIGlmIChuZXh0Q2hhcihzKSAhPT0gNjEgLyogRXF1YWxzICovKSB7XG4gICAgICAgIHJldHVybiAxNjM4NzQ4IC8qIEdyZWF0ZXJUaGFuICovO1xuICAgIH1cbiAgICBuZXh0Q2hhcihzKTtcbiAgICByZXR1cm4gMTYzODc1MCAvKiBHcmVhdGVyVGhhbkVxdWFscyAqLztcbn07XG5DaGFyU2Nhbm5lcnNbMzcgLyogUGVyY2VudCAqL10gPSByZXR1cm5Ub2tlbigxNjM4ODg2IC8qIFBlcmNlbnQgKi8pO1xuQ2hhclNjYW5uZXJzWzQwIC8qIE9wZW5QYXJlbiAqL10gPSByZXR1cm5Ub2tlbig2NzE3NTEgLyogT3BlblBhcmVuICovKTtcbkNoYXJTY2FubmVyc1s0MSAvKiBDbG9zZVBhcmVuICovXSA9IHJldHVyblRva2VuKDE4MzUwMTkgLyogQ2xvc2VQYXJlbiAqLyk7XG5DaGFyU2Nhbm5lcnNbNDIgLyogQXN0ZXJpc2sgKi9dID0gcmV0dXJuVG9rZW4oMTYzODg4NSAvKiBBc3RlcmlzayAqLyk7XG5DaGFyU2Nhbm5lcnNbNDMgLyogUGx1cyAqL10gPSByZXR1cm5Ub2tlbig2MjMwMDkgLyogUGx1cyAqLyk7XG5DaGFyU2Nhbm5lcnNbNDQgLyogQ29tbWEgKi9dID0gcmV0dXJuVG9rZW4oMTU3Mjg3NiAvKiBDb21tYSAqLyk7XG5DaGFyU2Nhbm5lcnNbNDUgLyogTWludXMgKi9dID0gcmV0dXJuVG9rZW4oNjIzMDEwIC8qIE1pbnVzICovKTtcbkNoYXJTY2FubmVyc1s0NyAvKiBTbGFzaCAqL10gPSByZXR1cm5Ub2tlbigxNjM4ODg3IC8qIFNsYXNoICovKTtcbkNoYXJTY2FubmVyc1s1OCAvKiBDb2xvbiAqL10gPSByZXR1cm5Ub2tlbigxNTcyODc5IC8qIENvbG9uICovKTtcbkNoYXJTY2FubmVyc1s2MyAvKiBRdWVzdGlvbiAqL10gPSByZXR1cm5Ub2tlbigxNTcyODgwIC8qIFF1ZXN0aW9uICovKTtcbkNoYXJTY2FubmVyc1s5MSAvKiBPcGVuQnJhY2tldCAqL10gPSByZXR1cm5Ub2tlbig2NzE3NTcgLyogT3BlbkJyYWNrZXQgKi8pO1xuQ2hhclNjYW5uZXJzWzkzIC8qIENsb3NlQnJhY2tldCAqL10gPSByZXR1cm5Ub2tlbigxODM1MDIyIC8qIENsb3NlQnJhY2tldCAqLyk7XG5DaGFyU2Nhbm5lcnNbMTIzIC8qIE9wZW5CcmFjZSAqL10gPSByZXR1cm5Ub2tlbigxMzEwODAgLyogT3BlbkJyYWNlICovKTtcbkNoYXJTY2FubmVyc1sxMjUgLyogQ2xvc2VCcmFjZSAqL10gPSByZXR1cm5Ub2tlbigxODM1MDE4IC8qIENsb3NlQnJhY2UgKi8pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwcmVzc2lvbi1wYXJzZXIuanMubWFwIiwiZXhwb3J0IHsgSVBsYXRmb3JtLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgeyBQbGF0Zm9ybSwgVGFza1F1ZXVlLCBUYXNrLCBUYXNrQWJvcnRFcnJvciwgVGFza1F1ZXVlUHJpb3JpdHksIFRhc2tTdGF0dXMsIH0gZnJvbSAnQGF1cmVsaWEvcGxhdGZvcm0nO1xuZXhwb3J0IHsgYWxpYXMsIHJlZ2lzdGVyQWxpYXNlcywgfSBmcm9tICcuL2FsaWFzLmpzJztcbmV4cG9ydCB7IEV4cHJlc3Npb25LaW5kLCBDYWxsRnVuY3Rpb25FeHByZXNzaW9uLCBDdXN0b21FeHByZXNzaW9uLCBCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uLCBWYWx1ZUNvbnZlcnRlckV4cHJlc3Npb24sIEFzc2lnbkV4cHJlc3Npb24sIENvbmRpdGlvbmFsRXhwcmVzc2lvbiwgQWNjZXNzVGhpc0V4cHJlc3Npb24sIEFjY2Vzc1Njb3BlRXhwcmVzc2lvbiwgQWNjZXNzTWVtYmVyRXhwcmVzc2lvbiwgQWNjZXNzS2V5ZWRFeHByZXNzaW9uLCBDYWxsU2NvcGVFeHByZXNzaW9uLCBDYWxsTWVtYmVyRXhwcmVzc2lvbiwgQmluYXJ5RXhwcmVzc2lvbiwgVW5hcnlFeHByZXNzaW9uLCBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbiwgSHRtbExpdGVyYWxFeHByZXNzaW9uLCBBcnJheUxpdGVyYWxFeHByZXNzaW9uLCBPYmplY3RMaXRlcmFsRXhwcmVzc2lvbiwgVGVtcGxhdGVFeHByZXNzaW9uLCBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24sIEFycmF5QmluZGluZ1BhdHRlcm4sIE9iamVjdEJpbmRpbmdQYXR0ZXJuLCBCaW5kaW5nSWRlbnRpZmllciwgRm9yT2ZTdGF0ZW1lbnQsIEludGVycG9sYXRpb24sIH0gZnJvbSAnLi9iaW5kaW5nL2FzdC5qcyc7XG5leHBvcnQgeyBjb25uZWN0YWJsZSwgQmluZGluZ01lZGlhdG9yLCBCaW5kaW5nT2JzZXJ2ZXJSZWNvcmQsIH0gZnJvbSAnLi9iaW5kaW5nL2Nvbm5lY3RhYmxlLmpzJztcbmV4cG9ydCB7IElFeHByZXNzaW9uUGFyc2VyLCBCaW5kaW5nVHlwZSwgcGFyc2VFeHByZXNzaW9uLCBDaGFyLCBBY2Nlc3MsIFByZWNlZGVuY2UsIHBhcnNlLCBQYXJzZXJTdGF0ZSwgfSBmcm9tICcuL2JpbmRpbmcvZXhwcmVzc2lvbi1wYXJzZXIuanMnO1xuZXhwb3J0IHsgQXJyYXlPYnNlcnZlciwgQXJyYXlJbmRleE9ic2VydmVyLCBlbmFibGVBcnJheU9ic2VydmF0aW9uLCBkaXNhYmxlQXJyYXlPYnNlcnZhdGlvbiwgYXBwbHlNdXRhdGlvbnNUb0luZGljZXMsIHN5bmNocm9uaXplSW5kaWNlcywgfSBmcm9tICcuL29ic2VydmF0aW9uL2FycmF5LW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IE1hcE9ic2VydmVyLCBlbmFibGVNYXBPYnNlcnZhdGlvbiwgZGlzYWJsZU1hcE9ic2VydmF0aW9uLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vbWFwLW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IFNldE9ic2VydmVyLCBlbmFibGVTZXRPYnNlcnZhdGlvbiwgZGlzYWJsZVNldE9ic2VydmF0aW9uIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9zZXQtb2JzZXJ2ZXIuanMnO1xuZXhwb3J0IHsgQmluZGluZ0NvbnRleHQsIFNjb3BlLCBPdmVycmlkZUNvbnRleHQsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9iaW5kaW5nLWNvbnRleHQuanMnO1xuZXhwb3J0IHsgQ29sbGVjdGlvbkxlbmd0aE9ic2VydmVyLCBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vY29sbGVjdGlvbi1sZW5ndGgtb2JzZXJ2ZXIuanMnO1xuZXhwb3J0IHsgQ29tcHV0ZWRPYnNlcnZlciwgfSBmcm9tICcuL29ic2VydmF0aW9uL2NvbXB1dGVkLW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IElEaXJ0eUNoZWNrZXIsIERpcnR5Q2hlY2tQcm9wZXJ0eSwgRGlydHlDaGVja1NldHRpbmdzLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vZGlydHktY2hlY2tlci5qcyc7XG5leHBvcnQgeyBvYnNlcnZhYmxlLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vb2JzZXJ2YWJsZS5qcyc7XG5leHBvcnQgeyBJT2JzZXJ2ZXJMb2NhdG9yLCBJTm9kZU9ic2VydmVyTG9jYXRvciwgZ2V0Q29sbGVjdGlvbk9ic2VydmVyLCBPYnNlcnZlckxvY2F0b3IsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9vYnNlcnZlci1sb2NhdG9yLmpzJztcbmV4cG9ydCB7IFByaW1pdGl2ZU9ic2VydmVyLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vcHJpbWl0aXZlLW9ic2VydmVyLmpzJztcbmV4cG9ydCB7IFByb3BlcnR5QWNjZXNzb3IsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9wcm9wZXJ0eS1hY2Nlc3Nvci5qcyc7XG5leHBvcnQgeyBQcm94eU9ic2VydmFibGUsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9wcm94eS1vYnNlcnZhdGlvbi5qcyc7XG5leHBvcnQgeyBTZXR0ZXJPYnNlcnZlciwgfSBmcm9tICcuL29ic2VydmF0aW9uL3NldHRlci1vYnNlcnZlci5qcyc7XG5leHBvcnQgeyBJU2lnbmFsZXIsIH0gZnJvbSAnLi9vYnNlcnZhdGlvbi9zaWduYWxlci5qcyc7XG5leHBvcnQgeyBTdWJzY3JpYmVyUmVjb3JkLCBzdWJzY3JpYmVyQ29sbGVjdGlvbiwgfSBmcm9tICcuL29ic2VydmF0aW9uL3N1YnNjcmliZXItY29sbGVjdGlvbi5qcyc7XG5leHBvcnQgeyBDb25uZWN0YWJsZVN3aXRjaGVyLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24vY29ubmVjdGFibGUtc3dpdGNoZXIuanMnO1xuZXhwb3J0IHsgYmluZGluZ0JlaGF2aW9yLCBCaW5kaW5nQmVoYXZpb3IsIEJpbmRpbmdCZWhhdmlvckRlZmluaXRpb24sIEJpbmRpbmdJbnRlcmNlcHRvciwgQmluZGluZ0JlaGF2aW9yRmFjdG9yeSwgQmluZGluZ0JlaGF2aW9yU3RyYXRlZ3ksIH0gZnJvbSAnLi9iaW5kaW5nLWJlaGF2aW9yLmpzJztcbmV4cG9ydCB7IFZhbHVlQ29udmVydGVyLCBWYWx1ZUNvbnZlcnRlckRlZmluaXRpb24sIHZhbHVlQ29udmVydGVyLCB9IGZyb20gJy4vdmFsdWUtY29udmVydGVyLmpzJztcbmV4cG9ydCB7IEJpbmRpbmdNb2RlLCBMaWZlY3ljbGVGbGFncywgQWNjZXNzb3JUeXBlLCBDb2xsZWN0aW9uS2luZCwgRGVsZWdhdGlvblN0cmF0ZWd5LCBpc0luZGV4TWFwLCBjb3B5SW5kZXhNYXAsIGNsb25lSW5kZXhNYXAsIGNyZWF0ZUluZGV4TWFwLCB9IGZyb20gJy4vb2JzZXJ2YXRpb24uanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLypcbiogTm90ZTogdGhlIG9uZVRpbWUgYmluZGluZyBub3cgaGFzIGEgbm9uLXplcm8gdmFsdWUgZm9yIDIgcmVhc29uczpcbiogIC0gcGxheXMgbmljZXIgd2l0aCBiaXR3aXNlIG9wZXJhdGlvbnMgKG1vcmUgY29uc2lzdGVudCBjb2RlLCBtb3JlIGV4cGxpY2l0IHNldHRpbmdzKVxuKiAgLSBhbGxvd3MgZm9yIHBvdGVudGlhbGx5IGhhdmluZyBzb21ldGhpbmcgbGlrZSBCaW5kaW5nTW9kZS5vbmVUaW1lIHwgQmluZGluZ01vZGUuZnJvbVZpZXcsIHdoZXJlIGFuIGluaXRpYWwgdmFsdWUgaXMgc2V0IG9uY2UgdG8gdGhlIHZpZXcgYnV0IHVwZGF0ZXMgZnJvbSB0aGUgdmlldyBhbHNvIHByb3BhZ2F0ZSBiYWNrIHRvIHRoZSB2aWV3IG1vZGVsXG4qXG4qIEZ1cnRoZXJtb3JlLCB0aGUgXCJkZWZhdWx0XCIgbW9kZSB3b3VsZCBiZSBmb3Igc2ltcGxlIFwiLmJpbmRcIiBleHByZXNzaW9ucyB0byBtYWtlIGl0IGV4cGxpY2l0IGZvciBvdXIgbG9naWMgdGhhdCB0aGUgZGVmYXVsdCBpcyBiZWluZyB1c2VkLlxuKiBUaGlzIGVzc2VudGlhbGx5IGFkZHMgZXh0cmEgaW5mb3JtYXRpb24gd2hpY2ggYmluZGluZyBjb3VsZCB1c2UgdG8gZG8gc21hcnRlciB0aGluZ3MgYW5kIGFsbG93cyBiaW5kaW5nQmVoYXZpb3JzIHRoYXQgYWRkIGEgbW9kZSBpbnN0ZWFkIG9mIHNpbXBseSBvdmVyd3JpdGluZyBpdFxuKi9cbmV4cG9ydCB2YXIgQmluZGluZ01vZGU7XG4oZnVuY3Rpb24gKEJpbmRpbmdNb2RlKSB7XG4gICAgQmluZGluZ01vZGVbQmluZGluZ01vZGVbXCJvbmVUaW1lXCJdID0gMV0gPSBcIm9uZVRpbWVcIjtcbiAgICBCaW5kaW5nTW9kZVtCaW5kaW5nTW9kZVtcInRvVmlld1wiXSA9IDJdID0gXCJ0b1ZpZXdcIjtcbiAgICBCaW5kaW5nTW9kZVtCaW5kaW5nTW9kZVtcImZyb21WaWV3XCJdID0gNF0gPSBcImZyb21WaWV3XCI7XG4gICAgQmluZGluZ01vZGVbQmluZGluZ01vZGVbXCJ0d29XYXlcIl0gPSA2XSA9IFwidHdvV2F5XCI7XG4gICAgQmluZGluZ01vZGVbQmluZGluZ01vZGVbXCJkZWZhdWx0XCJdID0gOF0gPSBcImRlZmF1bHRcIjtcbn0pKEJpbmRpbmdNb2RlIHx8IChCaW5kaW5nTW9kZSA9IHt9KSk7XG5leHBvcnQgdmFyIExpZmVjeWNsZUZsYWdzO1xuKGZ1bmN0aW9uIChMaWZlY3ljbGVGbGFncykge1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wibm9uZVwiXSA9IDBdID0gXCJub25lXCI7XG4gICAgLy8gQml0bWFzayBmb3IgZmxhZ3MgdGhhdCBuZWVkIHRvIGJlIHN0b3JlZCBvbiBhIGJpbmRpbmcgZHVyaW5nICRiaW5kIGZvciBtdXRhdGlvblxuICAgIC8vIGNhbGxiYWNrcyBvdXRzaWRlIG9mICRiaW5kXG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJwZXJzaXN0ZW50QmluZGluZ0ZsYWdzXCJdID0gMTUzNjddID0gXCJwZXJzaXN0ZW50QmluZGluZ0ZsYWdzXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJhbGxvd1BhcmVudFNjb3BlVHJhdmVyc2FsXCJdID0gMTAyNF0gPSBcImFsbG93UGFyZW50U2NvcGVUcmF2ZXJzYWxcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcIm9ic2VydmVMZWFmUHJvcGVydGllc09ubHlcIl0gPSAyMDQ4XSA9IFwib2JzZXJ2ZUxlYWZQcm9wZXJ0aWVzT25seVwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1widGFyZ2V0T2JzZXJ2ZXJGbGFnc1wiXSA9IDEyMjk1XSA9IFwidGFyZ2V0T2JzZXJ2ZXJGbGFnc1wiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wibm9GbHVzaFwiXSA9IDQwOTZdID0gXCJub0ZsdXNoXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJwZXJzaXN0ZW50VGFyZ2V0T2JzZXJ2ZXJRdWV1ZVwiXSA9IDgxOTJdID0gXCJwZXJzaXN0ZW50VGFyZ2V0T2JzZXJ2ZXJRdWV1ZVwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiYmluZGluZ1N0cmF0ZWd5XCJdID0gN10gPSBcImJpbmRpbmdTdHJhdGVneVwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZ2V0dGVyU2V0dGVyU3RyYXRlZ3lcIl0gPSAxXSA9IFwiZ2V0dGVyU2V0dGVyU3RyYXRlZ3lcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcInByb3h5U3RyYXRlZ3lcIl0gPSAyXSA9IFwicHJveHlTdHJhdGVneVwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiaXNTdHJpY3RCaW5kaW5nU3RyYXRlZ3lcIl0gPSA0XSA9IFwiaXNTdHJpY3RCaW5kaW5nU3RyYXRlZ3lcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcInVwZGF0ZVwiXSA9IDI0XSA9IFwidXBkYXRlXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJ1cGRhdGVUYXJnZXRcIl0gPSA4XSA9IFwidXBkYXRlVGFyZ2V0XCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJ1cGRhdGVTb3VyY2VcIl0gPSAxNl0gPSBcInVwZGF0ZVNvdXJjZVwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbVwiXSA9IDk2XSA9IFwiZnJvbVwiO1xuICAgIExpZmVjeWNsZUZsYWdzW0xpZmVjeWNsZUZsYWdzW1wiZnJvbUJpbmRcIl0gPSAzMl0gPSBcImZyb21CaW5kXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJmcm9tVW5iaW5kXCJdID0gNjRdID0gXCJmcm9tVW5iaW5kXCI7XG4gICAgTGlmZWN5Y2xlRmxhZ3NbTGlmZWN5Y2xlRmxhZ3NbXCJtdXN0RXZhbHVhdGVcIl0gPSAxMjhdID0gXCJtdXN0RXZhbHVhdGVcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImlzVHJhdmVyc2luZ1BhcmVudFNjb3BlXCJdID0gMjU2XSA9IFwiaXNUcmF2ZXJzaW5nUGFyZW50U2NvcGVcIjtcbiAgICBMaWZlY3ljbGVGbGFnc1tMaWZlY3ljbGVGbGFnc1tcImRpc3Bvc2VcIl0gPSA1MTJdID0gXCJkaXNwb3NlXCI7XG59KShMaWZlY3ljbGVGbGFncyB8fCAoTGlmZWN5Y2xlRmxhZ3MgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHZhciBTdWJzY3JpYmVyRmxhZ3M7XG4oZnVuY3Rpb24gKFN1YnNjcmliZXJGbGFncykge1xuICAgIFN1YnNjcmliZXJGbGFnc1tTdWJzY3JpYmVyRmxhZ3NbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBTdWJzY3JpYmVyRmxhZ3NbU3Vic2NyaWJlckZsYWdzW1wiU3Vic2NyaWJlcjBcIl0gPSAxXSA9IFwiU3Vic2NyaWJlcjBcIjtcbiAgICBTdWJzY3JpYmVyRmxhZ3NbU3Vic2NyaWJlckZsYWdzW1wiU3Vic2NyaWJlcjFcIl0gPSAyXSA9IFwiU3Vic2NyaWJlcjFcIjtcbiAgICBTdWJzY3JpYmVyRmxhZ3NbU3Vic2NyaWJlckZsYWdzW1wiU3Vic2NyaWJlcjJcIl0gPSA0XSA9IFwiU3Vic2NyaWJlcjJcIjtcbiAgICBTdWJzY3JpYmVyRmxhZ3NbU3Vic2NyaWJlckZsYWdzW1wiU3Vic2NyaWJlcnNSZXN0XCJdID0gOF0gPSBcIlN1YnNjcmliZXJzUmVzdFwiO1xuICAgIFN1YnNjcmliZXJGbGFnc1tTdWJzY3JpYmVyRmxhZ3NbXCJBbnlcIl0gPSAxNV0gPSBcIkFueVwiO1xufSkoU3Vic2NyaWJlckZsYWdzIHx8IChTdWJzY3JpYmVyRmxhZ3MgPSB7fSkpO1xuZXhwb3J0IHZhciBEZWxlZ2F0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKERlbGVnYXRpb25TdHJhdGVneSkge1xuICAgIERlbGVnYXRpb25TdHJhdGVneVtEZWxlZ2F0aW9uU3RyYXRlZ3lbXCJub25lXCJdID0gMF0gPSBcIm5vbmVcIjtcbiAgICBEZWxlZ2F0aW9uU3RyYXRlZ3lbRGVsZWdhdGlvblN0cmF0ZWd5W1wiY2FwdHVyaW5nXCJdID0gMV0gPSBcImNhcHR1cmluZ1wiO1xuICAgIERlbGVnYXRpb25TdHJhdGVneVtEZWxlZ2F0aW9uU3RyYXRlZ3lbXCJidWJibGluZ1wiXSA9IDJdID0gXCJidWJibGluZ1wiO1xufSkoRGVsZWdhdGlvblN0cmF0ZWd5IHx8IChEZWxlZ2F0aW9uU3RyYXRlZ3kgPSB7fSkpO1xuZXhwb3J0IHZhciBDb2xsZWN0aW9uS2luZDtcbihmdW5jdGlvbiAoQ29sbGVjdGlvbktpbmQpIHtcbiAgICBDb2xsZWN0aW9uS2luZFtDb2xsZWN0aW9uS2luZFtcImluZGV4ZWRcIl0gPSA4XSA9IFwiaW5kZXhlZFwiO1xuICAgIENvbGxlY3Rpb25LaW5kW0NvbGxlY3Rpb25LaW5kW1wia2V5ZWRcIl0gPSA0XSA9IFwia2V5ZWRcIjtcbiAgICBDb2xsZWN0aW9uS2luZFtDb2xsZWN0aW9uS2luZFtcImFycmF5XCJdID0gOV0gPSBcImFycmF5XCI7XG4gICAgQ29sbGVjdGlvbktpbmRbQ29sbGVjdGlvbktpbmRbXCJtYXBcIl0gPSA2XSA9IFwibWFwXCI7XG4gICAgQ29sbGVjdGlvbktpbmRbQ29sbGVjdGlvbktpbmRbXCJzZXRcIl0gPSA3XSA9IFwic2V0XCI7XG59KShDb2xsZWN0aW9uS2luZCB8fCAoQ29sbGVjdGlvbktpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBBY2Nlc3NvclR5cGU7XG4oZnVuY3Rpb24gKEFjY2Vzc29yVHlwZSkge1xuICAgIEFjY2Vzc29yVHlwZVtBY2Nlc3NvclR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiT2JzZXJ2ZXJcIl0gPSAxXSA9IFwiT2JzZXJ2ZXJcIjtcbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiTm9kZVwiXSA9IDJdID0gXCJOb2RlXCI7XG4gICAgLy8gbWlzYyBjaGFyYWN0ZXJpc3RpYyBvZiBhY2Nlc3NvcnMvb2JzZXJ2ZXJzIHdoZW4gdXBkYXRlXG4gICAgLy9cbiAgICAvLyBieSBkZWZhdWx0LCBldmVyeXRoaW5nIGlzIHN5bmNocm9ub3VzXG4gICAgLy8gZXhjZXB0IGNoYW5nZXMgdGhhdCBhcmUgc3VwcG9zZWQgdG8gY2F1c2UgcmVmbG93L2hlYXZ5IGNvbXB1dGF0aW9uXG4gICAgLy8gYW4gb2JzZXJ2ZXIgY2FuIHVzZSB0aGlzIGZsYWcgdG8gc2lnbmFsIGJpbmRpbmcgdGhhdCBkb24ndCBjYXJlbGVzc2x5IHRlbGwgaXQgdG8gdXBkYXRlXG4gICAgLy8gcXVldWUgaXQgaW5zdGVhZFxuICAgIC8vIHRvZG86IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYVxuICAgIC8vIHRvZG86IGh0dHBzOi8vY3NzdHJpZ2dlcnMuY29tL1xuICAgIEFjY2Vzc29yVHlwZVtBY2Nlc3NvclR5cGVbXCJMYXlvdXRcIl0gPSA0XSA9IFwiTGF5b3V0XCI7XG4gICAgLy8gYnkgZGVmYXVsdCwgZXZlcnl0aGluZyBpcyBhbiBvYmplY3RcbiAgICAvLyBlZzogYSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCBvbiBhbiBvYmplY3RcbiAgICAvLyB1bmxlc3MgZXhwbGljaXRseSBub3Qgc29cbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiUHJpbXRpdmVcIl0gPSA4XSA9IFwiUHJpbXRpdmVcIjtcbiAgICBBY2Nlc3NvclR5cGVbQWNjZXNzb3JUeXBlW1wiQXJyYXlcIl0gPSAxOF0gPSBcIkFycmF5XCI7XG4gICAgQWNjZXNzb3JUeXBlW0FjY2Vzc29yVHlwZVtcIlNldFwiXSA9IDM0XSA9IFwiU2V0XCI7XG4gICAgQWNjZXNzb3JUeXBlW0FjY2Vzc29yVHlwZVtcIk1hcFwiXSA9IDY2XSA9IFwiTWFwXCI7XG59KShBY2Nlc3NvclR5cGUgfHwgKEFjY2Vzc29yVHlwZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gY29weUluZGV4TWFwKGV4aXN0aW5nLCBkZWxldGVkSXRlbXMpIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gZXhpc3Rpbmc7XG4gICAgY29uc3QgYXJyID0gQXJyYXkobGVuZ3RoKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyW2ldID0gZXhpc3RpbmdbaV07XG4gICAgICAgICsraTtcbiAgICB9XG4gICAgaWYgKGRlbGV0ZWRJdGVtcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFyci5kZWxldGVkSXRlbXMgPSBkZWxldGVkSXRlbXMuc2xpY2UoMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4aXN0aW5nLmRlbGV0ZWRJdGVtcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFyci5kZWxldGVkSXRlbXMgPSBleGlzdGluZy5kZWxldGVkSXRlbXMuc2xpY2UoMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcnIuZGVsZXRlZEl0ZW1zID0gW107XG4gICAgfVxuICAgIGFyci5pc0luZGV4TWFwID0gdHJ1ZTtcbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluZGV4TWFwKGxlbmd0aCA9IDApIHtcbiAgICBjb25zdCBhcnIgPSBBcnJheShsZW5ndGgpO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBhcnJbaV0gPSBpKys7XG4gICAgfVxuICAgIGFyci5kZWxldGVkSXRlbXMgPSBbXTtcbiAgICBhcnIuaXNJbmRleE1hcCA9IHRydWU7XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUluZGV4TWFwKGluZGV4TWFwKSB7XG4gICAgY29uc3QgY2xvbmUgPSBpbmRleE1hcC5zbGljZSgpO1xuICAgIGNsb25lLmRlbGV0ZWRJdGVtcyA9IGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5zbGljZSgpO1xuICAgIGNsb25lLmlzSW5kZXhNYXAgPSB0cnVlO1xuICAgIHJldHVybiBjbG9uZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0luZGV4TWFwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdmFsdWUuaXNJbmRleE1hcCA9PT0gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmF0aW9uLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUluZGV4TWFwLCB9IGZyb20gJy4uL29ic2VydmF0aW9uLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb25MZW5ndGhPYnNlcnZlciwgfSBmcm9tICcuL2NvbGxlY3Rpb24tbGVuZ3RoLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uLCB9IGZyb20gJy4vc3Vic2NyaWJlci1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGRlZiwgZGVmaW5lSGlkZGVuUHJvcCB9IGZyb20gJy4uL3V0aWxpdGllcy1vYmplY3RzLmpzJztcbmNvbnN0IG9ic2VydmVyTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNvcnRjb21wYXJlXG5mdW5jdGlvbiBzb3J0Q29tcGFyZSh4LCB5KSB7XG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHggPSB4ID09PSBudWxsID8gJ251bGwnIDogeC50b1N0cmluZygpO1xuICAgIHkgPSB5ID09PSBudWxsID8gJ251bGwnIDogeS50b1N0cmluZygpO1xuICAgIHJldHVybiB4IDwgeSA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHByZVNvcnRDb21wYXJlKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHkgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChhcnIsIGluZGV4TWFwLCBmcm9tLCB0bywgY29tcGFyZUZuKSB7XG4gICAgbGV0IHZlbGVtZW50LCBpZWxlbWVudCwgdnRtcCwgaXRtcCwgb3JkZXI7XG4gICAgbGV0IGksIGo7XG4gICAgZm9yIChpID0gZnJvbSArIDE7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIHZlbGVtZW50ID0gYXJyW2ldO1xuICAgICAgICBpZWxlbWVudCA9IGluZGV4TWFwW2ldO1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSBmcm9tOyBqLS0pIHtcbiAgICAgICAgICAgIHZ0bXAgPSBhcnJbal07XG4gICAgICAgICAgICBpdG1wID0gaW5kZXhNYXBbal07XG4gICAgICAgICAgICBvcmRlciA9IGNvbXBhcmVGbih2dG1wLCB2ZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAob3JkZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXJyW2ogKyAxXSA9IHZ0bXA7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaiArIDFdID0gaXRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFycltqICsgMV0gPSB2ZWxlbWVudDtcbiAgICAgICAgaW5kZXhNYXBbaiArIDFdID0gaWVsZW1lbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcXVpY2tTb3J0KGFyciwgaW5kZXhNYXAsIGZyb20sIHRvLCBjb21wYXJlRm4pIHtcbiAgICBsZXQgdGhpcmRJbmRleCA9IDAsIGkgPSAwO1xuICAgIGxldCB2MCwgdjEsIHYyO1xuICAgIGxldCBpMCwgaTEsIGkyO1xuICAgIGxldCBjMDEsIGMwMiwgYzEyO1xuICAgIGxldCB2dG1wLCBpdG1wO1xuICAgIGxldCB2cGl2b3QsIGlwaXZvdCwgbG93RW5kLCBoaWdoU3RhcnQ7XG4gICAgbGV0IHZlbGVtZW50LCBpZWxlbWVudCwgb3JkZXIsIHZ0b3BFbGVtZW50O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodG8gLSBmcm9tIDw9IDEwKSB7XG4gICAgICAgICAgICBpbnNlcnRpb25Tb3J0KGFyciwgaW5kZXhNYXAsIGZyb20sIHRvLCBjb21wYXJlRm4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXJkSW5kZXggPSBmcm9tICsgKCh0byAtIGZyb20pID4+IDEpO1xuICAgICAgICB2MCA9IGFycltmcm9tXTtcbiAgICAgICAgaTAgPSBpbmRleE1hcFtmcm9tXTtcbiAgICAgICAgdjEgPSBhcnJbdG8gLSAxXTtcbiAgICAgICAgaTEgPSBpbmRleE1hcFt0byAtIDFdO1xuICAgICAgICB2MiA9IGFyclt0aGlyZEluZGV4XTtcbiAgICAgICAgaTIgPSBpbmRleE1hcFt0aGlyZEluZGV4XTtcbiAgICAgICAgYzAxID0gY29tcGFyZUZuKHYwLCB2MSk7XG4gICAgICAgIGlmIChjMDEgPiAwKSB7XG4gICAgICAgICAgICB2dG1wID0gdjA7XG4gICAgICAgICAgICBpdG1wID0gaTA7XG4gICAgICAgICAgICB2MCA9IHYxO1xuICAgICAgICAgICAgaTAgPSBpMTtcbiAgICAgICAgICAgIHYxID0gdnRtcDtcbiAgICAgICAgICAgIGkxID0gaXRtcDtcbiAgICAgICAgfVxuICAgICAgICBjMDIgPSBjb21wYXJlRm4odjAsIHYyKTtcbiAgICAgICAgaWYgKGMwMiA+PSAwKSB7XG4gICAgICAgICAgICB2dG1wID0gdjA7XG4gICAgICAgICAgICBpdG1wID0gaTA7XG4gICAgICAgICAgICB2MCA9IHYyO1xuICAgICAgICAgICAgaTAgPSBpMjtcbiAgICAgICAgICAgIHYyID0gdjE7XG4gICAgICAgICAgICBpMiA9IGkxO1xuICAgICAgICAgICAgdjEgPSB2dG1wO1xuICAgICAgICAgICAgaTEgPSBpdG1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYzEyID0gY29tcGFyZUZuKHYxLCB2Mik7XG4gICAgICAgICAgICBpZiAoYzEyID4gMCkge1xuICAgICAgICAgICAgICAgIHZ0bXAgPSB2MTtcbiAgICAgICAgICAgICAgICBpdG1wID0gaTE7XG4gICAgICAgICAgICAgICAgdjEgPSB2MjtcbiAgICAgICAgICAgICAgICBpMSA9IGkyO1xuICAgICAgICAgICAgICAgIHYyID0gdnRtcDtcbiAgICAgICAgICAgICAgICBpMiA9IGl0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJyW2Zyb21dID0gdjA7XG4gICAgICAgIGluZGV4TWFwW2Zyb21dID0gaTA7XG4gICAgICAgIGFyclt0byAtIDFdID0gdjI7XG4gICAgICAgIGluZGV4TWFwW3RvIC0gMV0gPSBpMjtcbiAgICAgICAgdnBpdm90ID0gdjE7XG4gICAgICAgIGlwaXZvdCA9IGkxO1xuICAgICAgICBsb3dFbmQgPSBmcm9tICsgMTtcbiAgICAgICAgaGlnaFN0YXJ0ID0gdG8gLSAxO1xuICAgICAgICBhcnJbdGhpcmRJbmRleF0gPSBhcnJbbG93RW5kXTtcbiAgICAgICAgaW5kZXhNYXBbdGhpcmRJbmRleF0gPSBpbmRleE1hcFtsb3dFbmRdO1xuICAgICAgICBhcnJbbG93RW5kXSA9IHZwaXZvdDtcbiAgICAgICAgaW5kZXhNYXBbbG93RW5kXSA9IGlwaXZvdDtcbiAgICAgICAgcGFydGl0aW9uOiBmb3IgKGkgPSBsb3dFbmQgKyAxOyBpIDwgaGlnaFN0YXJ0OyBpKyspIHtcbiAgICAgICAgICAgIHZlbGVtZW50ID0gYXJyW2ldO1xuICAgICAgICAgICAgaWVsZW1lbnQgPSBpbmRleE1hcFtpXTtcbiAgICAgICAgICAgIG9yZGVyID0gY29tcGFyZUZuKHZlbGVtZW50LCB2cGl2b3QpO1xuICAgICAgICAgICAgaWYgKG9yZGVyIDwgMCkge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGFycltsb3dFbmRdO1xuICAgICAgICAgICAgICAgIGluZGV4TWFwW2ldID0gaW5kZXhNYXBbbG93RW5kXTtcbiAgICAgICAgICAgICAgICBhcnJbbG93RW5kXSA9IHZlbGVtZW50O1xuICAgICAgICAgICAgICAgIGluZGV4TWFwW2xvd0VuZF0gPSBpZWxlbWVudDtcbiAgICAgICAgICAgICAgICBsb3dFbmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyID4gMCkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaFN0YXJ0LS07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hTdGFydCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBwYXJ0aXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdnRvcEVsZW1lbnQgPSBhcnJbaGlnaFN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSBjb21wYXJlRm4odnRvcEVsZW1lbnQsIHZwaXZvdCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAob3JkZXIgPiAwKTtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBhcnJbaGlnaFN0YXJ0XTtcbiAgICAgICAgICAgICAgICBpbmRleE1hcFtpXSA9IGluZGV4TWFwW2hpZ2hTdGFydF07XG4gICAgICAgICAgICAgICAgYXJyW2hpZ2hTdGFydF0gPSB2ZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpbmRleE1hcFtoaWdoU3RhcnRdID0gaWVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWxlbWVudCA9IGFycltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWVsZW1lbnQgPSBpbmRleE1hcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgYXJyW2ldID0gYXJyW2xvd0VuZF07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwW2ldID0gaW5kZXhNYXBbbG93RW5kXTtcbiAgICAgICAgICAgICAgICAgICAgYXJyW2xvd0VuZF0gPSB2ZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXBbbG93RW5kXSA9IGllbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBsb3dFbmQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvIC0gaGlnaFN0YXJ0IDwgbG93RW5kIC0gZnJvbSkge1xuICAgICAgICAgICAgcXVpY2tTb3J0KGFyciwgaW5kZXhNYXAsIGhpZ2hTdGFydCwgdG8sIGNvbXBhcmVGbik7XG4gICAgICAgICAgICB0byA9IGxvd0VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1aWNrU29ydChhcnIsIGluZGV4TWFwLCBmcm9tLCBsb3dFbmQsIGNvbXBhcmVGbik7XG4gICAgICAgICAgICBmcm9tID0gaGlnaFN0YXJ0O1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgcHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5jb25zdCAkcHVzaCA9IHByb3RvLnB1c2g7XG5jb25zdCAkdW5zaGlmdCA9IHByb3RvLnVuc2hpZnQ7XG5jb25zdCAkcG9wID0gcHJvdG8ucG9wO1xuY29uc3QgJHNoaWZ0ID0gcHJvdG8uc2hpZnQ7XG5jb25zdCAkc3BsaWNlID0gcHJvdG8uc3BsaWNlO1xuY29uc3QgJHJldmVyc2UgPSBwcm90by5yZXZlcnNlO1xuY29uc3QgJHNvcnQgPSBwcm90by5zb3J0O1xuY29uc3QgbmF0aXZlID0geyBwdXNoOiAkcHVzaCwgdW5zaGlmdDogJHVuc2hpZnQsIHBvcDogJHBvcCwgc2hpZnQ6ICRzaGlmdCwgc3BsaWNlOiAkc3BsaWNlLCByZXZlcnNlOiAkcmV2ZXJzZSwgc29ydDogJHNvcnQgfTtcbmNvbnN0IG1ldGhvZHMgPSBbJ3B1c2gnLCAndW5zaGlmdCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3JldmVyc2UnLCAnc29ydCddO1xuY29uc3Qgb2JzZXJ2ZSA9IHtcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucHVzaFxuICAgIHB1c2g6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiAkcHVzaC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gby5pbmRleE1hcC5sZW5ndGggPSBsZW4gKyBhcmdDb3VudDtcbiAgICAgICAgbGV0IGkgPSBsZW47XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBhcmdzW2kgLSBsZW5dO1xuICAgICAgICAgICAgby5pbmRleE1hcFtpXSA9IC0yO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS51bnNoaWZ0XG4gICAgdW5zaGlmdDogZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuICR1bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGluc2VydHMgPSBuZXcgQXJyYXkoYXJnQ291bnQpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgYXJnQ291bnQpIHtcbiAgICAgICAgICAgIGluc2VydHNbaSsrXSA9IC0yO1xuICAgICAgICB9XG4gICAgICAgICR1bnNoaWZ0LmFwcGx5KG8uaW5kZXhNYXAsIGluc2VydHMpO1xuICAgICAgICBjb25zdCBsZW4gPSAkdW5zaGlmdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5wb3BcbiAgICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuICRwb3AuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleE1hcCA9IG8uaW5kZXhNYXA7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAkcG9wLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIG9ubHkgbWFyayBpbmRpY2VzIGFzIGRlbGV0ZWQgaWYgdGhleSBhY3R1YWxseSBleGlzdGVkIGluIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgICAgICBjb25zdCBpbmRleCA9IGluZGV4TWFwLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleE1hcFtpbmRleF0gPiAtMSkge1xuICAgICAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnB1c2goaW5kZXhNYXBbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICAkcG9wLmNhbGwoaW5kZXhNYXApO1xuICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zaGlmdFxuICAgIHNoaWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiAkc2hpZnQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleE1hcCA9IG8uaW5kZXhNYXA7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAkc2hpZnQuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gb25seSBtYXJrIGluZGljZXMgYXMgZGVsZXRlZCBpZiB0aGV5IGFjdHVhbGx5IGV4aXN0ZWQgaW4gdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgICAgIGlmIChpbmRleE1hcFswXSA+IC0xKSB7XG4gICAgICAgICAgICBpbmRleE1hcC5kZWxldGVkSXRlbXMucHVzaChpbmRleE1hcFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgJHNoaWZ0LmNhbGwoaW5kZXhNYXApO1xuICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zcGxpY2VcbiAgICBzcGxpY2U6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXJnc1swXTtcbiAgICAgICAgY29uc3QgZGVsZXRlQ291bnQgPSBhcmdzWzFdO1xuICAgICAgICBjb25zdCBvID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJHNwbGljZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVTdGFydCA9IHN0YXJ0IHwgMDtcbiAgICAgICAgY29uc3QgYWN0dWFsU3RhcnQgPSByZWxhdGl2ZVN0YXJ0IDwgMCA/IE1hdGgubWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCkgOiBNYXRoLm1pbihyZWxhdGl2ZVN0YXJ0LCBsZW4pO1xuICAgICAgICBjb25zdCBpbmRleE1hcCA9IG8uaW5kZXhNYXA7XG4gICAgICAgIGNvbnN0IGFyZ0NvdW50ID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFjdHVhbERlbGV0ZUNvdW50ID0gYXJnQ291bnQgPT09IDAgPyAwIDogYXJnQ291bnQgPT09IDEgPyBsZW4gLSBhY3R1YWxTdGFydCA6IGRlbGV0ZUNvdW50O1xuICAgICAgICBpZiAoYWN0dWFsRGVsZXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgdG8gPSBpICsgYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwW2ldID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnB1c2goaW5kZXhNYXBbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ0NvdW50ID4gMikge1xuICAgICAgICAgICAgY29uc3QgaXRlbUNvdW50ID0gYXJnQ291bnQgLSAyO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0cyA9IG5ldyBBcnJheShpdGVtQ291bnQpO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBpdGVtQ291bnQpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRzW2krK10gPSAtMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRzcGxpY2UuY2FsbChpbmRleE1hcCwgc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pbnNlcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICRzcGxpY2UuYXBwbHkoaW5kZXhNYXAsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSAkc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZXZlcnNlXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBvID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAkcmV2ZXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IChsZW4gLyAyKSB8IDA7XG4gICAgICAgIGxldCBsb3dlciA9IDA7XG4gICAgICAgIHdoaWxlIChsb3dlciAhPT0gbWlkZGxlKSB7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IGxlbiAtIGxvd2VyIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyVmFsdWUgPSB0aGlzW2xvd2VyXTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VySW5kZXggPSBvLmluZGV4TWFwW2xvd2VyXTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyVmFsdWUgPSB0aGlzW3VwcGVyXTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVySW5kZXggPSBvLmluZGV4TWFwW3VwcGVyXTtcbiAgICAgICAgICAgIHRoaXNbbG93ZXJdID0gdXBwZXJWYWx1ZTtcbiAgICAgICAgICAgIG8uaW5kZXhNYXBbbG93ZXJdID0gdXBwZXJJbmRleDtcbiAgICAgICAgICAgIHRoaXNbdXBwZXJdID0gbG93ZXJWYWx1ZTtcbiAgICAgICAgICAgIG8uaW5kZXhNYXBbdXBwZXJdID0gbG93ZXJJbmRleDtcbiAgICAgICAgICAgIGxvd2VyKys7XG4gICAgICAgIH1cbiAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29ydFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iL21hc3Rlci9zcmMvanMvYXJyYXkuanNcbiAgICBzb3J0OiBmdW5jdGlvbiAoY29tcGFyZUZuKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICRzb3J0LmNhbGwodGhpcywgY29tcGFyZUZuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcXVpY2tTb3J0KHRoaXMsIG8uaW5kZXhNYXAsIDAsIGxlbiwgcHJlU29ydENvbXBhcmUpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVGbiA9PT0gdm9pZCAwIHx8IHR5cGVvZiBjb21wYXJlRm4gIT09ICdmdW5jdGlvbicgLyogc3BlYyBzYXlzIHRocm93IGEgVHlwZUVycm9yLCBzaG91bGQgd2UgZG8gdGhhdCB0b28/ICovKSB7XG4gICAgICAgICAgICBjb21wYXJlRm4gPSBzb3J0Q29tcGFyZTtcbiAgICAgICAgfVxuICAgICAgICBxdWlja1NvcnQodGhpcywgby5pbmRleE1hcCwgMCwgaSwgY29tcGFyZUZuKTtcbiAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBkZWYob2JzZXJ2ZVttZXRob2RdLCAnb2JzZXJ2aW5nJywgeyB2YWx1ZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbn1cbmxldCBlbmFibGVBcnJheU9ic2VydmF0aW9uQ2FsbGVkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQXJyYXlPYnNlcnZhdGlvbigpIHtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgIGlmIChwcm90b1ttZXRob2RdLm9ic2VydmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChwcm90bywgbWV0aG9kLCBvYnNlcnZlW21ldGhvZF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVBcnJheU9ic2VydmF0aW9uKCkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKHByb3RvW21ldGhvZF0ub2JzZXJ2aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWZpbmVIaWRkZW5Qcm9wKHByb3RvLCBtZXRob2QsIG5hdGl2ZVttZXRob2RdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJheU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAxOCAvKiBBcnJheSAqLztcbiAgICAgICAgaWYgKCFlbmFibGVBcnJheU9ic2VydmF0aW9uQ2FsbGVkKSB7XG4gICAgICAgICAgICBlbmFibGVBcnJheU9ic2VydmF0aW9uQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVuYWJsZUFycmF5T2JzZXJ2YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4T2JzZXJ2ZXJzID0ge307XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGFycmF5O1xuICAgICAgICB0aGlzLmluZGV4TWFwID0gY3JlYXRlSW5kZXhNYXAoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5PYnMgPSB2b2lkIDA7XG4gICAgICAgIG9ic2VydmVyTG9va3VwLnNldChhcnJheSwgdGhpcyk7XG4gICAgfVxuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgY29uc3QgaW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICB0aGlzLmluZGV4TWFwID0gY3JlYXRlSW5kZXhNYXAobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdWJzLm5vdGlmeUNvbGxlY3Rpb24oaW5kZXhNYXAsIDggLyogdXBkYXRlVGFyZ2V0ICovKTtcbiAgICB9XG4gICAgZ2V0TGVuZ3RoT2JzZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbk9icyA/PyAodGhpcy5sZW5PYnMgPSBuZXcgQ29sbGVjdGlvbkxlbmd0aE9ic2VydmVyKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0SW5kZXhPYnNlcnZlcihpbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEl0J3MgdW5uZWNlc3NhcnkgdG8gZGVzdHJveS9yZWNyZWF0ZSBpbmRleCBvYnNlcnZlciBhbGwgdGhlIHRpbWUsXG4gICAgICAgIC8vIHNvIGp1c3QgY3JlYXRlIG9uY2UsIGFuZCBhZGQvcmVtb3ZlIGluc3RlYWRcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuaW5kZXhPYnNlcnZlcnMpW2luZGV4XSA/PyAoX2FbaW5kZXhdID0gbmV3IEFycmF5SW5kZXhPYnNlcnZlcih0aGlzLCBpbmRleCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBcnJheUluZGV4T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm93bmVyLmNvbGxlY3Rpb25bdGhpcy5pbmRleF07XG4gICAgfVxuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHRoaXMuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5T2JzZXJ2ZXIgPSB0aGlzLm93bmVyO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gYXJyYXlPYnNlcnZlci5pbmRleE1hcDtcbiAgICAgICAgaWYgKGluZGV4TWFwW2luZGV4XSA+IC0xKSB7XG4gICAgICAgICAgICBpbmRleE1hcC5kZWxldGVkSXRlbXMucHVzaChpbmRleE1hcFtpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4TWFwW2luZGV4XSA9IC0yO1xuICAgICAgICAvLyBkbyBub3QgbmVlZCB0byB1cGRhdGUgY3VycmVudCB2YWx1ZSBoZXJlXG4gICAgICAgIC8vIGFzIGl0IHdpbGwgYmUgdXBkYXRlZCBpbnNpZGUgaGFuZGxlIGNvbGxlY3Rpb24gY2hhbmdlXG4gICAgICAgIGFycmF5T2JzZXJ2ZXIuY29sbGVjdGlvbltpbmRleF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgYXJyYXlPYnNlcnZlci5ub3RpZnkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnJvbSBpbnRlcmZhY2UgYElDb2xsZWN0aW9uU3Vic2NyaWJlcmBcbiAgICAgKi9cbiAgICBoYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncykge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGNvbnN0IG5vQ2hhbmdlID0gaW5kZXhNYXBbaW5kZXhdID09PSBpbmRleDtcbiAgICAgICAgaWYgKG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3QgY3VyclZhbHVlID0gdGhpcy52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgLy8gaG1tXG4gICAgICAgIGlmIChwcmV2VmFsdWUgIT09IGN1cnJWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShjdXJyVmFsdWUsIHByZXZWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5vd25lci5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLnJlbW92ZShzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIudW5zdWJzY3JpYmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihBcnJheU9ic2VydmVyKTtcbnN1YnNjcmliZXJDb2xsZWN0aW9uKEFycmF5SW5kZXhPYnNlcnZlcik7XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlPYnNlcnZlcihhcnJheSkge1xuICAgIGxldCBvYnNlcnZlciA9IG9ic2VydmVyTG9va3VwLmdldChhcnJheSk7XG4gICAgaWYgKG9ic2VydmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgQXJyYXlPYnNlcnZlcihhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbi8qKlxuICogQXBwbGllcyBvZmZzZXRzIHRvIHRoZSBub24tbmVnYXRpdmUgaW5kaWNlcyBpbiB0aGUgSW5kZXhNYXBcbiAqIGJhc2VkIG9uIGFkZGVkIGFuZCBkZWxldGVkIGl0ZW1zIHJlbGF0aXZlIHRvIHRob3NlIGluZGljZXMuXG4gKlxuICogZS5nLiB0dXJuIGBbLTIsIDAsIDFdYCBpbnRvIGBbLTIsIDEsIDJdYCwgYWxsb3dpbmcgdGhlIHZhbHVlcyBhdCB0aGUgaW5kaWNlcyB0byBiZVxuICogdXNlZCBmb3Igc29ydGluZy9yZW9yZGVyaW5nIGl0ZW1zIGlmIG5lZWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnNUb0luZGljZXMoaW5kZXhNYXApIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgbGVuID0gaW5kZXhNYXAubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgd2hpbGUgKGluZGV4TWFwLmRlbGV0ZWRJdGVtc1tqXSA8PSBpIC0gb2Zmc2V0KSB7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAtLW9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXhNYXBbaV0gPT09IC0yKSB7XG4gICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4TWFwW2ldICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQWZ0ZXIgYGFwcGx5TXV0YXRpb25zVG9JbmRpY2VzYCwgdGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byByZW9yZGVyIGl0ZW1zIGluIGEgZGVyaXZlZFxuICogYXJyYXkgKGUuZy4gIHRoZSBpdGVtcyBpbiB0aGUgYHZpZXdzYCBpbiB0aGUgcmVwZWF0ZXIgYXJlIGRlcml2ZWQgZnJvbSB0aGUgYGl0ZW1zYCBwcm9wZXJ0eSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN5bmNocm9uaXplSW5kaWNlcyhpdGVtcywgaW5kZXhNYXApIHtcbiAgICBjb25zdCBjb3B5ID0gaXRlbXMuc2xpY2UoKTtcbiAgICBjb25zdCBsZW4gPSBpbmRleE1hcC5sZW5ndGg7XG4gICAgbGV0IHRvID0gMDtcbiAgICBsZXQgZnJvbSA9IDA7XG4gICAgd2hpbGUgKHRvIDwgbGVuKSB7XG4gICAgICAgIGZyb20gPSBpbmRleE1hcFt0b107XG4gICAgICAgIGlmIChmcm9tICE9PSAtMikge1xuICAgICAgICAgICAgaXRlbXNbdG9dID0gY29weVtmcm9tXTtcbiAgICAgICAgfVxuICAgICAgICArK3RvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LW9ic2VydmVyLmpzLm1hcCIsImNvbnN0IG1hcmtlciA9IE9iamVjdC5mcmVlemUoe30pO1xuZXhwb3J0IGNsYXNzIEJpbmRpbmdDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihrZXlPck9iaiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleU9yT2JqICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdmFsdWUgaXMgZGVmaW5lZCB0aGVuIGl0J3MganVzdCBhIHByb3BlcnR5IGFuZCBhIHZhbHVlIHRvIGluaXRpYWxpemUgd2l0aFxuICAgICAgICAgICAgICAgIHRoaXNba2V5T3JPYmpdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYW4gZWl0aGVyIGJlIHNvbWUgcmFuZG9tIG9iamVjdCBvciBhbm90aGVyIGJpbmRpbmdDb250ZXh0IHRvIGNsb25lIGZyb21cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4ga2V5T3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrZXlPck9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBrZXlPck9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGtleU9yT2JqLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdDb250ZXh0KGtleU9yT2JqLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoc2NvcGUsIG5hbWUsIGFuY2VzdG9yLCBmbGFncywgaG9zdFNjb3BlKSB7XG4gICAgICAgIGlmIChzY29wZSA9PSBudWxsICYmIGhvc3RTY29wZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjb3BlIGlzICR7c2NvcGV9IGFuZCBIb3N0U2NvcGUgaXMgJHtob3N0U2NvcGV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc090aGVyU2NvcGUgPSBob3N0U2NvcGUgIT09IHNjb3BlICYmIGhvc3RTY29wZSAhPSBudWxsO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9jaGVjay1pbmRlbnRhdGlvbiAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmYWxsYmFjayBpcyBuZWVkZWQgdG8gc3VwcG9ydCB0aGUgZm9sbG93aW5nIGNhc2U6XG4gICAgICAgICAqIDxkaXYgYXUtc2xvdD1cInMxXCI+XG4gICAgICAgICAqICA8bGV0IG91dGVyLWhvc3QuYmluZD1cIiRob3N0XCI+PC9sZXQ+XG4gICAgICAgICAqICAke291dGVySG9zdC5wcm9wfVxuICAgICAgICAgKiA8L2Rpdj5cbiAgICAgICAgICogVG8gZW5hYmxlIHRoZSBgbGV0YCBiaW5kaW5nIGZvciAnaG9zdFNjb3BlJywgdGhlIHByb3BlcnR5IGlzIGFkZGVkIHRvIGBob3N0U2NvcGUub3ZlcnJpZGVDb250ZXh0YC4gVGhhdCBlbmFibGVzIHVzIHRvIHVzZSBzdWNoIGxldCBiaW5kaW5nIGFsc28gaW5zaWRlIGEgcmVwZWF0ZXIuXG4gICAgICAgICAqIEhvd2V2ZXIsIGFzIHRoZSBleHByZXNzaW9uIGAke291dGVySG9zdC5wcm9wfWAgZG9lcyBub3Qgc3RhcnQgd2l0aCBgJGhvc3RgLCBpdCBpcyBjb25zaWRlcmVkIHRoYXQgdG8gZXZhbHVhdGUgdGhpcyBleHByZXNzaW9uLCB3ZSBkb24ndCBuZWVkIHRoZSBhY2Nlc3MgdG8gaG9zdFNjb3BlLlxuICAgICAgICAgKiBUaGlzIGFydGlmYWN0IHJhaXNlcyB0aGUgbmVlZCBmb3IgdGhpcyBmYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUganNkb2MvY2hlY2staW5kZW50YXRpb24gKi9cbiAgICAgICAgbGV0IGNvbnRleHQgPSBjaG9vc2VDb250ZXh0KHNjb3BlLCBuYW1lLCBhbmNlc3Rvcik7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSBudWxsXG4gICAgICAgICAgICAmJiAoKGNvbnRleHQgPT0gbnVsbCA/IGZhbHNlIDogbmFtZSBpbiBjb250ZXh0KVxuICAgICAgICAgICAgICAgIHx8ICFoYXNPdGhlclNjb3BlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc090aGVyU2NvcGUpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjaG9vc2VDb250ZXh0KGhvc3RTY29wZSwgbmFtZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdGlsbCBub3RoaW5nIGZvdW5kLiByZXR1cm4gdGhlIHJvb3QgYmluZGluZyBjb250ZXh0IChvciBudWxsXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBwYXJlbnQgc2NvcGUgdHJhdmVyc2FsLCB0byBlbnN1cmUgd2UgZmFsbCBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBjb3JyZWN0IGxldmVsKVxuICAgICAgICBpZiAoZmxhZ3MgJiAyNTYgLyogaXNUcmF2ZXJzaW5nUGFyZW50U2NvcGUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlLmJpbmRpbmdDb250ZXh0IHx8IHNjb3BlLm92ZXJyaWRlQ29udGV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiBjaG9vc2VDb250ZXh0KHNjb3BlLCBuYW1lLCBhbmNlc3Rvcikge1xuICAgIGxldCBvdmVycmlkZUNvbnRleHQgPSBzY29wZS5vdmVycmlkZUNvbnRleHQ7XG4gICAgbGV0IGN1cnJlbnRTY29wZSA9IHNjb3BlO1xuICAgIGlmIChhbmNlc3RvciA+IDApIHtcbiAgICAgICAgLy8ganVtcCB1cCB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGFuY2VzdG9yIGNvbnRleHRzIChlZyAkcGFyZW50LiRwYXJlbnQgcmVxdWlyZXMgdHdvIGp1bXBzKVxuICAgICAgICB3aGlsZSAoYW5jZXN0b3IgPiAwKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci0tO1xuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gY3VycmVudFNjb3BlLnBhcmVudFNjb3BlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZT8ub3ZlcnJpZGVDb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG92ZXJyaWRlQ29udGV4dCA9IGN1cnJlbnRTY29wZS5vdmVycmlkZUNvbnRleHQ7XG4gICAgICAgIHJldHVybiBuYW1lIGluIG92ZXJyaWRlQ29udGV4dCA/IG92ZXJyaWRlQ29udGV4dCA6IG92ZXJyaWRlQ29udGV4dC5iaW5kaW5nQ29udGV4dDtcbiAgICB9XG4gICAgLy8gdHJhdmVyc2UgdGhlIGNvbnRleHQgYW5kIGl0J3MgYW5jZXN0b3JzLCBzZWFyY2hpbmcgZm9yIGEgY29udGV4dCB0aGF0IGhhcyB0aGUgbmFtZS5cbiAgICB3aGlsZSAoIWN1cnJlbnRTY29wZT8uaXNDb21wb25lbnRCb3VuZGFyeVxuICAgICAgICAmJiBvdmVycmlkZUNvbnRleHRcbiAgICAgICAgJiYgIShuYW1lIGluIG92ZXJyaWRlQ29udGV4dClcbiAgICAgICAgJiYgIShvdmVycmlkZUNvbnRleHQuYmluZGluZ0NvbnRleHRcbiAgICAgICAgICAgICYmIG5hbWUgaW4gb3ZlcnJpZGVDb250ZXh0LmJpbmRpbmdDb250ZXh0KSkge1xuICAgICAgICBjdXJyZW50U2NvcGUgPSBjdXJyZW50U2NvcGUucGFyZW50U2NvcGUgPz8gbnVsbDtcbiAgICAgICAgb3ZlcnJpZGVDb250ZXh0ID0gY3VycmVudFNjb3BlPy5vdmVycmlkZUNvbnRleHQgPz8gbnVsbDtcbiAgICB9XG4gICAgaWYgKG92ZXJyaWRlQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmFtZSBpbiBvdmVycmlkZUNvbnRleHQgPyBvdmVycmlkZUNvbnRleHQgOiBvdmVycmlkZUNvbnRleHQuYmluZGluZ0NvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTY29wZSwgYmluZGluZ0NvbnRleHQsIG92ZXJyaWRlQ29udGV4dCwgaXNDb21wb25lbnRCb3VuZGFyeSkge1xuICAgICAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgICAgIHRoaXMuYmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dDtcbiAgICAgICAgdGhpcy5vdmVycmlkZUNvbnRleHQgPSBvdmVycmlkZUNvbnRleHQ7XG4gICAgICAgIHRoaXMuaXNDb21wb25lbnRCb3VuZGFyeSA9IGlzQ29tcG9uZW50Qm91bmRhcnk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYmMsIG9jLCBpc0NvbXBvbmVudEJvdW5kYXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NvcGUobnVsbCwgYmMsIG9jID09IG51bGwgPyBPdmVycmlkZUNvbnRleHQuY3JlYXRlKGJjKSA6IG9jLCBpc0NvbXBvbmVudEJvdW5kYXJ5ID8/IGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PdmVycmlkZShvYykge1xuICAgICAgICBpZiAob2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdmVycmlkZUNvbnRleHQgaXMgJHtvY31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKG51bGwsIG9jLmJpbmRpbmdDb250ZXh0LCBvYywgZmFsc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhcmVudChwcywgYmMpIHtcbiAgICAgICAgaWYgKHBzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyZW50U2NvcGUgaXMgJHtwc31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHBzLCBiYywgT3ZlcnJpZGVDb250ZXh0LmNyZWF0ZShiYyksIGZhbHNlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3ZlcnJpZGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nQ29udGV4dCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdDb250ZXh0ID0gYmluZGluZ0NvbnRleHQ7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYmMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVycmlkZUNvbnRleHQoYmMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRpbmctY29udGV4dC5qcy5tYXAiLCJpbXBvcnQgeyBpc0FycmF5SW5kZXggfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24gfSBmcm9tICcuL3N1YnNjcmliZXItY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBlbnN1cmVQcm90byB9IGZyb20gJy4uL3V0aWxpdGllcy1vYmplY3RzLmpzJztcbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uTGVuZ3RoT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyKSB7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy50eXBlID0gMTggLyogQXJyYXkgKi87XG4gICAgICAgIHRoaXMudmFsdWUgPSAodGhpcy5vYmogPSBvd25lci5jb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmoubGVuZ3RoO1xuICAgIH1cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgLy8gaWYgaW4gdGhlIHRlbXBsYXRlLCBsZW5ndGggaXMgdHdvLXdheSBib3VuZCBkaXJlY3RseVxuICAgICAgICAvLyB0aGVuIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCB0aGUgbmV3IHZhbHVlIGlzIGludmFsaWRcbiAgICAgICAgLy8gYWRkIGEgZ3VhcmQgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkgYnJvYWRjYXN0IGludmFsaWQgdmFsdWVzXG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gY3VycmVudFZhbHVlICYmIGlzQXJyYXlJbmRleChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiA0MDk2IC8qIG5vRmx1c2ggKi8pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmoubGVuZ3RoID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN1YnMubm90aWZ5KG5ld1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZsYWdzIHwgOCAvKiB1cGRhdGVUYXJnZXQgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoXywgZmxhZ3MpIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMub2JqLmxlbmd0aDtcbiAgICAgICAgaWYgKCh0aGlzLnZhbHVlID0gdmFsdWUpICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeSh2YWx1ZSwgb2xkVmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihvd25lcikge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMudmFsdWUgPSAodGhpcy5vYmogPSBvd25lci5jb2xsZWN0aW9uKS5zaXplO1xuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLm9iaiBpbnN0YW5jZW9mIE1hcCA/IDY2IC8qIE1hcCAqLyA6IDM0IC8qIFNldCAqLztcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iai5zaXplO1xuICAgIH1cbiAgICBzZXRWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXAvU2V0IFwic2l6ZVwiIGlzIGEgcmVhZG9ubHkgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaGFuZGxlQ29sbGVjdGlvbkNoYW5nZShfLCBmbGFncykge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5vYmouc2l6ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnMubm90aWZ5KHZhbHVlLCBvbGRWYWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaW1wbGVtZW50TGVuZ3RoT2JzZXJ2ZXIoa2xhc3MpIHtcbiAgICBjb25zdCBwcm90byA9IGtsYXNzLnByb3RvdHlwZTtcbiAgICBlbnN1cmVQcm90byhwcm90bywgJ3N1YnNjcmliZScsIHN1YnNjcmliZSwgdHJ1ZSk7XG4gICAgZW5zdXJlUHJvdG8ocHJvdG8sICd1bnN1YnNjcmliZScsIHVuc3Vic2NyaWJlLCB0cnVlKTtcbiAgICBzdWJzY3JpYmVyQ29sbGVjdGlvbihrbGFzcyk7XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgIGlmICh0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMSkge1xuICAgICAgICB0aGlzLm93bmVyLnN1YnNjcmliZSh0aGlzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgaWYgKHRoaXMuc3Vicy5yZW1vdmUoc3Vic2NyaWJlcikgJiYgdGhpcy5zdWJzLmNvdW50ID09PSAwKSB7XG4gICAgICAgIHRoaXMub3duZXIuc3Vic2NyaWJlKHRoaXMpO1xuICAgIH1cbn1cbmltcGxlbWVudExlbmd0aE9ic2VydmVyKENvbGxlY3Rpb25MZW5ndGhPYnNlcnZlcik7XG5pbXBsZW1lbnRMZW5ndGhPYnNlcnZlcihDb2xsZWN0aW9uU2l6ZU9ic2VydmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb24tbGVuZ3RoLW9ic2VydmVyLmpzLm1hcCIsImltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgZW50ZXJDb25uZWN0YWJsZSwgZXhpdENvbm5lY3RhYmxlIH0gZnJvbSAnLi9jb25uZWN0YWJsZS1zd2l0Y2hlci5qcyc7XG5pbXBvcnQgeyBjb25uZWN0YWJsZSB9IGZyb20gJy4uL2JpbmRpbmcvY29ubmVjdGFibGUuanMnO1xuaW1wb3J0IHsgd3JhcCwgdW53cmFwIH0gZnJvbSAnLi9wcm94eS1vYnNlcnZhdGlvbi5qcyc7XG5pbXBvcnQgeyBkZWYgfSBmcm9tICcuLi91dGlsaXRpZXMtb2JqZWN0cy5qcyc7XG5leHBvcnQgY2xhc3MgQ29tcHV0ZWRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob2JqLCBnZXQsIHNldCwgdXNlUHJveHksIG9ic2VydmVyTG9jYXRvcikge1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5nZXQgPSBnZXQ7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLnVzZVByb3h5ID0gdXNlUHJveHk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJMb2NhdG9yID0gb2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLmludGVyY2VwdG9yID0gdGhpcztcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBPYnNlcnZlciAqLztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgLy8gdG9kbzogbWF5YmUgdXNlIGEgY291bnRlciBhbGxvdyByZWN1cnNpdmUgY2FsbCB0byBhIGNlcnRhaW4gbGV2ZWxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0YWJsZS5hc3NpZ25JZFRvKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKG9iaiwga2V5LCBkZXNjcmlwdG9yLCBvYnNlcnZlckxvY2F0b3IsIHVzZVByb3h5KSB7XG4gICAgICAgIGNvbnN0IGdldHRlciA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICBjb25zdCBzZXR0ZXIgPSBkZXNjcmlwdG9yLnNldDtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgQ29tcHV0ZWRPYnNlcnZlcihvYmosIGdldHRlciwgc2V0dGVyLCB1c2VQcm94eSwgb2JzZXJ2ZXJMb2NhdG9yKTtcbiAgICAgICAgY29uc3QgJGdldCA9ICgoIC8qIENvbXB1dGVkIE9ic2VydmVyICovKSA9PiBvYnNlcnZlci5nZXRWYWx1ZSgpKTtcbiAgICAgICAgJGdldC5nZXRPYnNlcnZlciA9ICgpID0+IG9ic2VydmVyO1xuICAgICAgICBkZWYob2JqLCBrZXksIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogJGdldCxcbiAgICAgICAgICAgIHNldDogKC8qIENvbXB1dGVkIE9ic2VydmVyICovIHYpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5zZXRWYWx1ZSh2LCAwIC8qIG5vbmUgKi8pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldC5jYWxsKHRoaXMub2JqLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHQtbGluZVxuICAgIHNldFZhbHVlKHYsIF9mbGFncykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodiAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgcnVubmluZyB0cnVlIGFzIGEgZm9ybSBvZiBiYXRjaGluZ1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQuY2FsbCh0aGlzLm9iaiwgdik7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgaXMgcmVhZG9ubHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuY291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuY291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIC8vIGluIHRoZW9yeSwgYSBjb2xsZWN0aW9uIHN1YnNjcmliZXIgY291bGQgYmUgYWRkZWQgYmVmb3JlIGEgcHJvcGVydHkgc3Vic2NyaWJlclxuICAgICAgICAvLyBhbmQgaXQgc2hvdWxkIGJlIGhhbmRsZWQgc2ltaWxhcmx5IGluIHN1YnNjcmliZVRvQ29sbGVjdGlvblxuICAgICAgICAvLyB0aG91Z2ggbm90IGhhbmRsaW5nIGZvciBub3csIGFuZCB3YWl0IHVudGlsIHRoZSBtZXJnZSBvZiBub3JtYWwgKyBjb2xsZWN0aW9uIHN1YnNjcmlwdGlvblxuICAgICAgICBpZiAodGhpcy5zdWJzLmFkZChzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLnJlbW92ZShzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9icy5jbGVhcih0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICBpZiAoIU9iamVjdC5pcyhuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgb3B0aW9uYWxseSBxdWV1ZVxuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShuZXdWYWx1ZSwgb2xkVmFsdWUsIDAgLyogbm9uZSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZSgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnMudmVyc2lvbisrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZW50ZXJDb25uZWN0YWJsZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gdW53cmFwKHRoaXMuZ2V0LmNhbGwodGhpcy51c2VQcm94eSA/IHdyYXAodGhpcy5vYmopIDogdGhpcy5vYmosIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub2JzLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZXhpdENvbm5lY3RhYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29ubmVjdGFibGUoQ29tcHV0ZWRPYnNlcnZlcik7XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihDb21wdXRlZE9ic2VydmVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXB1dGVkLW9ic2VydmVyLmpzLm1hcCIsIi8qKlxuICogQ3VycmVudCBzdWJzY3JpcHRpb24gY29sbGVjdG9yXG4gKi9cbmxldCBfY29ubmVjdGFibGUgPSBudWxsO1xuY29uc3QgY29ubmVjdGFibGVzID0gW107XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmV4cG9ydCBsZXQgY29ubmVjdGluZyA9IGZhbHNlO1xuLy8gdG9kbzogbGF5ZXIgYmFzZWQgY29sbGVjdGlvbiBwYXVzZS9yZXN1bWU/XG5leHBvcnQgZnVuY3Rpb24gcGF1c2VDb25uZWN0aW5nKCkge1xuICAgIGNvbm5lY3RpbmcgPSBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXN1bWVDb25uZWN0aW5nKCkge1xuICAgIGNvbm5lY3RpbmcgPSB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRDb25uZWN0YWJsZSgpIHtcbiAgICByZXR1cm4gX2Nvbm5lY3RhYmxlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVudGVyQ29ubmVjdGFibGUoY29ubmVjdGFibGUpIHtcbiAgICBpZiAoY29ubmVjdGFibGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvbm5lY3RhYmxlIGNhbm5vdCBiZSBudWxsL3VuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoX2Nvbm5lY3RhYmxlID09IG51bGwpIHtcbiAgICAgICAgX2Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgICAgIGNvbm5lY3RhYmxlc1swXSA9IF9jb25uZWN0YWJsZTtcbiAgICAgICAgY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKF9jb25uZWN0YWJsZSA9PT0gY29ubmVjdGFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbHJlYWR5IGluIHRoaXMgY29ubmVjdGFibGUgJHtjb25uZWN0YWJsZS5pZH1gKTtcbiAgICB9XG4gICAgY29ubmVjdGFibGVzLnB1c2goX2Nvbm5lY3RhYmxlKTtcbiAgICBfY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICBjb25uZWN0aW5nID0gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGl0Q29ubmVjdGFibGUoY29ubmVjdGFibGUpIHtcbiAgICBpZiAoY29ubmVjdGFibGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3RhYmxlIGNhbm5vdCBiZSBudWxsL3VuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoX2Nvbm5lY3RhYmxlICE9PSBjb25uZWN0YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29ubmVjdGFibGUuaWR9IGlzIG5vdCBjdXJyZW50bHkgY29sbGVjdGluZ2ApO1xuICAgIH1cbiAgICBjb25uZWN0YWJsZXMucG9wKCk7XG4gICAgX2Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGVzLmxlbmd0aCA+IDAgPyBjb25uZWN0YWJsZXNbY29ubmVjdGFibGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICBjb25uZWN0aW5nID0gX2Nvbm5lY3RhYmxlICE9IG51bGw7XG59XG5leHBvcnQgY29uc3QgQ29ubmVjdGFibGVTd2l0Y2hlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gX2Nvbm5lY3RhYmxlO1xuICAgIH0sXG4gICAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW5nO1xuICAgIH0sXG4gICAgZW50ZXI6IGVudGVyQ29ubmVjdGFibGUsXG4gICAgZXhpdDogZXhpdENvbm5lY3RhYmxlLFxuICAgIHBhdXNlOiBwYXVzZUNvbm5lY3RpbmcsXG4gICAgcmVzdW1lOiByZXN1bWVDb25uZWN0aW5nLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0YWJsZS1zd2l0Y2hlci5qcy5tYXAiLCJpbXBvcnQgeyBESSwgSVBsYXRmb3JtIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWNvbGxlY3Rpb24uanMnO1xuZXhwb3J0IGNvbnN0IElEaXJ0eUNoZWNrZXIgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lEaXJ0eUNoZWNrZXInLCB4ID0+IHguc2luZ2xldG9uKERpcnR5Q2hlY2tlcikpO1xuZXhwb3J0IGNvbnN0IERpcnR5Q2hlY2tTZXR0aW5ncyA9IHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0OiBgNmBcbiAgICAgKlxuICAgICAqIEFkanVzdCB0aGUgZ2xvYmFsIGRpcnR5IGNoZWNrIGZyZXF1ZW5jeS5cbiAgICAgKiBNZWFzdXJlcyBpbiBcInRpbWVvdXRzIHBlciBjaGVja1wiLCBzdWNoIHRoYXQgKGdpdmVuIGEgZGVmYXVsdCBvZiAyNTAgdGltZW91dHMgcGVyIHNlY29uZCBpbiBtb2Rlcm4gYnJvd3NlcnMpOlxuICAgICAqIC0gQSB2YWx1ZSBvZiAxIHdpbGwgcmVzdWx0IGluIDI1MCBkaXJ0eSBjaGVja3MgcGVyIHNlY29uZCAob3IgMSBkaXJ0eSBjaGVjayBwZXIgc2Vjb25kIGZvciBhbiBpbmFjdGl2ZSB0YWIpXG4gICAgICogLSBBIHZhbHVlIG9mIDI1IHdpbGwgcmVzdWx0IGluIDEwIGRpcnR5IGNoZWNrcyBwZXIgc2Vjb25kIChvciAxIGRpcnR5IGNoZWNrIHBlciAyNSBzZWNvbmRzIGZvciBhbiBpbmFjdGl2ZSB0YWIpXG4gICAgICovXG4gICAgdGltZW91dHNQZXJDaGVjazogMjUsXG4gICAgLyoqXG4gICAgICogRGVmYXVsdDogYGZhbHNlYFxuICAgICAqXG4gICAgICogRGlzYWJsZSBkaXJ0eS1jaGVja2luZyBlbnRpcmVseS4gUHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBvYnNlcnZlZCB3aXRob3V0IGRpcnR5IGNoZWNraW5nXG4gICAgICogb3IgYW4gYWRhcHRlciwgd2lsbCBzaW1wbHkgbm90IGJlIG9ic2VydmVkLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0OiBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBUaHJvdyBhbiBlcnJvciBpZiBhIHByb3BlcnR5IGlzIGJlaW5nIGRpcnR5LWNoZWNrZWQuXG4gICAgICovXG4gICAgdGhyb3c6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgZGlydHkgY2hlY2tpbmcgc2V0dGluZ3MgdG8gdGhlIGZyYW1ld29yaydzIGRlZmF1bHRzLlxuICAgICAqL1xuICAgIHJlc2V0VG9EZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRzUGVyQ2hlY2sgPSA2O1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3cgPSBmYWxzZTtcbiAgICB9XG59O1xuY29uc3QgcXVldWVUYXNrT3B0cyA9IHtcbiAgICBwZXJzaXN0ZW50OiB0cnVlLFxufTtcbmV4cG9ydCBjbGFzcyBEaXJ0eUNoZWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy50cmFja2VkID0gW107XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxhcHNlZEZyYW1lcyA9IDA7XG4gICAgICAgIHRoaXMuY2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoRGlydHlDaGVja1NldHRpbmdzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCsrdGhpcy5lbGFwc2VkRnJhbWVzIDwgRGlydHlDaGVja1NldHRpbmdzLnRpbWVvdXRzUGVyQ2hlY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRGcmFtZXMgPSAwO1xuICAgICAgICAgICAgY29uc3QgdHJhY2tlZCA9IHRoaXMudHJhY2tlZDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHRyYWNrZWQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRyYWNrZWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuaXNEaXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZmx1c2goMCAvKiBub25lICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZVByb3BlcnR5KG9iaiwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGlmIChEaXJ0eUNoZWNrU2V0dGluZ3MudGhyb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJyR7cHJvcGVydHlOYW1lfScgaXMgYmVpbmcgZGlydHktY2hlY2tlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERpcnR5Q2hlY2tQcm9wZXJ0eSh0aGlzLCBvYmosIHByb3BlcnR5TmFtZSk7XG4gICAgfVxuICAgIGFkZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMudHJhY2tlZC5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudGFzayA9IHRoaXMucGxhdGZvcm0ubWFjcm9UYXNrUXVldWUucXVldWVUYXNrKHRoaXMuY2hlY2ssIHF1ZXVlVGFza09wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMudHJhY2tlZC5zcGxpY2UodGhpcy50cmFja2VkLmluZGV4T2YocHJvcGVydHkpLCAxKTtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5EaXJ0eUNoZWNrZXIuaW5qZWN0ID0gW0lQbGF0Zm9ybV07XG5leHBvcnQgY2xhc3MgRGlydHlDaGVja1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihkaXJ0eUNoZWNrZXIsIG9iaiwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgdGhpcy5kaXJ0eUNoZWNrZXIgPSBkaXJ0eUNoZWNrZXI7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXk7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICB9XG4gICAgc2V0VmFsdWUodiwgZikge1xuICAgICAgICAvLyB0b2RvOiB0aGlzIHNob3VsZCBiZSBhbGxvd2VkLCBwcm9iYWJseVxuICAgICAgICAvLyBidXQgdGhlIGNvbnN0cnVjdGlvbiBvZiBkaXJ0eSBjaGVja2VyIHNob3VsZCB0aHJvdyBpbnN0ZWFkXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIHNldCB2YWx1ZSBmb3IgcHJvcGVydHkgJHt0aGlzLnByb3BlcnR5S2V5fSBpbiBkaXJ0eSBjaGVja2VyYCk7XG4gICAgfVxuICAgIGlzRGlydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9sZFZhbHVlICE9PSB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICB9XG4gICAgZmx1c2goZmxhZ3MpIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLm9sZFZhbHVlO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShuZXdWYWx1ZSwgb2xkVmFsdWUsIGZsYWdzIHwgOCAvKiB1cGRhdGVUYXJnZXQgKi8pO1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMuYWRkKHN1YnNjcmliZXIpICYmIHRoaXMuc3Vicy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHRoaXMub2JqW3RoaXMucHJvcGVydHlLZXldO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUNoZWNrZXIuYWRkUHJvcGVydHkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5zdWJzLnJlbW92ZShzdWJzY3JpYmVyKSAmJiB0aGlzLnN1YnMuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlDaGVja2VyLnJlbW92ZVByb3BlcnR5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuc3Vic2NyaWJlckNvbGxlY3Rpb24oRGlydHlDaGVja1Byb3BlcnR5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcnR5LWNoZWNrZXIuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlSW5kZXhNYXAgfSBmcm9tICcuLi9vYnNlcnZhdGlvbi5qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyIH0gZnJvbSAnLi9jb2xsZWN0aW9uLWxlbmd0aC1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBzdWJzY3JpYmVyQ29sbGVjdGlvbiB9IGZyb20gJy4vc3Vic2NyaWJlci1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGRlZiB9IGZyb20gJy4uL3V0aWxpdGllcy1vYmplY3RzLmpzJztcbmNvbnN0IG9ic2VydmVyTG9va3VwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHByb3RvID0gTWFwLnByb3RvdHlwZTtcbmNvbnN0ICRzZXQgPSBwcm90by5zZXQ7XG5jb25zdCAkY2xlYXIgPSBwcm90by5jbGVhcjtcbmNvbnN0ICRkZWxldGUgPSBwcm90by5kZWxldGU7XG5jb25zdCBuYXRpdmUgPSB7IHNldDogJHNldCwgY2xlYXI6ICRjbGVhciwgZGVsZXRlOiAkZGVsZXRlIH07XG5jb25zdCBtZXRob2RzID0gWydzZXQnLCAnY2xlYXInLCAnZGVsZXRlJ107XG4vLyBub3RlOiB3ZSBjYW4ndCByZWFsbHkgZG8gbXVjaCB3aXRoIE1hcCBkdWUgdG8gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlIG5vdCBiZWluZyBhY2Nlc3NpYmxlIHNvIHdlJ3JlIGp1c3QgdXNpbmcgdGhlIG5hdGl2ZSBjYWxsc1xuLy8gZm9ydHVuYXRlbHksIG1hcC9kZWxldGUvY2xlYXIgYXJlIGVhc3kgdG8gcmVjb25zdHJ1Y3QgZm9yIHRoZSBpbmRleE1hcFxuY29uc3Qgb2JzZXJ2ZSA9IHtcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLm1hcFxuICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJHNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICBjb25zdCBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgICAgICAkc2V0LmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmIChuZXdTaXplID09PSBvbGRTaXplKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5WzFdICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgby5pbmRleE1hcC5kZWxldGVkSXRlbXMucHVzaChvLmluZGV4TWFwW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaW5kZXhNYXBbaV0gPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG8uaW5kZXhNYXBbb2xkU2l6ZV0gPSAtMjtcbiAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICRjbGVhci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgLy8gZGVlcHNjYW4tZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGZvciAoY29uc3QgXyBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5wdXNoKGluZGV4TWFwW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJGNsZWFyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpbmRleE1hcC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgby5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5kZWxldGVcbiAgICBkZWxldGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBvID0gb2JzZXJ2ZXJMb29rdXAuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJGRlbGV0ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgaW5kZXhNYXAgPSBvLmluZGV4TWFwO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4TWFwW2ldID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXAuZGVsZXRlZEl0ZW1zLnB1c2goaW5kZXhNYXBbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleE1hcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzdWx0ID0gJGRlbGV0ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5jb25zdCBkZXNjcmlwdG9yUHJvcHMgPSB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG59O1xuZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgIGRlZihvYnNlcnZlW21ldGhvZF0sICdvYnNlcnZpbmcnLCB7IHZhbHVlOiB0cnVlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xufVxubGV0IGVuYWJsZU1hcE9ic2VydmF0aW9uQ2FsbGVkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTWFwT2JzZXJ2YXRpb24oKSB7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICBpZiAocHJvdG9bbWV0aG9kXS5vYnNlcnZpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlZihwcm90bywgbWV0aG9kLCB7IC4uLmRlc2NyaXB0b3JQcm9wcywgdmFsdWU6IG9ic2VydmVbbWV0aG9kXSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlTWFwT2JzZXJ2YXRpb24oKSB7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICBpZiAocHJvdG9bbWV0aG9kXS5vYnNlcnZpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlZihwcm90bywgbWV0aG9kLCB7IC4uLmRlc2NyaXB0b3JQcm9wcywgdmFsdWU6IG5hdGl2ZVttZXRob2RdIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1hcE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihtYXApIHtcbiAgICAgICAgdGhpcy50eXBlID0gNjYgLyogTWFwICovO1xuICAgICAgICBpZiAoIWVuYWJsZU1hcE9ic2VydmF0aW9uQ2FsbGVkKSB7XG4gICAgICAgICAgICBlbmFibGVNYXBPYnNlcnZhdGlvbkNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBlbmFibGVNYXBPYnNlcnZhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IG1hcDtcbiAgICAgICAgdGhpcy5pbmRleE1hcCA9IGNyZWF0ZUluZGV4TWFwKG1hcC5zaXplKTtcbiAgICAgICAgdGhpcy5sZW5PYnMgPSB2b2lkIDA7XG4gICAgICAgIG9ic2VydmVyTG9va3VwLnNldChtYXAsIHRoaXMpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gdGhpcy5pbmRleE1hcDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuY29sbGVjdGlvbi5zaXplO1xuICAgICAgICB0aGlzLmluZGV4TWFwID0gY3JlYXRlSW5kZXhNYXAoc2l6ZSk7XG4gICAgICAgIHRoaXMuc3Vicy5ub3RpZnlDb2xsZWN0aW9uKGluZGV4TWFwLCA4IC8qIHVwZGF0ZVRhcmdldCAqLyk7XG4gICAgfVxuICAgIGdldExlbmd0aE9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5PYnMgPz8gKHRoaXMubGVuT2JzID0gbmV3IENvbGxlY3Rpb25TaXplT2JzZXJ2ZXIodGhpcykpO1xuICAgIH1cbn1cbnN1YnNjcmliZXJDb2xsZWN0aW9uKE1hcE9ic2VydmVyKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBPYnNlcnZlcihtYXApIHtcbiAgICBsZXQgb2JzZXJ2ZXIgPSBvYnNlcnZlckxvb2t1cC5nZXQobWFwKTtcbiAgICBpZiAob2JzZXJ2ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICBvYnNlcnZlciA9IG5ldyBNYXBPYnNlcnZlcihtYXApO1xuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAtb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgU2V0dGVyTm90aWZpZXIgfSBmcm9tICcuL3NldHRlci1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBkZWYgfSBmcm9tICcuLi91dGlsaXRpZXMtb2JqZWN0cy5qcyc7XG5mdW5jdGlvbiBnZXRPYnNlcnZlcnNMb29rdXAob2JqKSB7XG4gICAgaWYgKG9iai4kb2JzZXJ2ZXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVmKG9iaiwgJyRvYnNlcnZlcnMnLCB7IHZhbHVlOiB7fSB9KTtcbiAgICAgICAgLy8gdG9kbzogZGVmaW5lIGluIGEgd2Vha21hcFxuICAgIH1cbiAgICByZXR1cm4gb2JqLiRvYnNlcnZlcnM7XG59XG5jb25zdCBub1ZhbHVlID0ge307XG4vLyBpbXBsLCB3b250IGJlIHNlZW5cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlKHRhcmdldE9yQ29uZmlnLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAvLyBlaXRoZXIgdGhpcyBjaGVjaywgb3IgYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgIC8vIG9yIGNvdWxkIGJlIGJvdGgsIHNvIGNhbiB0aHJvdyBhZ2FpbnN0IHVzZXIgZXJyb3IgZm9yIGJldHRlciBEWFxuICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAvLyBmb3I6XG4gICAgICAgIC8vICAgIEBvYnNlcnZhYmxlKCdwcm9wJylcbiAgICAgICAgLy8gICAgY2xhc3Mge31cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgQG9ic2VydmFibGUoeyBuYW1lOiAncHJvcCcsIGNhbGxiYWNrOiAuLi4gfSlcbiAgICAgICAgLy8gICAgY2xhc3Mge31cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgY2xhc3Mge1xuICAgICAgICAvLyAgICAgIEBvYnNlcnZhYmxlKCkgcHJvcFxuICAgICAgICAvLyAgICAgIEBvYnNlcnZhYmxlKHsgY2FsbGJhY2s6IC4uLiB9KSBwcm9wMlxuICAgICAgICAvLyAgICB9XG4gICAgICAgIHJldHVybiAoKHQsIGssIGQpID0+IGRlY28odCwgaywgZCwgdGFyZ2V0T3JDb25maWcpKTtcbiAgICB9XG4gICAgLy8gZm9yOlxuICAgIC8vICAgIGNsYXNzIHtcbiAgICAvLyAgICAgIEBvYnNlcnZhYmxlIHByb3BcbiAgICAvLyAgICB9XG4gICAgcmV0dXJuIGRlY28odGFyZ2V0T3JDb25maWcsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgZnVuY3Rpb24gZGVjbyh0YXJnZXQsIGtleSwgZGVzY3JpcHRvciwgY29uZmlnKSB7XG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRvcj9cbiAgICAgICAgY29uc3QgaXNDbGFzc0RlY29yYXRvciA9IGtleSA9PT0gdm9pZCAwO1xuICAgICAgICBjb25maWcgPSB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyB7IG5hbWU6IGNvbmZpZyB9XG4gICAgICAgICAgICA6IChjb25maWcgfHwge30pO1xuICAgICAgICBpZiAoaXNDbGFzc0RlY29yYXRvcikge1xuICAgICAgICAgICAga2V5ID0gY29uZmlnLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PSBudWxsIHx8IGtleSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1c2FnZSwgY2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBuYW1lIGZvciBAb2JzZXJ2YWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRldGVybWluZSBjYWxsYmFjayBuYW1lIGJhc2VkIG9uIGNvbmZpZyBvciBjb252ZW50aW9uLlxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFjayB8fCBgJHtTdHJpbmcoa2V5KX1DaGFuZ2VkYDtcbiAgICAgICAgbGV0IGluaXRpYWxWYWx1ZSA9IG5vVmFsdWU7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBhZGRpbmcgYSBnZXR0ZXIgYW5kIHNldHRlciB3aGljaCBtZWFucyB0aGUgcHJvcGVydHkgZGVzY3JpcHRvclxuICAgICAgICAgICAgLy8gY2Fubm90IGhhdmUgYSBcInZhbHVlXCIgb3IgXCJ3cml0YWJsZVwiIGF0dHJpYnV0ZVxuICAgICAgICAgICAgZGVsZXRlIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICBkZWxldGUgZGVzY3JpcHRvci53cml0YWJsZTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXI/LigpO1xuICAgICAgICAgICAgZGVsZXRlIGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIHRoZSBhY2Nlc3NvciBlbnVtZXJhYmxlIGJ5IGRlZmF1bHQsIGFzIGZpZWxkcyBhcmUgZW51bWVyYWJsZVxuICAgICAgICBpZiAoISgnZW51bWVyYWJsZScgaW4gZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbyhiaWdvcG9uL2ZyZWQpOiBkaXNjdXNzIHN0cmluZyBhcGkgZm9yIGNvbnZlcnRlclxuICAgICAgICBjb25zdCAkc2V0ID0gY29uZmlnLnNldDtcbiAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiBnKCAvKiBAb2JzZXJ2YWJsZSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5vdGlmaWVyKHRoaXMsIGtleSwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSwgJHNldCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVzY3JpcHRvci5zZXQgPSBmdW5jdGlvbiBzKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBnZXROb3RpZmllcih0aGlzLCBrZXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUsICRzZXQpLnNldFZhbHVlKG5ld1ZhbHVlLCAwIC8qIG5vbmUgKi8pO1xuICAgICAgICB9O1xuICAgICAgICBkZXNjcmlwdG9yLmdldC5nZXRPYnNlcnZlciA9IGZ1bmN0aW9uIGdPKC8qIEBvYnNlcnZhYmxlICovIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5vdGlmaWVyKG9iaiwga2V5LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlLCAkc2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzQ2xhc3NEZWNvcmF0b3IpIHtcbiAgICAgICAgICAgIGRlZih0YXJnZXQucHJvdG90eXBlLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXROb3RpZmllcihvYmosIGtleSwgY2FsbGJhY2tLZXksIGluaXRpYWxWYWx1ZSwgc2V0KSB7XG4gICAgY29uc3QgbG9va3VwID0gZ2V0T2JzZXJ2ZXJzTG9va3VwKG9iaik7XG4gICAgbGV0IG5vdGlmaWVyID0gbG9va3VwW2tleV07XG4gICAgaWYgKG5vdGlmaWVyID09IG51bGwpIHtcbiAgICAgICAgbm90aWZpZXIgPSBuZXcgU2V0dGVyTm90aWZpZXIob2JqLCBjYWxsYmFja0tleSwgc2V0LCBpbml0aWFsVmFsdWUgPT09IG5vVmFsdWUgPyB2b2lkIDAgOiBpbml0aWFsVmFsdWUpO1xuICAgICAgICBsb29rdXBba2V5XSA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICByZXR1cm4gbm90aWZpZXI7XG59XG4vKlxuICAgICAgICAgIHwgdHlwZXNjcmlwdCAgICAgICB8IGJhYmVsXG4tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5wcm9wZXJ0eSAgfCBjb25maWcgICAgICAgICAgIHwgY29uZmlnXG53L3BhcmVucyAgfCB0YXJnZXQsIGtleSAgICAgIHwgdGFyZ2V0LCBrZXksIGRlc2NyaXB0b3Jcbi0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnByb3BlcnR5ICB8IHRhcmdldCwga2V5ICAgICAgfCB0YXJnZXQsIGtleSwgZGVzY3JpcHRvclxubm8gcGFyZW5zIHwgbi9hICAgICAgICAgICAgICB8IG4vYVxuLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgICAgIHwgY29uZmlnICAgICAgICAgICB8IGNvbmZpZ1xuICAgICAgICAgIHwgdGFyZ2V0ICAgICAgICAgICB8IHRhcmdldFxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIiwiaW1wb3J0IHsgREksIGlzQXJyYXlJbmRleCwgSUxvZ2dlciB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5pbXBvcnQgeyBnZXRBcnJheU9ic2VydmVyIH0gZnJvbSAnLi9hcnJheS1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBDb21wdXRlZE9ic2VydmVyIH0gZnJvbSAnLi9jb21wdXRlZC1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBJRGlydHlDaGVja2VyIH0gZnJvbSAnLi9kaXJ0eS1jaGVja2VyLmpzJztcbmltcG9ydCB7IGdldE1hcE9ic2VydmVyIH0gZnJvbSAnLi9tYXAtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgUHJpbWl0aXZlT2JzZXJ2ZXIgfSBmcm9tICcuL3ByaW1pdGl2ZS1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUFjY2Vzc29yIH0gZnJvbSAnLi9wcm9wZXJ0eS1hY2Nlc3Nvci5qcyc7XG5pbXBvcnQgeyBnZXRTZXRPYnNlcnZlciB9IGZyb20gJy4vc2V0LW9ic2VydmVyLmpzJztcbmltcG9ydCB7IFNldHRlck9ic2VydmVyIH0gZnJvbSAnLi9zZXR0ZXItb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgZGVmIH0gZnJvbSAnLi4vdXRpbGl0aWVzLW9iamVjdHMuanMnO1xuZXhwb3J0IGNvbnN0IHByb3BlcnR5QWNjZXNzb3IgPSBuZXcgUHJvcGVydHlBY2Nlc3NvcigpO1xuZXhwb3J0IGNvbnN0IElPYnNlcnZlckxvY2F0b3IgPSBESS5jcmVhdGVJbnRlcmZhY2UoJ0lPYnNlcnZlckxvY2F0b3InLCB4ID0+IHguc2luZ2xldG9uKE9ic2VydmVyTG9jYXRvcikpO1xuZXhwb3J0IGNvbnN0IElOb2RlT2JzZXJ2ZXJMb2NhdG9yID0gRElcbiAgICAuY3JlYXRlSW50ZXJmYWNlKCdJTm9kZU9ic2VydmVyTG9jYXRvcicsIHggPT4geC5jYWNoZWRDYWxsYmFjayhoYW5kbGVyID0+IHtcbiAgICBoYW5kbGVyLmdldEFsbChJTG9nZ2VyKS5mb3JFYWNoKGxvZ2dlciA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignVXNpbmcgZGVmYXVsdCBJTm9kZU9ic2VydmVyTG9jYXRvciBpbXBsZW1lbnRhdGlvbi4gV2lsbCBub3QgYmUgYWJsZSB0byBvYnNlcnZlIG5vZGVzIChIVE1MIGV0Yy4uLikuJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0Tm9kZU9ic2VydmVyTG9jYXRvcigpO1xufSkpO1xuY2xhc3MgRGVmYXVsdE5vZGVPYnNlcnZlckxvY2F0b3Ige1xuICAgIGhhbmRsZXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0T2JzZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUFjY2Vzc29yO1xuICAgIH1cbiAgICBnZXRBY2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5QWNjZXNzb3I7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9ic2VydmVyTG9jYXRvciB7XG4gICAgY29uc3RydWN0b3IoZGlydHlDaGVja2VyLCBub2RlT2JzZXJ2ZXJMb2NhdG9yKSB7XG4gICAgICAgIHRoaXMuZGlydHlDaGVja2VyID0gZGlydHlDaGVja2VyO1xuICAgICAgICB0aGlzLm5vZGVPYnNlcnZlckxvY2F0b3IgPSBub2RlT2JzZXJ2ZXJMb2NhdG9yO1xuICAgICAgICB0aGlzLmFkYXB0ZXJzID0gW107XG4gICAgfVxuICAgIGFkZEFkYXB0ZXIoYWRhcHRlcikge1xuICAgICAgICB0aGlzLmFkYXB0ZXJzLnB1c2goYWRhcHRlcik7XG4gICAgfVxuICAgIGdldE9ic2VydmVyKG9iaiwga2V5KSB7XG4gICAgICAgIHJldHVybiBvYmouJG9ic2VydmVycz8uW2tleV1cbiAgICAgICAgICAgID8/IHRoaXMuY2FjaGUob2JqLCBrZXksIHRoaXMuY3JlYXRlT2JzZXJ2ZXIob2JqLCBrZXkpKTtcbiAgICB9XG4gICAgZ2V0QWNjZXNzb3Iob2JqLCBrZXkpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gb2JqLiRvYnNlcnZlcnM/LltrZXldO1xuICAgICAgICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9kZU9ic2VydmVyTG9jYXRvci5oYW5kbGVzKG9iaiwga2V5LCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZU9ic2VydmVyTG9jYXRvci5nZXRBY2Nlc3NvcihvYmosIGtleSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BlcnR5QWNjZXNzb3I7XG4gICAgfVxuICAgIGdldEFycmF5T2JzZXJ2ZXIob2JzZXJ2ZWRBcnJheSkge1xuICAgICAgICByZXR1cm4gZ2V0QXJyYXlPYnNlcnZlcihvYnNlcnZlZEFycmF5KTtcbiAgICB9XG4gICAgZ2V0TWFwT2JzZXJ2ZXIob2JzZXJ2ZWRNYXApIHtcbiAgICAgICAgcmV0dXJuIGdldE1hcE9ic2VydmVyKG9ic2VydmVkTWFwKTtcbiAgICB9XG4gICAgZ2V0U2V0T2JzZXJ2ZXIob2JzZXJ2ZWRTZXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldE9ic2VydmVyKG9ic2VydmVkU2V0KTtcbiAgICB9XG4gICAgY3JlYXRlT2JzZXJ2ZXIob2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmltaXRpdmVPYnNlcnZlcihvYmosIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9kZU9ic2VydmVyTG9jYXRvci5oYW5kbGVzKG9iaiwga2V5LCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZU9ic2VydmVyTG9jYXRvci5nZXRPYnNlcnZlcihvYmosIGtleSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRBcnJheU9ic2VydmVyKG9iaikuZ2V0TGVuZ3RoT2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNYXBPYnNlcnZlcihvYmopLmdldExlbmd0aE9ic2VydmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2V0T2JzZXJ2ZXIob2JqKS5nZXRMZW5ndGhPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIGlzQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRBcnJheU9ic2VydmVyKG9iaikuZ2V0SW5kZXhPYnNlcnZlcihOdW1iZXIoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAvLyBPbmx5IGluc3RhbmNlIHByb3BlcnRpZXMgd2lsbCB5aWVsZCBhIGRlc2NyaXB0b3IgaGVyZSwgb3RoZXJ3aXNlIHdhbGsgdXAgdGhlIHByb3RvIGNoYWluXG4gICAgICAgIGlmIChwZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm90byAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAocGQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGRlc2NyaXB0b3IgZG9lcyBub3QgaGF2ZSBhICd2YWx1ZScgcHJvcCwgaXQgbXVzdCBoYXZlIGEgZ2V0dGVyIGFuZC9vciBzZXR0ZXJcbiAgICAgICAgaWYgKHBkICE9PSB2b2lkIDAgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwZCwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGxldCBvYnMgPSB0aGlzLmdldEFkYXB0ZXJPYnNlcnZlcihvYmosIGtleSwgcGQpO1xuICAgICAgICAgICAgaWYgKG9icyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2JzID0gKHBkLmdldD8uZ2V0T2JzZXJ2ZXIgPz8gcGQuc2V0Py5nZXRPYnNlcnZlcik/LihvYmosIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9icyA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBwZC5jb25maWd1cmFibGVcbiAgICAgICAgICAgICAgICAgICAgPyBDb21wdXRlZE9ic2VydmVyLmNyZWF0ZShvYmosIGtleSwgcGQsIHRoaXMsIC8qIEFPVDogbm90IHRydWUgZm9yIElFMTEgKi8gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmRpcnR5Q2hlY2tlci5jcmVhdGVQcm9wZXJ0eShvYmosIGtleSlcbiAgICAgICAgICAgICAgICA6IG9icztcbiAgICAgICAgfVxuICAgICAgICAvLyBPcmRpbmFyeSBnZXQvc2V0IG9ic2VydmF0aW9uICh0aGUgY29tbW9uIHVzZSBjYXNlKVxuICAgICAgICAvLyBUT0RPOiB0aGluayBhYm91dCBob3cgdG8gaGFuZGxlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHNpdCBvbiB0aGUgaW5zdGFuY2UgKHNob3VsZCB3ZSBkbyBhbnl0aGluZyBkaWZmZXJlbnQ/KVxuICAgICAgICByZXR1cm4gbmV3IFNldHRlck9ic2VydmVyKG9iaiwga2V5KTtcbiAgICB9XG4gICAgZ2V0QWRhcHRlck9ic2VydmVyKG9iaiwgcHJvcGVydHlOYW1lLCBwZCkge1xuICAgICAgICBpZiAodGhpcy5hZGFwdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkYXB0ZXIgb2YgdGhpcy5hZGFwdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gYWRhcHRlci5nZXRPYnNlcnZlcihvYmosIHByb3BlcnR5TmFtZSwgcGQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhY2hlKG9iaiwga2V5LCBvYnNlcnZlcikge1xuICAgICAgICBpZiAob2JzZXJ2ZXIuZG9Ob3RDYWNoZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouJG9ic2VydmVycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWYob2JqLCAnJG9ic2VydmVycycsIHsgdmFsdWU6IHsgW2tleV06IG9ic2VydmVyIH0gfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iai4kb2JzZXJ2ZXJzW2tleV0gPSBvYnNlcnZlcjtcbiAgICB9XG59XG5PYnNlcnZlckxvY2F0b3IuaW5qZWN0ID0gW0lEaXJ0eUNoZWNrZXIsIElOb2RlT2JzZXJ2ZXJMb2NhdG9yXTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xsZWN0aW9uT2JzZXJ2ZXIoY29sbGVjdGlvbikge1xuICAgIGxldCBvYnM7XG4gICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBvYnMgPSBnZXRBcnJheU9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG9icyA9IGdldE1hcE9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG9icyA9IGdldFNldE9ic2VydmVyKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gb2JzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXItbG9jYXRvci5qcy5tYXAiLCJleHBvcnQgY2xhc3MgUHJpbWl0aXZlT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgdGhpcy50eXBlID0gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICBnZXQgZG9Ob3RDYWNoZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiB0aGlzLm9ialt0aGlzLnByb3BlcnR5S2V5XTtcbiAgICB9XG4gICAgc2V0VmFsdWUoKSB7IH1cbiAgICBzdWJzY3JpYmUoKSB7IH1cbiAgICB1bnN1YnNjcmliZSgpIHsgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpbWl0aXZlLW9ic2VydmVyLmpzLm1hcCIsImV4cG9ydCBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gdGhlIG9ubHkgdGhpbmcgY2FuIGJlIGd1YXJhbnRlZWQgaXMgaXQncyBhbiBvYmplY3RcbiAgICAgICAgLy8gZXZlbiBpZiB0aGlzIHByb3BlcnR5IGFjY2Vzc29yIGlzIHVzZWQgdG8gYWNjZXNzIGFuIGVsZW1lbnRcbiAgICAgICAgdGhpcy50eXBlID0gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICBnZXRWYWx1ZShvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlLCBmbGFncywgb2JqLCBrZXkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0eS1hY2Nlc3Nvci5qcy5tYXAiLCJpbXBvcnQgeyBjb25uZWN0aW5nLCBjdXJyZW50Q29ubmVjdGFibGUgfSBmcm9tICcuL2Nvbm5lY3RhYmxlLXN3aXRjaGVyLmpzJztcbmNvbnN0IFIkZ2V0ID0gUmVmbGVjdC5nZXQ7XG5jb25zdCB0b1N0cmluZ1RhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBwcm94eU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjYW5XcmFwKG9iaikge1xuICAgIHN3aXRjaCAodG9TdHJpbmdUYWcuY2FsbChvYmopKSB7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBNYXBdJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBTZXRdJzpcbiAgICAgICAgICAgIC8vIGl0J3MgdW5saWtlbHkgdGhhdCBtZXRob2RzIG9uIHRoZSBmb2xsb3dpbmcgMiBvYmplY3RzIG5lZWQgdG8gYmUgb2JzZXJ2ZWQgZm9yIGNoYW5nZXNcbiAgICAgICAgICAgIC8vIHNvIHdoaWxlIHRoZXkgYXJlIHZhbGlkLyB3ZSBkb24ndCB3cmFwIHRoZW0gZWl0aGVyXG4gICAgICAgICAgICAvLyBjYXNlICdbb2JqZWN0IE1hdGhdJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ1tvYmplY3QgUmVmbGVjdF0nOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHJhd0tleSA9ICdfX3Jhd19fJztcbmV4cG9ydCBmdW5jdGlvbiB3cmFwKHYpIHtcbiAgICByZXR1cm4gY2FuV3JhcCh2KSA/IGdldFByb3h5KHYpIDogdjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm94eShvYmopIHtcbiAgICAvLyBkZWVwc2Nhbi1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVybiBwcm94eU1hcC5nZXQob2JqKSA/PyBjcmVhdGVQcm94eShvYmopO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhdyhvYmopIHtcbiAgICAvLyB0b2RvOiBnZXQgaW4gYSB3ZWFrbWFwIGlmIG51bGwvdW5kZWZcbiAgICByZXR1cm4gb2JqW3Jhd0tleV0gPz8gb2JqO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcCh2KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuIGNhbldyYXAodikgJiYgdltyYXdLZXldIHx8IHY7XG59XG5mdW5jdGlvbiBkb05vdENvbGxlY3Qoa2V5KSB7XG4gICAgcmV0dXJuIGtleSA9PT0gJ2NvbnN0cnVjdG9yJ1xuICAgICAgICB8fCBrZXkgPT09ICdfX3Byb3RvX18nXG4gICAgICAgIC8vIHByb2JhYmx5IHNob3VsZCByZXZlcnQgdG8gdjEgbmFtaW5nIHN0eWxlIGZvciBjb25zaXN0ZW5jeSB3aXRoIGJ1aWx0aW4/XG4gICAgICAgIC8vIF9fb19fIGlzIHNob3J0ZXJzICYgbGVzcyBjaGFuY2Ugb2YgY29uZmxpY3Qgd2l0aCBvdGhlciBsaWJzIGFzIHdlbGxcbiAgICAgICAgfHwga2V5ID09PSAnJG9ic2VydmVycydcbiAgICAgICAgfHwga2V5ID09PSBTeW1ib2wudG9QcmltaXRpdmVcbiAgICAgICAgfHwga2V5ID09PSBTeW1ib2wudG9TdHJpbmdUYWc7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eShvYmopIHtcbiAgICBjb25zdCBoYW5kbGVyID0gb2JqIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgPyBhcnJheUhhbmRsZXJcbiAgICAgICAgOiBvYmogaW5zdGFuY2VvZiBNYXAgfHwgb2JqIGluc3RhbmNlb2YgU2V0XG4gICAgICAgICAgICA/IGNvbGxlY3Rpb25IYW5kbGVyXG4gICAgICAgICAgICA6IG9iamVjdEhhbmRsZXI7XG4gICAgY29uc3QgcHJveGllZE9iaiA9IG5ldyBQcm94eShvYmosIGhhbmRsZXIpO1xuICAgIHByb3h5TWFwLnNldChvYmosIHByb3hpZWRPYmopO1xuICAgIHJldHVybiBwcm94aWVkT2JqO1xufVxuY29uc3Qgb2JqZWN0SGFuZGxlciA9IHtcbiAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgIC8vIG1heWJlIHVzZSBzeW1ib2w/XG4gICAgICAgIGlmIChrZXkgPT09IHJhd0tleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGN1cnJlbnRDb25uZWN0YWJsZSgpO1xuICAgICAgICBpZiAoIWNvbm5lY3RpbmcgfHwgZG9Ob3RDb2xsZWN0KGtleSkgfHwgY29ubmVjdGFibGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFIkZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogc3RhdGljXG4gICAgICAgIGNvbm5lY3RhYmxlLm9ic2VydmVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgICAgIHJldHVybiB3cmFwKFIkZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpO1xuICAgIH0sXG59O1xuY29uc3QgYXJyYXlIYW5kbGVyID0ge1xuICAgIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgLy8gbWF5YmUgdXNlIHN5bWJvbD9cbiAgICAgICAgaWYgKGtleSA9PT0gcmF3S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlID0gY3VycmVudENvbm5lY3RhYmxlKCk7XG4gICAgICAgIGlmICghY29ubmVjdGluZyB8fCBkb05vdENvbGxlY3Qoa2V5KSB8fCBjb25uZWN0YWJsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUiRnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnbGVuZ3RoJzpcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZS5vYnNlcnZlUHJvcGVydHkodGFyZ2V0LCAnbGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGg7XG4gICAgICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlNYXA7XG4gICAgICAgICAgICBjYXNlICdpbmNsdWRlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheUluY2x1ZGVzO1xuICAgICAgICAgICAgY2FzZSAnaW5kZXhPZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheUluZGV4T2Y7XG4gICAgICAgICAgICBjYXNlICdsYXN0SW5kZXhPZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheUxhc3RJbmRleE9mO1xuICAgICAgICAgICAgY2FzZSAnZXZlcnknOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlFdmVyeTtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbHRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheUZpbHRlcjtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmRJbmRleCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheUZpbmRJbmRleDtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlGbGF0O1xuICAgICAgICAgICAgY2FzZSAnZmxhdE1hcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheUZsYXRNYXA7XG4gICAgICAgICAgICBjYXNlICdqb2luJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5Sm9pbjtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQXJyYXlQdXNoO1xuICAgICAgICAgICAgY2FzZSAncG9wJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5UG9wO1xuICAgICAgICAgICAgY2FzZSAncmVkdWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZFJlZHVjZTtcbiAgICAgICAgICAgIGNhc2UgJ3JlZHVjZVJpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZFJlZHVjZVJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAncmV2ZXJzZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVJldmVyc2U7XG4gICAgICAgICAgICBjYXNlICdzaGlmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVNoaWZ0O1xuICAgICAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVVuc2hpZnQ7XG4gICAgICAgICAgICBjYXNlICdzbGljZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVNsaWNlO1xuICAgICAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5U3BsaWNlO1xuICAgICAgICAgICAgY2FzZSAnc29tZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRBcnJheVNvbWU7XG4gICAgICAgICAgICBjYXNlICdzb3J0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEFycmF5U29ydDtcbiAgICAgICAgICAgIGNhc2UgJ2tleXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkS2V5cztcbiAgICAgICAgICAgIGNhc2UgJ3ZhbHVlcyc6XG4gICAgICAgICAgICBjYXNlIFN5bWJvbC5pdGVyYXRvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZFZhbHVlcztcbiAgICAgICAgICAgIGNhc2UgJ2VudHJpZXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW50cmllcztcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0YWJsZS5vYnNlcnZlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgICAgICByZXR1cm4gd3JhcChSJGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuICAgIC8vIGZvciAobGV0IGkgaW4gYXJyYXkpIC4uLlxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlUHJvcGVydHkodGFyZ2V0LCAnbGVuZ3RoJyk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHdyYXBwZWRBcnJheU1hcChjYiwgdGhpc0FyZykge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcubWFwKCh2LCBpKSA9PiBcbiAgICAvLyBkbyB3ZSB3cmFwIGB0aGlzQXJnYD9cbiAgICB1bndyYXAoY2IuY2FsbCh0aGlzQXJnLCB3cmFwKHYpLCBpLCB0aGlzKSkpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiB3cmFwKHJlcyk7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlFdmVyeShjYiwgdGhpc0FyZykge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcuZXZlcnkoKHYsIGkpID0+IGNiLmNhbGwodGhpc0FyZywgd3JhcCh2KSwgaSwgdGhpcykpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlGaWx0ZXIoY2IsIHRoaXNBcmcpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3LmZpbHRlcigodiwgaSkgPT4gXG4gICAgLy8gZG8gd2Ugd3JhcCBgdGhpc0FyZ2A/XG4gICAgdW53cmFwKGNiLmNhbGwodGhpc0FyZywgd3JhcCh2KSwgaSwgdGhpcykpKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gd3JhcChyZXMpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5SW5jbHVkZXModikge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcuaW5jbHVkZXModW53cmFwKHYpKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5SW5kZXhPZih2KSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGNvbnN0IHJlcyA9IHJhdy5pbmRleE9mKHVud3JhcCh2KSk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheUxhc3RJbmRleE9mKHYpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3Lmxhc3RJbmRleE9mKHVud3JhcCh2KSk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheUZpbmRJbmRleChjYiwgdGhpc0FyZykge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcuZmluZEluZGV4KCh2LCBpKSA9PiB1bndyYXAoY2IuY2FsbCh0aGlzQXJnLCB3cmFwKHYpLCBpLCB0aGlzKSkpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlGbGF0KCkge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gd3JhcChyYXcuZmxhdCgpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheUZsYXRNYXAoY2IsIHRoaXNBcmcpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIGdldFByb3h5KHJhdy5mbGF0TWFwKCh2LCBpKSA9PiB3cmFwKGNiLmNhbGwodGhpc0FyZywgd3JhcCh2KSwgaSwgdGhpcykpKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlKb2luKHNlcGFyYXRvcikge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gcmF3LmpvaW4oc2VwYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheVBvcCgpIHtcbiAgICByZXR1cm4gd3JhcChnZXRSYXcodGhpcykucG9wKCkpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5UHVzaCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGdldFJhdyh0aGlzKS5wdXNoKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5U2hpZnQoKSB7XG4gICAgcmV0dXJuIHdyYXAoZ2V0UmF3KHRoaXMpLnNoaWZ0KCkpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5VW5zaGlmdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGdldFJhdyh0aGlzKS51bnNoaWZ0KC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5U3BsaWNlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gd3JhcChnZXRSYXcodGhpcykuc3BsaWNlKC4uLmFyZ3MpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBcnJheVJldmVyc2UoLi4uYXJncykge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcucmV2ZXJzZSgpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiB3cmFwKHJlcyk7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlTb21lKGNiLCB0aGlzQXJnKSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGNvbnN0IHJlcyA9IHJhdy5zb21lKCh2LCBpKSA9PiB1bndyYXAoY2IuY2FsbCh0aGlzQXJnLCB3cmFwKHYpLCBpLCB0aGlzKSkpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwcGVkQXJyYXlTb3J0KGNiKSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGNvbnN0IHJlcyA9IHJhdy5zb3J0KGNiKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gd3JhcChyZXMpO1xufVxuZnVuY3Rpb24gd3JhcHBlZEFycmF5U2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gZ2V0UHJveHkocmF3LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRSZWR1Y2UoY2IsIGluaXRWYWx1ZSkge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjb25zdCByZXMgPSByYXcucmVkdWNlKChjdXJyLCB2LCBpKSA9PiBjYihjdXJyLCB3cmFwKHYpLCBpLCB0aGlzKSwgaW5pdFZhbHVlKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gd3JhcChyZXMpO1xufVxuZnVuY3Rpb24gd3JhcHBlZFJlZHVjZVJpZ2h0KGNiLCBpbml0VmFsdWUpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY29uc3QgcmVzID0gcmF3LnJlZHVjZVJpZ2h0KChjdXJyLCB2LCBpKSA9PiBjYihjdXJyLCB3cmFwKHYpLCBpLCB0aGlzKSwgaW5pdFZhbHVlKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICByZXR1cm4gd3JhcChyZXMpO1xufVxuLy8gdGhlIGJlbG93IGxvZ2ljIHRha2VzIGluc3BpcmF0aW9uIGZyb20gVnVlLCBNb2J4XG4vLyBtdWNoIHRoYW5rcyB0byB0aGVtIGZvciB3b3JraW5nIG91dCB0aGlzXG5jb25zdCBjb2xsZWN0aW9uSGFuZGxlciA9IHtcbiAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgIC8vIG1heWJlIHVzZSBzeW1ib2w/XG4gICAgICAgIGlmIChrZXkgPT09IHJhd0tleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGN1cnJlbnRDb25uZWN0YWJsZSgpO1xuICAgICAgICBpZiAoIWNvbm5lY3RpbmcgfHwgZG9Ob3RDb2xsZWN0KGtleSkgfHwgY29ubmVjdGFibGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFIkZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlLm9ic2VydmVQcm9wZXJ0eSh0YXJnZXQsICdzaXplJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5zaXplO1xuICAgICAgICAgICAgY2FzZSAnY2xlYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQ2xlYXI7XG4gICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRGVsZXRlO1xuICAgICAgICAgICAgY2FzZSAnZm9yRWFjaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRGb3JFYWNoO1xuICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkQWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRTZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGFzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEhhcztcbiAgICAgICAgICAgIGNhc2UgJ2tleXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkS2V5cztcbiAgICAgICAgICAgIGNhc2UgJ3ZhbHVlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRWYWx1ZXM7XG4gICAgICAgICAgICBjYXNlICdlbnRyaWVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVudHJpZXM7XG4gICAgICAgICAgICBjYXNlIFN5bWJvbC5pdGVyYXRvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgTWFwID8gd3JhcHBlZEVudHJpZXMgOiB3cmFwcGVkVmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwKFIkZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gd3JhcHBlZEZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHJhdy5mb3JFYWNoKCh2LCBrZXkpID0+IHtcbiAgICAgICAgY2IuY2FsbCgvKiBzaG91bGQgd3JhcCBvciBub3Q/PyAqLyB0aGlzQXJnLCB3cmFwKHYpLCB3cmFwKGtleSksIHRoaXMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gd3JhcHBlZEhhcyh2KSB7XG4gICAgY29uc3QgcmF3ID0gZ2V0UmF3KHRoaXMpO1xuICAgIGN1cnJlbnRDb25uZWN0YWJsZSgpPy5vYnNlcnZlQ29sbGVjdGlvbihyYXcpO1xuICAgIHJldHVybiByYXcuaGFzKHVud3JhcCh2KSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkR2V0KGspIHtcbiAgICBjb25zdCByYXcgPSBnZXRSYXcodGhpcyk7XG4gICAgY3VycmVudENvbm5lY3RhYmxlKCk/Lm9ic2VydmVDb2xsZWN0aW9uKHJhdyk7XG4gICAgcmV0dXJuIHdyYXAocmF3LmdldCh1bndyYXAoaykpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRTZXQoaywgdikge1xuICAgIHJldHVybiB3cmFwKGdldFJhdyh0aGlzKS5zZXQodW53cmFwKGspLCB1bndyYXAodikpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRBZGQodikge1xuICAgIHJldHVybiB3cmFwKGdldFJhdyh0aGlzKS5hZGQodW53cmFwKHYpKSk7XG59XG5mdW5jdGlvbiB3cmFwcGVkQ2xlYXIoKSB7XG4gICAgcmV0dXJuIHdyYXAoZ2V0UmF3KHRoaXMpLmNsZWFyKCkpO1xufVxuZnVuY3Rpb24gd3JhcHBlZERlbGV0ZShrKSB7XG4gICAgcmV0dXJuIHdyYXAoZ2V0UmF3KHRoaXMpLmRlbGV0ZSh1bndyYXAoaykpKTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRLZXlzKCkge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICBjb25zdCBpdGVyYXRvciA9IHJhdy5rZXlzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gbmV4dC5kb25lO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHZvaWQgMCwgZG9uZSB9XG4gICAgICAgICAgICAgICAgOiB7IHZhbHVlOiB3cmFwKHZhbHVlKSwgZG9uZSB9O1xuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwcGVkVmFsdWVzKCkge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICBjb25zdCBpdGVyYXRvciA9IHJhdy52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBuZXh0LmRvbmU7XG4gICAgICAgICAgICByZXR1cm4gZG9uZVxuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogdm9pZCAwLCBkb25lIH1cbiAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IHdyYXAodmFsdWUpLCBkb25lIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRFbnRyaWVzKCkge1xuICAgIGNvbnN0IHJhdyA9IGdldFJhdyh0aGlzKTtcbiAgICBjdXJyZW50Q29ubmVjdGFibGUoKT8ub2JzZXJ2ZUNvbGxlY3Rpb24ocmF3KTtcbiAgICBjb25zdCBpdGVyYXRvciA9IHJhdy5lbnRyaWVzKCk7XG4gICAgLy8gcmV0dXJuIGEgd3JhcHBlZCBpdGVyYXRvciB3aGljaCByZXR1cm5zIG9ic2VydmVkIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHZhbHVlcyBlbWl0dGVkIGZyb20gdGhlIHJlYWwgaXRlcmF0b3JcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBuZXh0LmRvbmU7XG4gICAgICAgICAgICByZXR1cm4gZG9uZVxuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogdm9pZCAwLCBkb25lIH1cbiAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldLCBkb25lIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBQcm94eU9ic2VydmFibGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBnZXRQcm94eSxcbiAgICBnZXRSYXcsXG4gICAgd3JhcCxcbiAgICB1bndyYXAsXG4gICAgcmF3S2V5LFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm94eS1vYnNlcnZhdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVJbmRleE1hcCB9IGZyb20gJy4uL29ic2VydmF0aW9uLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb25TaXplT2JzZXJ2ZXIgfSBmcm9tICcuL2NvbGxlY3Rpb24tbGVuZ3RoLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IHN1YnNjcmliZXJDb2xsZWN0aW9uIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgZGVmIH0gZnJvbSAnLi4vdXRpbGl0aWVzLW9iamVjdHMuanMnO1xuY29uc3Qgb2JzZXJ2ZXJMb29rdXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcHJvdG8gPSBTZXQucHJvdG90eXBlO1xuY29uc3QgJGFkZCA9IHByb3RvLmFkZDtcbmNvbnN0ICRjbGVhciA9IHByb3RvLmNsZWFyO1xuY29uc3QgJGRlbGV0ZSA9IHByb3RvLmRlbGV0ZTtcbmNvbnN0IG5hdGl2ZSA9IHsgYWRkOiAkYWRkLCBjbGVhcjogJGNsZWFyLCBkZWxldGU6ICRkZWxldGUgfTtcbmNvbnN0IG1ldGhvZHMgPSBbJ2FkZCcsICdjbGVhcicsICdkZWxldGUnXTtcbi8vIG5vdGU6IHdlIGNhbid0IHJlYWxseSBkbyBtdWNoIHdpdGggU2V0IGR1ZSB0byB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgbm90IGJlaW5nIGFjY2Vzc2libGUgc28gd2UncmUganVzdCB1c2luZyB0aGUgbmF0aXZlIGNhbGxzXG4vLyBmb3J0dW5hdGVseSwgYWRkL2RlbGV0ZS9jbGVhciBhcmUgZWFzeSB0byByZWNvbnN0cnVjdCBmb3IgdGhlIGluZGV4TWFwXG5jb25zdCBvYnNlcnZlID0ge1xuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXG4gICAgYWRkOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJGFkZC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgICRhZGQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmIChuZXdTaXplID09PSBvbGRTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvLmluZGV4TWFwW29sZFNpemVdID0gLTI7XG4gICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5jbGVhclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG8gPSBvYnNlcnZlckxvb2t1cC5nZXQodGhpcyk7XG4gICAgICAgIGlmIChvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkY2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4TWFwID0gby5pbmRleE1hcDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIC8vIGRlZXBzY2FuLWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBmb3IgKGNvbnN0IF8gb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhNYXBbaV0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcC5kZWxldGVkSXRlbXMucHVzaChpbmRleE1hcFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRjbGVhci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaW5kZXhNYXAubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIG8ubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZGVsZXRlXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbyA9IG9ic2VydmVyTG9va3VwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICRkZWxldGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gby5pbmRleE1hcDtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleE1hcFtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwLmRlbGV0ZWRJdGVtcy5wdXNoKGluZGV4TWFwW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhNYXAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3VsdCA9ICRkZWxldGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZVJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBvLm5vdGlmeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuY29uc3QgZGVzY3JpcHRvclByb3BzID0ge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBkZWYob2JzZXJ2ZVttZXRob2RdLCAnb2JzZXJ2aW5nJywgeyB2YWx1ZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbn1cbmxldCBlbmFibGVTZXRPYnNlcnZhdGlvbkNhbGxlZCA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVNldE9ic2VydmF0aW9uKCkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKHByb3RvW21ldGhvZF0ub2JzZXJ2aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWYocHJvdG8sIG1ldGhvZCwgeyAuLi5kZXNjcmlwdG9yUHJvcHMsIHZhbHVlOiBvYnNlcnZlW21ldGhvZF0gfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVNldE9ic2VydmF0aW9uKCkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKHByb3RvW21ldGhvZF0ub2JzZXJ2aW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWYocHJvdG8sIG1ldGhvZCwgeyAuLi5kZXNjcmlwdG9yUHJvcHMsIHZhbHVlOiBuYXRpdmVbbWV0aG9kXSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob2JzZXJ2ZWRTZXQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gMzQgLyogU2V0ICovO1xuICAgICAgICBpZiAoIWVuYWJsZVNldE9ic2VydmF0aW9uQ2FsbGVkKSB7XG4gICAgICAgICAgICBlbmFibGVTZXRPYnNlcnZhdGlvbkNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBlbmFibGVTZXRPYnNlcnZhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IG9ic2VydmVkU2V0O1xuICAgICAgICB0aGlzLmluZGV4TWFwID0gY3JlYXRlSW5kZXhNYXAob2JzZXJ2ZWRTZXQuc2l6ZSk7XG4gICAgICAgIHRoaXMubGVuT2JzID0gdm9pZCAwO1xuICAgICAgICBvYnNlcnZlckxvb2t1cC5zZXQob2JzZXJ2ZWRTZXQsIHRoaXMpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4TWFwID0gdGhpcy5pbmRleE1hcDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuY29sbGVjdGlvbi5zaXplO1xuICAgICAgICB0aGlzLmluZGV4TWFwID0gY3JlYXRlSW5kZXhNYXAoc2l6ZSk7XG4gICAgICAgIHRoaXMuc3Vicy5ub3RpZnlDb2xsZWN0aW9uKGluZGV4TWFwLCA4IC8qIHVwZGF0ZVRhcmdldCAqLyk7XG4gICAgfVxuICAgIGdldExlbmd0aE9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5PYnMgPz8gKHRoaXMubGVuT2JzID0gbmV3IENvbGxlY3Rpb25TaXplT2JzZXJ2ZXIodGhpcykpO1xuICAgIH1cbn1cbnN1YnNjcmliZXJDb2xsZWN0aW9uKFNldE9ic2VydmVyKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXRPYnNlcnZlcihvYnNlcnZlZFNldCkge1xuICAgIGxldCBvYnNlcnZlciA9IG9ic2VydmVyTG9va3VwLmdldChvYnNlcnZlZFNldCk7XG4gICAgaWYgKG9ic2VydmVyID09PSB2b2lkIDApIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgU2V0T2JzZXJ2ZXIob2JzZXJ2ZWRTZXQpO1xuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQtb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgc3Vic2NyaWJlckNvbGxlY3Rpb24gfSBmcm9tICcuL3N1YnNjcmliZXItY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBkZWYgfSBmcm9tICcuLi91dGlsaXRpZXMtb2JqZWN0cy5qcyc7XG4vKipcbiAqIE9ic2VydmVyIGZvciB0aGUgbXV0YXRpb24gb2Ygb2JqZWN0IHByb3BlcnR5IHZhbHVlIGVtcGxveWluZyBnZXR0ZXItc2V0dGVyIHN0cmF0ZWd5LlxuICogVGhpcyBpcyB1c2VkIGZvciBvYnNlcnZpbmcgb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBoYXMgbm8gZGVjb3JhdG9yLlxuICovXG5leHBvcnQgY2xhc3MgU2V0dGVyT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleTtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuaW5CYXRjaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmluZyA9IGZhbHNlO1xuICAgICAgICAvLyB0b2RvKGJpZ29wb24pOiB0d2VhayB0aGUgZmxhZyBiYXNlZCBvbiB0eXBlb2Ygb2JqIChhcnJheS9zZXQvbWFwL2l0ZXJhdG9yL3Byb3h5IGV0Yy4uLilcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBPYnNlcnZlciAqLztcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUobmV3VmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmluZykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeShuZXdWYWx1ZSwgY3VycmVudFZhbHVlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBzdWJzY3JpYmUoKSBoYXMgYmVlbiBjYWxsZWQsIHRoZSB0YXJnZXQgcHJvcGVydHkgZGVzY3JpcHRvciBpcyByZXBsYWNlZCBieSB0aGVzZSBnZXR0ZXIvc2V0dGVyIG1ldGhvZHMsXG4gICAgICAgICAgICAvLyBzbyBjYWxsaW5nIG9ialtwcm9wZXJ0eUtleV0gd2lsbCBhY3R1YWxseSByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWUuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBpZiBzdWJzY3JpYmUoKSB3YXMgbm90IHlldCBjYWxsZWQgKGluZGljYXRlZCBieSAhdGhpcy5vYnNlcnZpbmcpLCB0aGUgdGFyZ2V0IGRlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGlzIHVubW9kaWZpZWQgYW5kIHdlIG5lZWQgdG8gZXhwbGljaXRseSBzZXQgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGhhcHBlbiBpbiBvbmUtdGltZSwgdG8tdmlldyBhbmQgdHdvLXdheSBiaW5kaW5ncyBkdXJpbmcgJGJpbmQsIG1lYW5pbmcgdGhhdCB0aGUgJGJpbmQgd2lsbCBub3QgYWN0dWFsbHkgdXBkYXRlIHRoZSB0YXJnZXQgdmFsdWUuXG4gICAgICAgICAgICAvLyBUaGlzIHdhc24ndCB2aXNpYmxlIGluIHZDdXJyZW50IGR1ZSB0byBjb25uZWN0LXF1ZXVlIGFsd2F5cyBkb2luZyBhIGRlbGF5ZWQgdXBkYXRlLCBzbyBpbiBtYW55IGNhc2VzIGl0IGRpZG4ndCBtYXR0ZXIgd2hldGhlciAkYmluZCB1cGRhdGVkIHRoZSB0YXJnZXQgb3Igbm90LlxuICAgICAgICAgICAgdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzLmFkZChzdWJzY3JpYmVyKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wZXJ0eUtleV07XG4gICAgICAgICAgICBkZWYodGhpcy5vYmosIHRoaXMucHJvcGVydHlLZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICggLyogU2V0dGVyIE9ic2VydmVyICovKSA9PiB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgc2V0OiAoLyogU2V0dGVyIE9ic2VydmVyICovIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUsIDAgLyogbm9uZSAqLyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZpbmcpIHtcbiAgICAgICAgICAgIGRlZih0aGlzLm9iaiwgdGhpcy5wcm9wZXJ0eUtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHRvZG8oYmlnb3Bvbi9mcmVkKTogYWRkIC5yZW1vdmVBbGxTdWJzY3JpYmVycygpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNldHRlck5vdGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcihvYmosIGNhbGxiYWNrS2V5LCBzZXQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAxIC8qIE9ic2VydmVyICovO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnYgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnMgPSBzZXQ7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gb2JqW2NhbGxiYWNrS2V5XTtcbiAgICAgICAgdGhpcy5jYiA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogdm9pZCAwO1xuICAgICAgICB0aGlzLnYgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5zKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudjtcbiAgICAgICAgaWYgKCFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNiPy5jYWxsKHRoaXMub2JqLCB2YWx1ZSwgb2xkVmFsdWUsIGZsYWdzKTtcbiAgICAgICAgICAgIC8vIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBjYi5jYWxsKC4uLilcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgdGhlIGxhdGVzdCB2YWx1ZSBvZiB0aGlzIG9ic2VydmVyXG4gICAgICAgICAgICAvLyBhbmQgdGh1cyBtYWtpbmcgYHZhbHVlYCBzdGFsZVxuICAgICAgICAgICAgLy8gc28gZm9yIG5vdywgY2FsbCB3aXRoIHRoaXMudlxuICAgICAgICAgICAgLy8gdG9kbzogc2hvdWxkIG9sZFZhbHVlIGJlIHRyZWF0ZWQgdGhlIHNhbWUgd2F5P1xuICAgICAgICAgICAgdGhpcy5zdWJzLm5vdGlmeSh0aGlzLnYsIG9sZFZhbHVlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihTZXR0ZXJPYnNlcnZlcik7XG5zdWJzY3JpYmVyQ29sbGVjdGlvbihTZXR0ZXJOb3RpZmllcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0ZXItb2JzZXJ2ZXIuanMubWFwIiwiaW1wb3J0IHsgREkgfSBmcm9tICdAYXVyZWxpYS9rZXJuZWwnO1xuZXhwb3J0IGNvbnN0IElTaWduYWxlciA9IERJLmNyZWF0ZUludGVyZmFjZSgnSVNpZ25hbGVyJywgeCA9PiB4LnNpbmdsZXRvbihTaWduYWxlcikpO1xuZXhwb3J0IGNsYXNzIFNpZ25hbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaWduYWxzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgZGlzcGF0Y2hTaWduYWwobmFtZSwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5zaWduYWxzW25hbWVdO1xuICAgICAgICBpZiAobGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZUNoYW5nZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmxhZ3MgfCA4IC8qIHVwZGF0ZVRhcmdldCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkU2lnbmFsTGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFscyA9IHRoaXMuc2lnbmFscztcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gc2lnbmFsc1tuYW1lXTtcbiAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaWduYWxzW25hbWVdID0gbmV3IFNldChbbGlzdGVuZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVNpZ25hbExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuc2lnbmFsc1tuYW1lXTtcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYWxlci5qcy5tYXAiLCJpbXBvcnQgeyBkZWYsIGRlZmluZUhpZGRlblByb3AsIGVuc3VyZVByb3RvIH0gZnJvbSAnLi4vdXRpbGl0aWVzLW9iamVjdHMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZXJDb2xsZWN0aW9uKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgPT0gbnVsbCA/IHN1YnNjcmliZXJDb2xsZWN0aW9uRGVjbyA6IHN1YnNjcmliZXJDb2xsZWN0aW9uRGVjbyh0YXJnZXQpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlckNvbGxlY3Rpb25EZWNvKHRhcmdldCkge1xuICAgIGNvbnN0IHByb3RvID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAvLyBub3QgY29uZmlndXJhYmxlLCBhcyBpbiBkZXZ0b29sLCB0aGUgZ2V0dGVyIGNvdWxkIGJlIGludm9rZWQgb24gdGhlIHByb3RvdHlwZSxcbiAgICAvLyBhbmQgYmVjb21lIHBlcm1hbmVudGx5IGJyb2tlblxuICAgIGRlZihwcm90bywgJ3N1YnMnLCB7IGdldDogZ2V0U3Vic2NyaWJlclJlY29yZCB9KTtcbiAgICBlbnN1cmVQcm90byhwcm90bywgJ3N1YnNjcmliZScsIGFkZFN1YnNjcmliZXIpO1xuICAgIGVuc3VyZVByb3RvKHByb3RvLCAndW5zdWJzY3JpYmUnLCByZW1vdmVTdWJzY3JpYmVyKTtcbn1cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlcyAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmliZXJSZWNvcmQge1xuICAgIGNvbnN0cnVjdG9yKG93bmVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdWJzY3JpYmVyIGZsYWdzOiBiaXRzIGluZGljYXRpbmcgdGhlIGV4aXN0ZW5jZSBzdGF0dXMgb2YgdGhlIHN1YnNjcmliZXJzIG9mIHRoaXMgcmVjb3JkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZiA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICB9XG4gICAgYWRkKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlckZsYWdzID0gdGhpcy5fc2Y7XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgMSAvKiBTdWJzY3JpYmVyMCAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3MwID0gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NmIHw9IDEgLyogU3Vic2NyaWJlcjAgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDIgLyogU3Vic2NyaWJlcjEgKi8pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zMSA9IHN1YnNjcmliZXI7XG4gICAgICAgICAgICB0aGlzLl9zZiB8PSAyIC8qIFN1YnNjcmliZXIxICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiA0IC8qIFN1YnNjcmliZXIyICovKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fczIgPSBzdWJzY3JpYmVyO1xuICAgICAgICAgICAgdGhpcy5fc2YgfD0gNCAvKiBTdWJzY3JpYmVyMiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoc3Vic2NyaWJlckZsYWdzICYgOCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi8pID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zciA9IFtzdWJzY3JpYmVyXTtcbiAgICAgICAgICAgIHRoaXMuX3NmIHw9IDggLyogU3Vic2NyaWJlcnNSZXN0ICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3IucHVzaChzdWJzY3JpYmVyKTsgLy8gTm9uLW51bGwgaXMgaW1wbGllZCBieSBlbHNlIGJyYW5jaCBvZiAoc3Vic2NyaWJlckZsYWdzICYgU0YuU3Vic2NyaWJlcnNSZXN0KSA9PT0gMFxuICAgICAgICB9XG4gICAgICAgICsrdGhpcy5jb3VudDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhcyhzdWJzY3JpYmVyKSB7XG4gICAgICAgIC8vIEZsYWdzIGhlcmUgaXMganVzdCBhIHBlcmYgdHdlYWtcbiAgICAgICAgLy8gQ29tcGFyZWQgdG8gbm90IHVzaW5nIGZsYWdzLCBpdCdzIGEgbW9kZXJhdGUgc3BlZWQtdXAgd2hlbiB0aGlzIGNvbGxlY3Rpb24gZG9lcyBub3QgaGF2ZSB0aGUgc3Vic2NyaWJlcjtcbiAgICAgICAgLy8gYW5kIG1pbm9yIHNsb3ctZG93biB3aGVuIGl0IGRvZXMsIGFuZCB0aGUgZm9ybWVyIGlzIG1vcmUgY29tbW9uIHRoYW4gdGhlIGxhdHRlci5cbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlckZsYWdzID0gdGhpcy5fc2Y7XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgMSAvKiBTdWJzY3JpYmVyMCAqLykgPiAwICYmIHRoaXMuX3MwID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDIgLyogU3Vic2NyaWJlcjEgKi8pID4gMCAmJiB0aGlzLl9zMSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiA0IC8qIFN1YnNjcmliZXIyICovKSA+IDAgJiYgdGhpcy5fczIgPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3Vic2NyaWJlckZsYWdzICYgOCAvKiBTdWJzY3JpYmVyc1Jlc3QgKi8pID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLl9zcjsgLy8gTm9uLW51bGwgaXMgaW1wbGllZCBieSAoc3Vic2NyaWJlckZsYWdzICYgU0YuU3Vic2NyaWJlcnNSZXN0KSA+IDBcbiAgICAgICAgICAgIGNvbnN0IGlpID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzW2ldID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NmICE9PSAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHJlbW92ZShzdWJzY3JpYmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJGbGFncyA9IHRoaXMuX3NmO1xuICAgICAgICBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDEgLyogU3Vic2NyaWJlcjAgKi8pID4gMCAmJiB0aGlzLl9zMCA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdGhpcy5fczAgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9zZiA9ICh0aGlzLl9zZiB8IDEgLyogU3Vic2NyaWJlcjAgKi8pIF4gMSAvKiBTdWJzY3JpYmVyMCAqLztcbiAgICAgICAgICAgIC0tdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzdWJzY3JpYmVyRmxhZ3MgJiAyIC8qIFN1YnNjcmliZXIxICovKSA+IDAgJiYgdGhpcy5fczEgPT09IHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3MxID0gdm9pZCAwO1xuICAgICAgICAgICAgdGhpcy5fc2YgPSAodGhpcy5fc2YgfCAyIC8qIFN1YnNjcmliZXIxICovKSBeIDIgLyogU3Vic2NyaWJlcjEgKi87XG4gICAgICAgICAgICAtLXRoaXMuY291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoc3Vic2NyaWJlckZsYWdzICYgNCAvKiBTdWJzY3JpYmVyMiAqLykgPiAwICYmIHRoaXMuX3MyID09PSBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zMiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRoaXMuX3NmID0gKHRoaXMuX3NmIHwgNCAvKiBTdWJzY3JpYmVyMiAqLykgXiA0IC8qIFN1YnNjcmliZXIyICovO1xuICAgICAgICAgICAgLS10aGlzLmNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHN1YnNjcmliZXJGbGFncyAmIDggLyogU3Vic2NyaWJlcnNSZXN0ICovKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5fc3I7IC8vIE5vbi1udWxsIGlzIGltcGxpZWQgYnkgKHN1YnNjcmliZXJGbGFncyAmIFNGLlN1YnNjcmliZXJzUmVzdCkgPiAwXG4gICAgICAgICAgICBjb25zdCBpaSA9IHN1YnNjcmliZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyc1tpXSA9PT0gc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2YgPSAodGhpcy5fc2YgfCA4IC8qIFN1YnNjcmliZXJzUmVzdCAqLykgXiA4IC8qIFN1YnNjcmliZXJzUmVzdCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAtLXRoaXMuY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG5vdGlmeSh2YWwsIG9sZFZhbCwgZmxhZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGU6IGNoYW5nZSBoYW5kbGVycyBtYXkgaGF2ZSB0aGUgc2lkZS1lZmZlY3Qgb2YgYWRkaW5nL3JlbW92aW5nIHN1YnNjcmliZXJzIHRvIHRoaXMgY29sbGVjdGlvbiBkdXJpbmcgdGhpc1xuICAgICAgICAgKiBjYWxsU3Vic2NyaWJlcnMgaW52b2NhdGlvbiwgc28gd2UncmUgY2FjaGluZyB0aGVtIGFsbCBiZWZvcmUgaW52b2tpbmcgYW55LlxuICAgICAgICAgKiBTdWJzY3JpYmVycyBhZGRlZCBkdXJpbmcgdGhpcyBpbnZvY2F0aW9uIGFyZSBub3QgaW52b2tlZCAoYW5kIHRoZXkgc2hvdWxkbid0IGJlKS5cbiAgICAgICAgICogU3Vic2NyaWJlcnMgcmVtb3ZlZCBkdXJpbmcgdGhpcyBpbnZvY2F0aW9uIHdpbGwgc3RpbGwgYmUgaW52b2tlZCAoYW5kIHRoZXkgYWxzbyBzaG91bGRuJ3QgYmUsXG4gICAgICAgICAqIGhvd2V2ZXIgdGhpcyBpcyBhY2NvdW50ZWQgZm9yIHZpYSAkaXNCb3VuZCBhbmQgc2ltaWxhciBmbGFncyBvbiB0aGUgc3Vic2NyaWJlciBvYmplY3RzKVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgb3duZXIgPSB0aGlzLm93bmVyO1xuICAgICAgICBjb25zdCBzdWIwID0gdGhpcy5fczA7XG4gICAgICAgIGNvbnN0IHN1YjEgPSB0aGlzLl9zMTtcbiAgICAgICAgY29uc3Qgc3ViMiA9IHRoaXMuX3MyO1xuICAgICAgICBsZXQgc3VicyA9IHRoaXMuX3NyO1xuICAgICAgICBpZiAoc3VicyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdWJzID0gc3Vicy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZsYWdzID0gKGZsYWdzIHwgMjQgLyogdXBkYXRlICovKSBeIDI0IC8qIHVwZGF0ZSAqLztcbiAgICAgICAgaWYgKHN1YjAgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3ViMC5oYW5kbGVDaGFuZ2UodmFsLCBvbGRWYWwsIGZsYWdzIHwgLyogc3ViIG93biBmbGFncyAqLyAoc3ViMC5pZCA9PT0gdm9pZCAwID8gMCA6IG93bmVyW3N1YjAuaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YjEgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3ViMS5oYW5kbGVDaGFuZ2UodmFsLCBvbGRWYWwsIGZsYWdzIHwgLyogc3ViIG93biBmbGFncyAqLyAoc3ViMS5pZCA9PT0gdm9pZCAwID8gMCA6IG93bmVyW3N1YjEuaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YjIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3ViMi5oYW5kbGVDaGFuZ2UodmFsLCBvbGRWYWwsIGZsYWdzIHwgLyogc3ViIG93biBmbGFncyAqLyAoc3ViMi5pZCA9PT0gdm9pZCAwID8gMCA6IG93bmVyW3N1YjIuaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgaWkgPSBzdWJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdWI7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSBzdWJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdWIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuaGFuZGxlQ2hhbmdlKHZhbCwgb2xkVmFsLCBmbGFncyB8IC8qIHN1YiBvd24gZmxhZ3MgKi8gKHN1Yi5pZCA9PT0gdm9pZCAwID8gMCA6IG93bmVyW3N1Yi5pZF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5Q29sbGVjdGlvbihpbmRleE1hcCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3Qgc3ViMCA9IHRoaXMuX3MwO1xuICAgICAgICBjb25zdCBzdWIxID0gdGhpcy5fczE7XG4gICAgICAgIGNvbnN0IHN1YjIgPSB0aGlzLl9zMjtcbiAgICAgICAgbGV0IHN1YnMgPSB0aGlzLl9zcjtcbiAgICAgICAgaWYgKHN1YnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3VicyA9IHN1YnMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViMCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdWIwLmhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoaW5kZXhNYXAsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViMSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdWIxLmhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoaW5kZXhNYXAsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViMiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdWIyLmhhbmRsZUNvbGxlY3Rpb25DaGFuZ2UoaW5kZXhNYXAsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VicyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCBpaSA9IHN1YnMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHN1YjtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIHN1YiA9IHN1YnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN1YiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5oYW5kbGVDb2xsZWN0aW9uQ2hhbmdlKGluZGV4TWFwLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3Vic2NyaWJlclJlY29yZCgpIHtcbiAgICBjb25zdCByZWNvcmQgPSBuZXcgU3Vic2NyaWJlclJlY29yZCh0aGlzKTtcbiAgICBkZWZpbmVIaWRkZW5Qcm9wKHRoaXMsICdzdWJzJywgcmVjb3JkKTtcbiAgICByZXR1cm4gcmVjb3JkO1xufVxuZnVuY3Rpb24gYWRkU3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vicy5hZGQoc3Vic2NyaWJlcik7XG59XG5mdW5jdGlvbiByZW1vdmVTdWJzY3JpYmVyKHN1YnNjcmliZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzLnJlbW92ZShzdWJzY3JpYmVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZXItY29sbGVjdGlvbi5qcy5tYXAiLCJleHBvcnQgY29uc3QgZGVmID0gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVIaWRkZW5Qcm9wKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGRlZihvYmosIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWVcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVQcm90byhwcm90bywga2V5LCBkZWZhdWx0VmFsdWUsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywga2V5KSkge1xuICAgICAgICBkZWZpbmVIaWRkZW5Qcm9wKHByb3RvLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbGl0aWVzLW9iamVjdHMuanMubWFwIiwiaW1wb3J0IHsgUmVnaXN0cmF0aW9uLCBNZXRhZGF0YSwgUHJvdG9jb2wsIG1lcmdlQXJyYXlzLCBmaXJzdERlZmluZWQsIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IHJlZ2lzdGVyQWxpYXNlcyB9IGZyb20gJy4vYWxpYXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlQ29udmVydGVyKG5hbWVPckRlZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBWYWx1ZUNvbnZlcnRlci5kZWZpbmUobmFtZU9yRGVmLCB0YXJnZXQpO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgVmFsdWVDb252ZXJ0ZXJEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihUeXBlLCBuYW1lLCBhbGlhc2VzLCBrZXkpIHtcbiAgICAgICAgdGhpcy5UeXBlID0gVHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gYWxpYXNlcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUobmFtZU9yRGVmLCBUeXBlKSB7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBsZXQgZGVmO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVPckRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JEZWY7XG4gICAgICAgICAgICBkZWYgPSB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JEZWYubmFtZTtcbiAgICAgICAgICAgIGRlZiA9IG5hbWVPckRlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlQ29udmVydGVyRGVmaW5pdGlvbihUeXBlLCBmaXJzdERlZmluZWQoVmFsdWVDb252ZXJ0ZXIuZ2V0QW5ub3RhdGlvbihUeXBlLCAnbmFtZScpLCBuYW1lKSwgbWVyZ2VBcnJheXMoVmFsdWVDb252ZXJ0ZXIuZ2V0QW5ub3RhdGlvbihUeXBlLCAnYWxpYXNlcycpLCBkZWYuYWxpYXNlcywgVHlwZS5hbGlhc2VzKSwgVmFsdWVDb252ZXJ0ZXIua2V5RnJvbShuYW1lKSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCB7IFR5cGUsIGtleSwgYWxpYXNlcyB9ID0gdGhpcztcbiAgICAgICAgUmVnaXN0cmF0aW9uLnNpbmdsZXRvbihrZXksIFR5cGUpLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG4gICAgICAgIFJlZ2lzdHJhdGlvbi5hbGlhc1RvKGtleSwgVHlwZSkucmVnaXN0ZXIoY29udGFpbmVyKTtcbiAgICAgICAgcmVnaXN0ZXJBbGlhc2VzKGFsaWFzZXMsIFZhbHVlQ29udmVydGVyLCBrZXksIGNvbnRhaW5lcik7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IFZhbHVlQ29udmVydGVyID0ge1xuICAgIG5hbWU6IFByb3RvY29sLnJlc291cmNlLmtleUZvcigndmFsdWUtY29udmVydGVyJyksXG4gICAga2V5RnJvbShuYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHtWYWx1ZUNvbnZlcnRlci5uYW1lfToke25hbWV9YDtcbiAgICB9LFxuICAgIGlzVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIE1ldGFkYXRhLmhhc093bihWYWx1ZUNvbnZlcnRlci5uYW1lLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBkZWZpbmUobmFtZU9yRGVmLCBUeXBlKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBWYWx1ZUNvbnZlcnRlckRlZmluaXRpb24uY3JlYXRlKG5hbWVPckRlZiwgVHlwZSk7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShWYWx1ZUNvbnZlcnRlci5uYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uLlR5cGUpO1xuICAgICAgICBNZXRhZGF0YS5kZWZpbmUoVmFsdWVDb252ZXJ0ZXIubmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbik7XG4gICAgICAgIFByb3RvY29sLnJlc291cmNlLmFwcGVuZFRvKFR5cGUsIFZhbHVlQ29udmVydGVyLm5hbWUpO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi5UeXBlO1xuICAgIH0sXG4gICAgZ2V0RGVmaW5pdGlvbihUeXBlKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IE1ldGFkYXRhLmdldE93bihWYWx1ZUNvbnZlcnRlci5uYW1lLCBUeXBlKTtcbiAgICAgICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlZmluaXRpb24gZm91bmQgZm9yIHR5cGUgJHtUeXBlLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9LFxuICAgIGFubm90YXRlKFR5cGUsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIE1ldGFkYXRhLmRlZmluZShQcm90b2NvbC5hbm5vdGF0aW9uLmtleUZvcihwcm9wKSwgdmFsdWUsIFR5cGUpO1xuICAgIH0sXG4gICAgZ2V0QW5ub3RhdGlvbihUeXBlLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBNZXRhZGF0YS5nZXRPd24oUHJvdG9jb2wuYW5ub3RhdGlvbi5rZXlGb3IocHJvcCksIFR5cGUpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsdWUtY29udmVydGVyLmpzLm1hcCIsIjx0ZW1wbGF0ZT5cbiAgPHJlcXVpcmUgZnJvbT1cIi4vcmVzZXQuY3NzXCI+PC9yZXF1aXJlPlxuICA8cmVxdWlyZSBmcm9tPVwiLi9hcHAuY3NzXCI+PC9yZXF1aXJlPlxuXG4gIDxkaXYgaWQ9XCJhdS1kZXYtcm9vdFwiIGNsYXNzPVwiJHtpc0RhcmtUaGVtZSA/ICdkYXJrJyA6ICcnfVwiPlxuICAgIDxoMSBjbGFzcz1cImFwcC1oZWFkZXJcIj5cbiAgICAgIDxhdXJlbGlhLWxvZ28+PC9hdXJlbGlhLWxvZ28+XG4gICAgICA8c3BhbiBjbGFzcz1cImxvZ28tYmFkZ2VcIj5JTlNQRUNUT1I8L3NwYW4+XG4gICAgPC9oMT5cblxuICAgIDxtYWluPlxuICAgICAgPHAgY2xhc3M9XCJub3QtZm91bmRcIiBzdHlsZT1cIm1hcmdpbi1ib3R0b206IDEwcHhcIj5cbiAgICAgICAgU2VsZWN0IGEgbm9kZSB0aHJvdWdoIHRoZSBpbnNwZWN0IHdpbmRvdyB0byBzY29wZSBpbnRvIHRoYXQgbm9kZS4gQ2xpY2tcbiAgICAgICAgb24gdGhlIHZhbHVlIHdpbGwgYWxsb3cgb25lIHRvIGVkaXQgdGhlIHZhbHVlIGFuZCBiaW5kIHRvIHRoZSB2aWV3LlxuICAgICAgPC9wPlxuICAgICAgPCEtLSA8ZGVidWctZ3JvdXAgaGVhZGluZz1cIkJpbmRpbmcgQ29udGV4dFwiIHNob3cuYmluZD1cInRydWVcIj5cbiAgICAgICAgPHRlbXBsYXRlIGlmLmJpbmQ9XCJkZWJ1Z0luZm8uYmluZGluZ0NvbnRleHRcIj5cbiAgICAgICAgICA8dWw+XG4gICAgICAgICAgICA8bGkgcmVwZWF0LmZvcj1cInByb3BlcnR5IG9mIGRlYnVnSW5mby5iaW5kaW5nQ29udGV4dC5wcm9wZXJ0aWVzXCI+XG4gICAgICAgICAgICAgIDxwcm9wZXJ0eS12aWV3IHByb3BlcnR5LmJpbmQ9XCJwcm9wZXJ0eVwiPjwvcHJvcGVydHktdmlldz5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgICAgPHRlbXBsYXRlIGlmLmJpbmQ9XCIhZGVidWdJbmZvLmJpbmRpbmdDb250ZXh0XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJub3QtZm91bmRcIlxuICAgICAgICAgICAgPk5vIGJpbmRpbmcgY29udGV4dCBmb3VuZCBmb3IgdGhlIHNlbGVjdGVkIG5vZGUuPC9zcGFuXG4gICAgICAgICAgPlxuICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgPC9kZWJ1Zy1ncm91cD5cblxuICAgICAgPGRlYnVnLWdyb3VwIGhlYWRpbmc9XCJPdmVycmlkZSBDb250ZXh0XCI+XG4gICAgICAgIDx0ZW1wbGF0ZVxuICAgICAgICAgIGlmLmJpbmQ9XCJkZWJ1Z0luZm8ub3ZlcnJpZGVDb250ZXh0ICYmIGRlYnVnSW5mby5vdmVycmlkZUNvbnRleHQucHJvcGVydGllcy5sZW5ndGhcIlxuICAgICAgICA+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgPGxpIHJlcGVhdC5mb3I9XCJwcm9wZXJ0eSBvZiBkZWJ1Z0luZm8ub3ZlcnJpZGVDb250ZXh0LnByb3BlcnRpZXNcIj5cbiAgICAgICAgICAgICAgPHByb3BlcnR5LXZpZXcgcHJvcGVydHkuYmluZD1cInByb3BlcnR5XCI+PC9wcm9wZXJ0eS12aWV3PlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICA8dGVtcGxhdGVcbiAgICAgICAgICBpZi5iaW5kPVwiIWRlYnVnSW5mby5vdmVycmlkZUNvbnRleHQgfHwgIWRlYnVnSW5mby5vdmVycmlkZUNvbnRleHQucHJvcGVydGllcy5sZW5ndGhcIlxuICAgICAgICA+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJub3QtZm91bmRcIlxuICAgICAgICAgICAgPk5vIG92ZXJyaWRlIGNvbnRleHQgZm91bmQgZm9yIHRoZSBzZWxlY3RlZCBub2RlLjwvc3BhblxuICAgICAgICAgID5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgIDwvZGVidWctZ3JvdXA+IC0tPlxuXG4gICAgICA8ZGVidWctZ3JvdXAgaGVhZGluZz1cIkN1c3RvbSBFbGVtZW50XCI+XG4gICAgICAgIDx0ZW1wbGF0ZSBhdS1zbG90PlxuICAgICAgICAgIDxzcGFuIGlmLmJpbmQ9XCIhc2VsZWN0ZWRFbGVtZW50XCIgY2xhc3M9XCJub3QtZm91bmRcIlxuICAgICAgICAgICAgPlRoZSBzZWxlY3RlZCBub2RlIGlzIG5vdCBhIGN1c3RvbSBlbGVtZW50Ljwvc3BhblxuICAgICAgICAgID5cbiAgICAgICAgICA8Y29udHJvbGxlci12aWV3XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250cm9sbGVyLmJpbmQ9XCJzZWxlY3RlZEVsZW1lbnRcIlxuICAgICAgICAgID48L2NvbnRyb2xsZXItdmlldz5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICAgIDwvZGVidWctZ3JvdXA+XG5cbiAgICAgIDxkZWJ1Zy1ncm91cCBoZWFkaW5nPVwiQ3VzdG9tIEF0dHJpYnV0ZXNcIj5cbiAgICAgICAgPHRlbXBsYXRlIGF1LXNsb3Q+XG4gICAgICAgICAgPHNwYW4gaWYuYmluZD1cIiFzZWxlY3RlZEVsZW1lbnRBdHRyaWJ1dGVzXCIgY2xhc3M9XCJub3QtZm91bmRcIlxuICAgICAgICAgICAgPk5vIGN1c3RvbSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBzZWxlY3RlZCBub2RlLjwvc3BhblxuICAgICAgICAgID5cbiAgICAgICAgICA8dWwgZWxzZT5cbiAgICAgICAgICAgIDxsaVxuICAgICAgICAgICAgICByZXBlYXQuZm9yPVwiY3VzdG9tQXR0cmlidXRlIG9mIHNlbGVjdGVkRWxlbWVudEF0dHJpYnV0ZXNcIlxuICAgICAgICAgICAgICBjbGFzcz1cImN1c3RvbS1hdHRyaWJ1dGVcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8aDMgY2xhc3M9XCJhdHRyaWJ1dGUtbmFtZVwiPiR7Y3VzdG9tQXR0cmlidXRlLm5hbWV9PC9oMz5cbiAgICAgICAgICAgICAgJm5ic3A7PHNwYW4gY2xhc3M9XCJibG9jay10b2tlblwiPns8L3NwYW4+XG4gICAgICAgICAgICAgIDxjb250cm9sbGVyLXZpZXdcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmJpbmQ9XCJjdXN0b21BdHRyaWJ1dGVcIlxuICAgICAgICAgICAgICA+PC9jb250cm9sbGVyLXZpZXc+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYmxvY2stdG9rZW5cIj59PC9zcGFuPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgPC9kZWJ1Zy1ncm91cD5cbiAgICA8L21haW4+XG5cbiAgICA8IS0tIDxtYWluPlxuICAgICAgPGN1c3RvbS1lbGVtZW50IGlmLmJpbmQ9XCJzZWxlY3RlZEVsZW1lbnRcIj5cbiAgICAgICAgJHtKU09OLnN0cmluZ2lmeShzZWxlY3RlZEVsZW1lbnQpfVxuICAgICAgICA8ZGl2Pk5hbWUgPSAke3NlbGVjdGVkRWxlbWVudC5uYW1lfTwvZGl2PlxuICAgICAgICA8ZGl2PktleSA9ICR7c2VsZWN0ZWRFbGVtZW50LmtleX08L2Rpdj5cbiAgICAgICAgPGRpdj5BbGlhc2VzID0gJHtzZWxlY3RlZEVsZW1lbnQuYWxpYXNlcy5qb2luKCcsICcpfTwvZGl2PlxuICAgICAgICA8aDM+QmluZGFibGVzPC9oMz5cbiAgICAgICAgPGRpdiByZXBlYXQuZm9yPVwidmFsdWUgb2Ygc2VsZWN0ZWRFbGVtZW50LmJpbmRhYmxlc1wiPlxuICAgICAgICAgICR7dmFsdWUubmFtZX0gPVxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdmFsdWUuYmluZD1cInZhbHVlLnZhbHVlXCJcbiAgICAgICAgICAgIGtleXVwLmRlbGVnYXRlPVwidmFsdWVDaGFuZ2VkKHNlbGVjdGVkRWxlbWVudClcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aHIgLz5cbiAgICAgIDwvY3VzdG9tLWVsZW1lbnQ+XG4gICAgPC9tYWluPiAtLT5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuIiwiPHRlbXBsYXRlPlxuICA8c3ZnIGhlaWdodD1cIjI4cHhcIiB2aWV3Qm94PVwiMzE1IDE5IDE0MCA0MVwiIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+XG4gICAgPGRlZnM+XG4gICAgICA8bGluZWFyR3JhZGllbnQgeDE9XCItMzg4LjE0Nzg1MSVcIiB5MT1cIi0xNDQuMTc3NDI1JVwiIHgyPVwiMjM3LjY4MzgwOSVcIiB5Mj1cIjQzMC40MDU3NTQlXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC0xXCI+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjQzA2RkJCXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNkU0RDlCXCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD5cbiAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8bGluZWFyR3JhZGllbnQgeDE9XCI3Mi45NDU0ODU0JVwiIHkxPVwiODQuNDI0MDc3NyVcIiB4Mj1cIi05Ny4wNTE3OTA0JVwiIHkyPVwiLTE0Ny42OTY1OTElXCIgaWQ9XCJsaW5lYXJHcmFkaWVudC0yXCI+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNkU0RDlCXCIgb2Zmc2V0PVwiMCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjNzczMjdBXCIgb2Zmc2V0PVwiMTQlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0IzMTc3N1wiIG9mZnNldD1cIjI5JVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNDRDBGN0VcIiBvZmZzZXQ9XCI4NCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjRUQyQzg5XCIgb2Zmc2V0PVwiMTAwJVwiPjwvc3RvcD5cbiAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICA8bGluZWFyR3JhZGllbnQgeDE9XCItMjgzLjg4NDA3OSVcIiB5MT1cIi02OTMuNTk5ODcyJVwiIHgyPVwiMjg3LjUzNzQxNyVcIiB5Mj1cIjEwMS43MDk3NiVcIiBpZD1cImxpbmVhckdyYWRpZW50LTNcIj5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNDMDZGQkJcIiBvZmZzZXQ9XCIwJVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM2RTREOUJcIiBvZmZzZXQ9XCIxMDAlXCI+PC9zdG9wPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCB4MT1cIi04MjEuMTg2MjE0JVwiIHkxPVwiLTQ2OS4wNDc4NjIlXCIgeDI9XCIxMDEuOTg1MTQyJVwiIHkyPVwiMjg4LjIzNTk4JVwiIGlkPVwibGluZWFyR3JhZGllbnQtNFwiPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0MwNkZCQlwiIG9mZnNldD1cIjAlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiIzZFNEQ5QlwiIG9mZnNldD1cIjEwMCVcIj48L3N0b3A+XG4gICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgPGxpbmVhckdyYWRpZW50IHgxPVwiLTE0MC4zNTkzNzMlXCIgeTE9XCItMjMwLjkyNTcxOCVcIiB4Mj1cIjQxOS4wMTIzMTYlXCIgeTI9XCIyNjEuOTc2NzQyJVwiIGlkPVwibGluZWFyR3JhZGllbnQtNVwiPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0MwNkZCQlwiIG9mZnNldD1cIjAlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiIzZFNEQ5QlwiIG9mZnNldD1cIjEwMCVcIj48L3N0b3A+XG4gICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgPGxpbmVhckdyYWRpZW50IHgxPVwiMTkxLjA4MzcxNiVcIiB5MT1cIjI1My45NTI1MTclXCIgeDI9XCIyMC4zNTc3MDIyJVwiIHkyPVwiMjAuNDAyOTI4MyVcIiBpZD1cImxpbmVhckdyYWRpZW50LTZcIj5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM2RTREOUJcIiBvZmZzZXQ9XCIwJVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM3NzMyN0FcIiBvZmZzZXQ9XCIxNCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjQjMxNzc3XCIgb2Zmc2V0PVwiMjklXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0NEMEY3RVwiIG9mZnNldD1cIjg0JVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNFRDJDODlcIiBvZmZzZXQ9XCIxMDAlXCI+PC9zdG9wPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCB4MT1cIi0zODguMDk0MDA0JVwiIHkxPVwiLTE3My44NTAwNTUlXCIgeDI9XCIyMzcuNjc0ODAyJVwiIHkyPVwiNTE4Ljk5MDIyNSVcIiBpZD1cImxpbmVhckdyYWRpZW50LTdcIj5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNDMDZGQkJcIiBvZmZzZXQ9XCIwJVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM2RTREOUJcIiBvZmZzZXQ9XCIxMDAlXCI+PC9zdG9wPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCB4MT1cIjExLjE4ODQ1NjElXCIgeTE9XCI4OS42NTI1OTkzJVwiIHgyPVwiOTAuMTQ1MTI1JVwiIHkyPVwiMTEuNTc3Mzk4MiVcIiBpZD1cImxpbmVhckdyYWRpZW50LThcIj5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM2RTREOUJcIiBvZmZzZXQ9XCIwJVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiM3NzMyN0FcIiBvZmZzZXQ9XCIxNCVcIj48L3N0b3A+XG4gICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjQjMxNzc3XCIgb2Zmc2V0PVwiNTMlXCI+PC9zdG9wPlxuICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVwiI0NEMEY3RVwiIG9mZnNldD1cIjc5JVwiPjwvc3RvcD5cbiAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNFRDJDODlcIiBvZmZzZXQ9XCIxMDAlXCI+PC9zdG9wPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgIDxyZWN0IGlkPVwicGF0aC05XCIgeD1cIjAuNjI3NDk4MjU2XCIgeT1cIjBcIiB3aWR0aD1cIjM0XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIj48L3JlY3Q+XG4gICAgICA8ZmlsdGVyIHg9XCItNTAlXCIgeT1cIi01MCVcIiB3aWR0aD1cIjIwMCVcIiBoZWlnaHQ9XCIyMDAlXCIgZmlsdGVyVW5pdHM9XCJvYmplY3RCb3VuZGluZ0JveFwiIGlkPVwiZmlsdGVyLTEwXCI+XG4gICAgICAgIDxmZU9mZnNldCBkeD1cIjBcIiBkeT1cIjFcIiBpbj1cIlNvdXJjZUFscGhhXCIgcmVzdWx0PVwic2hhZG93T2Zmc2V0T3V0ZXIxXCI+PC9mZU9mZnNldD5cbiAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPVwiMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjE1IDBcIiB0eXBlPVwibWF0cml4XCIgaW49XCJzaGFkb3dPZmZzZXRPdXRlcjFcIj48L2ZlQ29sb3JNYXRyaXg+XG4gICAgICA8L2ZpbHRlcj5cbiAgICA8L2RlZnM+XG4gICAgPGcgaWQ9XCJHcm91cC0zXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMzE3LjAwMDAwMCwgMjEuMDAwMDAwKVwiPlxuICAgICAgPGcgaWQ9XCJJY29uXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDE4LjgyMTQzNiwgMTguODIxNDM2KSByb3RhdGUoMTEuMjgzODY0KSB0cmFuc2xhdGUoLTE4LjgyMTQzNiwgLTE4LjgyMTQzNikgdHJhbnNsYXRlKDIuODIxNDM2LCAyLjgyMTQzNilcIj5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNi4wNjIyMTcsIDQuMzE0NjQ5KSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC0xNi4wNjIyMTcsIC00LjMxNDY0OSkgdHJhbnNsYXRlKDEyLjkwOTM1NCwgMC44NTI2ODIpXCJcbiAgICAgICAgICBmaWxsPVwidXJsKCNsaW5lYXJHcmFkaWVudC0xKVwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCI2LjI0NTE0MTM0IDQuNzgxOTY1NjggMy4yMTM0NDczMSA2LjgwNTM2MTggMC4wOTAyNTg0Mjc2IDIuMTI0OTA1OTQgMy4xMjE5NTI0NiAwLjEwMTUwOTgyMVwiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDI0LjU3NjY3MSwgMjMuNjA2MDYyKSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC0yNC41NzY2NzEsIC0yMy42MDYwNjIpIHRyYW5zbGF0ZSgxOC4zOTQ1ODcsIDE2LjkyOTQxMSlcIlxuICAgICAgICAgIGZpbGw9XCJ1cmwoI2xpbmVhckdyYWRpZW50LTIpXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJTaGFwZVwiIHBvaW50cz1cIjcuMTY0MDQ2MzIgMS40NzMxOTA2NCAxMi4zNDQwMTQ2IDkuMjM1NDE1NDEgNi4xNzM0MjkxNiAxMy4zNTMzMDE2IDAuOTkzNDYwOTEyIDUuNTkwOTUzMiAwLjA4OTc2Mzg2MDkgNC4yMzY5NTMxNSA2LjI2MDQ3MjkxIDAuMTE5MDY2OTM5XCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTYuMDY0MDAxLCAyNy4wNjk2NzEpIHJvdGF0ZSgtMTEuMjgzODY0KSB0cmFuc2xhdGUoLTE2LjA2NDAwMSwgLTI3LjA2OTY3MSkgdHJhbnNsYXRlKDEyLjYwMjAzNCwgMjMuODU0OTg4KVwiXG4gICAgICAgICAgZmlsbD1cInVybCgjbGluZWFyR3JhZGllbnQtMylcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiNS42OTc3Nzk2MiAxLjQ2NjYzNzYzIDYuODM4MjUwNDkgMy4xNzU2MTI5NSAyLjE0MTQ3MzkzIDYuMzA5OTI5NTggMC4wOTczMDYwMDM1IDMuMjQ2ODMwNTYgMS4xMjM0MDgzMiAyLjU2MjEwMjkzIDQuNzk0MjA2MjEgMC4xMTI1MTM5M1wiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDI3LjQxNzI4NywgMTUuNzI2NzEyKSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC0yNy40MTcyODcsIC0xNS43MjY3MTIpIHRyYW5zbGF0ZSgyNC44MjA4MTIsIDEzLjEzMDIzNilcIlxuICAgICAgICAgIGZpbGw9XCJ1cmwoI2xpbmVhckdyYWRpZW50LTQpXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0xLjgxNzAzODE1LDAuODk0NjcxMjA4IEwzLjEzNDQ0MDI3LDAuMDE1NTc4ODUxOSBMNS4xNzg0ODQ1NSwzLjA3ODY3Nzg3IEwyLjE0NjQxOTU5LDUuMTAyMDczOTkgTDEuMDA1OTQ4NzIsMy4zOTMwOTg2NyBMMi43MjA2MTE1NiwyLjI0ODc5NDkxIEwxLjgxNzAzODE1LDAuODk0NjcxMjA4IEwxLjgxNzAzODE1LDAuODk0NjcxMjA4IFogTTEuMDA1OTQ4NzIsMy4zOTMwOTg2NyBMMC4xMDIzNzUzMTIsMi4wMzg5NzQ5NyBMMS44MTcwMzgxNSwwLjg5NDY3MTIwOCBMMi43MjA2MTE1NiwyLjI0ODc5NDkxIEwxLjAwNTk0ODcyLDMuMzkzMDk4NjcgTDEuMDA1OTQ4NzIsMy4zOTMwOTg2NyBaXCJcbiAgICAgICAgICAgIGlkPVwiU2hhcGVcIj48L3BhdGg+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg0LjcyMTA0MSwgMTUuNzE2Mzg1KSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC00LjcyMTA0MSwgLTE1LjcxNjM4NSkgdHJhbnNsYXRlKDAuNzY0NTA3LCAxMS43NTk4NTEpXCJcbiAgICAgICAgICBmaWxsPVwidXJsKCNsaW5lYXJHcmFkaWVudC01KVwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCI0LjE3MjQxMjE5IDcuMTQ1MDA1NSAzLjE0NjQzMzUxIDcuODI5NzMzMTMgMC4wMjI5OTczNTI4IDMuMTQ5Mjc3MjcgNC43MTk3NzM5MSAwLjAxNDk2MDY0MzUgNi45MDkwOTcxNyAzLjI5NTc5MjY3IDMuMjM4NDIyOTMgNS43NDUzODE2NiA2LjkwOTA5NzE3IDMuMjk1NzkyNjcgNy44NDMyMTAwNyA0LjY5NTU0MDE0XCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoOC44MjI1NjAsIDcuODM3NjA5KSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC04LjgyMjU2MCwgLTcuODM3NjA5KSB0cmFuc2xhdGUoMi42NDA0NzYsIDEuMTYwOTU4KVwiXG4gICAgICAgICAgZmlsbD1cInVybCgjbGluZWFyR3JhZGllbnQtNilcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiMTEuMzQyODg3OSA3Ljc1MzMyMjU3IDEyLjI3Njg3NzEgOS4xNTMwNzAwNSA2LjEwNjE2ODA5IDEzLjI3MDk1NjMgNS4xNzIxNzg4MyAxMS44NzEyMDg4IDAuMDQwNjc4MTEzMyA0LjE4MTY4NTMxIDYuMjExMzg3MTYgMC4wNjM3OTkxMDc3XCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTYuMTIyODU3LCA0LjMwMDcwMykgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMTYuMTIyODU3LCAtNC4zMDA3MDMpIHRyYW5zbGF0ZSgxMi45Njk5OTQsIDAuOTAwNTU3KVwiXG4gICAgICAgICAgZmlsbD1cInVybCgjbGluZWFyR3JhZGllbnQtNylcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiNC44NjYwNDIwMiA1LjYwMTMzOTEgMy4xNTEzNzkxOCA2Ljc0NTUxOTIzIDIuMjE3MjY2MjggNS4zNDU4OTUzOSAwLjAyNzk0MzAyMDEgMi4wNjUwNjMzNyAzLjA2MDAwNzk4IDAuMDQxNjY3MjQ2NyA2LjE4MzQ0NDE0IDQuNzIyMTIzMTFcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNS44MjIwNzEsIDI1Ljg1NzE1NSkgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMTUuODIyMDcxLCAtMjUuODU3MTU1KSB0cmFuc2xhdGUoMTMuNDcyODc5LCAyMy44Nzg4ODgpXCJcbiAgICAgICAgICBmaWxsPVwiIzcxNDg5NlwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCIwLjkxNDMzMDIzNiAzLjkxNjIyNjYyIDAuMDEwNjMzMTg0NiAyLjU2MjEwMjkzIDMuNjgxNDMxMDcgMC4xMTI1MTM5MyA0LjU4NTAwNDQ4IDEuNDY2NjM3NjNcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyNi4xODA3MjEsIDE1LjUzMjE2NCkgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtMjYuMTgwNzIxLCAtMTUuNTMyMTY0KSB0cmFuc2xhdGUoMjQuNzU4ODQyLCAxNC4yMzM5MjYpXCJcbiAgICAgICAgICBmaWxsPVwiIzZGNDc5NVwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCIxLjAwNTk0ODcyIDIuNTI3NjA2OSAwLjEwMjM3NTMxMiAxLjE3MzQ4MzIgMS44MTcwMzgxNSAwLjAyOTE3OTQzNjkgMi43MjA2MTE1NiAxLjM4MzMwMzEzXCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNi41MzkyNDIsIDE2LjYxNDM5Mykgcm90YXRlKC0xMS4yODM4NjQpIHRyYW5zbGF0ZSgtNi41MzkyNDIsIC0xNi42MTQzOTMpIHRyYW5zbGF0ZSg0LjE5MDA1MCwgMTQuNjM2MTI2KVwiXG4gICAgICAgICAgZmlsbD1cIiM4ODUxOUZcIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cIlNoYXBlXCIgcG9pbnRzPVwiMC45NTc3Mjg0NjYgMy45MzAzMjE3OCAwLjAyMzczOTIwMjkgMi41MzA2OTc5NCAzLjY5NDQxMzQ1IDAuMDgxMTA4OTQzMiA0LjYyODUyNjM1IDEuNDgwODU2NDJcIj48L3BvbHlnb24+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNi44ODU3OTUsIDYuMjI4Nzc3KSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC0xNi44ODU3OTUsIC02LjIyODc3NykgdHJhbnNsYXRlKDE1LjQ2MzkxNiwgNC44Njg3MTgpXCJcbiAgICAgICAgICBmaWxsPVwiIzg1NTA5RVwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCIxLjA0OTQ3MDU5IDIuNjY1MzQzNzMgMC4xMTUzNTc2ODkgMS4yNjU3MTk4OSAxLjgzMDE0NDE3IDAuMTIxNDE2MTMxIDIuNzY0MTMzNDMgMS41MjExNjM2MVwiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIxLjI4MDQwNCwgMjAuMzU1MzEzKSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC0yMS4yODA0MDQsIC0yMC4zNTUzMTMpIHRyYW5zbGF0ZSgxNy42OTQ3OTUsIDE3LjUxMTU1NClcIlxuICAgICAgICAgIGZpbGw9XCIjOEQxNjZBXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJTaGFwZVwiIHBvaW50cz1cIjcuMTY0MDQ2MzIgMS40NzMxOTA2NCAwLjk5MzQ2MDkxMiA1LjU5MDk1MzIgMC4wODk3NjM4NjA5IDQuMjM2OTUzMTUgNi4yNjA0NzI5MSAwLjExOTA2NjkzOVwiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgICA8ZyBpZD1cIkdyb3VwXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEyLjA1ODIwMSwgMTEuMTAwNDU0KSByb3RhdGUoLTExLjI4Mzg2NCkgdHJhbnNsYXRlKC0xMi4wNTgyMDEsIC0xMS4xMDA0NTQpIHRyYW5zbGF0ZSg4LjQxMDc3MSwgOC4yNTY2OTYpXCJcbiAgICAgICAgICBmaWxsPVwiI0E3MEQ2RlwiPlxuICAgICAgICAgIDxwb2x5Z29uIGlkPVwiU2hhcGVcIiBwb2ludHM9XCI2LjI3MzU3ODkzIDAuMDg3NTM4MzEwNiA3LjIwNzU2ODE5IDEuNDg3Mjg1NzkgMS4wMzY4NTkxNCA1LjYwNTE3MiAwLjEwMjg2OTg3OSA0LjIwNTQyNDUyXCI+PC9wb2x5Z29uPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiR3JvdXBcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMS44NTM0MTEsIDEwLjY3ODI2Nykgcm90YXRlKDQ1LjAwMDAwMCkgdHJhbnNsYXRlKC0xLjg1MzQxMSwgLTEwLjY3ODI2NykgdHJhbnNsYXRlKDAuNzk3OTA2LCA5LjYyMjc2MilcIlxuICAgICAgICAgIGZpbGw9XCIjOUU2MUFEXCI+XG4gICAgICAgICAgPHJlY3QgaWQ9XCJSZWN0YW5nbGUtcGF0aFwiIHg9XCIxLjY2NjYyNTcxZS0xNVwiIHk9XCIwXCIgd2lkdGg9XCIyLjA5ODI3MTVcIiBoZWlnaHQ9XCIyLjA5ODI3MTVcIj48L3JlY3Q+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMi4xMTU2NjksIDI5Ljk2NjM2Nikgcm90YXRlKDQ1LjAwMDAwMCkgdHJhbnNsYXRlKC0xMi4xMTU2NjksIC0yOS45NjYzNjYpIHRyYW5zbGF0ZSgxMS4wNjAxNjMsIDI4LjkxMDg2MClcIlxuICAgICAgICAgIGZpbGw9XCIjODA1M0EzXCI+XG4gICAgICAgICAgPHJlY3QgaWQ9XCJSZWN0YW5nbGUtcGF0aFwiIHg9XCIxLjY2NjYyNTcxZS0xNVwiIHk9XCIwXCIgd2lkdGg9XCIyLjA5ODI3MTVcIiBoZWlnaHQ9XCIyLjA5ODI3MTVcIj48L3JlY3Q+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgaWQ9XCJHcm91cFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNi42NDE5NTQsIDE2LjQyNzQzNykgcm90YXRlKDAuMDAwMDAwKSB0cmFuc2xhdGUoLTE2LjY0MTk1NCwgLTE2LjQyNzQzNykgdHJhbnNsYXRlKDEuNDIyNDQyLCAxLjIwNzkyNClcIlxuICAgICAgICAgIGZpbGw9XCJ1cmwoI2xpbmVhckdyYWRpZW50LTgpXCI+XG4gICAgICAgICAgPHBvbHlnb24gaWQ9XCJTaGFwZVwiIHBvaW50cz1cIjYuNTM0NDYxNTcgMjkuODg3ODk3OCAwLjAxMjk4MjM3NCAyMy4zMTc1ODAxIDIzLjIxODY2NjggMC4wNjMwNTcyNDUxIDI5Ljk1OTYwOTkgNi40NjM5ODU4M1wiPjwvcG9seWdvbj5cbiAgICAgICAgPC9nPlxuICAgICAgPC9nPlxuICAgICAgPGcgaWQ9XCJBdXJlbGlhLSstVHlwZS1zb21ldGhpbmdcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMzguMTMxOTYwLCAzLjAyMTQyNylcIj5cbiAgICAgICAgPGcgaWQ9XCJBdXJlbGlhXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAuOTI5NTA1LCAwLjI5MDI5NylcIj5cbiAgICAgICAgICA8ZyBpZD1cIkFcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMC4wNzY2NzMsIDguNDEzNDY1KVwiIGZpbGw9XCIjRUQyQzg4XCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTguNzk1MjQ3NTIsMTYuNTQwMzU2NCBDOC45MTA4OTEwOSwxNi41Mzk4ODEyIDkuMDI4MTE4ODEsMTYuNTM3NjYzNCA5LjE0Mzc2MjM4LDE2LjUzMjU5NDEgQzkuMzg5MzA2OTMsMTYuNTIxNjYzNCA5LjYzMzI2NzMzLDE2LjQ5OTMyNjcgOS44NzcyMjc3MiwxNi40NjUyNjczIEMxMC41ODUzNDY1LDE2LjM2NTk0MDYgMTEuMjc5MjA3OSwxNi4xNjc2MDQgMTEuOTMzNDY1MywxNS44NzY1OTQxIEMxMi43NDI5NzAzLDE1LjUxNjY3MzMgMTMuNDg5MTA4OSwxNS4wMTYyMzc2IDE0LjEzMDY5MzEsMTQuNDA1MDY5MyBDMTQuNzM1ODQxNiwxMy44MjcxNjgzIDE1LjI0NzUyNDgsMTMuMTUxMjA3OSAxNS42Mzg4MTE5LDEyLjQxMDQ1NTQgQzE1Ljk2OTkwMSwxMS43ODIxNzgyIDE2LjIxMzg2MTQsMTEuMTA4NDM1NiAxNi4zNjExODgxLDEwLjQxMzMwNjkgQzE2LjU0MDE5OCw5LjU2MzU2NDM2IDE2LjU3NTA0OTUsOC42ODMyNDc1MiAxNi40NjU3NDI2LDcuODIxNzgyMTggQzE2LjM2NDM1NjQsNy4wMzI3MTI4NyAxNi4xNDI1NzQzLDYuMjYwNDM1NjQgMTUuODA1MTQ4NSw1LjUzOTY0MzU2IEMxNS40MTg2MTM5LDQuNzA5NTQ0NTUgMTQuODgxNTg0MiwzLjk1MDI1NzQzIDE0LjIzMDQ5NSwzLjMwNjQ1NTQ1IEMxMy41NDQ1NTQ1LDIuNjI5MjI3NzIgMTIuNzMzNDY1MywyLjA4MTEwODkxIDExLjg0NzkyMDgsMS43MDAxMTg4MSBDMTEuMzY3OTIwOCwxLjQ5MzU0NDU1IDEwLjg2NTc0MjYsMS4zMzYwNzkyMSAxMC4zNTQwNTk0LDEuMjMxMzY2MzQgQzkuODc0MDU5NDEsMS4xMzMxNDg1MSA5LjM4NDU1NDQ2LDEuMDgxMDI5NyA4Ljg5NTA0OTUsMS4wNzQ4NTE0OSBDOC40MTgyMTc4MiwxLjA2ODgzMTY4IDcuOTQxMzg2MTQsMS4xMDU5MDA5OSA3LjQ3MjQ3NTI1LDEuMTg2NjkzMDcgQzYuOTQwMTk4MDIsMS4yNzg0MTU4NCA2LjQxNzQyNTc0LDEuNDI2NTM0NjUgNS45MTUyNDc1MiwxLjYyNzg4MTE5IEM1LjAzNDQ1NTQ1LDEuOTgxMzA2OTMgNC4yMjE3ODIxOCwyLjQ5OTE2ODMyIDMuNTI2MzM2NjMsMy4xNDU4MjE3OCBDMi44NDUxNDg1MSwzLjc4MDExODgxIDIuMjc5NjAzOTYsNC41MzY4NzEyOSAxLjg2NDU1NDQ2LDUuMzcwNjEzODYgQzEuNTEyODcxMjksNi4wODA3OTIwOCAxLjI3MDQ5NTA1LDYuODQ0OTkwMSAxLjE1MDA5OTAxLDcuNjI4OTkwMSBDMS4wMTcwMjk3LDguNTA0MDc5MjEgMS4wMzI4NzEyOSw5LjQwMjI5NzAzIDEuMjAwNzkyMDgsMTAuMjcxODQxNiBDMS4zMzcwMjk3LDEwLjk4NTk4MDIgMS41NzYyMzc2MiwxMS42ODAxNTg0IDEuOTA3MzI2NzMsMTIuMzI3NDQ1NSBDMi4yODkxMDg5MSwxMy4wNzMxMDg5IDIuNzkyODcxMjksMTMuNzU1MjQ3NSAzLjM5MzI2NzMzLDE0LjM0MDU5NDEgQzQuMDE0MjU3NDMsMTQuOTQ4Mjc3MiA0LjczODIxNzgyLDE1LjQ1MDI5NyA1LjUyNzEyODcxLDE1LjgxODEzODYgQzYuMTU5MjA3OTIsMTYuMTEzNDI1NyA2LjgzMjQ3NTI1LDE2LjMyMTkwMSA3LjUyLDE2LjQzNTk2MDQgQzcuNzYwNzkyMDgsMTYuNDc1ODgxMiA4LjAwNDc1MjQ4LDE2LjUwNDM5NiA4LjI0ODcxMjg3LDE2LjUyMTM0NjUgQzguMzgwMTk4MDIsMTYuNTMwNTM0NyA4LjUxMTY4MzE3LDE2LjUzNTkyMDggOC42NDQ3NTI0OCwxNi41Mzg5MzA3IEM4LjY5NTQ0NTU0LDE2LjUzOTcyMjggOC43NDQ1NTQ0NiwxNi41NDAxOTggOC43OTUyNDc1MiwxNi41NDAzNTY0IEw4Ljc5NTI0NzUyLDE2LjU0MDM1NjQgWiBNMTYuODUzODYxNCwxMi4xOTk2MDQgQzE2Ljc2OTkwMSwxMi4zOTg4OTExIDE2LjY3ODAxOTgsMTIuNTk1MDA5OSAxNi41Nzk4MDIsMTIuNzg3NDg1MSBDMTYuMTMzMDY5MywxMy42NjEzMDY5IDE1LjUzNzQyNTcsMTQuNDU3OTgwMiAxNC44MjYxMzg2LDE1LjEzNTM2NjMgQzE0LjEyNzUyNDgsMTUuODAxODIxOCAxMy4zMTgwMTk4LDE2LjM1MTg0MTYgMTIuNDQwMzk2LDE2Ljc1NTAwOTkgQzExLjcwNTM0NjUsMTcuMDkyNDM1NiAxMC45MjQzNTY0LDE3LjMyNjU3NDMgMTAuMTI1OTQwNiwxNy40NDg3MTI5IEM5Ljg1MTg4MTE5LDE3LjQ5MDUzNDcgOS41NzYyMzc2MiwxNy41MTkzNjYzIDkuMjk5MDA5OSwxNy41MzUwNDk1IEM5LjE2OTEwODkxLDE3LjU0MjQ5NSA5LjAzNzYyMzc2LDE3LjU0NjYxMzkgOC45MDc3MjI3NywxNy41NDg2NzMzIEM4Ljg2OTcwMjk3LDE3LjU0OTE0ODUgOC44MzE2ODMxNywxNy41NDkzMDY5IDguNzk1MjQ3NTIsMTcuNTQ5NDY1MyBDOC42NjM3NjIzOCwxNy41NDg5OTAxIDguNTMyMjc3MjMsMTcuNTQ2NjEzOSA4LjQwMDc5MjA4LDE3LjU0MDc1MjUgQzguMTIzNTY0MzYsMTcuNTI4Mzk2IDcuODQ3OTIwNzksMTcuNTAzMDQ5NSA3LjU3MjI3NzIzLDE3LjQ2NDcxMjkgQzYuNzcwNjkzMDcsMTcuMzUyMzk2IDUuOTg0OTUwNSwxNy4xMjc3NjI0IDUuMjQ1MTQ4NTEsMTYuNzk4NzMyNyBDNC4zNDY5MzA2OSwxNi4zOTg4OTExIDMuNTE2ODMxNjgsMTUuODQ2MDE5OCAyLjgwMDc5MjA4LDE1LjE3MTQ4NTEgQzIuMDczNjYzMzcsMTQuNDg2MTc4MiAxLjQ2NTM0NjUzLDEzLjY3NjgzMTcgMS4wMDkxMDg5MSwxMi43ODc0ODUxIEMwLjY0MTU4NDE1OCwxMi4wNzEyODcxIDAuMzc1NDQ1NTQ1LDExLjMwNDU1NDUgMC4yMTg2MTM4NjEsMTAuNTE1MTY4MyBDMC4wMzE2ODMxNjgzLDkuNTcwMzc2MjQgMC4wMDMxNjgzMTY4Myw4LjU5NDUzNDY1IDAuMTI5OTAwOTksNy42Mzk5MjA3OSBDMC4yNDcxMjg3MTMsNi43NjYyNTc0MyAwLjQ5NTg0MTU4NCw1LjkxMTI4NzEzIDAuODY5NzAyOTcsNS4xMTI3MTI4NyBDMS4zMTQ4NTE0OSw0LjE1ODU3NDI2IDEuOTM0MjU3NDMsMy4yODc2MDM5NiAyLjY4ODMxNjgzLDIuNTUxOTIwNzkgQzMuNDY2MTM4NjEsMS43OTA3MzI2NyA0LjM4ODExODgxLDEuMTc2NzEyODcgNS4zOTA4OTEwOSwwLjc1MjMxNjgzMiBDNS45MiwwLjUyODYzMzY2MyA2LjQ3MTI4NzEzLDAuMzU3NzAyOTcgNy4wMzM2NjMzNywwLjI0MjY5MzA2OSBDNy41OTQ0NTU0NSwwLjEyOCA4LjE2NjMzNjYzLDAuMDY4NzUyNDc1MiA4LjczODIxNzgyLDAuMDY1MjY3MzI2NyBDOS4zMTE2ODMxNywwLjA2MTYyMzc2MjQgOS44ODUxNDg1MSwwLjExMzU4NDE1OCAxMC40NDkxMDg5LDAuMjIxNDY1MzQ3IEMxMS4wMTMwNjkzLDAuMzI5NjYzMzY2IDExLjU2NzUyNDgsMC40OTM5NDA1OTQgMTIuMDk5ODAyLDAuNzExMjg3MTI5IEMxMy4xMDg5MTA5LDEuMTIzNjQzNTYgMTQuMDM3MjI3NywxLjcyNjg5MTA5IDE0LjgyNjEzODYsMi40NzkwNDk1IEMxNS41NzU0NDU1LDMuMTkzMDI5NyAxNi4xOTY0MzU2LDQuMDM5NjAzOTYgMTYuNjUxMDg5MSw0Ljk2OTE4ODEyIEMxNi43MjIzNzYyLDUuMTE1ODgxMTkgMTYuNzkwNDk1LDUuMjY0NDc1MjUgMTYuODUzODYxNCw1LjQxNDk3MDMgTDE2Ljg1Mzg2MTQsMC4wOTQ0MTU4NDE2IEwxNy44NDM5NjA0LDAuMDk0NDE1ODQxNiBMMTcuODQzOTYwNCwxNy41MjAxNTg0IEwxNi44NTM4NjE0LDE3LjUyMDE1ODQgTDE2Ljg1Mzg2MTQsMTIuMTk5NjA0IEwxNi44NTM4NjE0LDEyLjE5OTYwNCBaXCJcbiAgICAgICAgICAgICAgaWQ9XCJTaGFwZVwiPjwvcGF0aD5cbiAgICAgICAgICA8L2c+XG4gICAgICAgICAgPGcgaWQ9XCJVXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIwLjM1MzkwMSwgOC40MTM0NjUpXCIgZmlsbD1cIiNDRDBGN0VcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTYuNTM3MDI5NywxMi44MTg4NTE1IEMxNi4xNzEwODkxLDEzLjUyMzQ4NTEgMTUuNzExNjgzMiwxNC4xNzkwMDk5IDE1LjE3MTQ4NTEsMTQuNzYxNTA1IEMxNC43MTA0OTUsMTUuMjYwNTE0OSAxNC4xODkzMDY5LDE1LjcwNTY2MzQgMTMuNjI1MzQ2NSwxNi4wODQ1OTQxIEMxMy4wMTA2OTMxLDE2LjQ5Njc5MjEgMTIuMzQyMTc4MiwxNi44Mjk5NDA2IDExLjY0MzU2NDQsMTcuMDcyNDc1MiBDMTEuMDYzNzYyNCwxNy4yNzM2NjM0IDEwLjQ2MTc4MjIsMTcuNDEyMjc3MiA5Ljg1MTg4MTE5LDE3LjQ4NTk0MDYgQzkuNjQ5MTA4OTEsMTcuNTEwNDk1IDkuNDQ3OTIwNzksMTcuNTI3NzYyNCA5LjI0MzU2NDM2LDE3LjUzODA1OTQgQzkuMTMxMDg5MTEsMTcuNTQzNzYyNCA5LjAyMDE5ODAyLDE3LjU0NjkzMDcgOC45MDc3MjI3NywxNy41NDg2NzMzIEM4Ljg2OTcwMjk3LDE3LjU0OTE0ODUgOC44MzE2ODMxNywxNy41NDkzMDY5IDguNzk1MjQ3NTIsMTcuNTQ5NDY1MyBDOC42ODExODgxMiwxNy41NDkxNDg1IDguNTcwMjk3MDMsMTcuNTQ3MjQ3NSA4LjQ1NjIzNzYyLDE3LjU0Mjk3MDMgQzguMjE1NDQ1NTQsMTcuNTMzOTQwNiA3Ljk3NDY1MzQ3LDE3LjUxNDkzMDcgNy43MzU0NDU1NCwxNy40ODYwOTkgQzcuMDMzNjYzMzcsMTcuNDAxNTA1IDYuMzQyOTcwMywxNy4yMzE4NDE2IDUuNjgwNzkyMDgsMTYuOTgxNzAzIEM0LjY4OTEwODkxLDE2LjYwNjU3NDMgMy43NjcxMjg3MSwxNi4wNTA1MzQ3IDIuOTcxODgxMTksMTUuMzQ5MjI3NyBDMi40MDc5MjA3OSwxNC44NTA1MzQ3IDEuOTA1NzQyNTcsMTQuMjc4ODExOSAxLjQ4NzUyNDc1LDEzLjY1MTk2MDQgQzEuMDM0NDU1NDUsMTIuOTc0NTc0MyAwLjY3ODAxOTgwMiwxMi4yMzMwMjk3IDAuNDM1NjQzNTY0LDExLjQ1NTM2NjMgQzAuMjU2NjMzNjYzLDEwLjg4MzAwOTkgMC4xMzk0MDU5NDEsMTAuMjkxODAyIDAuMDg1NTQ0NTU0NSw5LjY5NDczMjY3IEMwLjA1ODYxMzg2MTQsOS4zOTg2NTM0NyAwLjA0OTEwODkxMDksOS4xMDE2MjM3NiAwLjA1MjI3NzIyNzcsOC44MDQ0MzU2NCBMMC4wNTIyNzcyMjc3LDAuMDk0NDE1ODQxNiBMMS4wNjEzODYxNCwwLjA5NDQxNTg0MTYgTDEuMDYxMzg2MTQsOC44MTAxMzg2MSBMMS4wNjEzODYxNCw4LjkxNDUzNDY1IEwxLjA2MTM4NjE0LDkuMDE0MDE5OCBDMS4wNjI5NzAzLDkuMTEzMDI5NyAxLjA2NDU1NDQ2LDkuMjExODgxMTkgMS4wNzA4OTEwOSw5LjMxMDczMjY3IEMxLjA4MTk4MDIsOS41MzgwNTk0MSAxLjEwNDE1ODQyLDkuNzY0OTEwODkgMS4xMzU4NDE1OCw5Ljk5MDMzNjYzIEMxLjIyNzcyMjc3LDEwLjYzMzM0NjUgMS40MDM1NjQzNiwxMS4yNjQgMS42NjAxOTgwMiwxMS44NjEzODYxIEMyLjAxOTgwMTk4LDEyLjcwNDc5MjEgMi41MzYyMzc2MiwxMy40NzkyODcxIDMuMTY5OTAwOTksMTQuMTQxNDY1MyBDMy43OTU2NDM1NiwxNC43OTM5ODAyIDQuNTM1NDQ1NTQsMTUuMzM1NzYyNCA1LjM0NDk1MDUsMTUuNzM2MjM3NiBDNi4wNTk0MDU5NCwxNi4wODkwMjk3IDYuODI3NzIyNzcsMTYuMzMxMDg5MSA3LjYxNTA0OTUsMTYuNDUxMTY4MyBDOC40MjYxMzg2MSwxNi41NzQ3MzI3IDkuMjU3ODIxNzgsMTYuNTcwNDU1NCAxMC4wNjczMjY3LDE2LjQzNTk2MDQgQzEwLjcwNTc0MjYsMTYuMzI5NjYzNCAxMS4zMzE0ODUxLDE2LjE0MTYyMzggMTEuOTIzOTYwNCwxNS44NzY5MTA5IEMxMi43NzE0ODUxLDE1LjQ5Nzk4MDIgMTMuNTQ3NzIyOCwxNC45NjMxNjgzIDE0LjIwNjczMjcsMTQuMzA4OTEwOSBDMTQuODM0MDU5NCwxMy42ODUzODYxIDE1LjM1MzY2MzQsMTIuOTU1MjQ3NSAxNS43NDAxOTgsMTIuMTU4NzMyNyBDMTYuMDU4NjEzOSwxMS41MDAzNTY0IDE2LjI4MzU2NDQsMTAuNzk3NjIzOCAxNi40MDg3MTI5LDEwLjA3NzE0ODUgQzE2LjQ1NzgyMTgsOS44MDMwODkxMSAxNi40OTEwODkxLDkuNTI2NjUzNDcgMTYuNTEwMDk5LDkuMjQ5MjY3MzMgQzE2LjUxODAxOTgsOS4xMTY1MTQ4NSAxNi41MjQzNTY0LDguOTgzNzYyMzggMTYuNTI3NTI0OCw4Ljg1MDY5MzA3IEwxNi41Mjc1MjQ4LDguODAzMTY4MzIgTDE2LjUzNzAyOTcsMC4wOTQ0MTU4NDE2IEwxNy41MjcxMjg3LDAuMDk0NDE1ODQxNiBMMTcuNTI3MTI4NywxNy41MjAxNTg0IEwxNi41MzcwMjk3LDE3LjUyMDE1ODQgTDE2LjUzNzAyOTcsMTIuODE4ODUxNSBMMTYuNTM3MDI5NywxMi44MTg4NTE1IFpcIlxuICAgICAgICAgICAgICBpZD1cIlNoYXBlXCI+PC9wYXRoPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8ZyBpZD1cIlJcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDAuMzE0Mjk3LCA4LjQxMzQ2NSlcIiBmaWxsPVwiI0IzMTc3NlwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0xLjA2NDU1NDQ2LDguNDE1NTI0NzUgTDEuMDQyMzc2MjQsMTcuNTIwMTU4NCBMMC4wNTIyNzcyMjc3LDE3LjUyMDE1ODQgTDAuMDUyMjc3MjI3NywwLjA5NDQxNTg0MTYgTDEuMDQyMzc2MjQsMC4wOTQ0MTU4NDE2IEwxLjA0MjM3NjI0LDQuNTU1MjQ3NTIgQzEuMTY1OTQwNTksNC4zMjk2NjMzNyAxLjMwMDU5NDA2LDQuMTA5NzgyMTggMS40NDMxNjgzMiwzLjg5NjM5NjA0IEMxLjgzMjg3MTI5LDMuMzE2OTEwODkgMi4yOTU0NDU1NCwyLjc4NjM3NjI0IDIuODEzNDY1MzUsMi4zMTg4OTEwOSBDMy41NzA2OTMwNywxLjYzNjExODgxIDQuNDQ4MzE2ODMsMS4wODkxMDg5MSA1LjM5NDA1OTQxLDAuNzA2NjkzMDY5IEM2LjA4OTUwNDk1LDAuNDI1MTg4MTE5IDYuODIxMzg2MTQsMC4yMzI4NzEyODcgNy41NjU5NDA1OSwwLjEzMzM4NjEzOSBDNy44MjI1NzQyNiwwLjA5OTMyNjczMjcgOC4wNzkyMDc5MiwwLjA3NjAzOTYwNCA4LjMzNzQyNTc0LDAuMDYzNTI0NzUyNSBDOC40ODYzMzY2MywwLjA1NjM5NjAzOTYgOC42MzUyNDc1MiwwLjA1MzIyNzcyMjggOC43ODQxNTg0MiwwLjA1Mjc1MjQ3NTIgTDguNzg3MzI2NzMsMS4wODY0MTU4NCBDOC43NTI0NzUyNSwxLjA4NjU3NDI2IDguNzE5MjA3OTIsMS4wODY3MzI2NyA4LjY4NTk0MDU5LDEuMDg3MDQ5NSBDOC42NTI2NzMyNywxLjA4NzUyNDc1IDguNjE5NDA1OTQsMS4wODgxNTg0MiA4LjU4NjEzODYxLDEuMDg4OTUwNSBDOC40NzA0OTUwNSwxLjA5MTk2MDQgOC4zNTQ4NTE0OSwxLjA5Njg3MTI5IDguMjM5MjA3OTIsMS4xMDQ2MzM2NiBDNy45OTUyNDc1MiwxLjEyMDc5MjA4IDcuNzUyODcxMjksMS4xNDc4ODExOSA3LjUxMjA3OTIxLDEuMTg1OTAwOTkgQzYuODczNjYzMzcsMS4yODY4MTE4OCA2LjI0NzkyMDc5LDEuNDY1NTA0OTUgNS42NTIyNzcyMywxLjcxODQ5NTA1IEM0LjgyNjkzMDY5LDIuMDcwMDE5OCA0LjA2MTc4MjE4LDIuNTY1MDY5MzEgMy40MDU5NDA1OSwzLjE3ODEzODYxIEMyLjk0NjUzNDY1LDMuNjA3MTI4NzEgMi41NDA5OTAxLDQuMDkzNDY1MzUgMi4yMDM1NjQzNiw0LjYyMzIwNzkyIEMxLjg1NjYzMzY2LDUuMTY2NzMyNjcgMS41ODA5OTAxLDUuNzU2MTk4MDIgMS4zODkzMDY5Myw2LjM3MTgwMTk4IEMxLjI1MzA2OTMxLDYuODA5NjYzMzcgMS4xNTk2MDM5Niw3LjI2MDM1NjQ0IDEuMTA4OTEwODksNy43MTYxMTg4MSBDMS4wODE5ODAyLDcuOTQ4NTE0ODUgMS4wNjkzMDY5Myw4LjE4MTg2MTM5IDEuMDY0NTU0NDYsOC40MTU1MjQ3NSBMMS4wNjQ1NTQ0Niw4LjQxNTUyNDc1IFpcIlxuICAgICAgICAgICAgICBpZD1cIlNoYXBlXCI+PC9wYXRoPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgICA8ZyBpZD1cIkVcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNDguMzkzNTA1LCA4LjQxMzQ2NSlcIiBmaWxsPVwiIzlCMjA3M1wiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk05LjM3NTA0OTUsMTcuNTUxMDQ5NSBMOC44MTU4NDE1OCwxNy41NDkzMDY5IEM4Ljc3OTQwNTk0LDE3LjU0ODgzMTcgOC43NDEzODYxNCwxNy41NDgzNTY0IDguNzAzMzY2MzQsMTcuNTQ3ODgxMiBDOC41OTA4OTEwOSwxNy41NDUzNDY1IDguNDgsMTcuNTQxMzg2MSA4LjM2NzUyNDc1LDE3LjUzNTA0OTUgQzguMTI4MzE2ODMsMTcuNTIxNDI1NyA3Ljg4OTEwODkxLDE3LjQ5Nzk4MDIgNy42NTE0ODUxNSwxNy40NjQ3MTI5IEM2Ljk4OTMwNjkzLDE3LjM3MjAzOTYgNi4zMzk4MDE5OCwxNy4yMDMzMjY3IDUuNzE3MjI3NzIsMTYuOTYyMzc2MiBDNC42ODI3NzIyOCwxNi41NjIwNTk0IDMuNzI5MTA4OTEsMTUuOTYyNjEzOSAyLjkxODAxOTgsMTUuMjA3Mjg3MSBDMi4xMjExODgxMiwxNC40NjYzNzYyIDEuNDY1MzQ2NTMsMTMuNTc3MzQ2NSAwLjk5MzI2NzMyNywxMi41OTc1NDQ2IEMwLjY0MzE2ODMxNywxMS44NzA3MzI3IDAuMzk0NDU1NDQ2LDExLjA5NTQ0NTUgMC4yNTgyMTc4MjIsMTAuMzAwMzU2NCBDMC4wOTM0NjUzNDY1LDkuMzUwODExODggMC4wODg3MTI4NzEzLDguMzczODYxMzkgMC4yMzkyMDc5MjEsNy40MjI0MTU4NCBDMC40MDA3OTIwNzksNi40MTQ4OTEwOSAwLjczOTgwMTk4LDUuNDM3NzgyMTggMS4yMzcyMjc3Miw0LjU0NzMyNjczIEMxLjc4Mzc2MjM4LDMuNTY4NzkyMDggMi41MjAzOTYwNCwyLjY5ODQ1NTQ1IDMuMzkzMjY3MzMsMS45OTUyNDc1MiBDMy44NTc0MjU3NCwxLjYyMDc1MjQ4IDQuMzYxMTg4MTIsMS4yOTM5NDA1OSA0Ljg5MTg4MTE5LDEuMDIxNzgyMTggQzUuMzgyOTcwMywwLjc3MDIxNzgyMiA1Ljg5NzgyMTc4LDAuNTY1NTQ0NTU0IDYuNDI4NTE0ODUsMC40MTE1NjQzNTYgQzcuMTg1NzQyNTcsMC4xOTE1MjQ3NTIgNy45NzE0ODUxNSwwLjA3NTcyMjc3MjMgOC43NjAzOTYwNCwwLjA2NTc0MjU3NDMgQzkuNjQxMTg4MTIsMC4wNTQ2NTM0NjUzIDEwLjUyMzU2NDQsMC4xNzUzNjYzMzcgMTEuMzY5NTA1LDAuNDI2NzcyMjc3IEMxMi4zMTg0MTU4LDAuNzA5Mzg2MTM5IDEzLjIxODIxNzgsMS4xNTU2NDM1NiAxNC4wMTk4MDIsMS43Mzk3MjI3NyBDMTQuODY3MzI2NywyLjM1ODQ5NTA1IDE1LjYwMjM3NjIsMy4xMjk2NjMzNyAxNi4xODA1OTQxLDQuMDA2NjUzNDcgQzE2LjU1OTIwNzksNC41ODIzMzY2MyAxNi44Njk3MDMsNS4yMDMwMDk5IDE3LjEwMjU3NDMsNS44NTE3MjI3NyBDMTcuMzQxNzgyMiw2LjUxNjc1MjQ4IDE3LjQ5ODYxMzksNy4yMTA5MzA2OSAxNy41Njk5MDEsNy45MTQxMzg2MSBDMTcuNTkyMDc5Miw4LjEzNjA3OTIxIDE3LjYwNjMzNjYsOC4zNTg4MTE4OCAxNy42MTI2NzMzLDguNTgxODYxMzkgQzE3LjYxMjY3MzMsOC42MzgyNTc0MyAxNy42MTQyNTc0LDguNjk0NDk1MDUgMTcuNjE0MjU3NCw4Ljc1MDczMjY3IEMxNy42MTU4NDE2LDguNzg3MzI2NzMgMTcuNjE1ODQxNiw4LjgyNTgyMTc4IDE3LjYxMjY3MzMsOC44NjIwOTkwMSBDMTcuNjA5NTA1LDguODgwOTUwNSAxNy42MDYzMzY2LDguODk5NjQzNTYgMTcuNjAzMTY4Myw4LjkxODE3ODIyIEMxNy41OTA0OTUsOC45NzM0NjUzNSAxNy41NjgzMTY4LDkuMDI2NjkzMDcgMTcuNTM4MjE3OCw5LjA3NDY5MzA3IEMxNy40NzgwMTk4LDkuMTcxMzI2NzMgMTcuMzg0NTU0NSw5LjI0NTYyMzc2IDE3LjI3NjgzMTcsOS4yODMzMjY3MyBDMTcuMjQxOTgwMiw5LjI5NTg0MTU4IDE3LjIwMzk2MDQsOS4zMDQzOTYwNCAxNy4xNjc1MjQ4LDkuMzA4NjczMjcgQzE3LjE0ODUxNDksOS4zMTA3MzI2NyAxNy4xMjk1MDUsOS4zMTA3MzI2NyAxNy4xMTA0OTUsOS4zMTE4NDE1OCBMOS4wODE5ODAyLDkuMzExODQxNTggTDkuMDgxOTgwMiw4LjMwMjczMjY3IEwxNi41ODkzMDY5LDguMzAyNzMyNjcgQzE2LjU3MTg4MTIsOC4wMjg2NzMyNyAxNi41NDAxOTgsNy43NTU4ODExOSAxNi40OTI2NzMzLDcuNDg1MzA2OTMgQzE2LjQwMjM3NjIsNi45NTI3MTI4NyAxNi4yNTM0NjUzLDYuNDI5NjIzNzYgMTYuMDUyMjc3Miw1LjkyODA3OTIxIEMxNS43NjIzNzYyLDUuMjA1Mzg2MTQgMTUuMzYxNTg0Miw0LjUyOCAxNC44Njg5MTA5LDMuOTI0NDM1NjQgQzE0LjMxMTI4NzEsMy4yNDAwNzkyMSAxMy42MzY0MzU2LDIuNjUxODgxMTkgMTIuODgyMzc2MiwyLjE5MzQyNTc0IEMxMi4yNjQ1NTQ1LDEuODE4NDU1NDUgMTEuNTk2MDM5NiwxLjUzMDc3MjI4IDEwLjg5NzQyNTcsMS4zNDE5NDA1OSBDMTAuMDYyNTc0MywxLjExNTg4MTE5IDkuMTg5NzAyOTcsMS4wMzI4NzEyOSA4LjMyNjMzNjYzLDEuMDkzMjI3NzIgQzcuOTA2NTM0NjUsMS4xMjI1MzQ2NSA3LjQ4ODMxNjgzLDEuMTg1OTAwOTkgNy4wNzk2MDM5NiwxLjI4MzE2ODMyIEM2LjYzMjg3MTI5LDEuMzg5MTQ4NTEgNi4xOTcyMjc3MiwxLjUzNTIwNzkyIDUuNzc1ODQxNTgsMS43MTg5NzAzIEM0Ljg5MzQ2NTM1LDIuMTA0ODcxMjkgNC4wODU1NDQ1NSwyLjY1NzkwMDk5IDMuNDA0MzU2NDQsMy4zMzkwODkxMSBDMy4wODc1MjQ3NSwzLjY1NjU1NDQ2IDIuNzk3NjIzNzYsNC4wMDE1ODQxNiAyLjUzOTQwNTk0LDQuMzY4OTUwNSBDMi4yMTYyMzc2Miw0LjgyODM1NjQ0IDEuOTQzNzYyMzgsNS4zMjI2MTM4NiAxLjcyODMxNjgzLDUuODQwNzkyMDggQzEuNTAzMzY2MzQsNi4zODM4NDE1OCAxLjM0MDE5ODAyLDYuOTUyODcxMjkgMS4yNDM1NjQzNiw3LjUzMzE0ODUxIEMxLjE2NTk0MDU5LDguMDAzMzI2NzMgMS4xMzI2NzMyNyw4LjQ4MDYzMzY2IDEuMTQwNTk0MDYsOC45NTczMDY5MyBDMS4xNTE2ODMxNyw5LjQ5NDQ5NTA1IDEuMjE2NjMzNjYsMTAuMDMwNTc0MyAxLjMzNzAyOTcsMTAuNTU0MTM4NiBDMS40NzY0MzU2NCwxMS4xNTM1ODQyIDEuNjg3MTI4NzEsMTEuNzM2MjM3NiAxLjk2NDM1NjQ0LDEyLjI4NTYyMzggQzIuMjY1MzQ2NTMsMTIuODgxNzQyNiAyLjY0Mzk2MDQsMTMuNDM4MjU3NCAzLjA4NTk0MDU5LDEzLjkzNzU4NDIgQzMuNDk3ODIxNzgsMTQuNDAwNzkyMSAzLjk2MzU2NDM2LDE0LjgxNDU3NDMgNC40NzIwNzkyMSwxNS4xNjczNjYzIEM0Ljg4MjM3NjI0LDE1LjQ1MTQwNTkgNS4zMTk2MDM5NiwxNS42OTU4NDE2IDUuNzc1ODQxNTgsMTUuODk1NjA0IEM2LjI1NTg0MTU4LDE2LjEwNTAyOTcgNi43NTQ4NTE0OSwxNi4yNjUzNDY1IDcuMjY2NTM0NjUsMTYuMzczMzg2MSBDNy41OTkyMDc5MiwxNi40NDM3MjI4IDcuOTM4MjE3ODIsMTYuNDkxODgxMiA4LjI3NzIyNzcyLDE2LjUxNzcwMyBDOC40NTk0MDU5NCwxNi41MzE0ODUxIDguNjQsMTYuNTM4NDU1NCA4LjgyMjE3ODIyLDE2LjU0MDE5OCBMOS4zNzgyMTc4MiwxNi41NDE5NDA2IEM5LjM3ODIxNzgyLDE2Ljg3ODI1NzQgOS4zNzY2MzM2NiwxNy4yMTQ1NzQzIDkuMzc1MDQ5NSwxNy41NTEwNDk1IEw5LjM3NTA0OTUsMTcuNTUxMDQ5NSBaXCJcbiAgICAgICAgICAgICAgaWQ9XCJTaGFwZVwiPjwvcGF0aD5cbiAgICAgICAgICA8L2c+XG4gICAgICAgICAgPGcgaWQ9XCJMXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDY4LjUxMjMxNywgMC4wMTc0MjYpXCIgZmlsbD1cIiM4RjI0NzVcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNNS4xNTAwOTkwMSwyNS45NDU1MDUgQzQuOTg4NTE0ODUsMjUuOTQ1MDI5NyA0LjgyNjkzMDY5LDI1Ljk0MDExODggNC42NjUzNDY1MywyNS45MjkxODgxIEM0LjMyNDc1MjQ4LDI1LjkwNjIxNzggMy45ODQxNTg0MiwyNS44NTc3NDI2IDMuNjUxNDg1MTUsMjUuNzgwMjc3MiBDMy4zMTg4MTE4OCwyNS43MDI2NTM1IDIuOTkwODkxMDksMjUuNTk1NzIyOCAyLjY3ODgxMTg4LDI1LjQ1NjYzMzcgQzIuMjkyMjc3MjMsMjUuMjg0OTEwOSAxLjkyNjMzNjYzLDI1LjA2NDIzNzYgMS42MDE1ODQxNiwyNC43OTQ3NzIzIEMxLjQzMDQ5NTA1LDI0LjY1NDg5MTEgMS4yNzIwNzkyMSwyNC41MDIwMTk4IDEuMTI2MzM2NjMsMjQuMzM3NTg0MiBDMC45NDI1NzQyNTcsMjQuMTMxNDg1MSAwLjc4MDk5MDA5OSwyMy45MDc0ODUxIDAuNjQxNTg0MTU4LDIzLjY2OTIyNzcgQzAuNDY3MzI2NzMzLDIzLjM2OTk4MDIgMC4zMzEwODkxMDksMjMuMDQ5MTg4MSAwLjIzNDQ1NTQ0NiwyMi43MTY4MzE3IEMwLjE2MzE2ODMxNywyMi40NjkzODYxIDAuMTEyNDc1MjQ4LDIyLjIxNTc2MjQgMC4wODM5NjAzOTYsMjEuOTU5NzYyNCBDMC4wNjAxOTgwMTk4LDIxLjc0NzAwOTkgMC4wNDkxMDg5MTA5LDIxLjUzMjk5MDEgMC4wNTIyNzcyMjc3LDIxLjMxODk3MDMgTDAuMDUyMjc3MjI3NywwLjE0MDY3MzI2NyBMMS4wNjEzODYxNCwwLjE0MDY3MzI2NyBMMS4wNjEzODYxNCwyMS4zMjUzMDY5IEwxLjA2MTM4NjE0LDIxLjQzMDQ5NSBDMS4wNjI5NzAzLDIxLjU2OTEwODkgMS4wNzA4OTEwOSwyMS43MDc3MjI4IDEuMDg2NzMyNjcsMjEuODQ1NTQ0NiBDMS4xMTIwNzkyMSwyMi4wNjczMjY3IDEuMTU2NDM1NjQsMjIuMjg3MDQ5NSAxLjIyMjk3MDMsMjIuNTAwMTE4OCBDMS4zMDIxNzgyMiwyMi43NTEwNDk1IDEuNDA5OTAwOTksMjIuOTkyNzkyMSAxLjU0NzcyMjc3LDIzLjIxNzI2NzMgQzEuNjUyMjc3MjMsMjMuMzg5MzA2OSAxLjc3NDI1NzQzLDIzLjU1MTA0OTUgMS45MTA0OTUwNSwyMy42OTk4MDIgQzIuMDE4MjE3ODIsMjMuODE4NjEzOSAyLjEzNTQ0NTU0LDIzLjkyOTE4ODEgMi4yNjA1OTQwNiwyNC4wMzA1NzQzIEMyLjM2NTE0ODUxLDI0LjExNjExODggMi40NzYwMzk2LDI0LjE5NTMyNjcgMi41OTAwOTkwMSwyNC4yNjgwMzk2IEMyLjY4ODMxNjgzLDI0LjMzMDYxMzkgMi43ODk3MDI5NywyNC4zODg0MzU2IDIuODkyNjczMjcsMjQuNDQxNTA1IEMzLjM4NTM0NjUzLDI0LjY5MzA2OTMgMy45MjcxMjg3MSwyNC44MzcwNjkzIDQuNDc1MjQ3NTIsMjQuODk5MTY4MyBDNC43MDAxOTgwMiwyNC45MjQ2NzMzIDQuOTI2NzMyNjcsMjQuOTM1NzYyNCA1LjE1MTY4MzE3LDI0LjkzNjM5NiBDNS4xNTE2ODMxNywyNS4yNzI3MTI5IDUuMTUwMDk5MDEsMjUuNjA5MDI5NyA1LjE1MDA5OTAxLDI1Ljk0NTUwNSBMNS4xNTAwOTkwMSwyNS45NDU1MDUgWlwiXG4gICAgICAgICAgICAgIGlkPVwiU2hhcGVcIj48L3BhdGg+XG4gICAgICAgICAgPC9nPlxuICAgICAgICAgIDxnIGlkPVwiSVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg3NS45NTc4NjEsIDAuMDE3NDI2KVwiIGZpbGw9XCIjNzgzMjdBXCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTAuMTQ4OTEwODkxLDI1LjkxNjE5OCBMMC4xNDg5MTA4OTEsOC40OTA0NTU0NSBMMS4xMzkwMDk5LDguNDkwNDU1NDUgTDEuMTM5MDA5OSwyNS45MTYxOTggTDAuMTQ4OTEwODkxLDI1LjkxNjE5OCBMMC4xNDg5MTA4OTEsMjUuOTE2MTk4IFogTTAuMTUzNjYzMzY2LDIuNDcwNjUzNDcgTDAuMTUzNjYzMzY2LDAuMTQwNjczMjY3IEwxLjEzNTg0MTU4LDAuMTQwNjczMjY3IEwxLjEzNTg0MTU4LDIuNDcwNjUzNDcgTDAuMTUzNjYzMzY2LDIuNDcwNjUzNDcgTDAuMTUzNjYzMzY2LDIuNDcwNjUzNDcgWlwiXG4gICAgICAgICAgICAgIGlkPVwiU2hhcGVcIj48L3BhdGg+XG4gICAgICAgICAgPC9nPlxuICAgICAgICAgIDxnIGlkPVwiQTFcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoNzkuNjAxNDI2LCA4LjQxMzQ2NSlcIiBmaWxsPVwiIzZFNEQ5QlwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk04Ljc5NTI0NzUyLDE2LjU0MDM1NjQgQzguOTEwODkxMDksMTYuNTM5ODgxMiA5LjAyODExODgxLDE2LjUzNzY2MzQgOS4xNDM3NjIzOCwxNi41MzI1OTQxIEM5LjM4OTMwNjkzLDE2LjUyMTY2MzQgOS42MzMyNjczMywxNi40OTkzMjY3IDkuODc3MjI3NzIsMTYuNDY1MjY3MyBDMTAuNTg1MzQ2NSwxNi4zNjU5NDA2IDExLjI3OTIwNzksMTYuMTY3NjA0IDExLjkzMzQ2NTMsMTUuODc2NTk0MSBDMTIuNjcxNjgzMiwxNS41NDgwMzk2IDEzLjM1NzYyMzgsMTUuMTAyNzMyNyAxMy45NTk2MDQsMTQuNTYyNjkzMSBDMTQuNjI4MTE4OCwxMy45NjE2NjM0IDE1LjE5MjA3OTIsMTMuMjQ0NjczMyAxNS42MTY2MzM3LDEyLjQ1MTgwMiBDMTUuOTU4ODExOSwxMS44MTE4MDIgMTYuMjEwNjkzMSwxMS4xMjM2NDM2IDE2LjM2MTE4ODEsMTAuNDEzMzA2OSBDMTYuNTQzMzY2Myw5LjU0NzU2NDM2IDE2LjU3NjYzMzcsOC42NTAyOTcwMyAxNi40NTk0MDU5LDcuNzczMzA2OTMgQzE2LjM1NDg1MTUsNi45ODU1MDQ5NSAxNi4xMjY3MzI3LDYuMjE1Mjg3MTMgMTUuNzg2MTM4Niw1LjQ5NzE4ODEyIEMxNS4zOTMyNjczLDQuNjY5NDY1MzUgMTQuODUxNDg1MSwzLjkxMzgyMTc4IDE0LjE5NzIyNzcsMy4yNzM4MjE3OCBDMTMuNTA2NTM0NywyLjYwMDU1NDQ2IDEyLjY5MjI3NzIsMi4wNTcwMjk3IDExLjgwNTE0ODUsMS42ODE3NDI1NyBDMTEuMzM3ODIxOCwxLjQ4NDE5ODAyIDEwLjg0OTkwMSwxLjMzMjkxMDg5IDEwLjM1NDA1OTQsMS4yMzEzNjYzNCBDOS44NTY2MzM2NiwxLjEyOTgyMTc4IDkuMzUxMjg3MTMsMS4wNzc1NDQ1NSA4Ljg0NDM1NjQ0LDEuMDc0Mzc2MjQgQzguMzM3NDI1NzQsMS4wNzEyMDc5MiA3LjgyODkxMDg5LDEuMTE2OTkwMSA3LjMyOTkwMDk5LDEuMjEyNTE0ODUgQzYuODMwODkxMDksMS4zMDgxOTgwMiA2LjM0MTM4NjE0LDEuNDUzNDY1MzUgNS44NzI0NzUyNSwxLjY0NTQ2NTM1IEM0Ljk3OTAwOTksMi4wMTAyOTcwMyA0LjE1NjgzMTY4LDIuNTQ0MTU4NDIgMy40NTk4MDE5OCwzLjIwOTUwNDk1IEMyLjc5NjAzOTYsMy44NDEyNjczMyAyLjI0NjMzNjYzLDQuNTkwNDE1ODQgMS44NDM5NjA0LDUuNDEyNzUyNDggQzEuNDk1NDQ1NTQsNi4xMjU0NjUzNSAxLjI1NzgyMTc4LDYuODkxODgxMTkgMS4xNDM3NjIzOCw3LjY3Njk5MDEgQzEuMDE4NjEzODYsOC41MzY3MTI4NyAxLjAzNjAzOTYsOS40MTgxMzg2MSAxLjIwMDc5MjA4LDEwLjI3MTY4MzIgQzEuMzQzMzY2MzQsMTEuMDE2NzEyOSAxLjU5NjgzMTY4LDExLjczOTU2NDQgMS45NTAwOTkwMSwxMi40MTA0NTU0IEMyLjM0MTM4NjE0LDEzLjE1MTIwNzkgMi44NTMwNjkzMSwxMy44MjcxNjgzIDMuNDU5ODAxOTgsMTQuNDA1MDY5MyBDNC4wNzc2MjM3NiwxNC45OTQ1MzQ3IDQuNzkzNjYzMzcsMTUuNDgxMzQ2NSA1LjU2OTkwMDk5LDE1LjgzNzk0MDYgQzYuMjE5NDA1OTQsMTYuMTM2MjM3NiA2LjkxMDA5OTAxLDE2LjM0MzI4NzEgNy42MTY2MzM2NiwxNi40NTExNjgzIEM3Ljg1OTAwOTksMTYuNDg4MjM3NiA4LjEwMjk3MDMsMTYuNTEzNTg0MiA4LjM0NjkzMDY5LDE2LjUyNzUyNDggQzguNDYyNTc0MjYsMTYuNTM0MTc4MiA4LjU3ODIxNzgyLDE2LjUzNzgyMTggOC42OTM4NjEzOSwxNi41Mzk3MjI4IEM4LjcyODcxMjg3LDE2LjU0MDAzOTYgOC43NjAzOTYwNCwxNi41NDAxOTggOC43OTUyNDc1MiwxNi41NDAzNTY0IEw4Ljc5NTI0NzUyLDE2LjU0MDM1NjQgWiBNMTYuODUzODYxNCwxMi4xOTk2MDQgQzE2Ljc2OTkwMSwxMi4zOTg4OTExIDE2LjY3ODAxOTgsMTIuNTk1MDA5OSAxNi41Nzk4MDIsMTIuNzg3NDg1MSBDMTYuMTI1MTQ4NSwxMy42NzY4MzE3IDE1LjUxNTI0NzUsMTQuNDg2MTc4MiAxNC43ODgxMTg4LDE1LjE3MTQ4NTEgQzE0LjA3MjA3OTIsMTUuODQ2MDE5OCAxMy4yNDM1NjQ0LDE2LjM5ODg5MTEgMTIuMzQzNzYyNCwxNi43OTg3MzI3IEMxMS42MDM5NjA0LDE3LjEyNzc2MjQgMTAuODE4MjE3OCwxNy4zNTIzOTYgMTAuMDE2NjMzNywxNy40NjQ3MTI5IEM5Ljc0MjU3NDI2LDE3LjUwMzA0OTUgOS40NjUzNDY1MywxNy41MjgzOTYgOS4xODgxMTg4MSwxNy41NDA3NTI1IEM5LjA1NjYzMzY2LDE3LjU0NjYxMzkgOC45MjUxNDg1MSwxNy41NDg5OTAxIDguNzk1MjQ3NTIsMTcuNTQ5NDY1MyBDOC42NjM3NjIzOCwxNy41NDg5OTAxIDguNTMyMjc3MjMsMTcuNTQ2NjEzOSA4LjQwMDc5MjA4LDE3LjU0MDc1MjUgQzguMTIzNTY0MzYsMTcuNTI4Mzk2IDcuODQ3OTIwNzksMTcuNTAzMDQ5NSA3LjU3MjI3NzIzLDE3LjQ2NDcxMjkgQzYuNzcwNjkzMDcsMTcuMzUyMzk2IDUuOTg0OTUwNSwxNy4xMjc3NjI0IDUuMjQ1MTQ4NTEsMTYuNzk4NzMyNyBDNC4zMzEwODkxMSwxNi4zOTE3NjI0IDMuNDg2NzMyNjcsMTUuODI2MjE3OCAyLjc2Mjc3MjI4LDE1LjEzNTM2NjMgQzIuMDUzMDY5MzEsMTQuNDU3OTgwMiAxLjQ1NzQyNTc0LDEzLjY2MTMwNjkgMS4wMDkxMDg5MSwxMi43ODc0ODUxIEMwLjYzMzY2MzM2NiwxMi4wNTUxMjg3IDAuMzY0MzU2NDM2LDExLjI2OTcwMyAwLjIwOTEwODkxMSwxMC40NjE2MjM4IEMwLjAzMTY4MzE2ODMsOS41MzM2MjM3NiAwLjAwNDc1MjQ3NTI1LDguNTc2MzE2ODMgMC4xMjk5MDA5OSw3LjYzOTc2MjM4IEMwLjI0ODcxMjg3MSw2Ljc0ODY3MzI3IDAuNTA2OTMwNjkzLDUuODc3MDY5MzEgMC44OTE4ODExODgsNS4wNjQ3MTI4NyBDMS4zNDMzNjYzNCw0LjExMzQyNTc0IDEuOTY3NTI0NzUsMy4yNDY0MTU4NCAyLjcyNDc1MjQ4LDIuNTE1NDg1MTUgQzMuNTA4OTEwODksMS43NTg3MzI2NyA0LjQzNDA1OTQxLDEuMTUwMDk5MDEgNS40NCwwLjczMTcyMjc3MiBDNS45ODgxMTg4MSwwLjUwNDIzNzYyNCA2LjU1ODQxNTg0LDAuMzMyOTkwMDk5IDcuMTM5ODAxOTgsMC4yMjE0NjUzNDcgQzcuNjg0NzUyNDgsMC4xMTcwNjkzMDcgOC4yMzkyMDc5MiwwLjA2NTEwODkxMDkgOC43OTUyNDc1MiwwLjA2NTEwODkxMDkgQzkuMzQ5NzAyOTcsMC4wNjUxMDg5MTA5IDkuOTA0MTU4NDIsMC4xMTcwNjkzMDcgMTAuNDQ5MTA4OSwwLjIyMTQ2NTM0NyBDMTEuMDMwNDk1LDAuMzMyOTkwMDk5IDExLjYwMDc5MjEsMC41MDQyMzc2MjQgMTIuMTQ4OTEwOSwwLjczMTcyMjc3MiBDMTMuMTU0ODUxNSwxLjE1MDA5OTAxIDE0LjA4LDEuNzU4NzMyNjcgMTQuODY0MTU4NCwyLjUxNTMyNjczIEMxNS42MDg3MTI5LDMuMjMzOTAwOTkgMTYuMjI0OTUwNSw0LjA4NDQzNTY0IDE2LjY3NDg1MTUsNS4wMTY4NzEyOSBDMTYuNzM4MjE3OCw1LjE0ODAzOTYgMTYuNzk2ODMxNyw1LjI4MDc5MjA4IDE2Ljg1Mzg2MTQsNS40MTQ5NzAzIEwxNi44NTM4NjE0LDAuMDk0NDE1ODQxNiBMMTcuODQzOTYwNCwwLjA5NDQxNTg0MTYgTDE3Ljg0Mzk2MDQsMTcuNTIwMTU4NCBDMTcuODQyMzc2MiwxNy41MzkzMjY3IDE2Ljg1Mzg2MTQsMTcuNTIwMTU4NCAxNi44NTM4NjE0LDE3LjUyMDE1ODQgTDE2Ljg1Mzg2MTQsMTIuMTk5NjA0IEwxNi44NTM4NjE0LDEyLjE5OTYwNCBaXCJcbiAgICAgICAgICAgICAgaWQ9XCJTaGFwZVwiPjwvcGF0aD5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvZz5cbiAgICA8L2c+XG4gIDwvc3ZnPlxuPC90ZW1wbGF0ZT5cbiIsIjx0ZW1wbGF0ZSBiaW5kYWJsZT1cImNvbnRyb2xsZXJcIj5cbiAgPHJlcXVpcmUgZnJvbT1cIi4vY29udHJvbGxlci12aWV3LmNzc1wiPjwvcmVxdWlyZT5cblxuICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnlcIiBpZi5iaW5kPVwiY29udHJvbGxlci5iaW5kYWJsZXMubGVuZ3RoXCI+XG4gICAgPGg0IGNsYXNzPVwiY2F0ZWdvcnktbmFtZVwiPkJpbmRhYmxlczwvaDQ+XG4gICAgPHVsIGNsYXNzPVwicHJvcGVydGllc1wiPlxuICAgICAgPGxpIHJlcGVhdC5mb3I9XCJiaW5kYWJsZSBvZiBjb250cm9sbGVyLmJpbmRhYmxlc1wiPlxuICAgICAgICA8cHJvcGVydHktdmlld1xuICAgICAgICAgIGNvbnRyb2xsZXIuYmluZD1cImNvbnRyb2xsZXJcIlxuICAgICAgICAgIHByb3BlcnR5LmJpbmQ9XCJiaW5kYWJsZVwiXG4gICAgICAgID48L3Byb3BlcnR5LXZpZXc+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJjYXRlZ29yeVwiIGlmLmJpbmQ9XCJjb250cm9sbGVyLnByb3BlcnRpZXMubGVuZ3RoXCI+XG4gICAgPGg0IGNsYXNzPVwiY2F0ZWdvcnktbmFtZVwiPlByb3BlcnRpZXM8L2g0PlxuICAgIDx1bCBjbGFzcz1cInByb3BlcnRpZXNcIj5cbiAgICAgIDxsaSByZXBlYXQuZm9yPVwicHJvcGVydHkgb2YgY29udHJvbGxlci5wcm9wZXJ0aWVzXCI+XG4gICAgICAgIDxwcm9wZXJ0eS12aWV3XG4gICAgICAgICAgY29udHJvbGxlci5iaW5kPVwiY29udHJvbGxlclwiXG4gICAgICAgICAgcHJvcGVydHkuYmluZD1cInByb3BlcnR5XCJcbiAgICAgICAgPjwvcHJvcGVydHktdmlldz5cbiAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuIiwiPGltcG9ydCBmcm9tPVwiLi9kZWJ1Zy1ncm91cC5jc3NcIj48L2ltcG9ydD5cbjxzZWN0aW9uPlxuICA8aDIgY2xhc3M9XCJoZWFkZXJcIj4ke2hlYWRpbmd9PC9oMj5cbiAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICA8YXUtc2xvdD48L2F1LXNsb3Q+XG4gIDwvZGl2PlxuPC9zZWN0aW9uPlxuIiwiPHJlcXVpcmUgZnJvbT1cIi4vcHJvcGVydHktdmlldy5jc3NcIj48L3JlcXVpcmU+XG5cbjxzcGFuIGNsYXNzPVwicHJvcGVydHktbGluZVwiPlxuICA8c3BhblxuICAgIGNzcz1cIm9wYWNpdHk6ICR7cHJvcGVydHkuY2FuRXhwYW5kID8gMSA6IDB9XCJcbiAgICBjbGFzcz1cImFycm93XCJcbiAgICBjbGljay50cmlnZ2VyPVwiZGVidWdIb3N0LnRvZ2dsZURlYnVnVmFsdWVFeHBhbnNpb24ocHJvcGVydHkpXCJcbiAgPlxuICAgIDxzcGFuIGlmLmJpbmQ9XCJwcm9wZXJ0eS5pc0V4cGFuZGVkXCIgY2xhc3M9XCJkb3duXCI+4pa8PC9zcGFuPlxuICAgIDxzcGFuIGlmLmJpbmQ9XCIhcHJvcGVydHkuaXNFeHBhbmRlZFwiIGNsYXNzPVwicmlnaHRcIj7ilrY8L3NwYW4+XG4gIDwvc3Bhbj5cbiAgPHNwYW4gY2xhc3M9XCJwcm9wZXJ0eS1uYW1lXCI+JHtwcm9wZXJ0eS5uYW1lfTwvc3BhblxuICA+PHNwYW4gY2xhc3M9XCJ0b2tlbi1jb2xvblwiPjo8L3NwYW4+Jm5ic3A7XG5cbiAgPHNwYW4gY2xhc3M9XCJ2YWx1ZS1jb250YWluZXJcIj5cbiAgICA8c3BhblxuICAgICAgaWYuYmluZD1cInByb3BlcnR5LnR5cGUgPT09ICdzdHJpbmcnICYmICFwcm9wZXJ0eS5pc0VkaXRpbmdcIlxuICAgICAgY2xhc3M9XCJwcm9wZXJ0eS12YWx1ZSBzdHJpbmdcIlxuICAgICAgPlwiPC9zcGFuXG4gICAgPjxzcGFuXG4gICAgICBpZi5iaW5kPVwiIXByb3BlcnR5LmlzRWRpdGluZ1wiXG4gICAgICBjbGFzcz1cInByb3BlcnR5LXZhbHVlICR7cHJvcGVydHkudHlwZX1cIlxuICAgICAgY2xpY2sudHJpZ2dlcj1cImJlZ2luRWRpdGluZygpXCJcbiAgICAgID4ke3Byb3BlcnR5LnZhbHVlfTwvc3BhblxuICAgID48c3BhblxuICAgICAgaWYuYmluZD1cInByb3BlcnR5LnR5cGUgPT09ICdzdHJpbmcnICYmICFwcm9wZXJ0eS5pc0VkaXRpbmdcIlxuICAgICAgY2xhc3M9XCJwcm9wZXJ0eS12YWx1ZSBzdHJpbmdcIlxuICAgICAgPlwiPC9zcGFuXG4gICAgPlxuXG4gICAgPCEtLSA8c2VsZWN0XG4gICAgICBpZi5iaW5kPVwicHJvcGVydHkuaXNFZGl0aW5nICYmICBwcm9wZXJ0eS50eXBlID09PSAnYm9vbGVhbidcIlxuICAgICAgY2xhc3M9XCJwcm9wZXJ0eS1lZGl0b3JcIlxuICAgICAgdmFsdWUuYmluZD1cImZhbHNlXCJcbiAgICA+XG4gICAgICA8b3B0aW9uIG1vZGVsLmJpbmQ9XCJ0cnVlXCI+VHJ1ZTwvb3B0aW9uPlxuICAgICAgPG9wdGlvbiBtb2RlbC5iaW5kPVwiZmFsc2VcIj5GYWxzZTwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PiAtLT5cblxuICAgIDxpbnB1dFxuICAgICAgaWYuYmluZD1cInByb3BlcnR5LmlzRWRpdGluZ1wiXG4gICAgICBjbGFzcz1cInByb3BlcnR5LWVkaXRvclwiXG4gICAgICByZWY9XCJlZGl0b3JcIlxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgdmFsdWUuYmluZD1cInByb3BlcnR5LnZhbHVlXCJcbiAgICAgIGtleXVwLnRyaWdnZXI9XCJvbktleURvd24oJGV2ZW50KVwiXG4gICAgICBibHVyLnRyaWdnZXI9XCJlbmRFZGl0aW5nKClcIlxuICAgIC8+XG4gIDwvc3Bhbj5cbjwvc3Bhbj5cblxuPHVsIGlmLmJpbmQ9XCJwcm9wZXJ0eS5pc0V4cGFuZGVkICYmIHByb3BlcnR5LmV4cGFuZGVkVmFsdWVcIiBjbGFzcz1cInByb3BlcnRpZXNcIj5cbiAgPGRpdlxuICAgIGlmLmJpbmQ9XCIhcHJvcGVydHkuZXhwYW5kZWRWYWx1ZS5wcm9wZXJ0aWVzLmxlbmd0aFwiXG4gICAgY2xhc3M9XCJuby1wcm9wZXJ0aWVzXCJcbiAgPlxuICAgIE9iamVjdCBoYXMgbm8gcHJvcGVydGllcy5cbiAgPC9kaXY+XG4gIDxsaSByZXBlYXQuZm9yPVwicCBvZiBwcm9wZXJ0eS5leHBhbmRlZFZhbHVlLnByb3BlcnRpZXNcIj5cbiAgICA8cHJvcGVydHktdmlldyBwcm9wZXJ0eS5iaW5kPVwicFwiPjwvcHJvcGVydHktdmlldz5cbiAgPC9saT5cbjwvdWw+XG4iLCJpbXBvcnQgeyBESSwgUmVnaXN0cmF0aW9uIH0gZnJvbSAnQGF1cmVsaWEva2VybmVsJztcbmltcG9ydCB7IFN0YW5kYXJkQ29uZmlndXJhdGlvbiwgQXVyZWxpYSBhcyAkQXVyZWxpYSwgSVBsYXRmb3JtLCBDdXN0b21FbGVtZW50IH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbmltcG9ydCB7IEJyb3dzZXJQbGF0Zm9ybSB9IGZyb20gJ0BhdXJlbGlhL3BsYXRmb3JtLWJyb3dzZXInO1xuZXhwb3J0IGNvbnN0IFBMQVRGT1JNID0gQnJvd3NlclBsYXRmb3JtLmdldE9yQ3JlYXRlKGdsb2JhbFRoaXMpO1xuZXhwb3J0IHsgSVBsYXRmb3JtIH07XG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIERJLmNyZWF0ZUNvbnRhaW5lcigpXG4gICAgICAgIC5yZWdpc3RlcihSZWdpc3RyYXRpb24uaW5zdGFuY2UoSVBsYXRmb3JtLCBQTEFURk9STSksIFN0YW5kYXJkQ29uZmlndXJhdGlvbik7XG59XG5leHBvcnQgY2xhc3MgQXVyZWxpYSBleHRlbmRzICRBdXJlbGlhIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIgPSBjcmVhdGVDb250YWluZXIoKSkge1xuICAgICAgICBzdXBlcihjb250YWluZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQocm9vdCkge1xuICAgICAgICByZXR1cm4gbmV3IEF1cmVsaWEoKS5zdGFydChyb290KTtcbiAgICB9XG4gICAgc3RhdGljIGFwcChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXJlbGlhKCkuYXBwKGNvbmZpZyk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmhhbmNlKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IEF1cmVsaWEoKS5lbmhhbmNlKGNvbmZpZyk7XG4gICAgfVxuICAgIHN0YXRpYyByZWdpc3RlciguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXJlbGlhKCkucmVnaXN0ZXIoLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgYXBwKGNvbmZpZykge1xuICAgICAgICBpZiAoQ3VzdG9tRWxlbWVudC5pc1R5cGUoY29uZmlnKSkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXN0b20gZWxlbWVudCBlbGVtZW50IG5hbWVcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBDdXN0b21FbGVtZW50LmdldERlZmluaXRpb24oY29uZmlnKTtcbiAgICAgICAgICAgIGxldCBob3N0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihkZWZpbml0aW9uLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGhvc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIHRhcmdldCBpcyBmb3VuZCwgZGVmYXVsdCB0byBib2R5LlxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHVzZXIgZm9yZ290IHRvIHdyaXRlIDxteS1hcHA+PC9teS1hcHA+IGluIGh0bWwuXG4gICAgICAgICAgICAgICAgaG9zdCA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYXBwKHtcbiAgICAgICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29uZmlnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuYXBwKGNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgQXVyZWxpYTtcbmV4cG9ydCB7IFxuLy8gUmV0cnlDb25maWd1cmF0aW9uLFxuLy8gUmV0cnlhYmxlUmVxdWVzdCxcbi8vIFZhbGlkSW50ZXJjZXB0b3JNZXRob2ROYW1lLFxuanNvbiwgXG4vLyByZXRyeVN0cmF0ZWd5LFxuLy8gUmV0cnlJbnRlcmNlcHRvcixcbkh0dHBDbGllbnRDb25maWd1cmF0aW9uLCBIdHRwQ2xpZW50LCBJSHR0cENsaWVudCwgfSBmcm9tICdAYXVyZWxpYS9mZXRjaC1jbGllbnQnO1xuZXhwb3J0IHsgYWxsLCBESSwgSUNvbnRhaW5lciwgXG4vLyBJRGVmYXVsdGFibGVJbnRlcmZhY2VTeW1ib2wsXG4vLyBJRmFjdG9yeSxcbmluamVjdCwgSVNlcnZpY2VMb2NhdG9yLCBsYXp5LCBvcHRpb25hbCwgXG4vLyBSZWdpc3RlclNlbGYsXG5SZWdpc3RyYXRpb24sIFxuLy8gUmVzb2x2ZUNhbGxiYWNrLFxuc2luZ2xldG9uLCB0cmFuc2llbnQsIFxuLy8gSW5qZWN0YWJsZSxcbi8vIEludGVyZmFjZVN5bWJvbCxcbkluc3RhbmNlUHJvdmlkZXIsIFxuLy8gSVBlcmZvcm1hbmNlLFxuLy8gSVRpbWVySGFuZGxlcixcbi8vIElXaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlLFxuLy8gS25vd25LZXlzLFxuLy8gTm9JbmZlcixcbi8vIE9taXQsXG4vLyBPcHRpb25hbEtub3duS2V5cyxcbi8vIE9wdGlvbmFsVmFsdWVzT2YsXG4vLyBPdmVyd3JpdGUsXG4vLyBQYXJhbTAsXG4vLyBQYXJhbTEsXG4vLyBQYXJhbTIsXG4vLyBQYXJhbTMsXG4vLyBQaWNrMixcbi8vIFBpY2szLFxuLy8gUHJpbWl0aXZlLFxuLy8gUHVibGljLFxuLy8gUHVyaWZ5LFxuLy8gUmVxdWlyZWRLbm93bktleXMsXG4vLyBSZXF1aXJlZFZhbHVlc09mLFxuLy8gU3RyaWN0UHJpbWl0aXZlLFxuLy8gVW53cmFwLFxuLy8gVmFsdWVzT2YsXG4vLyBXcml0YWJsZSxcbi8vIElmRXF1YWxzLFxuLy8gUmVhZG9ubHlLZXlzLFxuLy8gV3JpdGFibGVLZXlzLFxuLy8gbWV0YWRhdGEsXG5NZXRhZGF0YSwgXG4vLyBJQ29uc29sZUxpa2UsXG5Db2xvck9wdGlvbnMsIFxuLy8gSUxvZ0NvbmZpZyxcbi8vIElMb2dFdmVudCxcbi8vIElMb2dFdmVudEZhY3RvcnksXG4vLyBJU2luayxcbklMb2dnZXIsIFxuLy8gTG9nQ29uZmlnLFxuLy8gRGVmYXVsdExvZ0V2ZW50LFxuLy8gRGVmYXVsdExvZ0V2ZW50RmFjdG9yeSxcbi8vIERlZmF1bHRMb2dnZXIsXG4vLyBDb25zb2xlU2luayxcbkxvZ2dlckNvbmZpZ3VyYXRpb24sIFxuLy8gcmVsYXRpdmVUb0ZpbGUsXG4vLyBqb2luLFxuLy8gcGFyc2VRdWVyeVN0cmluZyxcbi8vIElRdWVyeVBhcmFtcyxcbmVtcHR5QXJyYXksIGVtcHR5T2JqZWN0LCBub29wLCBcbi8vIElUcmFjZUluZm8sXG4vLyBJVHJhY2VXcml0ZXIsXG4vLyBJTGl2ZUxvZ2dpbmdPcHRpb25zLFxuTG9nTGV2ZWwsIFxuLy8gSVJlc291cmNlRGVmaW5pdGlvbixcbi8vIElSZXNvdXJjZURlc2NyaXB0aW9ucyxcbi8vIElSZXNvdXJjZUtpbmQsXG4vLyBJUmVzb3VyY2VUeXBlLFxuLy8gUmVzb3VyY2VEZXNjcmlwdGlvbixcbi8vIFJlc291cmNlUGFydERlc2NyaXB0aW9uLFxuLy8gZnJvbUFubm90YXRpb25PckRlZmluaXRpb25PclR5cGVPckRlZmF1bHQsXG4vLyBmcm9tQW5ub3RhdGlvbk9yVHlwZU9yRGVmYXVsdCxcbi8vIGZyb21EZWZpbml0aW9uT3JEZWZhdWx0LFxuRXZlbnRBZ2dyZWdhdG9yLCBJRXZlbnRBZ2dyZWdhdG9yLCBpc0FycmF5SW5kZXgsIGNhbWVsQ2FzZSwga2ViYWJDYXNlLCBwYXNjYWxDYXNlLCB0b0FycmF5LCBcbi8vIG5leHRJZCxcbi8vIHJlc2V0SWQsXG4vLyBjb21wYXJlTnVtYmVyLFxuLy8gbWVyZ2VEaXN0aW5jdCxcbi8vIGlzTnVtYmVyT3JCaWdJbnQsXG4vLyBpc1N0cmluZ09yRGF0ZSxcbmJvdW5kLCB9IGZyb20gJ0BhdXJlbGlhL2tlcm5lbCc7XG5leHBvcnQgeyBcbi8vIE5hdixcbk5hdlJvdXRlLCBcbi8vIElTdG9yZWROYXZpZ2F0b3JFbnRyeSxcbi8vIElOYXZpZ2F0b3JFbnRyeSxcbi8vIElOYXZpZ2F0b3JPcHRpb25zLFxuLy8gSU5hdmlnYXRvckZsYWdzLFxuLy8gSU5hdmlnYXRvclN0YXRlLFxuLy8gSU5hdmlnYXRvclN0b3JlLFxuLy8gSU5hdmlnYXRvclZpZXdlcixcbi8vIElOYXZpZ2F0b3JWaWV3ZXJFdmVudCxcbi8vIE5hdmlnYXRvcixcbi8vIFF1ZXVlSXRlbSxcbi8vIElRdWV1ZU9wdGlvbnMsXG4vLyBRdWV1ZSxcbi8vIFJvdXRlSGFuZGxlcixcbi8vIENvbmZpZ3VyYWJsZVJvdXRlLFxuLy8gSGFuZGxlckVudHJ5LFxuLy8gUm91dGVHZW5lcmF0b3IsXG4vLyBUeXBlc1JlY29yZCxcbi8vIFJlY29nbml6ZVJlc3VsdCxcbi8vIFJlY29nbml6ZVJlc3VsdHMsXG4vLyBDaGFyU3BlYyxcbi8vIC8vIFN0YXRlIGFzIFJvdXRlclN0YXRlLCAvLyBkdXBsaWNhdGVkIGluIEBhdXJlbGlhL3J1bnRpbWVcbi8vIFN0YXRpY1NlZ21lbnQsXG4vLyBEeW5hbWljU2VnbWVudCxcbi8vIFN0YXJTZWdtZW50LFxuLy8gRXBzaWxvblNlZ21lbnQsXG4vLyBTZWdtZW50LFxuLy8gUm91dGVSZWNvZ25pemVyLFxuUm91dGVyT3B0aW9ucywgSVJvdXRlciwgUm91dGVyLCBcbi8vIElWaWV3cG9ydE9wdGlvbnMsXG4vLyBWaWV3cG9ydCxcbi8vIENvbnRlbnRTdGF0dXMsXG4vLyBWaWV3cG9ydENvbnRlbnQsXG5WaWV3cG9ydEluc3RydWN0aW9uLCBSb3V0ZXJDb25maWd1cmF0aW9uLCBSb3V0ZXJSZWdpc3RyYXRpb24sIH0gZnJvbSAnQGF1cmVsaWEvcm91dGVyJztcbmV4cG9ydCB7IFxuLy8gQ2FsbEZ1bmN0aW9uRXhwcmVzc2lvbixcbi8vIGNvbm5lY3RzLFxuLy8gb2JzZXJ2ZXMsXG4vLyBjYWxsc0Z1bmN0aW9uLFxuLy8gaGFzQW5jZXN0b3IsXG4vLyBpc0Fzc2lnbmFibGUsXG4vLyBpc0xlZnRIYW5kU2lkZSxcbi8vIGlzUHJpbWFyeSxcbi8vIGlzUmVzb3VyY2UsXG4vLyBoYXNCaW5kLFxuLy8gaGFzVW5iaW5kLFxuLy8gaXNMaXRlcmFsLFxuLy8gYXJlUHVyZUxpdGVyYWxzLFxuLy8gaXNQdXJlTGl0ZXJhbCxcbi8vIEN1c3RvbUV4cHJlc3Npb24sXG4vLyBCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uLFxuLy8gVmFsdWVDb252ZXJ0ZXJFeHByZXNzaW9uLFxuLy8gQXNzaWduRXhwcmVzc2lvbixcbi8vIENvbmRpdGlvbmFsRXhwcmVzc2lvbixcbi8vIEFjY2Vzc1RoaXNFeHByZXNzaW9uLFxuLy8gQWNjZXNzU2NvcGVFeHByZXNzaW9uLFxuLy8gQWNjZXNzTWVtYmVyRXhwcmVzc2lvbixcbi8vIEFjY2Vzc0tleWVkRXhwcmVzc2lvbixcbi8vIENhbGxTY29wZUV4cHJlc3Npb24sXG4vLyBDYWxsTWVtYmVyRXhwcmVzc2lvbixcbi8vIEJpbmFyeUV4cHJlc3Npb24sXG4vLyBVbmFyeUV4cHJlc3Npb24sXG4vLyBQcmltaXRpdmVMaXRlcmFsRXhwcmVzc2lvbixcbi8vIEh0bWxMaXRlcmFsRXhwcmVzc2lvbixcbi8vIEFycmF5TGl0ZXJhbEV4cHJlc3Npb24sXG4vLyBPYmplY3RMaXRlcmFsRXhwcmVzc2lvbixcbi8vIFRlbXBsYXRlRXhwcmVzc2lvbixcbi8vIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbixcbi8vIEFycmF5QmluZGluZ1BhdHRlcm4sXG4vLyBPYmplY3RCaW5kaW5nUGF0dGVybixcbi8vIEJpbmRpbmdJZGVudGlmaWVyLFxuLy8gRm9yT2ZTdGF0ZW1lbnQsXG4vLyBJbnRlcnBvbGF0aW9uLFxuLy8gQW55QmluZGluZ0V4cHJlc3Npb24sXG4vLyBJc1ByaW1hcnksXG4vLyBJc0xpdGVyYWwsXG4vLyBJc0xlZnRIYW5kU2lkZSxcbi8vIElzVW5hcnksXG4vLyBJc0JpbmFyeSxcbi8vIElzQ29uZGl0aW9uYWwsXG4vLyBJc0Fzc2lnbixcbi8vIElzVmFsdWVDb252ZXJ0ZXIsXG4vLyBJc0JpbmRpbmdCZWhhdmlvcixcbi8vIElzQXNzaWduYWJsZSxcbi8vIElzRXhwcmVzc2lvbixcbi8vIElzRXhwcmVzc2lvbk9yU3RhdGVtZW50LFxuLy8gQ29ubmVjdHMsXG4vLyBPYnNlcnZlcyxcbi8vIENhbGxzRnVuY3Rpb24sXG4vLyBJc1Jlc291cmNlLFxuLy8gSGFzQmluZCxcbi8vIEhhc1VuYmluZCxcbi8vIEhhc0FuY2VzdG9yLFxuLy8gSVZpc2l0b3IsXG4vLyBJRXhwcmVzc2lvbixcbi8vIElBY2Nlc3NLZXllZEV4cHJlc3Npb24sXG4vLyBJQWNjZXNzTWVtYmVyRXhwcmVzc2lvbixcbi8vIElBY2Nlc3NTY29wZUV4cHJlc3Npb24sXG4vLyBJQWNjZXNzVGhpc0V4cHJlc3Npb24sXG4vLyBJQXJyYXlCaW5kaW5nUGF0dGVybixcbi8vIElBcnJheUxpdGVyYWxFeHByZXNzaW9uLFxuLy8gSUFzc2lnbkV4cHJlc3Npb24sXG4vLyBJQmluYXJ5RXhwcmVzc2lvbixcbi8vIElCaW5kaW5nQmVoYXZpb3JFeHByZXNzaW9uLFxuLy8gSUJpbmRpbmdJZGVudGlmaWVyLFxuLy8gSUNhbGxGdW5jdGlvbkV4cHJlc3Npb24sXG4vLyBJQ2FsbE1lbWJlckV4cHJlc3Npb24sXG4vLyBJQ2FsbFNjb3BlRXhwcmVzc2lvbixcbi8vIElDb25kaXRpb25hbEV4cHJlc3Npb24sXG4vLyBGb3JPZlN0YXRlbWVudCxcbi8vIElIdG1sTGl0ZXJhbEV4cHJlc3Npb24sXG4vLyBJbnRlcnBvbGF0aW9uLFxuLy8gSU9iamVjdEJpbmRpbmdQYXR0ZXJuLFxuLy8gSU9iamVjdExpdGVyYWxFeHByZXNzaW9uLFxuLy8gSVByaW1pdGl2ZUxpdGVyYWxFeHByZXNzaW9uLFxuLy8gSVRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbixcbi8vIElUZW1wbGF0ZUV4cHJlc3Npb24sXG4vLyBJVW5hcnlFeHByZXNzaW9uLFxuLy8gSVZhbHVlQ29udmVydGVyRXhwcmVzc2lvbixcbi8vIEJpbmFyeU9wZXJhdG9yLFxuLy8gQmluZGluZ0lkZW50aWZpZXJPclBhdHRlcm4sXG4vLyBVbmFyeU9wZXJhdG9yLFxuLy8gUHJvcGVydHlCaW5kaW5nLFxuLy8gQ2FsbEJpbmRpbmcsXG4vLyBJUGFydGlhbENvbm5lY3RhYmxlQmluZGluZyxcbi8vIElDb25uZWN0YWJsZUJpbmRpbmcsXG4vLyBjb25uZWN0YWJsZSxcbi8vIElFeHByZXNzaW9uUGFyc2VyLFxuLy8gQmluZGluZ1R5cGUsXG4vLyBNdWx0aUludGVycG9sYXRpb25CaW5kaW5nLFxuLy8gSW50ZXJwb2xhdGlvbkJpbmRpbmcsXG4vLyBMZXRCaW5kaW5nLFxuLy8gUmVmQmluZGluZyxcbi8vIEFycmF5T2JzZXJ2ZXIsXG4vLyBlbmFibGVBcnJheU9ic2VydmF0aW9uLFxuLy8gZGlzYWJsZUFycmF5T2JzZXJ2YXRpb24sXG4vLyBhcHBseU11dGF0aW9uc1RvSW5kaWNlcyxcbi8vIHN5bmNocm9uaXplSW5kaWNlcyxcbi8vIE1hcE9ic2VydmVyLFxuLy8gZW5hYmxlTWFwT2JzZXJ2YXRpb24sXG4vLyBkaXNhYmxlTWFwT2JzZXJ2YXRpb24sXG4vLyBTZXRPYnNlcnZlcixcbi8vIGVuYWJsZVNldE9ic2VydmF0aW9uLFxuLy8gZGlzYWJsZVNldE9ic2VydmF0aW9uLFxuLy8gQmluZGluZ0NvbnRleHQsXG4vLyBPdmVycmlkZUNvbnRleHQsXG4vLyBDb2xsZWN0aW9uTGVuZ3RoT2JzZXJ2ZXIsXG4vLyBDb2xsZWN0aW9uU2l6ZU9ic2VydmVyLFxuLy8gSURpcnR5Q2hlY2tlcixcbi8vIERpcnR5Q2hlY2tQcm9wZXJ0eSxcbi8vIERpcnR5Q2hlY2tTZXR0aW5ncyxcbkNvbXB1dGVkT2JzZXJ2ZXIsIENvbXB1dGVkV2F0Y2hlciwgRXhwcmVzc2lvbldhdGNoZXIsIFdhdGNoLCB3YXRjaCwgXG4vLyBJT2JqZWN0T2JzZXJ2YXRpb25BZGFwdGVyLFxuSU9ic2VydmVyTG9jYXRvciwgXG4vLyBJVGFyZ2V0T2JzZXJ2ZXJMb2NhdG9yLFxuLy8gSVRhcmdldEFjY2Vzc29yTG9jYXRvcixcbi8vIGdldENvbGxlY3Rpb25PYnNlcnZlcixcbi8vIE9ic2VydmVyTG9jYXRvcixcbi8vIFByaW1pdGl2ZU9ic2VydmVyLFxuLy8gUHJvcGVydHlBY2Nlc3Nvcixcbi8vIEJpbmRhYmxlT2JzZXJ2ZXIsXG4vLyBTZXR0ZXJPYnNlcnZlcixcbklTaWduYWxlciwgc3Vic2NyaWJlckNvbGxlY3Rpb24sIGJpbmRpbmdCZWhhdmlvciwgQmluZGluZ0JlaGF2aW9yLCBcbi8vIFBhcnRpYWxCaW5kaW5nQmVoYXZpb3JEZWZpbml0aW9uLFxuLy8gQmluZGluZ0JlaGF2aW9yS2luZCxcbi8vIEJpbmRpbmdCZWhhdmlvckRlY29yYXRvcixcbi8vIEJpbmRpbmdCZWhhdmlvckluc3RhbmNlLFxuLy8gQmluZGluZ0JlaGF2aW9yVHlwZSxcbi8vIEJpbmRpbmdNb2RlQmVoYXZpb3IsXG4vLyBPbmVUaW1lQmluZGluZ0JlaGF2aW9yLFxuLy8gVG9WaWV3QmluZGluZ0JlaGF2aW9yLFxuLy8gRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3IsXG4vLyBUd29XYXlCaW5kaW5nQmVoYXZpb3IsXG4vLyBEZWJvdW5jZUJpbmRpbmdCZWhhdmlvcixcbi8vIFNpZ25hbGFibGVCaW5kaW5nLFxuLy8gU2lnbmFsQmluZGluZ0JlaGF2aW9yLFxuLy8gVGhyb3R0bGVCaW5kaW5nQmVoYXZpb3IsXG5jdXN0b21BdHRyaWJ1dGUsIFxuLy8gQ3VzdG9tQXR0cmlidXRlRGVjb3JhdG9yLFxuQ3VzdG9tQXR0cmlidXRlLCBcbi8vIEN1c3RvbUF0dHJpYnV0ZURlZmluaXRpb25cbi8vIEN1c3RvbUF0dHJpYnV0ZUtpbmQsXG4vLyBDdXN0b21BdHRyaWJ1dGVUeXBlLFxuLy8gUGFydGlhbEN1c3RvbUF0dHJpYnV0ZURlZmluaXRpb24sXG50ZW1wbGF0ZUNvbnRyb2xsZXIsIFxuLy8gRnJlcXVlbnRNdXRhdGlvbnMsXG4vLyBJbmZyZXF1ZW50TXV0YXRpb25zLFxuLy8gT2JzZXJ2ZVNoYWxsb3csXG4vLyBJZixcbi8vIEVsc2UsXG4vLyBSZXBlYXQsXG4vLyBSZXBsYWNlYWJsZSxcbi8vIFdpdGgsXG5jb250YWluZXJsZXNzLCBjdXN0b21FbGVtZW50LCBDdXN0b21FbGVtZW50LCBcbi8vIEN1c3RvbUVsZW1lbnREZWNvcmF0b3IsXG4vLyBDdXN0b21FbGVtZW50S2luZCxcbi8vIEN1c3RvbUVsZW1lbnRUeXBlLFxuLy8gQ3VzdG9tRWxlbWVudERlZmluaXRpb24sXG4vLyBQYXJ0aWFsQ3VzdG9tRWxlbWVudERlZmluaXRpb24sXG4vLyBJRWxlbWVudFByb2plY3Rvcixcbi8vIElQcm9qZWN0b3JMb2NhdG9yLFxudXNlU2hhZG93RE9NLCBWYWx1ZUNvbnZlcnRlciwgXG4vLyBWYWx1ZUNvbnZlcnRlclR5cGUsXG52YWx1ZUNvbnZlcnRlciwgXG4vLyBJU2FuaXRpemVyLFxuLy8gU2FuaXRpemVWYWx1ZUNvbnZlcnRlcixcbi8vIFZpZXdWYWx1ZUNvbnZlcnRlcixcbi8vIENsb2NrLFxuLy8gSUNsb2NrLFxuLy8gSUNsb2NrU2V0dGluZ3MsXG4vLyBJVGFzayxcbi8vIFRhc2tRdWV1ZSxcbi8vIFF1ZXVlVGFza09wdGlvbnMsXG4vLyBUYXNrLFxuLy8gVGFza0Fib3J0RXJyb3IsXG4vLyBUYXNrQ2FsbGJhY2ssXG4vLyBUYXNrUXVldWUsXG5BcHBUYXNrLCBUYXNrUXVldWVQcmlvcml0eSwgXG4vLyBUYXNrU3RhdHVzLFxuLy8gUXVldWVUYXNrVGFyZ2V0T3B0aW9ucyxcbmJpbmRhYmxlLCBcbi8vIFBhcnRpYWxCaW5kYWJsZURlZmluaXRpb24sXG4vLyBCaW5kYWJsZURlZmluaXRpb24sXG5CaW5kYWJsZSwgXG4vLyBQYXJ0aWFsQ2hpbGRyZW5EZWZpbml0aW9uLFxuLy8gQ2hpbGRyZW5EZWZpbml0aW9uLFxuLy8gQ2hpbGRyZW4sXG5jaGlsZHJlbiwgXG4vLyBUaGVzZSBleHBvcnRzIGFyZSB0ZW1wb3JhcnkgdW50aWwgd2UgaGF2ZSBhIHByb3BlciB3YXkgdG8gdW5pdCB0ZXN0IHRoZW1cbkNvbnRyb2xsZXIsIFZpZXdGYWN0b3J5LCBcbi8vIElWaWV3TG9jYXRvcixcbi8vIFZpZXdMb2NhdG9yLFxuLy8gdmlldyxcbi8vIFZpZXdzLFxuLy8gQXVyZWxpYSwgLy8gUmVwbGFjZWQgYnkgcXVpY2stc3RhcnQgd3JhcHBlclxuLy8gSURPTUluaXRpYWxpemVyLFxuLy8gSVNpbmdsZVBhZ2VBcHAsXG5JQXBwUm9vdCwgXG4vLyBJZlJlZ2lzdHJhdGlvbixcbi8vIEVsc2VSZWdpc3RyYXRpb24sXG4vLyBSZXBlYXRSZWdpc3RyYXRpb24sXG4vLyBSZXBsYWNlYWJsZVJlZ2lzdHJhdGlvbixcbi8vIFdpdGhSZWdpc3RyYXRpb24sXG4vLyBTYW5pdGl6ZVZhbHVlQ29udmVydGVyUmVnaXN0cmF0aW9uLFxuLy8gRGVib3VuY2VCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4vLyBPbmVUaW1lQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuLy8gVG9WaWV3QmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuLy8gRnJvbVZpZXdCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4vLyBTaWduYWxCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4vLyBUaHJvdHRsZUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbi8vIFR3b1dheUJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbi8vIFJlZkJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIENhbGxCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBDdXN0b21BdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIEN1c3RvbUVsZW1lbnRSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIEludGVycG9sYXRpb25CaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBJdGVyYXRvckJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIExldEVsZW1lbnRSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIFByb3BlcnR5QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gU2V0UHJvcGVydHlSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIFRlbXBsYXRlQ29udHJvbGxlclJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gRGVmYXVsdFJlc291cmNlcyBhcyBSdW50aW1lRGVmYXVsdFJlc291cmNlcyxcbi8vIElPYnNlcnZlckxvY2F0b3JSZWdpc3RyYXRpb24sXG4vLyBJUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBSdW50aW1lQ29uZmlndXJhdGlvbixcbi8vIEF0dHJpYnV0ZUluc3RydWN0aW9uLFxuLy8gSUNhbGxCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBJSHlkcmF0ZUF0dHJpYnV0ZUluc3RydWN0aW9uLFxuLy8gSUh5ZHJhdGVFbGVtZW50SW5zdHJ1Y3Rpb24sXG4vLyBJSHlkcmF0ZUxldEVsZW1lbnRJbnN0cnVjdGlvbixcbi8vIElIeWRyYXRlVGVtcGxhdGVDb250cm9sbGVyLFxuLy8gSUludGVycG9sYXRpb25JbnN0cnVjdGlvbixcbi8vIElJdGVyYXRvckJpbmRpbmdJbnN0cnVjdGlvbixcbi8vIElMZXRCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBJSW5zdHJ1Y3Rpb25Sb3csXG4vLyBJbnN0cnVjdGlvblR5cGVOYW1lLFxuLy8gSVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uLFxuLy8gSVJlZkJpbmRpbmdJbnN0cnVjdGlvbixcbi8vIElTZXRQcm9wZXJ0eUluc3RydWN0aW9uLFxuLy8gaXNJbnN0cnVjdGlvbixcbi8vIElJbnN0cnVjdGlvbixcbi8vIE5vZGVJbnN0cnVjdGlvbixcbi8vIElJbnN0cnVjdGlvbixcbi8vIEluc3RydWN0aW9uVHlwZSxcbi8vIFBhcnRpYWxDdXN0b21FbGVtZW50RGVmaW5pdGlvblBhcnRzLFxuYWxpYXMsIHJlZ2lzdGVyQWxpYXNlcywgXG4vLyBET00sIHNob3VsZCBleHBvc2UgdGhlIG9uZSBleHBvcnRlZCBpbiBydW50aW1lLWh0bWxcbklOb2RlLCBJRXZlbnRUYXJnZXQsIElSZW5kZXJMb2NhdGlvbiwgXG4vLyBOb2RlU2VxdWVuY2UsXG4vLyBJTm9kZVNlcXVlbmNlLFxuLy8gSU5vZGVTZXF1ZW5jZUZhY3RvcnksXG5CaW5kaW5nTW9kZSwgXG4vLyBFeHByZXNzaW9uS2luZCxcbi8vIEhvb2tzLFxuTGlmZWN5Y2xlRmxhZ3MsIFxuLy8gSU9ic2VydmFibGUsXG4vLyBJT2JzZXJ2ZWRBcnJheSxcbi8vIElPYnNlcnZlZE1hcCxcbi8vIElPYnNlcnZlZFNldCxcbi8vIElPdmVycmlkZUNvbnRleHQsXG4vLyBTY29wZSxcbi8vIElTdWJzY3JpYmFibGUsXG4vLyBJU3Vic2NyaWJlckNvbGxlY3Rpb24sXG4vLyBPYnNlcnZlZENvbGxlY3Rpb24sXG4vLyBDb2xsZWN0aW9uT2JzZXJ2ZXIsXG4vLyBJQ29sbGVjdGlvblN1YnNjcmliZXJDb2xsZWN0aW9uLFxuLy8gSUNvbGxlY3Rpb25TdWJzY3JpYmFibGUsXG4vLyBJU3Vic2NyaWJlcixcbi8vIGlzSW5kZXhNYXAsXG4vLyBjb3B5SW5kZXhNYXAsXG4vLyBjbG9uZUluZGV4TWFwLFxuLy8gY3JlYXRlSW5kZXhNYXAsXG5yZW5kZXJlciwgXG4vLyBEZWZhdWx0QmluZGluZ0xhbmd1YWdlIGFzIEppdERlZmF1bHRCaW5kaW5nTGFuZ3VhZ2UsXG4vLyBKaXRDb25maWd1cmF0aW9uLFxuLy8gQWNjZXNzLFxuLy8gUHJlY2VkZW5jZSxcbi8vIENoYXIsXG4vLyBUaGVzZSBleHBvcnRzIGFyZSB0ZW1wb3JhcnkgdW50aWwgd2UgaGF2ZSBhIHByb3BlciB3YXkgdG8gdW5pdCB0ZXN0IHRoZW1cbi8vIHBhcnNlRXhwcmVzc2lvbixcbi8vIHBhcnNlLFxuLy8gUGFyc2VyU3RhdGUsXG4vLyBCaW5kYWJsZUluZm8sXG4vLyBFbGVtZW50SW5mbyxcbi8vIEF0dHJJbmZvLFxuLy8gQW55U3ltYm9sLFxuLy8gQmluZGluZ1N5bWJvbCxcbi8vIEN1c3RvbUF0dHJpYnV0ZVN5bWJvbCxcbi8vIEN1c3RvbUVsZW1lbnRTeW1ib2wsXG4vLyBFbGVtZW50U3ltYm9sLFxuLy8gTGV0RWxlbWVudFN5bWJvbCxcbi8vIE5vZGVTeW1ib2wsXG4vLyBQYXJlbnROb2RlU3ltYm9sLFxuLy8gUGxhaW5BdHRyaWJ1dGVTeW1ib2wsXG4vLyBQbGFpbkVsZW1lbnRTeW1ib2wsXG4vLyBSZXBsYWNlUGFydFN5bWJvbCxcbi8vIFJlc291cmNlQXR0cmlidXRlU3ltYm9sLFxuLy8gU3ltYm9sRmxhZ3MsXG4vLyBTeW1ib2xXaXRoQmluZGluZ3MsXG4vLyBTeW1ib2xXaXRoTWFya2VyLFxuLy8gU3ltYm9sV2l0aFRlbXBsYXRlLFxuLy8gVGVtcGxhdGVDb250cm9sbGVyU3ltYm9sLFxuLy8gVGV4dFN5bWJvbFxuSUF1cmVsaWEsIFxuLy8gTGlzdGVuZXIsXG4vLyBBdHRyaWJ1dGVCaW5kaW5nLFxuLy8gQXR0cmlidXRlTlNBY2Nlc3Nvcixcbi8vIElJbnB1dEVsZW1lbnQsXG4vLyBDaGVja2VkT2JzZXJ2ZXIsXG4vLyBDbGFzc0F0dHJpYnV0ZUFjY2Vzc29yLFxuLy8gRGF0YUF0dHJpYnV0ZUFjY2Vzc29yLFxuLy8gRWxlbWVudFByb3BlcnR5QWNjZXNzb3IsXG4vLyBJTWFuYWdlZEV2ZW50LFxuLy8gTGlzdGVuZXJUcmFja2VyLFxuLy8gRGVsZWdhdGVPckNhcHR1cmVTdWJzY3JpcHRpb24sXG4vLyBUcmlnZ2VyU3Vic2NyaXB0aW9uLFxuLy8gSUVsZW1lbnRDb25maWd1cmF0aW9uLFxuLy8gSUV2ZW50RGVsZWdhdG9yLFxuLy8gSUV2ZW50U3Vic2NyaWJlcixcbi8vIElFdmVudFRhcmdldFdpdGhMb29rdXBzLFxuLy8gRXZlbnRTdWJzY3JpYmVyLFxuLy8gRXZlbnRTdWJzY3JpcHRpb24sXG4vLyBFdmVudERlbGVnYXRvcixcbk5vZGVPYnNlcnZlckxvY2F0b3IsIFxuLy8gVGFyZ2V0QWNjZXNzb3JMb2NhdG9yLFxuLy8gVGFyZ2V0T2JzZXJ2ZXJMb2NhdG9yLFxuLy8gSVNlbGVjdEVsZW1lbnQsXG4vLyBJT3B0aW9uRWxlbWVudCxcbi8vIFNlbGVjdFZhbHVlT2JzZXJ2ZXIsXG4vLyBTdHlsZUF0dHJpYnV0ZUFjY2Vzc29yLFxuLy8gSVNWR0FuYWx5emVyLFxuLy8gVmFsdWVBdHRyaWJ1dGVPYnNlcnZlcixcbi8vIEF0dHJCaW5kaW5nQmVoYXZpb3IsXG4vLyBTZWxmYWJsZUJpbmRpbmcsXG4vLyBTZWxmQmluZGluZ0JlaGF2aW9yLFxuLy8gVXBkYXRlVHJpZ2dlckJpbmRpbmdCZWhhdmlvcixcbi8vIFVwZGF0ZVRyaWdnZXJhYmxlQmluZGluZyxcbi8vIFVwZGF0ZVRyaWdnZXJhYmxlT2JzZXJ2ZXIsXG4vLyBCbHVyLFxuLy8gQmx1ck1hbmFnZXIsXG4vLyBGb2N1cyxcbi8vIFBvcnRhbCxcbi8vIFBvcnRhbFRhcmdldCxcbi8vIFBvcnRhbExpZmVjeWNsZUNhbGxiYWNrLFxuLy8gU3ViamVjdCxcbi8vIENvbXBvc2UsXG4vLyBJUHJvamVjdG9yTG9jYXRvclJlZ2lzdHJhdGlvbixcbi8vIElUYXJnZXRBY2Nlc3NvckxvY2F0b3JSZWdpc3RyYXRpb24sXG4vLyBJVGFyZ2V0T2JzZXJ2ZXJMb2NhdG9yUmVnaXN0cmF0aW9uLFxuLy8gSVRlbXBsYXRlRmFjdG9yeVJlZ2lzdHJhdGlvbixcbi8vIERlZmF1bHRDb21wb25lbnRzIGFzIFJ1bnRpbWVIdG1sRGVmYXVsdENvbXBvbmVudHMsXG4vLyBDb21waWxlZFRlbXBsYXRlLFxuLy8gQ2hpbGRyZW5PYnNlcnZlcixcbi8vIElSZW5kZXJlcixcbi8vIElJbnN0cnVjdGlvblR5cGVDbGFzc2lmaWVyLFxuLy8gSVJlbmRlcmluZ0VuZ2luZSxcbi8vIElUZW1wbGF0ZSxcbi8vIElUZW1wbGF0ZUNvbXBpbGVyLFxuLy8gSVRlbXBsYXRlRmFjdG9yeSxcbi8vIFJlbmRlckNvbnRleHRcbi8vIEF0dHJTeW50YXgsXG4vLyBJQXR0cmlidXRlUGFyc2VyLFxuYXR0cmlidXRlUGF0dGVybiwgXG4vLyBBdHRyaWJ1dGVQYXR0ZXJuRGVmaW5pdGlvbixcbklBdHRyaWJ1dGVQYXR0ZXJuLCBcbi8vIElBdHRyaWJ1dGVQYXR0ZXJuSGFuZGxlcixcbi8vIEludGVycHJldGF0aW9uLFxuLy8gSVN5bnRheEludGVycHJldGVyLFxuSUF0dHJTeW50YXhUcmFuc2Zvcm1lciwgXG4vLyBBdFByZWZpeGVkVHJpZ2dlckF0dHJpYnV0ZVBhdHRlcm4sXG4vLyBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm4sXG4vLyBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuLFxuLy8gUmVmQXR0cmlidXRlUGF0dGVybixcbmJpbmRpbmdDb21tYW5kLCBcbi8vIEJpbmRpbmdDb21tYW5kRGVmaW5pdGlvbixcbi8vIEJpbmRpbmdDb21tYW5kS2luZCxcbi8vIEJpbmRpbmdDb21tYW5kVHlwZSxcbmdldFRhcmdldCwgXG4vLyBDYWxsQmluZGluZ0NvbW1hbmQsXG4vLyBEZWZhdWx0QmluZGluZ0NvbW1hbmQsXG4vLyBGb3JCaW5kaW5nQ29tbWFuZCxcbi8vIEZyb21WaWV3QmluZGluZ0NvbW1hbmQsXG4vLyBPbmVUaW1lQmluZGluZ0NvbW1hbmQsXG4vLyBUb1ZpZXdCaW5kaW5nQ29tbWFuZCxcbi8vIFR3b1dheUJpbmRpbmdDb21tYW5kLFxuLy8gSUV4cHJlc3Npb25QYXJzZXJSZWdpc3RyYXRpb24sXG4vLyBEZWZhdWx0Q29tcG9uZW50cyBhcyBKaXREZWZhdWx0Q29tcG9uZW50cyxcbi8vIFJlZkF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24sXG4vLyBEb3RTZXBhcmF0ZWRBdHRyaWJ1dGVQYXR0ZXJuUmVnaXN0cmF0aW9uLFxuLy8gRGVmYXVsdEJpbmRpbmdTeW50YXgsXG4vLyBBdFByZWZpeGVkVHJpZ2dlckF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24sXG4vLyBDb2xvblByZWZpeGVkQmluZEF0dHJpYnV0ZVBhdHRlcm5SZWdpc3RyYXRpb24sXG5TaG9ydEhhbmRCaW5kaW5nU3ludGF4LCBcbi8vIENhbGxCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbi8vIERlZmF1bHRCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbi8vIEZvckJpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuLy8gRnJvbVZpZXdCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbi8vIE9uZVRpbWVCaW5kaW5nQ29tbWFuZFJlZ2lzdHJhdGlvbixcbi8vIFRvVmlld0JpbmRpbmdDb21tYW5kUmVnaXN0cmF0aW9uLFxuLy8gVHdvV2F5QmluZGluZ0NvbW1hbmRSZWdpc3RyYXRpb24sXG4vLyBBdHRyQmluZGluZ0JlaGF2aW9yUmVnaXN0cmF0aW9uLFxuLy8gU2VsZkJpbmRpbmdCZWhhdmlvclJlZ2lzdHJhdGlvbixcbi8vIFVwZGF0ZVRyaWdnZXJCaW5kaW5nQmVoYXZpb3JSZWdpc3RyYXRpb24sXG4vLyBDb21wb3NlUmVnaXN0cmF0aW9uLFxuLy8gRGVmYXVsdFJlc291cmNlcyBhcyBSdW50aW1lSHRtbERlZmF1bHRSZXNvdXJjZXMsXG4vLyBBdHRyaWJ1dGVCaW5kaW5nUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBMaXN0ZW5lckJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIFNldEF0dHJpYnV0ZVJlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gU2V0Q2xhc3NBdHRyaWJ1dGVSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIFNldFN0eWxlQXR0cmlidXRlUmVuZGVyZXJSZWdpc3RyYXRpb24sXG4vLyBTdHlsZVByb3BlcnR5QmluZGluZ1JlbmRlcmVyUmVnaXN0cmF0aW9uLFxuLy8gVGV4dEJpbmRpbmdSZW5kZXJlclJlZ2lzdHJhdGlvbixcbi8vIERlZmF1bHRSZW5kZXJlcnMsXG4vLyBTdGFuZGFyZENvbmZpZ3VyYXRpb24sXG5jcmVhdGVFbGVtZW50LCBcbi8vIFJlbmRlclBsYW4sXG4vLyBBdHRyaWJ1dGVJbnN0cnVjdGlvbixcbi8vIElJbnN0cnVjdGlvblJvdyxcbi8vIE5vZGVJbnN0cnVjdGlvbixcbi8vIElJbnN0cnVjdGlvbixcbi8vIEluc3RydWN0aW9uVHlwZSxcbi8vIElBdHRyaWJ1dGVCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBJTGlzdGVuZXJCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBJU2V0QXR0cmlidXRlSW5zdHJ1Y3Rpb24sXG4vLyBpc0luc3RydWN0aW9uLFxuLy8gSVN0eWxlUHJvcGVydHlCaW5kaW5nSW5zdHJ1Y3Rpb24sXG4vLyBJVGV4dEJpbmRpbmdJbnN0cnVjdGlvbixcbi8vIE5vZGVTZXF1ZW5jZUZhY3RvcnksXG4vLyBGcmFnbWVudE5vZGVTZXF1ZW5jZSxcbi8vIEF0dHJpYnV0ZUJpbmRpbmdJbnN0cnVjdGlvbixcbi8vIFNldEF0dHJpYnV0ZUluc3RydWN0aW9uLFxuLy8gU2V0Q2xhc3NBdHRyaWJ1dGVJbnN0cnVjdGlvbixcbi8vIFNldFN0eWxlQXR0cmlidXRlSW5zdHJ1Y3Rpb24sXG4vLyBTdHlsZVByb3BlcnR5QmluZGluZ0luc3RydWN0aW9uLFxuLy8gVGV4dEJpbmRpbmdJbnN0cnVjdGlvbixcbi8vIENvbnRhaW5lcmxlc3NQcm9qZWN0b3IsXG4vLyBIb3N0UHJvamVjdG9yLFxuLy8gSFRNTFByb2plY3RvckxvY2F0b3IsXG4vLyBTaGFkb3dET01Qcm9qZWN0b3IsXG5TdHlsZUNvbmZpZ3VyYXRpb24sIFxuLy8gQ1NTTW9kdWxlc1Byb2Nlc3NvclJlZ2lzdHJ5LFxuY3NzTW9kdWxlcywgXG4vLyBTaGFkb3dET01SZWdpc3RyeSxcbi8vIElTaGFkb3dET01TdHlsZUZhY3RvcnksXG5zaGFkb3dDU1MsIH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLmFwcC1oZWFkZXIge1xcbiAgYmFja2dyb3VuZDogI2Y0ZjRmNDtcXG4gIHBhZGRpbmc6IDA7XFxuICBwYWRkaW5nOiA1cHggMCAwIDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5kYXJrIC5hcHAtaGVhZGVyIHtcXG4gIGJhY2tncm91bmQ6ICMyYTJhMmE7XFxufVxcblxcbi5sb2dvLWJhZGdlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogLTdweDtcXG4gIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBjb2xvcjogI0JCNzlBODtcXG59XFxuXFxuLm5vdC1mb3VuZCB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICBmb250LXNpemU6IDEwcHg7XFxufVxcblxcbi5kYXJrIC5ub3QtZm91bmQge1xcbiAgY29sb3I6ICM5ODk4OTg7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIHtcXG4gIG1hcmdpbi1ib3R0b206IDRweDtcXG59XFxuXFxuLmN1c3RvbS1hdHRyaWJ1dGUgLmF0dHJpYnV0ZS1uYW1lIHtcXG4gIGNvbG9yOiBzYWRkbGVicm93bjtcXG59XFxuLmRhcmsgLmN1c3RvbS1hdHRyaWJ1dGUgLmF0dHJpYnV0ZS1uYW1lIHtcXG4gIGNvbG9yOiAjZWY5NTY1O1xcbn1cXG5cXG4uY3VzdG9tLWF0dHJpYnV0ZSAuYmxvY2stdG9rZW4ge1xcbiAgY29sb3I6IGdyYXk7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIC5hdHRyaWJ1dGUtbmFtZSwgLmN1c3RvbS1hdHRyaWJ1dGUgLmJsb2NrLXRva2VuIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGlubGluZTtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIGNvbnRyb2xsZXItdmlldyB7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IHtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAuYXJyb3cge1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgY29sb3I6IGRpbWdyYXk7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5hcnJvdyAucmlnaHQge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS1saW5lIHtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiBwdXJwbGU7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLWxlZnQ6IDFweDtcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LW5hbWUge1xcbiAgY29sb3I6ICMzNGM3YmI7XFxufVxcbmN1c3RvbS1lbGVtZW50IC52YWx1ZS1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktZWRpdG9yIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuICBoZWlnaHQ6IDEycHg7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgZGFya2dyYXk7XFxuICBib3gtc2hhZG93OiAwIDAgNXB4IHJnYmEoMCwwLDAsLjUpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA0cHg7XFxuICBsZWZ0OiAycHg7XFxuICBwYWRkaW5nOiAwIDAgMCAycHg7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZSwgY3VzdG9tLWVsZW1lbnQgLnRva2VuLWNvbG9uIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm51bGwsIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS51bmRlZmluZWQge1xcbiAgY29sb3I6IGRpbWdyYXk7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5ib29sZWFuIHtcXG4gIGNvbG9yOiBkZWVwcGluaztcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLnN0cmluZyB7XFxuICBjb2xvcjogcmVkO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLnN0cmluZyB7XFxuICBjb2xvcjojY2JjYmNiO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUubnVtYmVyIHtcXG4gIGNvbG9yOiBibHVlO1xcbn1cXG5cXG4uZGFyayBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUubnVtYmVyIHtcXG4gIGNvbG9yOiAjNTlhNmNhO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUuYXJyYXkge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uZGFyayBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUuYXJyYXkge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5vYmplY3QsIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5ub2RlIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm9iamVjdCwgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm5vZGUge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IHVsLnByb3BlcnRpZXMge1xcbiAgbWFyZ2luLWxlZnQ6IDE2cHg7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5uby1wcm9wZXJ0aWVzIHtcXG4gIG1hcmdpbi10b3A6IDRweDtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG59XFxuXFxuLmRhcmsgY3VzdG9tLWVsZW1lbnQgLm5vLXByb3BlcnRpZXMge1xcbiAgY29sb3I6ICM5ODk4OTg7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9hcHAuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsbUJBQW1CO0VBQ25CLFVBQVU7RUFDVixrQkFBa0I7RUFDbEIsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFNBQVM7RUFDVCxnQkFBZ0I7RUFDaEIsZUFBZTtFQUNmLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxrQkFBa0I7QUFDcEI7QUFDQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxXQUFXO0FBQ2I7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsZUFBZTtFQUNmLHNCQUFzQjtBQUN4Qjs7QUFFQTtFQUNFLGdCQUFnQjtFQUNoQixjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsY0FBYztFQUNkLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsYUFBYTtFQUNiLHNCQUFzQjtFQUN0QixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxzQkFBc0I7RUFDdEIsZUFBZTtFQUNmLFNBQVM7RUFDVCxZQUFZO0VBQ1osYUFBYTtFQUNiLDBCQUEwQjtFQUMxQixrQ0FBa0M7RUFDbEMsa0JBQWtCO0VBQ2xCLFFBQVE7RUFDUixTQUFTO0VBQ1Qsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsZUFBZTtFQUNmLGNBQWM7RUFDZCxzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLFVBQVU7RUFDVixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGFBQWE7QUFDZjs7QUFFQTtFQUNFLFdBQVc7QUFDYjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsWUFBWTtBQUNkOztBQUVBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLGVBQWU7RUFDZixlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsY0FBYztBQUNoQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuYXBwLWhlYWRlciB7XFxuICBiYWNrZ3JvdW5kOiAjZjRmNGY0O1xcbiAgcGFkZGluZzogMDtcXG4gIHBhZGRpbmc6IDVweCAwIDAgMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLmRhcmsgLmFwcC1oZWFkZXIge1xcbiAgYmFja2dyb3VuZDogIzJhMmEyYTtcXG59XFxuXFxuLmxvZ28tYmFkZ2Uge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAtN3B4O1xcbiAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGNvbG9yOiAjQkI3OUE4O1xcbn1cXG5cXG4ubm90LWZvdW5kIHtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG59XFxuXFxuLmRhcmsgLm5vdC1mb3VuZCB7XFxuICBjb2xvcjogIzk4OTg5ODtcXG59XFxuXFxuLmN1c3RvbS1hdHRyaWJ1dGUge1xcbiAgbWFyZ2luLWJvdHRvbTogNHB4O1xcbn1cXG5cXG4uY3VzdG9tLWF0dHJpYnV0ZSAuYXR0cmlidXRlLW5hbWUge1xcbiAgY29sb3I6IHNhZGRsZWJyb3duO1xcbn1cXG4uZGFyayAuY3VzdG9tLWF0dHJpYnV0ZSAuYXR0cmlidXRlLW5hbWUge1xcbiAgY29sb3I6ICNlZjk1NjU7XFxufVxcblxcbi5jdXN0b20tYXR0cmlidXRlIC5ibG9jay10b2tlbiB7XFxuICBjb2xvcjogZ3JheTtcXG59XFxuXFxuLmN1c3RvbS1hdHRyaWJ1dGUgLmF0dHJpYnV0ZS1uYW1lLCAuY3VzdG9tLWF0dHJpYnV0ZSAuYmxvY2stdG9rZW4ge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZGlzcGxheTogaW5saW5lO1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG59XFxuXFxuLmN1c3RvbS1hdHRyaWJ1dGUgY29udHJvbGxlci12aWV3IHtcXG4gIG1hcmdpbi1sZWZ0OiA4cHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQge1xcbiAgbWFyZ2luLXRvcDogMnB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5hcnJvdyB7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICBjb2xvcjogZGltZ3JheTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLmFycm93IC5yaWdodCB7XFxuICBtYXJnaW4tcmlnaHQ6IDFweDtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LWxpbmUge1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LW5hbWUge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY29sb3I6IHB1cnBsZTtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tbGVmdDogMXB4O1xcbn1cXG5cXG4uZGFyayBjdXN0b20tZWxlbWVudCAucHJvcGVydHktbmFtZSB7XFxuICBjb2xvcjogIzM0YzdiYjtcXG59XFxuY3VzdG9tLWVsZW1lbnQgLnZhbHVlLWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS1lZGl0b3Ige1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMDtcXG4gIGhlaWdodDogMTJweDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCBkYXJrZ3JheTtcXG4gIGJveC1zaGFkb3c6IDAgMCA1cHggcmdiYSgwLDAsMCwuNSk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDRweDtcXG4gIGxlZnQ6IDJweDtcXG4gIHBhZGRpbmc6IDAgMCAwIDJweDtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLCBjdXN0b20tZWxlbWVudCAudG9rZW4tY29sb24ge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY29sb3I6IGRpbWdyYXk7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUubnVsbCwgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLnVuZGVmaW5lZCB7XFxuICBjb2xvcjogZGltZ3JheTtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLmJvb2xlYW4ge1xcbiAgY29sb3I6IGRlZXBwaW5rO1xcbn1cXG5cXG5jdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUuc3RyaW5nIHtcXG4gIGNvbG9yOiByZWQ7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4uZGFyayBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUuc3RyaW5nIHtcXG4gIGNvbG9yOiNjYmNiY2I7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5udW1iZXIge1xcbiAgY29sb3I6IGJsdWU7XFxufVxcblxcbi5kYXJrIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5udW1iZXIge1xcbiAgY29sb3I6ICM1OWE2Y2E7XFxufVxcblxcbmN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5hcnJheSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbi5kYXJrIGN1c3RvbS1lbGVtZW50IC5wcm9wZXJ0eS12YWx1ZS5hcnJheSB7XFxuICBjb2xvcjogI2NiY2JjYjtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm9iamVjdCwgY3VzdG9tLWVsZW1lbnQgLnByb3BlcnR5LXZhbHVlLm5vZGUge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uZGFyayBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUub2JqZWN0LCBjdXN0b20tZWxlbWVudCAucHJvcGVydHktdmFsdWUubm9kZSB7XFxuICBjb2xvcjogI2NiY2JjYjtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgdWwucHJvcGVydGllcyB7XFxuICBtYXJnaW4tbGVmdDogMTZweDtcXG59XFxuXFxuY3VzdG9tLWVsZW1lbnQgLm5vLXByb3BlcnRpZXMge1xcbiAgbWFyZ2luLXRvcDogNHB4O1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbn1cXG5cXG4uZGFyayBjdXN0b20tZWxlbWVudCAubm8tcHJvcGVydGllcyB7XFxuICBjb2xvcjogIzk4OTg5ODtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyogaHR0cDovL21leWVyd2ViLmNvbS9lcmljL3Rvb2xzL2Nzcy9yZXNldC9cXG4gICB2Mi4wIHwgMjAxMTAxMjZcXG4gICBMaWNlbnNlOiBub25lIChwdWJsaWMgZG9tYWluKVxcbiovXFxuXFxuaHRtbCwgYm9keSwgZGl2LCBzcGFuLCBhcHBsZXQsIG9iamVjdCwgaWZyYW1lLFxcbmgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHAsIGJsb2NrcXVvdGUsIHByZSxcXG5hLCBhYmJyLCBhY3JvbnltLCBhZGRyZXNzLCBiaWcsIGNpdGUsIGNvZGUsXFxuZGVsLCBkZm4sIGVtLCBpbWcsIGlucywga2JkLCBxLCBzLCBzYW1wLFxcbnNtYWxsLCBzdHJpa2UsIHN0cm9uZywgc3ViLCBzdXAsIHR0LCB2YXIsXFxuYiwgdSwgaSwgY2VudGVyLFxcbmRsLCBkdCwgZGQsIG9sLCB1bCwgbGksXFxuZmllbGRzZXQsIGZvcm0sIGxhYmVsLCBsZWdlbmQsXFxudGFibGUsIGNhcHRpb24sIHRib2R5LCB0Zm9vdCwgdGhlYWQsIHRyLCB0aCwgdGQsXFxuYXJ0aWNsZSwgYXNpZGUsIGNhbnZhcywgZGV0YWlscywgZW1iZWQsXFxuZmlndXJlLCBmaWdjYXB0aW9uLCBmb290ZXIsIGhlYWRlciwgaGdyb3VwLFxcbm1lbnUsIG5hdiwgb3V0cHV0LCBydWJ5LCBzZWN0aW9uLCBzdW1tYXJ5LFxcbnRpbWUsIG1hcmssIGF1ZGlvLCB2aWRlbyB7XFxuXFx0bWFyZ2luOiAwO1xcblxcdHBhZGRpbmc6IDA7XFxuXFx0Ym9yZGVyOiAwO1xcblxcdGZvbnQtc2l6ZTogMTAwJTtcXG5cXHRmb250OiBpbmhlcml0O1xcblxcdHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuLyogSFRNTDUgZGlzcGxheS1yb2xlIHJlc2V0IGZvciBvbGRlciBicm93c2VycyAqL1xcbmFydGljbGUsIGFzaWRlLCBkZXRhaWxzLCBmaWdjYXB0aW9uLCBmaWd1cmUsXFxuZm9vdGVyLCBoZWFkZXIsIGhncm91cCwgbWVudSwgbmF2LCBzZWN0aW9uIHtcXG5cXHRkaXNwbGF5OiBibG9jaztcXG59XFxuYm9keSB7XFxuXFx0bGluZS1oZWlnaHQ6IDE7XFxufVxcbm9sLCB1bCB7XFxuXFx0bGlzdC1zdHlsZTogbm9uZTtcXG59XFxuYmxvY2txdW90ZSwgcSB7XFxuXFx0cXVvdGVzOiBub25lO1xcbn1cXG5ibG9ja3F1b3RlOmJlZm9yZSwgYmxvY2txdW90ZTphZnRlcixcXG5xOmJlZm9yZSwgcTphZnRlciB7XFxuXFx0Y29udGVudDogJyc7XFxuXFx0Y29udGVudDogbm9uZTtcXG59XFxudGFibGUge1xcblxcdGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuXFx0Ym9yZGVyLXNwYWNpbmc6IDA7XFxufVxcblxcbi8qISBub3JtYWxpemUuY3NzIHY1LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cXG5cXG4vKiBEb2N1bWVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQ2hhbmdlIHRoZSBkZWZhdWx0IGZvbnQgZmFtaWx5IGluIGFsbCBicm93c2VycyAob3BpbmlvbmF0ZWQpLlxcbiAqIDIuIENvcnJlY3QgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4gKiAzLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluXFxuICogICAgSUUgb24gV2luZG93cyBQaG9uZSBhbmQgaW4gaU9TLlxcbiAqL1xcblxcbmh0bWwge1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiAxLjE1OyAvKiAyICovXFxuICAtbXMtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMyAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAzICovXFxufVxcblxcbi8qIEZvcm1zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiAxLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2VycyAob3BpbmlvbmF0ZWQpLlxcbiAqIDIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaW5wdXQsXFxub3B0Z3JvdXAsXFxuc2VsZWN0LFxcbnRleHRhcmVhIHtcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmOyAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiAxLjE1OyAvKiAxICovXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogU2hvdyB0aGUgb3ZlcmZsb3cgaW4gSUUuXFxuICogMS4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaW5wdXQgeyAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlLCBGaXJlZm94LCBhbmQgSUUuXFxuICogMS4gUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBGaXJlZm94LlxcbiAqL1xcblxcbmJ1dHRvbixcXG5zZWxlY3QgeyAvKiAxICovXFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gUHJldmVudCBhIFdlYktpdCBidWcgd2hlcmUgKDIpIGRlc3Ryb3lzIG5hdGl2ZSBgYXVkaW9gIGFuZCBgdmlkZW9gXFxuICogICAgY29udHJvbHMgaW4gQW5kcm9pZCA0LlxcbiAqIDIuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcbmh0bWwgW3R5cGU9XFxcImJ1dHRvblxcXCJdLCAvKiAxICovXFxuW3R5cGU9XFxcInJlc2V0XFxcIl0sXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgYm9yZGVyIGFuZCBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuXFxuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLyoqXFxuICogUmVzdG9yZSB0aGUgZm9jdXMgc3R5bGVzIHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlLlxcbiAqL1xcblxcbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDtcXG59XFxuXFxuLyoqXFxuICogQ2hhbmdlIHRoZSBib3JkZXIsIG1hcmdpbiwgYW5kIHBhZGRpbmcgaW4gYWxsIGJyb3dzZXJzIChvcGluaW9uYXRlZCkuXFxuICovXFxuXFxuZmllbGRzZXQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2MwYzBjMDtcXG4gIG1hcmdpbjogMCAycHg7XFxuICBwYWRkaW5nOiAwLjM1ZW0gMC42MjVlbSAwLjc1ZW07XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIHRleHQgd3JhcHBpbmcgaW4gRWRnZSBhbmQgSUUuXFxuICogMi4gQ29ycmVjdCB0aGUgY29sb3IgaW5oZXJpdGFuY2UgZnJvbSBgZmllbGRzZXRgIGVsZW1lbnRzIGluIElFLlxcbiAqIDMuIFJlbW92ZSB0aGUgcGFkZGluZyBzbyBkZXZlbG9wZXJzIGFyZSBub3QgY2F1Z2h0IG91dCB3aGVuIHRoZXkgemVybyBvdXRcXG4gKiAgICBgZmllbGRzZXRgIGVsZW1lbnRzIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5sZWdlbmQge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gIGRpc3BsYXk6IHRhYmxlOyAvKiAxICovXFxuICBtYXgtd2lkdGg6IDEwMCU7IC8qIDEgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDMgKi9cXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7IC8qIDEgKi9cXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICogMi4gQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBPcGVyYS5cXG4gKi9cXG5cXG5wcm9ncmVzcyB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGRlZmF1bHQgdmVydGljYWwgc2Nyb2xsYmFyIGluIElFLlxcbiAqL1xcblxcbnRleHRhcmVhIHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBJRSAxMC0uXFxuICogMi4gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIElFIDEwLS5cXG4gKi9cXG5cXG5bdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG5bdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIENocm9tZS5cXG4gKi9cXG5cXG5bdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuICogMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxuICovXFxuXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgYW5kIGNhbmNlbCBidXR0b25zIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxcbiAqL1xcblxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXTo6LXdlYmtpdC1zZWFyY2gtY2FuY2VsLWJ1dHRvbixcXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbiAqIDIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXG4gKi9cXG5cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9yZXNldC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7OztDQUdDOztBQUVEOzs7Ozs7Ozs7Ozs7O0NBYUMsU0FBUztDQUNULFVBQVU7Q0FDVixTQUFTO0NBQ1QsZUFBZTtDQUNmLGFBQWE7Q0FDYix3QkFBd0I7QUFDekI7QUFDQSxnREFBZ0Q7QUFDaEQ7O0NBRUMsY0FBYztBQUNmO0FBQ0E7Q0FDQyxjQUFjO0FBQ2Y7QUFDQTtDQUNDLGdCQUFnQjtBQUNqQjtBQUNBO0NBQ0MsWUFBWTtBQUNiO0FBQ0E7O0NBRUMsV0FBVztDQUNYLGFBQWE7QUFDZDtBQUNBO0NBQ0MseUJBQXlCO0NBQ3pCLGlCQUFpQjtBQUNsQjs7QUFFQSwyRUFBMkU7O0FBRTNFOytFQUMrRTs7QUFFL0U7Ozs7O0VBS0U7O0FBRUY7RUFDRSx1QkFBdUIsRUFBRSxNQUFNO0VBQy9CLGlCQUFpQixFQUFFLE1BQU07RUFDekIsMEJBQTBCLEVBQUUsTUFBTTtFQUNsQyw4QkFBOEIsRUFBRSxNQUFNO0FBQ3hDOztBQUVBOytFQUMrRTs7QUFFL0U7OztFQUdFOztBQUVGOzs7OztFQUtFLHVCQUF1QixFQUFFLE1BQU07RUFDL0IsZUFBZSxFQUFFLE1BQU07RUFDdkIsaUJBQWlCLEVBQUUsTUFBTTtFQUN6QixTQUFTLEVBQUUsTUFBTTtBQUNuQjs7QUFFQTs7O0VBR0U7O0FBRUY7UUFDUSxNQUFNO0VBQ1osaUJBQWlCO0FBQ25COztBQUVBOzs7RUFHRTs7QUFFRjtTQUNTLE1BQU07RUFDYixvQkFBb0I7QUFDdEI7O0FBRUE7Ozs7RUFJRTs7QUFFRjs7OztFQUlFLDBCQUEwQixFQUFFLE1BQU07QUFDcEM7O0FBRUE7O0VBRUU7O0FBRUY7Ozs7RUFJRSxrQkFBa0I7RUFDbEIsVUFBVTtBQUNaOztBQUVBOztFQUVFOztBQUVGOzs7O0VBSUUsOEJBQThCO0FBQ2hDOztBQUVBOztFQUVFOztBQUVGO0VBQ0UseUJBQXlCO0VBQ3pCLGFBQWE7RUFDYiw4QkFBOEI7QUFDaEM7O0FBRUE7Ozs7O0VBS0U7O0FBRUY7RUFDRSxzQkFBc0IsRUFBRSxNQUFNO0VBQzlCLGNBQWMsRUFBRSxNQUFNO0VBQ3RCLGNBQWMsRUFBRSxNQUFNO0VBQ3RCLGVBQWUsRUFBRSxNQUFNO0VBQ3ZCLFVBQVUsRUFBRSxNQUFNO0VBQ2xCLG1CQUFtQixFQUFFLE1BQU07QUFDN0I7O0FBRUE7OztFQUdFOztBQUVGO0VBQ0UscUJBQXFCLEVBQUUsTUFBTTtFQUM3Qix3QkFBd0IsRUFBRSxNQUFNO0FBQ2xDOztBQUVBOztFQUVFOztBQUVGO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTs7O0VBR0U7O0FBRUY7O0VBRUUsc0JBQXNCLEVBQUUsTUFBTTtFQUM5QixVQUFVLEVBQUUsTUFBTTtBQUNwQjs7QUFFQTs7RUFFRTs7QUFFRjs7RUFFRSxZQUFZO0FBQ2Q7O0FBRUE7OztFQUdFOztBQUVGO0VBQ0UsNkJBQTZCLEVBQUUsTUFBTTtFQUNyQyxvQkFBb0IsRUFBRSxNQUFNO0FBQzlCOztBQUVBOztFQUVFOztBQUVGOztFQUVFLHdCQUF3QjtBQUMxQjs7QUFFQTs7O0VBR0U7O0FBRUY7RUFDRSwwQkFBMEIsRUFBRSxNQUFNO0VBQ2xDLGFBQWEsRUFBRSxNQUFNO0FBQ3ZCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qIGh0dHA6Ly9tZXllcndlYi5jb20vZXJpYy90b29scy9jc3MvcmVzZXQvXFxuICAgdjIuMCB8IDIwMTEwMTI2XFxuICAgTGljZW5zZTogbm9uZSAocHVibGljIGRvbWFpbilcXG4qL1xcblxcbmh0bWwsIGJvZHksIGRpdiwgc3BhbiwgYXBwbGV0LCBvYmplY3QsIGlmcmFtZSxcXG5oMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwLCBibG9ja3F1b3RlLCBwcmUsXFxuYSwgYWJiciwgYWNyb255bSwgYWRkcmVzcywgYmlnLCBjaXRlLCBjb2RlLFxcbmRlbCwgZGZuLCBlbSwgaW1nLCBpbnMsIGtiZCwgcSwgcywgc2FtcCxcXG5zbWFsbCwgc3RyaWtlLCBzdHJvbmcsIHN1Yiwgc3VwLCB0dCwgdmFyLFxcbmIsIHUsIGksIGNlbnRlcixcXG5kbCwgZHQsIGRkLCBvbCwgdWwsIGxpLFxcbmZpZWxkc2V0LCBmb3JtLCBsYWJlbCwgbGVnZW5kLFxcbnRhYmxlLCBjYXB0aW9uLCB0Ym9keSwgdGZvb3QsIHRoZWFkLCB0ciwgdGgsIHRkLFxcbmFydGljbGUsIGFzaWRlLCBjYW52YXMsIGRldGFpbHMsIGVtYmVkLFxcbmZpZ3VyZSwgZmlnY2FwdGlvbiwgZm9vdGVyLCBoZWFkZXIsIGhncm91cCxcXG5tZW51LCBuYXYsIG91dHB1dCwgcnVieSwgc2VjdGlvbiwgc3VtbWFyeSxcXG50aW1lLCBtYXJrLCBhdWRpbywgdmlkZW8ge1xcblxcdG1hcmdpbjogMDtcXG5cXHRwYWRkaW5nOiAwO1xcblxcdGJvcmRlcjogMDtcXG5cXHRmb250LXNpemU6IDEwMCU7XFxuXFx0Zm9udDogaW5oZXJpdDtcXG5cXHR2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcbi8qIEhUTUw1IGRpc3BsYXktcm9sZSByZXNldCBmb3Igb2xkZXIgYnJvd3NlcnMgKi9cXG5hcnRpY2xlLCBhc2lkZSwgZGV0YWlscywgZmlnY2FwdGlvbiwgZmlndXJlLFxcbmZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsIG1lbnUsIG5hdiwgc2VjdGlvbiB7XFxuXFx0ZGlzcGxheTogYmxvY2s7XFxufVxcbmJvZHkge1xcblxcdGxpbmUtaGVpZ2h0OiAxO1xcbn1cXG5vbCwgdWwge1xcblxcdGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcbmJsb2NrcXVvdGUsIHEge1xcblxcdHF1b3Rlczogbm9uZTtcXG59XFxuYmxvY2txdW90ZTpiZWZvcmUsIGJsb2NrcXVvdGU6YWZ0ZXIsXFxucTpiZWZvcmUsIHE6YWZ0ZXIge1xcblxcdGNvbnRlbnQ6ICcnO1xcblxcdGNvbnRlbnQ6IG5vbmU7XFxufVxcbnRhYmxlIHtcXG5cXHRib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcblxcdGJvcmRlci1zcGFjaW5nOiAwO1xcbn1cXG5cXG4vKiEgbm9ybWFsaXplLmNzcyB2NS4wLjAgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovXFxuXFxuLyogRG9jdW1lbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZGVmYXVsdCBmb250IGZhbWlseSBpbiBhbGwgYnJvd3NlcnMgKG9waW5pb25hdGVkKS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuICogMy4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpblxcbiAqICAgIElFIG9uIFdpbmRvd3MgUGhvbmUgYW5kIGluIGlPUy5cXG4gKi9cXG5cXG5odG1sIHtcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMiAqL1xcbiAgLW1zLXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDMgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMyAqL1xcbn1cXG5cXG4vKiBGb3Jtc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMgKG9waW5pb25hdGVkKS5cXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxcbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0IHsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSwgRmlyZWZveCwgYW5kIElFLlxcbiAqIDEuIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b24sXFxuc2VsZWN0IHsgLyogMSAqL1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqIDEuIFByZXZlbnQgYSBXZWJLaXQgYnVnIHdoZXJlICgyKSBkZXN0cm95cyBuYXRpdmUgYGF1ZGlvYCBhbmQgYHZpZGVvYFxcbiAqICAgIGNvbnRyb2xzIGluIEFuZHJvaWQgNC5cXG4gKiAyLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmJ1dHRvbixcXG5odG1sIFt0eXBlPVxcXCJidXR0b25cXFwiXSwgLyogMSAqL1xcblt0eXBlPVxcXCJyZXNldFxcXCJdLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGlubmVyIGJvcmRlciBhbmQgcGFkZGluZyBpbiBGaXJlZm94LlxcbiAqL1xcblxcbmJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOjotbW96LWZvY3VzLWlubmVyIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi8qKlxcbiAqIFJlc3RvcmUgdGhlIGZvY3VzIHN0eWxlcyB1bnNldCBieSB0aGUgcHJldmlvdXMgcnVsZS5cXG4gKi9cXG5cXG5idXR0b246LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTotbW96LWZvY3VzcmluZyB7XFxuICBvdXRsaW5lOiAxcHggZG90dGVkIEJ1dHRvblRleHQ7XFxufVxcblxcbi8qKlxcbiAqIENoYW5nZSB0aGUgYm9yZGVyLCBtYXJnaW4sIGFuZCBwYWRkaW5nIGluIGFsbCBicm93c2VycyAob3BpbmlvbmF0ZWQpLlxcbiAqL1xcblxcbmZpZWxkc2V0IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjMGMwYzA7XFxuICBtYXJnaW46IDAgMnB4O1xcbiAgcGFkZGluZzogMC4zNWVtIDAuNjI1ZW0gMC43NWVtO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDktLlxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRS5cXG4gKi9cXG5cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAtLlxcbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC0uXFxuICovXFxuXFxuW3R5cGU9XFxcImNoZWNrYm94XFxcIl0sXFxuW3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBDaHJvbWUuXFxuICovXFxuXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiAqIDIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiAqL1xcblxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGFuZCBjYW5jZWwgYnV0dG9ucyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuICovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJjb250cm9sbGVyLXZpZXcgLmNhdGVnb3J5LW5hbWUge1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMnB4O1xcbiAgbWFyZ2luLXRvcDogMnB4O1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uZGFyayBjb250cm9sbGVyLXZpZXcgLmNhdGVnb3J5LW5hbWUge1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMnB4O1xcbiAgbWFyZ2luLXRvcDogMnB4O1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvcmVzb3VyY2VzL2VsZW1lbnRzL2NvbnRyb2xsZXItdmlldy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxlQUFlO0VBQ2Ysa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxlQUFlO0VBQ2Ysa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixZQUFZO0FBQ2RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiY29udHJvbGxlci12aWV3IC5jYXRlZ29yeS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIG1hcmdpbi1ib3R0b206IDJweDtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgY29udHJvbGxlci12aWV3IC5jYXRlZ29yeS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIG1hcmdpbi1ib3R0b206IDJweDtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiZGVidWctZ3JvdXAgLmhlYWRlciB7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogNHB4O1xcbiAgYmFja2dyb3VuZDogI2Y0ZjRmNDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxufVxcblxcbi5kYXJrIGRlYnVnLWdyb3VwIC5oZWFkZXIge1xcbiAgY29sb3I6ICM5ODk4OTg7XFxuICBiYWNrZ3JvdW5kOiAjMmEyYTJhO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICM1YzVjNWM7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgIzNkM2QzZDtcXG59XFxuXFxuZGVidWctZ3JvdXAgLmNvbnRlbnQge1xcbiAgbWFyZ2luOiA0cHg7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvZGVidWctZ3JvdXAuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsbUJBQW1CO0VBQ25CLGVBQWU7RUFDZixTQUFTO0VBQ1QsWUFBWTtFQUNaLG1CQUFtQjtFQUNuQiw0Q0FBNEM7RUFDNUMseUNBQXlDO0FBQzNDOztBQUVBO0VBQ0UsY0FBYztFQUNkLG1CQUFtQjtFQUNuQixnQ0FBZ0M7RUFDaEMsNkJBQTZCO0FBQy9COztBQUVBO0VBQ0UsV0FBVztBQUNiXCIsXCJzb3VyY2VzQ29udGVudFwiOltcImRlYnVnLWdyb3VwIC5oZWFkZXIge1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDRweDtcXG4gIGJhY2tncm91bmQ6ICNmNGY0ZjQ7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbn1cXG5cXG4uZGFyayBkZWJ1Zy1ncm91cCAuaGVhZGVyIHtcXG4gIGNvbG9yOiAjOTg5ODk4O1xcbiAgYmFja2dyb3VuZDogIzJhMmEyYTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjNWM1YzVjO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICMzZDNkM2Q7XFxufVxcblxcbmRlYnVnLWdyb3VwIC5jb250ZW50IHtcXG4gIG1hcmdpbjogNHB4O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJwcm9wZXJ0eS12aWV3IHtcXG4gIHBhZGRpbmctdG9wOiAycHg7XFxuICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLmFycm93IHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5hcnJvdyAucmlnaHQge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LWxpbmUge1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktbmFtZSB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjb2xvcjogcHVycGxlO1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi1sZWZ0OiAxcHg7XFxufVxcblxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLnByb3BlcnR5LW5hbWUge1xcbiAgY29sb3I6ICMzNGM3YmI7XFxufVxcbnByb3BlcnR5LXZpZXcgLnZhbHVlLWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LWVkaXRvciB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGRhcmtncmF5O1xcbiAgYm94LXNoYWRvdzogMCAwIDVweCByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAycHg7XFxuICBwYWRkaW5nOiAwIDAgMCAycHg7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLFxcbnByb3BlcnR5LXZpZXcgLnRva2VuLWNvbG9uIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiBkaW1ncmF5O1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUubnVsbCxcXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS51bmRlZmluZWQge1xcbiAgY29sb3I6IGRpbWdyYXk7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLmJvb2xlYW4ge1xcbiAgY29sb3I6IGRlZXBwaW5rO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5zdHJpbmcge1xcbiAgY29sb3I6IHJlZDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLnN0cmluZyB7XFxuICBjb2xvcjogI2NiY2JjYjtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUubnVtYmVyIHtcXG4gIGNvbG9yOiBibHVlO1xcbn1cXG5cXG4uZGFyayBwcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5udW1iZXIge1xcbiAgY29sb3I6ICM1OWE2Y2E7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLmFycmF5IHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgcHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUuYXJyYXkge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm9iamVjdCxcXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5ub2RlIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLmRhcmsgcHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUub2JqZWN0LFxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm5vZGUge1xcbiAgY29sb3I6ICNjYmNiY2I7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgdWwucHJvcGVydGllcyB7XFxuICBtYXJnaW4tbGVmdDogMTZweDtcXG59XFxuXFxucHJvcGVydHktdmlldyAubm8tcHJvcGVydGllcyB7XFxuICBtYXJnaW4tdG9wOiA0cHg7XFxuICBmb250LXNpemU6IDEwcHg7XFxufVxcblxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLm5vLXByb3BlcnRpZXMge1xcbiAgY29sb3I6ICM5ODk4OTg7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9yZXNvdXJjZXMvZWxlbWVudHMvcHJvcGVydHktdmlldy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxnQkFBZ0I7RUFDaEIsbUJBQW1CO0VBQ25CLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsY0FBYztFQUNkLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxlQUFlO0VBQ2YsYUFBYTtFQUNiLHNCQUFzQjtFQUN0QixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxzQkFBc0I7RUFDdEIsZUFBZTtFQUNmLFNBQVM7RUFDVCxZQUFZO0VBQ1osYUFBYTtFQUNiLDBCQUEwQjtFQUMxQixzQ0FBc0M7RUFDdEMsa0JBQWtCO0VBQ2xCLE1BQU07RUFDTixTQUFTO0VBQ1Qsa0JBQWtCO0FBQ3BCOztBQUVBOztFQUVFLGVBQWU7RUFDZixjQUFjO0VBQ2Qsc0JBQXNCO0FBQ3hCOztBQUVBOztFQUVFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsVUFBVTtFQUNWLG1CQUFtQjtBQUNyQjtBQUNBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTtFQUNFLFdBQVc7QUFDYjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBOztFQUVFLFlBQVk7QUFDZDs7QUFFQTs7RUFFRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsZUFBZTtFQUNmLGVBQWU7QUFDakI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcInByb3BlcnR5LXZpZXcge1xcbiAgcGFkZGluZy10b3A6IDJweDtcXG4gIHBhZGRpbmctYm90dG9tOiAycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxucHJvcGVydHktdmlldyAuYXJyb3cge1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgY29sb3I6IGRpbWdyYXk7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLmFycm93IC5yaWdodCB7XFxuICBtYXJnaW4tcmlnaHQ6IDFweDtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktbGluZSB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS1uYW1lIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiBwdXJwbGU7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLWxlZnQ6IDFweDtcXG59XFxuXFxuLmRhcmsgcHJvcGVydHktdmlldyAucHJvcGVydHktbmFtZSB7XFxuICBjb2xvcjogIzM0YzdiYjtcXG59XFxucHJvcGVydHktdmlldyAudmFsdWUtY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktZWRpdG9yIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuICBoZWlnaHQ6IDEycHg7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgZGFya2dyYXk7XFxuICBib3gtc2hhZG93OiAwIDAgNXB4IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDJweDtcXG4gIHBhZGRpbmc6IDAgMCAwIDJweDtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUsXFxucHJvcGVydHktdmlldyAudG9rZW4tY29sb24ge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY29sb3I6IGRpbWdyYXk7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5udWxsLFxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLnVuZGVmaW5lZCB7XFxuICBjb2xvcjogZGltZ3JheTtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUuYm9vbGVhbiB7XFxuICBjb2xvcjogZGVlcHBpbms7XFxufVxcblxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLnN0cmluZyB7XFxuICBjb2xvcjogcmVkO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuLmRhcmsgcHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUuc3RyaW5nIHtcXG4gIGNvbG9yOiAjY2JjYmNiO1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5udW1iZXIge1xcbiAgY29sb3I6IGJsdWU7XFxufVxcblxcbi5kYXJrIHByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm51bWJlciB7XFxuICBjb2xvcjogIzU5YTZjYTtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUuYXJyYXkge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uZGFyayBwcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5hcnJheSB7XFxuICBjb2xvcjogI2NiY2JjYjtcXG59XFxuXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUub2JqZWN0LFxcbnByb3BlcnR5LXZpZXcgLnByb3BlcnR5LXZhbHVlLm5vZGUge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4uZGFyayBwcm9wZXJ0eS12aWV3IC5wcm9wZXJ0eS12YWx1ZS5vYmplY3QsXFxucHJvcGVydHktdmlldyAucHJvcGVydHktdmFsdWUubm9kZSB7XFxuICBjb2xvcjogI2NiY2JjYjtcXG59XFxuXFxucHJvcGVydHktdmlldyB1bC5wcm9wZXJ0aWVzIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4O1xcbn1cXG5cXG5wcm9wZXJ0eS12aWV3IC5uby1wcm9wZXJ0aWVzIHtcXG4gIG1hcmdpbi10b3A6IDRweDtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG59XFxuXFxuLmRhcmsgcHJvcGVydHktdmlldyAubm8tcHJvcGVydGllcyB7XFxuICBjb2xvcjogIzk4OTg5ODtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKSB7XG4gIHZhciBfaXRlbSA9IF9zbGljZWRUb0FycmF5KGl0ZW0sIDQpLFxuICAgICAgY29udGVudCA9IF9pdGVtWzFdLFxuICAgICAgY3NzTWFwcGluZyA9IF9pdGVtWzNdO1xuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2FwcC5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3Jlc2V0LmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vY29udHJvbGxlci12aWV3LmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZGVidWctZ3JvdXAuY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9wcm9wZXJ0eS12aWV3LmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxuaW1wb3J0ICogYXMgX19hdTJWaWV3RGVmIGZyb20gJy4vYXBwLmh0bWwnO1xyXG5pbXBvcnQgeyBjdXN0b21FbGVtZW50LCB2YWx1ZUNvbnZlcnRlciB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XHJcbmltcG9ydCB7IERlYnVnSG9zdCB9IGZyb20gXCIuL2JhY2tlbmQvZGVidWctaG9zdFwiO1xyXG5pbXBvcnQgeyBpbmplY3QsIElQbGF0Zm9ybSB9IGZyb20gXCJhdXJlbGlhXCI7XHJcbmxldCBTdHJpbmdpZnlWYWx1ZUNvbnZlcnRlciA9IGNsYXNzIFN0cmluZ2lmeVZhbHVlQ29udmVydGVyIHtcclxuICAgIHRvVmlldyh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcblN0cmluZ2lmeVZhbHVlQ29udmVydGVyID0gX19kZWNvcmF0ZShbXHJcbiAgICB2YWx1ZUNvbnZlcnRlcignc3RyaW5naWZ5JylcclxuXSwgU3RyaW5naWZ5VmFsdWVDb252ZXJ0ZXIpO1xyXG5leHBvcnQgeyBTdHJpbmdpZnlWYWx1ZUNvbnZlcnRlciB9O1xyXG5sZXQgQXBwID0gY2xhc3MgQXBwIHtcclxuICAgIGNvbnN0cnVjdG9yKGRlYnVnSG9zdCwgcGxhdCkge1xyXG4gICAgICAgIHRoaXMuZGVidWdIb3N0ID0gZGVidWdIb3N0O1xyXG4gICAgICAgIHRoaXMucGxhdCA9IHBsYXQ7XHJcbiAgICAgICAgdGhpcy5pc0RhcmtUaGVtZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuSlNPTiA9IEpTT047XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZEVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZEVsZW1lbnRBdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYWxsQXVyZWxpYU9iamVjdHMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBhdHRhY2hpbmcoKSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1Z0hvc3QuYXR0YWNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaXNEYXJrVGhlbWUgPSBjaHJvbWU/LmRldnRvb2xzPy5wYW5lbHM/LnRoZW1lTmFtZSA9PT0gXCJkYXJrXCI7XHJcbiAgICAgICAgW10uam9pbigpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGN1cnJlbnRDb250cm9sbGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkRWxlbWVudDtcclxuICAgIH1cclxuICAgIHZhbHVlQ2hhbmdlZChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5wbGF0LnF1ZXVlTWljcm90YXNrKCgpID0+IHRoaXMuZGVidWdIb3N0LnVwZGF0ZVZhbHVlcyhlbGVtZW50KSk7XHJcbiAgICB9XHJcbn07XHJcbkFwcCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgY3VzdG9tRWxlbWVudCh7IC4uLl9fYXUyVmlld0RlZiwgZGVwZW5kZW5jaWVzOiBbLi4uX19hdTJWaWV3RGVmLmRlcGVuZGVuY2llcywgU3RyaW5naWZ5VmFsdWVDb252ZXJ0ZXJdIH0pLFxyXG4gICAgaW5qZWN0KCksXHJcbiAgICBfX3BhcmFtKDEsIElQbGF0Zm9ybSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RlYnVnSG9zdCwgT2JqZWN0XSlcclxuXSwgQXBwKTtcclxuZXhwb3J0IHsgQXBwIH07XHJcbiIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbmltcG9ydCB7IGluamVjdCB9IGZyb20gXCJhdXJlbGlhXCI7XHJcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25DaGFuZ2VkIHtcclxuICAgIGNvbnN0cnVjdG9yKGRlYnVnSW5mbykge1xyXG4gICAgICAgIHRoaXMuZGVidWdJbmZvID0gZGVidWdJbmZvO1xyXG4gICAgfVxyXG59XHJcbmxldCBEZWJ1Z0hvc3QgPSBjbGFzcyBEZWJ1Z0hvc3Qge1xyXG4gICAgYXR0YWNoKGNvbnN1bWVyKSB7XHJcbiAgICAgICAgdGhpcy5jb25zdW1lciA9IGNvbnN1bWVyO1xyXG4gICAgICAgIGlmIChjaHJvbWUgJiYgY2hyb21lLmRldnRvb2xzKSB7XHJcbiAgICAgICAgICAgIGNocm9tZS5kZXZ0b29scy5uZXR3b3JrLm9uTmF2aWdhdGVkLmFkZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNocm9tZS5kZXZ0b29scy5pbnNwZWN0ZWRXaW5kb3cuZXZhbChgd2luZG93Ll9fQVVSRUxJQV9ERVZUT09MU19HTE9CQUxfSE9PS19fLmdldEFsbEluZm8oKWAsIChkZWJ1Z09iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZXIuYWxsQXVyZWxpYU9iamVjdHMgPSBkZWJ1Z09iamVjdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2hyb21lLmRldnRvb2xzLnBhbmVscy5lbGVtZW50cy5vblNlbGVjdGlvbkNoYW5nZWQuYWRkTGlzdGVuZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2hyb21lLmRldnRvb2xzLmluc3BlY3RlZFdpbmRvdy5ldmFsKGB3aW5kb3cuX19BVVJFTElBX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uZ2V0Q3VzdG9tRWxlbWVudEluZm8oJDAsIGZhbHNlKWAsIChkZWJ1Z09iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZXIuc2VsZWN0ZWRFbGVtZW50ID0gZGVidWdPYmplY3Q/LmN1c3RvbUVsZW1lbnRJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZXIuc2VsZWN0ZWRFbGVtZW50QXR0cmlidXRlcyA9IGRlYnVnT2JqZWN0Py5jdXN0b21BdHRyaWJ1dGVzSW5mbztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2hyb21lLmRldnRvb2xzLmluc3BlY3RlZFdpbmRvdy5ldmFsKGB3aW5kb3cuX19BVVJFTElBX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uZ2V0QWxsSW5mbygpYCwgKGRlYnVnT2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVyLmFsbEF1cmVsaWFPYmplY3RzID0gZGVidWdPYmplY3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZVZhbHVlcyh2YWx1ZSkge1xyXG4gICAgICAgIGNocm9tZS5kZXZ0b29scy5pbnNwZWN0ZWRXaW5kb3cuZXZhbChgd2luZG93Ll9fQVVSRUxJQV9ERVZUT09MU19HTE9CQUxfSE9PS19fLnVwZGF0ZVZhbHVlcygke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYCwgKGRlYnVnT2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuY29uc3VtZXIuc2VsZWN0ZWRFbGVtZW50ID0gZGVidWdPYmplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVEZWJ1Z1ZhbHVlKGRlYnVnSW5mbykge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGRlYnVnSW5mby52YWx1ZTtcclxuICAgICAgICBpZiAoZGVidWdJbmZvLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBcIidcIiArIHZhbHVlICsgXCInXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb2RlID0gYGF1cmVsaWFEZWJ1Z2dlci51cGRhdGVWYWx1ZUZvcklkKCR7ZGVidWdJbmZvLmRlYnVnSWR9LCAke3ZhbHVlfSlgO1xyXG4gICAgICAgIGNocm9tZS5kZXZ0b29scy5pbnNwZWN0ZWRXaW5kb3cuZXZhbChjb2RlKTtcclxuICAgIH1cclxuICAgIHRvZ2dsZURlYnVnVmFsdWVFeHBhbnNpb24oZGVidWdJbmZvKSB7XHJcbiAgICAgICAgaWYgKGRlYnVnSW5mby5jYW5FeHBhbmQpIHtcclxuICAgICAgICAgICAgZGVidWdJbmZvLmlzRXhwYW5kZWQgPSAhZGVidWdJbmZvLmlzRXhwYW5kZWQ7XHJcbiAgICAgICAgICAgIGlmIChkZWJ1Z0luZm8uaXNFeHBhbmRlZCAmJiAhZGVidWdJbmZvLmV4cGFuZGVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gYGF1cmVsaWFEZWJ1Z2dlci5nZXRFeHBhbmRlZERlYnVnVmFsdWVGb3JJZCgke2RlYnVnSW5mby5kZWJ1Z0lkfSk7YDtcclxuICAgICAgICAgICAgICAgIGNocm9tZS5kZXZ0b29scy5pbnNwZWN0ZWRXaW5kb3cuZXZhbChjb2RlLCAoZXhwYW5kZWRWYWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnSW5mby5leHBhbmRlZFZhbHVlID0gZXhwYW5kZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8uaXNFeHBhbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuRGVidWdIb3N0ID0gX19kZWNvcmF0ZShbXHJcbiAgICBpbmplY3QoKVxyXG5dLCBEZWJ1Z0hvc3QpO1xyXG5leHBvcnQgeyBEZWJ1Z0hvc3QgfTtcclxuIiwiaW1wb3J0IEF1cmVsaWEsIHsgREksIElQbGF0Zm9ybSwgUExBVEZPUk0sIFJlZ2lzdHJhdGlvbiB9IGZyb20gXCJhdXJlbGlhXCI7XHJcbmltcG9ydCB7IFN0YW5kYXJkQ29uZmlndXJhdGlvbiB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XHJcbmltcG9ydCB7IEFwcCB9IGZyb20gXCIuL2FwcFwiO1xyXG5pbXBvcnQgKiBhcyByZXNvdXJjZXMgZnJvbSAnLi9yZXNvdXJjZXMvaW5kZXgnO1xyXG5jb25zdCBhdXJlbGlhID0gbmV3IEF1cmVsaWEoREkuY3JlYXRlQ29udGFpbmVyKClcclxuICAgIC5yZWdpc3RlcihSZWdpc3RyYXRpb24uaW5zdGFuY2UoSVBsYXRmb3JtLCBQTEFURk9STSksIFN0YW5kYXJkQ29uZmlndXJhdGlvbiwgcmVzb3VyY2VzKSkuYXBwKEFwcCk7XHJcbmF1cmVsaWEuc3RhcnQoKTtcclxuIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbmltcG9ydCAqIGFzIF9fYXUyVmlld0RlZiBmcm9tICcuL2RlYnVnLWdyb3VwLmh0bWwnO1xyXG5pbXBvcnQgeyBjdXN0b21FbGVtZW50IH0gZnJvbSAnQGF1cmVsaWEvcnVudGltZS1odG1sJztcclxuaW1wb3J0IHsgYmluZGFibGUgfSBmcm9tIFwiYXVyZWxpYVwiO1xyXG5sZXQgRGVidWdHcm91cCA9IGNsYXNzIERlYnVnR3JvdXAge1xyXG59O1xyXG5fX2RlY29yYXRlKFtcclxuICAgIGJpbmRhYmxlLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgRGVidWdHcm91cC5wcm90b3R5cGUsIFwiaGVhZGluZ1wiLCB2b2lkIDApO1xyXG5EZWJ1Z0dyb3VwID0gX19kZWNvcmF0ZShbXHJcbiAgICBjdXN0b21FbGVtZW50KF9fYXUyVmlld0RlZilcclxuXSwgRGVidWdHcm91cCk7XHJcbmV4cG9ydCB7IERlYnVnR3JvdXAgfTtcclxuIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufTtcclxuaW1wb3J0ICogYXMgX19hdTJWaWV3RGVmIGZyb20gJy4vcHJvcGVydHktdmlldy5odG1sJztcclxuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCB9IGZyb20gJ0BhdXJlbGlhL3J1bnRpbWUtaHRtbCc7XHJcbmltcG9ydCB7IGluamVjdCwgYmluZGFibGUsIElQbGF0Zm9ybSB9IGZyb20gJ2F1cmVsaWEnO1xyXG5pbXBvcnQgeyBEZWJ1Z0hvc3QgfSBmcm9tICcuLi8uLi9iYWNrZW5kL2RlYnVnLWhvc3QnO1xyXG5jb25zdCBlZGl0YWJsZVR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnYmlnaW50J107XHJcbmxldCBQcm9wZXJ0eVZpZXcgPSBjbGFzcyBQcm9wZXJ0eVZpZXcge1xyXG4gICAgY29uc3RydWN0b3IoZGVidWdIb3N0LCBwbGF0Zm9ybSkge1xyXG4gICAgICAgIHRoaXMuZGVidWdIb3N0ID0gZGVidWdIb3N0O1xyXG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcclxuICAgIH1cclxuICAgIGJlZ2luRWRpdGluZygpIHtcclxuICAgICAgICBpZiAoZWRpdGFibGVUeXBlcy5zb21lKHggPT4geCA9PT0gdGhpcy5wcm9wZXJ0eT8udHlwZSB8fCB0aGlzLnByb3BlcnR5LnZhbHVlID09IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkuaXNFZGl0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5wbGF0Zm9ybS5xdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGtleXVwKGUpIHtcclxuICAgICAgICBpZiAoZS5jb2RlID09PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRWRpdGluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eS50eXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5LnR5cGUgPSAnc3RyaW5nJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5xdWV1ZU1pY3JvdGFzaygoKSA9PiB0aGlzLmRlYnVnSG9zdC51cGRhdGVWYWx1ZXModGhpcy5jb250cm9sbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbmRFZGl0aW5nKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydHkuaXNFZGl0aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgYmluZGFibGUsXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQcm9wZXJ0eVZpZXcucHJvdG90eXBlLCBcInByb3BlcnR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgYmluZGFibGUsXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQcm9wZXJ0eVZpZXcucHJvdG90eXBlLCBcImNvbnRyb2xsZXJcIiwgdm9pZCAwKTtcclxuUHJvcGVydHlWaWV3ID0gX19kZWNvcmF0ZShbXHJcbiAgICBjdXN0b21FbGVtZW50KF9fYXUyVmlld0RlZiksXHJcbiAgICBpbmplY3QoKSxcclxuICAgIF9fcGFyYW0oMSwgSVBsYXRmb3JtKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRGVidWdIb3N0LCBPYmplY3RdKVxyXG5dLCBQcm9wZXJ0eVZpZXcpO1xyXG5leHBvcnQgeyBQcm9wZXJ0eVZpZXcgfTtcclxuIiwiZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9kZWJ1Zy1ncm91cCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZWxlbWVudHMvcHJvcGVydHktdmlldyc7XHJcbmV4cG9ydCAqIGFzIHQgZnJvbSAnLi9lbGVtZW50cy9hdXJlbGlhLWxvZ28uaHRtbCc7XHJcbmV4cG9ydCAqIGFzIHQyIGZyb20gJy4vZWxlbWVudHMvY29udHJvbGxlci12aWV3Lmh0bWwnO1xyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IG1vZHVsZVsnZGVmYXVsdCddIDpcblx0XHQoKSA9PiBtb2R1bGU7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIG1vZHVsZSBleHBvcnRzIG11c3QgYmUgcmV0dXJuZWQgZnJvbSBydW50aW1lIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbnJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbWFpbi50c1wiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=